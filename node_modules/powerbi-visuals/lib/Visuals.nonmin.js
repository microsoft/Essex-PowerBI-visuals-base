var __extends = this && this.__extends || function(d, b) {
    function __() {
        this.constructor = d;
    }
    for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
    d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
}, powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var Point = function() {
            function Point(x, y) {
                this.x = x || 0, this.y = y || 0;
            }
            return Point;
        }();
        visuals.Point = Point;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var Rect = function() {
            function Rect(left, top, width, height) {
                this.left = left || 0, this.top = top || 0, this.width = width || 0, this.height = height || 0;
            }
            return Rect;
        }();
        visuals.Rect = Rect;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition) {
            return void 0 === isScrollable && (isScrollable = !1), void 0 === legendPosition && (legendPosition = LegendPosition.Top), 
            interactive ? new CartesianChartInteractiveLegend(legendParentElement) : new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable);
        }
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter;
        !function(LegendIcon) {
            LegendIcon[LegendIcon.Box = 0] = "Box", LegendIcon[LegendIcon.Circle = 1] = "Circle", 
            LegendIcon[LegendIcon.Line = 2] = "Line";
        }(visuals.LegendIcon || (visuals.LegendIcon = {}));
        visuals.LegendIcon;
        !function(LegendPosition) {
            LegendPosition[LegendPosition.Top = 0] = "Top", LegendPosition[LegendPosition.Bottom = 1] = "Bottom", 
            LegendPosition[LegendPosition.Right = 2] = "Right", LegendPosition[LegendPosition.Left = 3] = "Left", 
            LegendPosition[LegendPosition.None = 4] = "None", LegendPosition[LegendPosition.TopCenter = 5] = "TopCenter", 
            LegendPosition[LegendPosition.BottomCenter = 6] = "BottomCenter", LegendPosition[LegendPosition.RightCenter = 7] = "RightCenter", 
            LegendPosition[LegendPosition.LeftCenter = 8] = "LeftCenter";
        }(visuals.LegendPosition || (visuals.LegendPosition = {}));
        var LegendPosition = visuals.LegendPosition;
        visuals.legendProps = {
            show: "show",
            position: "position",
            titleText: "titleText",
            showTitle: "showTitle",
            labelColor: "labelColor",
            fontSize: "fontSize"
        }, visuals.createLegend = createLegend;
        var Legend;
        !function(Legend) {
            function isLeft(orientation) {
                switch (orientation) {
                  case LegendPosition.Left:
                  case LegendPosition.LeftCenter:
                    return !0;

                  default:
                    return !1;
                }
            }
            function isTop(orientation) {
                switch (orientation) {
                  case LegendPosition.Top:
                  case LegendPosition.TopCenter:
                    return !0;

                  default:
                    return !1;
                }
            }
            function positionChartArea(chartArea, legend) {
                var legendMargins = legend.getMargins(), legendOrientation = legend.getOrientation();
                chartArea.style({
                    "margin-left": Legend.isLeft(legendOrientation) ? legendMargins.width + "px" : null,
                    "margin-top": Legend.isTop(legendOrientation) ? legendMargins.height + "px" : null
                });
            }
            Legend.isLeft = isLeft, Legend.isTop = isTop, Legend.positionChartArea = positionChartArea;
        }(Legend = visuals.Legend || (visuals.Legend = {}));
        var SVGLegend = function() {
            function SVGLegend(element, legendPosition, interactivityService, isScrollable) {
                this.legendDataStartIndex = 0, this.arrowPosWindow = 1, this.lastCalculatedWidth = 0, 
                this.visibleLegendWidth = 0, this.visibleLegendHeight = 0, this.legendFontSizeMarginDifference = 0, 
                this.legendFontSizeMarginValue = 0, this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute"), 
                this.svg.style("display", "inherit"), this.svg.classed("legend", !0), interactivityService && (this.clearCatcher = visuals.appendClearCatcher(this.svg)), 
                this.group = this.svg.append("g").attr("id", "legendGroup"), this.interactivityService = interactivityService, 
                this.isScrollable = isScrollable, this.element = element, this.changeOrientation(legendPosition), 
                this.parentViewport = {
                    height: 0,
                    width: 0
                }, this.calculateViewport(), this.updateLayout();
            }
            return SVGLegend.prototype.updateLayout = function() {
                var legendViewport = this.viewport, orientation = this.orientation;
                this.svg.attr({
                    height: legendViewport.height || (orientation === LegendPosition.None ? 0 : this.parentViewport.height),
                    width: legendViewport.width || (orientation === LegendPosition.None ? 0 : this.parentViewport.width)
                });
                var isRight = orientation === LegendPosition.Right || orientation === LegendPosition.RightCenter, isBottom = orientation === LegendPosition.Bottom || orientation === LegendPosition.BottomCenter;
                this.svg.style({
                    "margin-left": isRight ? this.parentViewport.width - legendViewport.width + "px" : null,
                    "margin-top": isBottom ? this.parentViewport.height - legendViewport.height + "px" : null
                });
            }, SVGLegend.prototype.calculateViewport = function() {
                switch (this.orientation) {
                  case LegendPosition.Top:
                  case LegendPosition.Bottom:
                  case LegendPosition.TopCenter:
                  case LegendPosition.BottomCenter:
                    var pixelHeight = PixelConverter.fromPointToPixel(this.data && this.data.fontSize ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt), fontHeightSize = SVGLegend.TopLegendHeight + (pixelHeight - SVGLegend.DefaultFontSizeInPt);
                    return void (this.viewport = {
                        height: fontHeightSize,
                        width: 0
                    });

                  case LegendPosition.Right:
                  case LegendPosition.Left:
                  case LegendPosition.RightCenter:
                  case LegendPosition.LeftCenter:
                    var width = this.lastCalculatedWidth ? this.lastCalculatedWidth : this.parentViewport.width * SVGLegend.LegendMaxWidthFactor;
                    return void (this.viewport = {
                        height: 0,
                        width: width
                    });

                  case LegendPosition.None:
                    this.viewport = {
                        height: 0,
                        width: 0
                    };
                }
            }, SVGLegend.prototype.getMargins = function() {
                return this.viewport;
            }, SVGLegend.prototype.isVisible = function() {
                return this.orientation !== LegendPosition.None;
            }, SVGLegend.prototype.changeOrientation = function(orientation) {
                orientation ? this.orientation = orientation : this.orientation = LegendPosition.Top, 
                this.svg.attr("orientation", orientation);
            }, SVGLegend.prototype.getOrientation = function() {
                return this.orientation;
            }, SVGLegend.prototype.drawLegend = function(data, viewport) {
                for (var clonedData = powerbi.Prototype.inherit(data), newDataPoints = [], _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    newDataPoints.push(powerbi.Prototype.inherit(dp));
                }
                clonedData.dataPoints = newDataPoints, this.setTooltipToLegendItems(clonedData), 
                this.drawLegendInternal(clonedData, viewport, !0);
            }, SVGLegend.prototype.drawLegendInternal = function(data, viewport, autoWidth) {
                this.parentViewport = viewport, this.data = data, this.interactivityService && this.interactivityService.applySelectionStateToData(data.dataPoints), 
                0 === data.dataPoints.length && this.changeOrientation(LegendPosition.None), this.getOrientation() === LegendPosition.None && (data.dataPoints = []);
                var mapControl = this.element.children(".mapControl");
                mapControl.length > 0 && !this.isTopOrBottom(this.orientation) && mapControl.css("display", "inline-block"), 
                this.calculateViewport();
                var layout = this.calculateLayout(data, autoWidth), titleLayout = layout.title, titleData = titleLayout ? [ titleLayout ] : [], hasSelection = this.interactivityService && powerbi.visuals.dataHasSelection(data.dataPoints), group = this.group;
                if (this.isCentered(this.orientation)) {
                    var centerOffset = 0;
                    this.isTopOrBottom(this.orientation) ? (centerOffset = Math.max(0, (this.parentViewport.width - this.visibleLegendWidth) / 2), 
                    group.attr("transform", visuals.SVGUtil.translate(centerOffset, 0))) : (centerOffset = Math.max((this.parentViewport.height - this.visibleLegendHeight) / 2), 
                    group.attr("transform", visuals.SVGUtil.translate(0, centerOffset)));
                } else group.attr("transform", null);
                var legendTitle = group.selectAll(SVGLegend.LegendTitle.selector).data(titleData);
                legendTitle.enter().append("text").classed(SVGLegend.LegendTitle["class"], !0), 
                legendTitle.style({
                    fill: data.labelColor,
                    "font-size": PixelConverter.fromPoint(data.fontSize),
                    "font-family": SVGLegend.DefaultTitleFontFamily
                }).text(function(d) {
                    return d.text;
                }).attr({
                    x: function(d) {
                        return d.x;
                    },
                    y: function(d) {
                        return d.y;
                    }
                }).append("title").text(data.title), legendTitle.exit().remove();
                var virtualizedDataPoints = data.dataPoints.slice(this.legendDataStartIndex, this.legendDataStartIndex + layout.numberOfItems), iconRadius = powerbi.TextMeasurementService.estimateSvgTextHeight(SVGLegend.getTextProperties(!1, "", this.data.fontSize)) / SVGLegend.LegendIconRadiusFactor;
                iconRadius = this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin && iconRadius > SVGLegend.LegendIconRadius ? iconRadius : SVGLegend.LegendIconRadius;
                var legendItems = group.selectAll(SVGLegend.LegendItem.selector).data(virtualizedDataPoints, function(d) {
                    return d.identity.getKey();
                }), itemsEnter = legendItems.enter().append("g").classed(SVGLegend.LegendItem["class"], !0);
                if (itemsEnter.append("circle").classed(SVGLegend.LegendIcon["class"], !0), itemsEnter.append("text").classed(SVGLegend.LegendText["class"], !0), 
                itemsEnter.append("title").text(function(d) {
                    return d.tooltip;
                }), itemsEnter.style({
                    "font-family": SVGLegend.DefaultFontFamily
                }), legendItems.select(SVGLegend.LegendIcon.selector).attr({
                    cx: function(d, i) {
                        return d.glyphPosition.x;
                    },
                    cy: function(d) {
                        return d.glyphPosition.y;
                    },
                    r: iconRadius
                }).style({
                    fill: function(d) {
                        return hasSelection && !d.selected ? visuals.LegendBehavior.dimmedLegendColor : d.color;
                    }
                }), legendItems.select("title").text(function(d) {
                    return d.tooltip;
                }), legendItems.select(SVGLegend.LegendText.selector).attr({
                    x: function(d) {
                        return d.textPosition.x;
                    },
                    y: function(d) {
                        return d.textPosition.y;
                    }
                }).text(function(d) {
                    return d.label;
                }).style({
                    fill: data.labelColor,
                    "font-size": PixelConverter.fromPoint(data.fontSize)
                }), this.interactivityService) {
                    var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector), behaviorOptions = {
                        legendItems: legendItems,
                        legendIcons: iconsSelection,
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.bind(data.dataPoints, new visuals.LegendBehavior(), behaviorOptions, {
                        isLegend: !0
                    });
                }
                legendItems.exit().remove(), this.drawNavigationArrows(layout.navigationArrows), 
                this.updateLayout();
            }, SVGLegend.prototype.normalizePosition = function(points) {
                this.legendDataStartIndex >= points.length && (this.legendDataStartIndex = points.length - 1), 
                this.legendDataStartIndex < 0 && (this.legendDataStartIndex = 0);
            }, SVGLegend.prototype.calculateTitleLayout = function(title) {
                var width = 0, hasTitle = !_.isEmpty(title);
                if (hasTitle) {
                    var isHorizontal = this.isTopOrBottom(this.orientation), maxMeasureLength = void 0;
                    if (isHorizontal) {
                        var fontSizeMargin = this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding, fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius, fixedHorizontalTextShift = SVGLegend.LegendIconRadius + fontSizeMargin + fixedHorizontalIconShift;
                        maxMeasureLength = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                    } else maxMeasureLength = this.legendFontSizeMarginValue < SVGLegend.DefaultTextMargin ? SVGLegend.MaxTitleLength : SVGLegend.MaxTitleLength + SVGLegend.DefaultMaxLegendFactor * this.legendFontSizeMarginDifference;
                    var textProperties = SVGLegend.getTextProperties(!0, title, this.data.fontSize), text = title;
                    return width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), 
                    width > maxMeasureLength && (text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxMeasureLength), 
                    width = maxMeasureLength), isHorizontal ? width += SVGLegend.TitlePadding : text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, this.viewport.width), 
                    {
                        x: 0,
                        y: 0,
                        text: text,
                        width: width,
                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
                    };
                }
                return null;
            }, SVGLegend.prototype.calculateLayout = function(data, autoWidth) {
                var dataPoints = data.dataPoints;
                if (0 === data.dataPoints.length) return {
                    startIndex: null,
                    numberOfItems: 0,
                    title: null,
                    navigationArrows: []
                };
                this.legendFontSizeMarginValue = PixelConverter.fromPointToPixel(this.data && void 0 !== this.data.fontSize ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt), 
                this.legendFontSizeMarginDifference = this.legendFontSizeMarginValue - SVGLegend.DefaultTextMargin, 
                this.normalizePosition(dataPoints), this.legendDataStartIndex < dataPoints.length && (dataPoints = dataPoints.slice(this.legendDataStartIndex));
                var navArrows, numberOfItems, title = this.calculateTitleLayout(data.title);
                return this.isTopOrBottom(this.orientation) ? (navArrows = this.isScrollable ? this.calculateHorizontalNavigationArrowsLayout(title) : [], 
                numberOfItems = this.calculateHorizontalLayout(dataPoints, title, navArrows)) : (navArrows = this.isScrollable ? this.calculateVerticalNavigationArrowsLayout(title) : [], 
                numberOfItems = this.calculateVerticalLayout(dataPoints, title, navArrows, autoWidth)), 
                {
                    numberOfItems: numberOfItems,
                    title: title,
                    navigationArrows: navArrows
                };
            }, SVGLegend.prototype.updateNavigationArrowLayout = function(navigationArrows, remainingDataLength, visibleDataLength) {
                0 === this.legendDataStartIndex && navigationArrows.shift();
                var lastWindow = this.arrowPosWindow;
                this.arrowPosWindow = visibleDataLength, navigationArrows && navigationArrows.length > 0 && this.arrowPosWindow === remainingDataLength && (this.arrowPosWindow = lastWindow, 
                navigationArrows.length = navigationArrows.length - 1);
            }, SVGLegend.prototype.calculateHorizontalNavigationArrowsLayout = function(title) {
                var height = SVGLegend.LegendArrowHeight, width = SVGLegend.LegendArrowWidth, translateY = this.viewport.height / 2 - height / 2, data = [], rightShift = title ? title.x + title.width : 0, arrowLeft = visuals.SVGUtil.createArrow(width, height, 180), arrowRight = visuals.SVGUtil.createArrow(width, height, 0);
                return data.push({
                    x: rightShift,
                    y: translateY,
                    path: arrowLeft.path,
                    rotateTransform: arrowLeft.transform,
                    type: 1
                }), data.push({
                    x: this.parentViewport.width - width,
                    y: translateY,
                    path: arrowRight.path,
                    rotateTransform: arrowRight.transform,
                    type: 0
                }), data;
            }, SVGLegend.prototype.calculateVerticalNavigationArrowsLayout = function(title) {
                var height = SVGLegend.LegendArrowHeight, width = SVGLegend.LegendArrowWidth, verticalCenter = this.viewport.height / 2, data = [], rightShift = verticalCenter + height / 2, arrowTop = visuals.SVGUtil.createArrow(width, height, 270), arrowBottom = visuals.SVGUtil.createArrow(width, height, 90), titleHeight = title ? title.height : 0;
                return data.push({
                    x: rightShift,
                    y: width + titleHeight,
                    path: arrowTop.path,
                    rotateTransform: arrowTop.transform,
                    type: 1
                }), data.push({
                    x: rightShift,
                    y: this.parentViewport.height - height,
                    path: arrowBottom.path,
                    rotateTransform: arrowBottom.transform,
                    type: 0
                }), data;
            }, SVGLegend.prototype.calculateHorizontalLayout = function(dataPoints, title, navigationArrows) {
                var HorizontalTextShift = 4 + SVGLegend.LegendIconRadius, fontSizeBiggerThanDefault = this.legendFontSizeMarginDifference > 0, fontSizeMargin = fontSizeBiggerThanDefault ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding, fixedTextShift = fontSizeMargin / (SVGLegend.LegendIconRadiusFactor / 2) + HorizontalTextShift, totalSpaceOccupiedThusFar = 0, iconTotalItemPadding = 2 * SVGLegend.LegendIconRadius + 1.5 * fontSizeMargin, numberOfItems = dataPoints.length, defaultTextProperties = SVGLegend.getTextProperties(!1, "", this.data.fontSize), verticalCenter = this.viewport.height / 2, textYCoordinate = verticalCenter + powerbi.TextMeasurementService.estimateSvgTextHeight(defaultTextProperties) / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(defaultTextProperties);
                title && (totalSpaceOccupiedThusFar += title.width, title.y = verticalCenter + title.height / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(SVGLegend.getTextProperties(!0, title.text, this.data.fontSize))), 
                this.legendDataStartIndex > 0 && (totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset);
                var dataPointsLength = dataPoints.length, parentWidth = this.parentViewport.width, maxTextLength = dataPointsLength > 0 ? (parentWidth - totalSpaceOccupiedThusFar - iconTotalItemPadding * dataPointsLength) / dataPointsLength | 0 : 0;
                maxTextLength = maxTextLength > SVGLegend.MaxTextLength ? maxTextLength : SVGLegend.MaxTextLength;
                for (var i = 0; dataPointsLength > i; i++) {
                    var dp = dataPoints[i], textProperties = SVGLegend.getTextProperties(!1, dp.label, this.data.fontSize);
                    dp.glyphPosition = {
                        x: totalSpaceOccupiedThusFar + SVGLegend.LegendIconRadius + this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor,
                        y: this.viewport.height * SVGLegend.LegendIconYRatio
                    }, dp.textPosition = {
                        x: totalSpaceOccupiedThusFar + fixedTextShift,
                        y: textYCoordinate
                    };
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), spaceTakenByItem = 0;
                    if (maxTextLength > width) spaceTakenByItem = iconTotalItemPadding + width; else {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextLength);
                        dp.label = text, spaceTakenByItem = iconTotalItemPadding + maxTextLength;
                    }
                    if (totalSpaceOccupiedThusFar += spaceTakenByItem, totalSpaceOccupiedThusFar > parentWidth) {
                        numberOfItems = i;
                        break;
                    }
                }
                return this.visibleLegendWidth = totalSpaceOccupiedThusFar, this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems), 
                numberOfItems;
            }, SVGLegend.prototype.calculateVerticalLayout = function(dataPoints, title, navigationArrows, autoWidth) {
                var _this = this, fontSizeBiggerThenDefault = this.legendFontSizeMarginDifference > 0, fontFactor = fontSizeBiggerThenDefault ? this.legendFontSizeMarginDifference : 0, verticalLegendHeight = 20 + fontFactor, spaceNeededByTitle = 15 + fontFactor, extraShiftForTextAlignmentToIcon = 4 + fontFactor, totalSpaceOccupiedThusFar = verticalLegendHeight, fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius + this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor, fixedHorizontalTextShift = 2 * fixedHorizontalIconShift, maxHorizontalSpaceAvaliable = autoWidth ? this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth : this.lastCalculatedWidth - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth, numberOfItems = dataPoints.length, maxHorizontalSpaceUsed = 0, parentHeight = this.parentViewport.height;
                title && (totalSpaceOccupiedThusFar += spaceNeededByTitle, title.x = SVGLegend.TextAndIconPadding, 
                title.y = spaceNeededByTitle, maxHorizontalSpaceUsed = title.width || 0), this.legendDataStartIndex > 0 && (totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset);
                for (var dataPointsLength = dataPoints.length, i = 0; dataPointsLength > i; i++) {
                    var dp = dataPoints[i], textProperties = SVGLegend.getTextProperties(!1, dp.label, this.data.fontSize);
                    dp.glyphPosition = {
                        x: fixedHorizontalIconShift,
                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties)
                    }, dp.textPosition = {
                        x: fixedHorizontalTextShift,
                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
                    };
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (width > maxHorizontalSpaceUsed && (maxHorizontalSpaceUsed = width), width > maxHorizontalSpaceAvaliable) {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxHorizontalSpaceAvaliable);
                        dp.label = text;
                    }
                    if (totalSpaceOccupiedThusFar += verticalLegendHeight, totalSpaceOccupiedThusFar > parentHeight) {
                        numberOfItems = i;
                        break;
                    }
                }
                return autoWidth ? maxHorizontalSpaceAvaliable > maxHorizontalSpaceUsed ? this.lastCalculatedWidth = this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + SVGLegend.LegendEdgeMariginWidth) : this.lastCalculatedWidth = this.viewport.width = Math.ceil(this.parentViewport.width * SVGLegend.LegendMaxWidthFactor) : this.viewport.width = this.lastCalculatedWidth, 
                this.visibleLegendHeight = totalSpaceOccupiedThusFar, navigationArrows.forEach(function(d) {
                    return d.x = _this.lastCalculatedWidth / 2;
                }), this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems), 
                numberOfItems;
            }, SVGLegend.prototype.drawNavigationArrows = function(layout) {
                var _this = this, arrows = this.group.selectAll(SVGLegend.NavigationArrow.selector).data(layout);
                arrows.enter().append("g").on("click", function(d) {
                    var pos = _this.legendDataStartIndex;
                    _this.legendDataStartIndex = 0 === d.type ? pos + _this.arrowPosWindow : pos - _this.arrowPosWindow, 
                    _this.drawLegendInternal(_this.data, _this.parentViewport, !1);
                }).classed(SVGLegend.NavigationArrow["class"], !0).append("path"), arrows.attr("transform", function(d) {
                    return visuals.SVGUtil.translate(d.x, d.y);
                }).select("path").attr({
                    d: function(d) {
                        return d.path;
                    },
                    transform: function(d) {
                        return d.rotateTransform;
                    }
                }), arrows.exit().remove();
            }, SVGLegend.prototype.isTopOrBottom = function(orientation) {
                switch (orientation) {
                  case LegendPosition.Top:
                  case LegendPosition.Bottom:
                  case LegendPosition.BottomCenter:
                  case LegendPosition.TopCenter:
                    return !0;

                  default:
                    return !1;
                }
            }, SVGLegend.prototype.isCentered = function(orientation) {
                switch (orientation) {
                  case LegendPosition.BottomCenter:
                  case LegendPosition.LeftCenter:
                  case LegendPosition.RightCenter:
                  case LegendPosition.TopCenter:
                    return !0;

                  default:
                    return !1;
                }
            }, SVGLegend.prototype.reset = function() {}, SVGLegend.getTextProperties = function(isTitle, text, fontSize) {
                return {
                    text: text,
                    fontFamily: isTitle ? SVGLegend.DefaultTitleFontFamily : SVGLegend.DefaultFontFamily,
                    fontSize: PixelConverter.fromPoint(fontSize || SVGLegend.DefaultFontSizeInPt)
                };
            }, SVGLegend.prototype.setTooltipToLegendItems = function(data) {
                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dataPoint = _a[_i];
                    dataPoint.tooltip = dataPoint.label;
                }
            }, SVGLegend.DefaultFontSizeInPt = 8, SVGLegend.LegendIconRadius = 5, SVGLegend.LegendIconRadiusFactor = 5, 
            SVGLegend.MaxTextLength = 60, SVGLegend.MaxTitleLength = 80, SVGLegend.TextAndIconPadding = 5, 
            SVGLegend.TitlePadding = 15, SVGLegend.LegendEdgeMariginWidth = 10, SVGLegend.LegendMaxWidthFactor = .3, 
            SVGLegend.TopLegendHeight = 24, SVGLegend.DefaultTextMargin = PixelConverter.fromPointToPixel(SVGLegend.DefaultFontSizeInPt), 
            SVGLegend.DefaultMaxLegendFactor = SVGLegend.MaxTitleLength / SVGLegend.DefaultTextMargin, 
            SVGLegend.LegendIconYRatio = .52, SVGLegend.LegendArrowOffset = 10, SVGLegend.LegendArrowHeight = 15, 
            SVGLegend.LegendArrowWidth = 7.5, SVGLegend.DefaultFontFamily = "wf_segoe-ui_normal", 
            SVGLegend.DefaultTitleFontFamily = "wf_segoe-ui_Semibold", SVGLegend.LegendItem = createClassAndSelector("legendItem"), 
            SVGLegend.LegendText = createClassAndSelector("legendText"), SVGLegend.LegendIcon = createClassAndSelector("legendIcon"), 
            SVGLegend.LegendTitle = createClassAndSelector("legendTitle"), SVGLegend.NavigationArrow = createClassAndSelector("navArrow"), 
            SVGLegend;
        }();
        visuals.SVGLegend = SVGLegend;
        var LegendData, CartesianChartInteractiveLegend = function() {
            function CartesianChartInteractiveLegend(element) {
                this.legendContainerParent = d3.select(element.get(0));
            }
            return CartesianChartInteractiveLegend.prototype.getMargins = function() {
                return {
                    height: CartesianChartInteractiveLegend.LegendHeight,
                    width: 0
                };
            }, CartesianChartInteractiveLegend.prototype.drawLegend = function(legendData) {
                var data = legendData.dataPoints;
                if (!(data.length < 1)) {
                    var legendContainerDiv = this.legendContainerParent.select(CartesianChartInteractiveLegend.LegendContainerSelector);
                    if (legendContainerDiv.empty()) {
                        if (!data.length) return;
                        var divToPrepend = $("<div></div>").height(this.getMargins().height).addClass(CartesianChartInteractiveLegend.LegendContainerClass);
                        $(this.legendContainerParent[0]).prepend(divToPrepend), legendContainerDiv = d3.select(divToPrepend.get(0));
                    }
                    this.legendContainerDiv = legendContainerDiv, this.drawTitle(data), this.drawLegendItems(data);
                }
            }, CartesianChartInteractiveLegend.prototype.reset = function() {
                this.legendContainerDiv && (this.legendContainerDiv.remove(), this.legendContainerDiv = null);
            }, CartesianChartInteractiveLegend.prototype.isVisible = function() {
                return !0;
            }, CartesianChartInteractiveLegend.prototype.changeOrientation = function(orientation) {}, 
            CartesianChartInteractiveLegend.prototype.getOrientation = function() {
                return LegendPosition.Top;
            }, CartesianChartInteractiveLegend.prototype.drawTitle = function(data) {
                var titleDiv = this.legendContainerDiv.selectAll("div." + CartesianChartInteractiveLegend.LegendTitleClass), item = titleDiv.data([ data[0] ]), itemEnter = item.enter(), titleDivEnter = itemEnter.append("div").attr("class", CartesianChartInteractiveLegend.LegendTitleClass);
                titleDivEnter.filter(function(d) {
                    return d.iconOnlyOnLabel;
                }).append("span").attr("class", CartesianChartInteractiveLegend.legendIconClass).html(CartesianChartInteractiveLegend.legendPlaceSelector), 
                titleDivEnter.append("span"), item.filter(function(d) {
                    return d.iconOnlyOnLabel;
                }).select("span." + CartesianChartInteractiveLegend.legendIconClass).style(CartesianChartInteractiveLegend.legendColorCss, function(d) {
                    return d.color;
                }), item.select("span:last-child").text(function(d) {
                    return d.category;
                });
            }, CartesianChartInteractiveLegend.prototype.drawLegendItems = function(data) {
                this.ensureLegendTableCreated();
                var dataPointsMatrix = CartesianChartInteractiveLegend.splitArrayToOddEven(data), legendItemsContainer = this.legendContainerDiv.select("tbody").selectAll("tr").data(dataPointsMatrix), legendItemsEnter = legendItemsContainer.enter(), rowEnter = legendItemsEnter.append("tr"), cellEnter = rowEnter.selectAll("td").data(function(d) {
                    return d;
                }, function(d) {
                    return d.label;
                }).enter().append("td").attr("class", CartesianChartInteractiveLegend.LegendItem), cellSpanEnter = cellEnter.append("span");
                cellSpanEnter.filter(function(d) {
                    return !d.iconOnlyOnLabel;
                }).append("span").html(CartesianChartInteractiveLegend.legendPlaceSelector).attr("class", CartesianChartInteractiveLegend.legendIconClass).attr("white-space", "nowrap"), 
                cellSpanEnter.append("span").attr("class", CartesianChartInteractiveLegend.legendItemNameClass), 
                cellSpanEnter.append("span").attr("class", CartesianChartInteractiveLegend.legendItemMeasureClass);
                var legendCells = legendItemsContainer.selectAll("td").data(function(d) {
                    return d;
                }, function(d) {
                    return d.label;
                });
                legendCells.select("span." + CartesianChartInteractiveLegend.legendItemNameClass).html(function(d) {
                    return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label);
                }), legendCells.select("span." + CartesianChartInteractiveLegend.legendItemMeasureClass).html(function(d) {
                    return "&nbsp;" + d.measure;
                }), legendCells.select("span." + CartesianChartInteractiveLegend.legendIconClass).style("color", function(d) {
                    return d.color;
                }), legendCells.exit().remove();
            }, CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function() {
                if (this.legendContainerDiv.select("div table").empty()) {
                    var legendTable = this.legendContainerDiv.append("div").append("table");
                    legendTable.style("table-layout", "fixed").append("tbody"), this.setPanGestureOnLegend(legendTable);
                }
            }, CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function(legendTable) {
                var viewportWidth = $(this.legendContainerDiv.select("div:nth-child(2)")[0]).width(), xscale = d3.scale.linear().domain([ 0, viewportWidth ]).range([ 0, viewportWidth ]), zoom = d3.behavior.zoom().scaleExtent([ 1, 1 ]).x(xscale).on("zoom", function() {
                    if ($(legendTable[0]).width() > viewportWidth) {
                        var t = zoom.translate(), tx_1 = t[0], ty = t[1];
                        tx_1 = Math.min(tx_1, 0), tx_1 = Math.max(tx_1, viewportWidth - $(legendTable[0]).width()), 
                        zoom.translate([ tx_1, ty ]), legendTable.style("-ms-transform", function() {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        }), legendTable.style("-webkit-transform", function() {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        }), legendTable.style("transform", function() {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        });
                    }
                });
                this.legendContainerDiv ? this.legendContainerDiv.call(zoom) : legendTable.call(zoom);
            }, CartesianChartInteractiveLegend.splitArrayToOddEven = function(data) {
                for (var oddData = [], evenData = [], i = 0; i < data.length; ++i) i % 2 === 0 ? evenData.push(data[i]) : oddData.push(data[i]);
                return [ evenData, oddData ];
            }, CartesianChartInteractiveLegend.LegendHeight = 70, CartesianChartInteractiveLegend.LegendContainerClass = "interactive-legend", 
            CartesianChartInteractiveLegend.LegendContainerSelector = ".interactive-legend", 
            CartesianChartInteractiveLegend.LegendTitleClass = "title", CartesianChartInteractiveLegend.LegendItem = "item", 
            CartesianChartInteractiveLegend.legendPlaceSelector = "â– ", CartesianChartInteractiveLegend.legendIconClass = "icon", 
            CartesianChartInteractiveLegend.legendColorCss = "color", CartesianChartInteractiveLegend.legendItemNameClass = "itemName", 
            CartesianChartInteractiveLegend.legendItemMeasureClass = "itemMeasure", CartesianChartInteractiveLegend;
        }();
        !function(LegendData) {
            function update(legendData, legendObject) {
                if (null == legendObject[visuals.legendProps.show] && (legendObject[visuals.legendProps.show] = !0), 
                legendObject[visuals.legendProps.show] === !1 && (legendData.dataPoints = []), legendObject[visuals.legendProps.show] === !0 && null == legendObject[visuals.legendProps.position] && (legendObject[visuals.legendProps.position] = visuals.legendPosition.top), 
                void 0 !== legendObject[visuals.legendProps.fontSize] && (legendData.fontSize = legendObject[visuals.legendProps.fontSize]), 
                void 0 !== legendObject[visuals.legendProps.labelColor]) {
                    var fillColor = legendObject[visuals.legendProps.labelColor];
                    null != fillColor && (legendData.labelColor = fillColor.solid.color);
                }
                legendObject[visuals.legendProps.showTitle] === !1 ? legendData.title = "" : void 0 !== legendObject[visuals.legendProps.titleText] && (legendData.title = legendObject[visuals.legendProps.titleText]);
            }
            LegendData.DefaultLegendLabelFillColor = "#666666", LegendData.update = update;
        }(LegendData = visuals.LegendData || (visuals.LegendData = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var axisScale;
        !function(axisScale) {
            axisScale.linear = "linear", axisScale.log = "log", axisScale.type = powerbi.createEnumType([ {
                value: axisScale.linear,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_Linear");
                }
            }, {
                value: axisScale.log,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_Log");
                }
            } ]);
        }(axisScale = visuals.axisScale || (visuals.axisScale = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var axisStyle;
        !function(axisStyle) {
            axisStyle.showBoth = "showBoth", axisStyle.showTitleOnly = "showTitleOnly", axisStyle.showUnitOnly = "showUnitOnly", 
            axisStyle.type = powerbi.createEnumType([ {
                value: axisStyle.showTitleOnly,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_ShowTitleOnly");
                }
            }, {
                value: axisStyle.showUnitOnly,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_ShowUnitOnly");
                }
            }, {
                value: axisStyle.showBoth,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_ShowBoth");
                }
            } ]);
        }(axisStyle = visuals.axisStyle || (visuals.axisStyle = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var axisType;
        !function(axisType) {
            axisType.scalar = "Scalar", axisType.categorical = "Categorical", axisType.both = "Both", 
            axisType.type = powerbi.createEnumType([ {
                value: axisType.scalar,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_Scalar");
                }
            }, {
                value: axisType.categorical,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_Categorical");
                }
            } ]);
        }(axisType = visuals.axisType || (visuals.axisType = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var basicShapeType;
        !function(basicShapeType) {
            basicShapeType.rectangle = "rectangle", basicShapeType.oval = "oval", basicShapeType.line = "line", 
            basicShapeType.arrow = "arrow", basicShapeType.triangle = "triangle", basicShapeType.type = powerbi.createEnumType([ {
                value: basicShapeType.rectangle,
                displayName: "rectangle"
            }, {
                value: basicShapeType.oval,
                displayName: "oval"
            }, {
                value: basicShapeType.line,
                displayName: "line"
            }, {
                value: basicShapeType.arrow,
                displayName: "arrow"
            }, {
                value: basicShapeType.triangle,
                displayName: "triangle"
            } ]);
        }(basicShapeType = visuals.basicShapeType || (visuals.basicShapeType = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var imageScalingType;
        !function(imageScalingType) {
            imageScalingType.normal = "Normal", imageScalingType.fit = "Fit", imageScalingType.fill = "Fill", 
            imageScalingType.type = powerbi.createEnumType([ {
                value: imageScalingType.normal,
                displayName: function(resources) {
                    return resources.get("Visual_ImageScalingType_Normal");
                }
            }, {
                value: imageScalingType.fit,
                displayName: function(resources) {
                    return resources.get("Visual_ImageScalingType_Fit");
                }
            }, {
                value: imageScalingType.fill,
                displayName: function(resources) {
                    return resources.get("Visual_ImageScalingType_Fill");
                }
            } ]);
        }(imageScalingType = visuals.imageScalingType || (visuals.imageScalingType = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var labelPosition;
        !function(labelPosition) {
            labelPosition.insideEnd = "InsideEnd", labelPosition.insideCenter = "InsideCenter", 
            labelPosition.outsideEnd = "OutsideEnd", labelPosition.insideBase = "InsideBase", 
            labelPosition.type = powerbi.createEnumType([ {
                value: labelPosition.insideEnd,
                displayName: function(resources) {
                    return resources.get("Visual_LabelPosition_InsideEnd");
                }
            }, {
                value: labelPosition.outsideEnd,
                displayName: function(resources) {
                    return resources.get("Visual_LabelPosition_OutsideEnd");
                }
            }, {
                value: labelPosition.insideCenter,
                displayName: function(resources) {
                    return resources.get("Visual_LabelPosition_InsideCenter");
                }
            }, {
                value: labelPosition.insideBase,
                displayName: function(resources) {
                    return resources.get("Visual_LabelPosition_InsideBase");
                }
            } ]);
        }(labelPosition = visuals.labelPosition || (visuals.labelPosition = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var labelStyle;
        !function(labelStyle) {
            labelStyle.category = "Category", labelStyle.data = "Data", labelStyle.both = "Both", 
            labelStyle.type = powerbi.createEnumType([ {
                value: labelStyle.category,
                displayName: function(resources) {
                    return resources.get("Visual_LabelStyle_Category");
                }
            }, {
                value: labelStyle.data,
                displayName: function(resources) {
                    return resources.get("Visual_LabelStyle_DataValue");
                }
            }, {
                value: labelStyle.both,
                displayName: function(resources) {
                    return resources.get("Visual_LabelStyle_Both");
                }
            } ]);
        }(labelStyle = visuals.labelStyle || (visuals.labelStyle = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var legendPosition;
        !function(legendPosition) {
            legendPosition.top = "Top", legendPosition.bottom = "Bottom", legendPosition.left = "Left", 
            legendPosition.right = "Right", legendPosition.topCenter = "TopCenter", legendPosition.bottomCenter = "BottomCenter", 
            legendPosition.leftCenter = "LeftCenter", legendPosition.rightCenter = "RightCenter", 
            legendPosition.type = powerbi.createEnumType([ {
                value: legendPosition.top,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Top");
                }
            }, {
                value: legendPosition.bottom,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Bottom");
                }
            }, {
                value: legendPosition.left,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Left");
                }
            }, {
                value: legendPosition.right,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Right");
                }
            }, {
                value: legendPosition.topCenter,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_TopCenter");
                }
            }, {
                value: legendPosition.bottomCenter,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_BottomCenter");
                }
            }, {
                value: legendPosition.leftCenter,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_LeftCenter");
                }
            }, {
                value: legendPosition.rightCenter,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_RightCenter");
                }
            } ]);
        }(legendPosition = visuals.legendPosition || (visuals.legendPosition = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var kpiDirection;
        !function(kpiDirection) {
            kpiDirection.positive = "Positive", kpiDirection.negative = "Negative", kpiDirection.type = powerbi.createEnumType([ {
                value: kpiDirection.positive,
                displayName: function(resources) {
                    return resources.get("Visual_KPI_Direction_Positive");
                }
            }, {
                value: kpiDirection.negative,
                displayName: function(resources) {
                    return resources.get("Visual_KPI_Direction_Negative");
                }
            } ]);
        }(kpiDirection = visuals.kpiDirection || (visuals.kpiDirection = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var lineStyle;
        !function(lineStyle) {
            lineStyle.dashed = "dashed", lineStyle.solid = "solid", lineStyle.dotted = "dotted", 
            lineStyle.type = powerbi.createEnumType([ {
                value: lineStyle.dashed,
                displayName: function(resources) {
                    return resources.get("Visual_LineStyle_Dashed");
                }
            }, {
                value: lineStyle.solid,
                displayName: function(resources) {
                    return resources.get("Visual_LineStyle_Solid");
                }
            }, {
                value: lineStyle.dotted,
                displayName: function(resources) {
                    return resources.get("Visual_LineStyle_Dotted");
                }
            } ]);
        }(lineStyle = visuals.lineStyle || (visuals.lineStyle = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var outline;
        !function(outline_1) {
            function showTop(outline) {
                return [ outline_1.topOnly, outline_1.topBottom, outline_1.frame ].some(function(o) {
                    return o === outline;
                });
            }
            function showRight(outline) {
                return [ outline_1.rightOnly, outline_1.leftRight, outline_1.frame ].some(function(o) {
                    return o === outline;
                });
            }
            function showBottom(outline) {
                return [ outline_1.bottomOnly, outline_1.topBottom, outline_1.frame ].some(function(o) {
                    return o === outline;
                });
            }
            function showLeft(outline) {
                return [ outline_1.leftOnly, outline_1.leftRight, outline_1.frame ].some(function(o) {
                    return o === outline;
                });
            }
            outline_1.none = "None", outline_1.bottomOnly = "BottomOnly", outline_1.topOnly = "TopOnly", 
            outline_1.leftOnly = "LeftOnly", outline_1.rightOnly = "RightOnly", outline_1.topBottom = "TopBottom", 
            outline_1.leftRight = "LeftRight", outline_1.frame = "Frame", outline_1.showTop = showTop, 
            outline_1.showRight = showRight, outline_1.showBottom = showBottom, outline_1.showLeft = showLeft, 
            outline_1.type = powerbi.createEnumType([ {
                value: outline_1.none,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_none");
                }
            }, {
                value: outline_1.bottomOnly,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_bottom_only");
                }
            }, {
                value: outline_1.topOnly,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_top_only");
                }
            }, {
                value: outline_1.leftOnly,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_LeftOnly");
                }
            }, {
                value: outline_1.rightOnly,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_RightOnly");
                }
            }, {
                value: outline_1.topBottom,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_top_Bottom");
                }
            }, {
                value: outline_1.leftRight,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_leftRight");
                }
            }, {
                value: outline_1.frame,
                displayName: function(resources) {
                    return resources.get("Visual_Outline_frame");
                }
            } ]);
        }(outline = visuals.outline || (visuals.outline = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var referenceLinePosition;
        !function(referenceLinePosition) {
            referenceLinePosition.back = "back", referenceLinePosition.front = "front", referenceLinePosition.type = powerbi.createEnumType([ {
                value: referenceLinePosition.back,
                displayName: function(resources) {
                    return resources.get("Visual_Reference_Line_Behind");
                }
            }, {
                value: referenceLinePosition.front,
                displayName: function(resources) {
                    return resources.get("Visual_Reference_Line_InFront");
                }
            } ]);
        }(referenceLinePosition = visuals.referenceLinePosition || (visuals.referenceLinePosition = {}));
        var referenceLineDataLabelHorizontalPosition;
        !function(referenceLineDataLabelHorizontalPosition) {
            referenceLineDataLabelHorizontalPosition.left = "left", referenceLineDataLabelHorizontalPosition.right = "right", 
            referenceLineDataLabelHorizontalPosition.type = powerbi.createEnumType([ {
                value: referenceLineDataLabelHorizontalPosition.left,
                displayName: function(resources) {
                    return resources.get("Visual_Reference_Line_Data_Label_Left");
                }
            }, {
                value: referenceLineDataLabelHorizontalPosition.right,
                displayName: function(resources) {
                    return resources.get("Visual_Reference_Line_Data_Label_Right");
                }
            } ]);
        }(referenceLineDataLabelHorizontalPosition = visuals.referenceLineDataLabelHorizontalPosition || (visuals.referenceLineDataLabelHorizontalPosition = {}));
        var referenceLineDataLabelVerticalPosition;
        !function(referenceLineDataLabelVerticalPosition) {
            referenceLineDataLabelVerticalPosition.above = "above", referenceLineDataLabelVerticalPosition.under = "under", 
            referenceLineDataLabelVerticalPosition.type = powerbi.createEnumType([ {
                value: referenceLineDataLabelVerticalPosition.above,
                displayName: function(resources) {
                    return resources.get("Visual_Reference_Line_Data_Label_Above");
                }
            }, {
                value: referenceLineDataLabelVerticalPosition.under,
                displayName: function(resources) {
                    return resources.get("Visual_Reference_Line_Data_Label_Under");
                }
            } ]);
        }(referenceLineDataLabelVerticalPosition = visuals.referenceLineDataLabelVerticalPosition || (visuals.referenceLineDataLabelVerticalPosition = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var slicerOrientation;
        !function(slicerOrientation) {
            slicerOrientation.type = powerbi.createEnumType([ {
                value: 0,
                displayName: function(resources) {
                    return resources.get("Slicer_Orientation_Vertical");
                }
            }, {
                value: 1,
                displayName: function(resources) {
                    return resources.get("Slicer_Orientation_Horizontal");
                }
            } ]);
        }(slicerOrientation = visuals.slicerOrientation || (visuals.slicerOrientation = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var yAxisPosition;
        !function(yAxisPosition) {
            yAxisPosition.left = "Left", yAxisPosition.right = "Right", yAxisPosition.type = powerbi.createEnumType([ {
                value: yAxisPosition.left,
                displayName: function(resources) {
                    return resources.get("Visual_yAxis_Left");
                }
            }, {
                value: yAxisPosition.right,
                displayName: function(resources) {
                    return resources.get("Visual_yAxis_Right");
                }
            } ]);
        }(yAxisPosition = visuals.yAxisPosition || (visuals.yAxisPosition = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var AnimatorCommon;
        !function(AnimatorCommon) {
            function GetAnimationDuration(animator, suppressAnimations) {
                return suppressAnimations || !animator ? 0 : animator.getDuration();
            }
            AnimatorCommon.MinervaAnimationDuration = 250, AnimatorCommon.MaxDataPointsToAnimate = 1e3, 
            AnimatorCommon.GetAnimationDuration = GetAnimationDuration;
        }(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
        var BaseAnimator = function() {
            function BaseAnimator(options) {
                options && options.duration && (this.animationDuration = options.duration), this.animationDuration = this.animationDuration >= 0 ? this.animationDuration : AnimatorCommon.MinervaAnimationDuration;
            }
            return BaseAnimator.prototype.getDuration = function() {
                return this.animationDuration;
            }, BaseAnimator.prototype.animate = function(options) {
                return null;
            }, BaseAnimator;
        }();
        visuals.BaseAnimator = BaseAnimator;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var WebColumnChartAnimator = function(_super) {
            function WebColumnChartAnimator(options) {
                _super.call(this, options);
            }
            return __extends(WebColumnChartAnimator, _super), WebColumnChartAnimator.prototype.animate = function(options) {
                var result = {
                    failed: !0,
                    shapes: null
                }, viewModel = options.viewModel, previousViewModel = this.previousViewModel, dataPointCount = viewModel.categories.length * viewModel.series.length;
                return dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate ? result : (previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                this.previousViewModel = viewModel, result);
            }, WebColumnChartAnimator.prototype.animateNormalToHighlighted = function(options) {
                var data = options.viewModel, itemCS = options.itemCS, shapeSelection = options.series.selectAll(itemCS.selector), shapes = shapeSelection.data(function(d) {
                    return d.data;
                }, function(d) {
                    return d.key;
                }), hasHighlights = data.hasHighlights;
                return shapes.enter().append("rect").attr("class", function(d) {
                    return itemCS["class"].concat(d.highlight ? " highlight" : "");
                }).attr(options.layout.shapeLayoutWithoutHighlights), shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !1, hasHighlights);
                }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout), 
                shapes.exit().remove(), {
                    failed: !1,
                    shapes: shapes
                };
            }, WebColumnChartAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var shapes = this.animateDefaultShapes(options.viewModel, options.series, options.layout, options.itemCS);
                return {
                    failed: !1,
                    shapes: shapes
                };
            }, WebColumnChartAnimator.prototype.animateHighlightedToNormal = function(options) {
                var itemCS = options.itemCS, shapeSelection = options.series.selectAll(itemCS.selector), shapes = shapeSelection.data(function(d) {
                    return d.data;
                }, function(d) {
                    return d.key;
                }), hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                return shapes.enter().append("rect").attr("class", function(d) {
                    return itemCS["class"].concat(d.highlight ? " highlight" : "");
                }), shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, d.selected, !d.selected);
                }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout).transition().duration(0).delay(this.animationDuration).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                }), shapes.exit().transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayoutWithoutHighlights).remove(), 
                {
                    failed: !1,
                    shapes: shapes
                };
            }, WebColumnChartAnimator.prototype.animateDefaultShapes = function(data, series, layout, itemCS) {
                var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(function(d) {
                    return d.data;
                }, function(d) {
                    return d.key;
                });
                return shapes.enter().append("rect").attr("class", function(d) {
                    return itemCS["class"].concat(d.highlight ? " highlight" : "");
                }), shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !1, data.hasHighlights);
                }).transition().duration(this.animationDuration).attr(layout.shapeLayout), shapes.exit().remove(), 
                shapes;
            }, WebColumnChartAnimator;
        }(visuals.BaseAnimator);
        visuals.WebColumnChartAnimator = WebColumnChartAnimator;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var WebDonutChartAnimator = function(_super) {
            function WebDonutChartAnimator(options) {
                _super.call(this, options);
            }
            return __extends(WebDonutChartAnimator, _super), WebDonutChartAnimator.prototype.animate = function(options) {
                var result = {
                    failed: !0,
                    shapes: null,
                    highlightShapes: null
                }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                return previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                this.previousViewModel = viewModel, result;
            }, WebDonutChartAnimator.prototype.animateNormalToHighlighted = function(options) {
                var shapes = this.animateDefaultShapes(options), highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                return highlightShapes.enter().insert("path").classed("slice-highlight", !0).each(function(d) {
                    this._current = d;
                }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                })), highlightShapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, options.viewModel.hasHighlights);
                }).style("stroke-dasharray", function(d) {
                    return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio);
                }).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).attr(options.layout.shapeLayout).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout), 
                highlightShapes.exit().remove(), visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, !1, !0, !0), 
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels), 
                {
                    failed: !1,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            }, WebDonutChartAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var shapes = this.animateDefaultShapes(options), highlightShapes = this.animateDefaultHighlightShapes(options);
                return visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, !1, !0, !0), 
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels), 
                {
                    failed: !1,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            }, WebDonutChartAnimator.prototype.animateHighlightedToNormal = function(options) {
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection(), duration = this.animationDuration, shapes = options.graphicsContext.select(".slices").selectAll("path.slice").data(options.viewModel.dataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                shapes.enter().insert("path").classed("slice", !0).each(function(d) {
                    this._current = d;
                }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints), shapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, d.data.selected, !d.data.selected);
                }).style("stroke-dasharray", function(d) {
                    return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio);
                }).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).transition().duration(duration).attr(options.layout.shapeLayout).transition().duration(0).delay(duration).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                }), shapes.exit().remove();
                var highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                return highlightShapes.enter().insert("path").classed("slice-highlight", !0).each(function(d) {
                    this._current = d;
                }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                })), highlightShapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(!1, !0, !1, !0);
                }).style("stroke-dasharray", function(d) {
                    return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio);
                }).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).transition().duration(duration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout).remove(), 
                highlightShapes.exit().remove(), visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, !1, !0, !0), 
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels), 
                {
                    failed: !1,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            }, WebDonutChartAnimator.prototype.animateDefaultShapes = function(options) {
                var shapes = options.graphicsContext.select(".slices").selectAll("path.slice").data(options.viewModel.dataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                return shapes.enter().insert("path").classed("slice", !0).each(function(d) {
                    this._current = d;
                }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints), shapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, !1, options.viewModel.hasHighlights);
                }).style("stroke-dasharray", function(d) {
                    return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio);
                }).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout), 
                shapes.exit().remove(), shapes;
            }, WebDonutChartAnimator.prototype.animateDefaultHighlightShapes = function(options) {
                var highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                return highlightShapes.enter().insert("path").classed("slice-highlight", !0).each(function(d) {
                    this._current = d;
                }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                })), highlightShapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, options.viewModel.hasHighlights);
                }).style("stroke-dasharray", function(d) {
                    return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio);
                }).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout), 
                highlightShapes.exit().remove(), highlightShapes;
            }, WebDonutChartAnimator;
        }(visuals.BaseAnimator);
        visuals.WebDonutChartAnimator = WebDonutChartAnimator;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var WebFunnelAnimator = function(_super) {
            function WebFunnelAnimator(options) {
                _super.call(this, options);
            }
            return __extends(WebFunnelAnimator, _super), WebFunnelAnimator.prototype.animate = function(options) {
                var result = {
                    failed: !0,
                    shapes: null,
                    dataLabels: null
                }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                return previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                this.previousViewModel = viewModel, result;
            }, WebFunnelAnimator.prototype.animateNormalToHighlighted = function(options) {
                var data = options.viewModel, layout = options.layout, hasHighlights = !0, hasSelection = !1;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.slices, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars["class"];
                }).attr(layout.shapeLayoutWithoutHighlights), shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                }).transition().duration(this.animationDuration).attr(layout.shapeLayout), shapes.exit().remove(), 
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: !1,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            }, WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var data = options.viewModel, layout = options.layout;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = this.animateDefaultShapes(data, data.slices, options.shapeGraphicsContext, layout);
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: !1,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            }, WebFunnelAnimator.prototype.animateHighlightedToNormal = function(options) {
                var data = options.viewModel, layout = options.layout, hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : !1;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.slices, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars["class"];
                }), shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !d.selected);
                }).transition().duration(this.animationDuration).attr(layout.shapeLayoutWithoutHighlights).transition().duration(0).delay(this.animationDuration).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                });
                var exitShapes = shapes.exit();
                exitShapes.transition().duration(this.animationDuration).attr(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights).remove(), 
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: !1,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            }, WebFunnelAnimator.prototype.animateDefaultAxis = function(graphicsContext, axisOptions, isHidingPercentBars) {
                var xScaleForAxis = d3.scale.ordinal().domain(axisOptions.categoryLabels).rangeBands([ axisOptions.rangeStart, axisOptions.rangeEnd ], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : visuals.FunnelChart.PercentBarToBarRatio), xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right").tickPadding(visuals.FunnelChart.TickPadding).innerTickSize(visuals.FunnelChart.InnerTickSize);
                graphicsContext.classed("axis", !0).transition().duration(this.animationDuration).attr("transform", visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis);
            }, WebFunnelAnimator.prototype.animateDefaultShapes = function(data, slices, graphicsContext, layout) {
                var hasHighlights = data.hasHighlights, shapes = graphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(slices, function(d) {
                    return d.key;
                });
                return shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars["class"];
                }), shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !1, hasHighlights);
                    };
                }).transition().duration(this.animationDuration).attr(layout.shapeLayout), shapes.exit().remove(), 
                shapes;
            }, WebFunnelAnimator.prototype.animateDefaultDataLabels = function(options) {
                var dataLabels;
                return options.viewModel.dataLabelsSettings.show && options.viewModel.canShowDataLabels ? dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(options.viewModel.slices, options.labelGraphicsContext, options.labelLayout, !0, this.animationDuration) : visuals.dataLabelUtils.cleanDataLabels(options.labelGraphicsContext), 
                dataLabels;
            }, WebFunnelAnimator.prototype.animatePercentBars = function(options) {
                var data = options.viewModel, isHidingPercentBars = options.isHidingPercentBars;
                if (isHidingPercentBars || !data.slices || (data.hasHighlights ? data.slices.length / 2 : data.slices.length) < 2) return void this.animatePercentBarComponents([], options);
                var slices = [ data.slices[data.hasHighlights ? 1 : 0], data.slices[data.slices.length - 1] ], baseline = visuals.FunnelChart.getFunnelSliceValue(slices[0]);
                if (0 >= baseline) return void this.animatePercentBarComponents([], options);
                var percentData = slices.map(function(slice, i) {
                    return {
                        value: visuals.FunnelChart.getFunnelSliceValue(slice),
                        percent: 0 === i ? 1 : visuals.FunnelChart.getFunnelSliceValue(slice) / baseline,
                        isTop: 0 === i
                    };
                });
                this.animatePercentBarComponents(percentData, options);
            }, WebFunnelAnimator.prototype.animateToFunnelPercent = function(context, targetData, layout) {
                return context.data(targetData).transition().duration(this.animationDuration).attr(layout);
            }, WebFunnelAnimator.prototype.animatePercentBarComponents = function(data, options) {
                var graphicsContext = options.percentGraphicsContext, layout = options.layout, zeroData = [ {
                    percent: 0,
                    value: 0,
                    isTop: !0
                }, {
                    percent: 0,
                    value: 0,
                    isTop: !1
                } ], mainLine = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                this.animateToFunnelPercent(mainLine.exit(), zeroData, layout.percentBarLayout.mainLine).remove(), 
                mainLine.enter().append("line").classed(visuals.FunnelChart.Selectors.percentBar.mainLine["class"], !0).data(zeroData).attr(layout.percentBarLayout.mainLine), 
                this.animateToFunnelPercent(mainLine, data, layout.percentBarLayout.mainLine);
                var leftTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                this.animateToFunnelPercent(leftTick.exit(), zeroData, layout.percentBarLayout.leftTick).remove(), 
                leftTick.enter().append("line").classed(visuals.FunnelChart.Selectors.percentBar.leftTick["class"], !0).data(zeroData).attr(layout.percentBarLayout.leftTick), 
                this.animateToFunnelPercent(leftTick, data, layout.percentBarLayout.leftTick);
                var rightTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                this.animateToFunnelPercent(rightTick.exit(), zeroData, layout.percentBarLayout.rightTick).remove(), 
                rightTick.enter().append("line").classed(visuals.FunnelChart.Selectors.percentBar.rightTick["class"], !0).data(zeroData).attr(layout.percentBarLayout.rightTick), 
                this.animateToFunnelPercent(rightTick, data, layout.percentBarLayout.rightTick);
                var text = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.text.selector).data(data);
                this.animateToFunnelPercent(text.exit(), zeroData, layout.percentBarLayout.text).remove(), 
                text.enter().append("text").classed(visuals.FunnelChart.Selectors.percentBar.text["class"], !0).data(zeroData).attr(layout.percentBarLayout.text), 
                this.animateToFunnelPercent(text, data, layout.percentBarLayout.text).text(function(fp) {
                    return powerbi.formattingService.formatValue(fp.percent, visuals.valueFormatter.getLocalizedString("Percentage1"));
                }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(options.visualInitOptions);
            }, WebFunnelAnimator;
        }(visuals.BaseAnimator);
        visuals.WebFunnelAnimator = WebFunnelAnimator;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var WebTreemapAnimator = function(_super) {
            function WebTreemapAnimator(options) {
                _super.call(this, options);
            }
            return __extends(WebTreemapAnimator, _super), WebTreemapAnimator.prototype.animate = function(options) {
                var result = {
                    failed: !0,
                    shapes: null,
                    highlightShapes: null,
                    majorLabels: null,
                    minorLabels: null
                }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                return previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                this.previousViewModel = viewModel, result;
            }, WebTreemapAnimator.prototype.animateNormalToHighlighted = function(options) {
                var hasSelection = !1, hasHighlights = !0, shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout), highlightShapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function(d) {
                    return d.key + "highlight";
                });
                highlightShapes.enter().append("rect").attr("class", options.layout.highlightShapeClass).attr(options.layout.shapeLayout), 
                highlightShapes.style("fill", function(d) {
                    return visuals.Treemap.getFill(d, !0);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, !0);
                }).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout), 
                highlightShapes.exit().remove();
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout), minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: !1,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels
                };
            }, WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var hasSelection = !1, hasHighlights = !0, shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
                options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function(d) {
                    return d.key + "highlight";
                });
                var highlightShapes = this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, hasHighlights, options.layout), majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout), minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: !1,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels
                };
            }, WebTreemapAnimator.prototype.animateHighlightedToNormal = function(options) {
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : !1, shapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.TreemapNodeClassName).data(options.nodes, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", options.layout.shapeClass), shapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return visuals.Treemap.getFill(d, !1);
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, d.selected, !d.selected);
                }).attr(options.layout.shapeLayout).transition().duration(0).delay(this.animationDuration).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                }), shapes.exit().remove();
                var highlightShapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.nodes, function(d) {
                    return d.key + "highlight";
                });
                highlightShapes.enter().append("rect").attr("class", options.layout.highlightShapeClass), 
                highlightShapes.style("fill", function(d) {
                    return visuals.Treemap.getFill(d, !0);
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !0, d.selected, !d.selected);
                }).transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout).remove(), 
                highlightShapes.exit().remove();
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout), minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: !1,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels
                };
            }, WebTreemapAnimator.prototype.animateDefaultShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = !1, shapes = context.selectAll("." + visuals.Treemap.TreemapNodeClassName).data(nodes, function(d) {
                    return d.key;
                });
                return shapes.enter().append("rect").attr("class", layout.shapeClass), shapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return visuals.Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
            }, WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = !0, highlightShapes = context.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(nodes, function(d) {
                    return d.key + "highlight";
                });
                return highlightShapes.enter().append("rect").attr("class", layout.highlightShapeClass), 
                highlightShapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return visuals.Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(layout.highlightShapeLayout), highlightShapes.exit().remove(), highlightShapes;
            }, WebTreemapAnimator.prototype.animateDefaultMajorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + visuals.Treemap.MajorLabelClassName).data(nodes, function(d) {
                    return d.key;
                });
                return labels.enter().append("text").attr("class", layout.majorLabelClass), labels.text(layout.majorLabelText).style("fill", function() {
                    return labelSettings.labelColor;
                }).transition().duration(this.animationDuration).attr(layout.majorLabelLayout), 
                labels.exit().remove(), labels;
            }, WebTreemapAnimator.prototype.animateDefaultMinorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + visuals.Treemap.MinorLabelClassName).data(nodes, function(d) {
                    return d.key;
                });
                return labels.enter().append("text").attr("class", layout.minorLabelClass), labels.text(layout.minorLabelText).style("fill", function() {
                    return labelSettings.labelColor;
                }).transition().duration(this.animationDuration).attr(layout.minorLabelLayout), 
                labels.exit().remove(), labels;
            }, WebTreemapAnimator;
        }(visuals.BaseAnimator);
        visuals.WebTreemapAnimator = WebTreemapAnimator;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.animatedTextObjectDescs = {
            general: {
                properties: {
                    formatString: {
                        type: {
                            formatting: {
                                formatString: !0
                            }
                        }
                    }
                }
            }
        }, visuals.animatedNumberCapabilities = {
            objects: visuals.animatedTextObjectDescs,
            dataViewMappings: [ {
                single: {
                    role: "Values"
                }
            } ],
            supportsSelection: !1
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.basicShapeCapabilities = {
            objects: {
                line: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Line"),
                    properties: {
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_LineColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Background_TransparencyDescription"),
                            type: {
                                numeric: !0
                            }
                        },
                        weight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Weight"),
                            type: {
                                numeric: !0
                            }
                        },
                        roundEdge: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_RoundEdges"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                fill: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        fillColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_FillColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Background_TransparencyDescription"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                rotation: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Rotate"),
                    properties: {
                        angle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Rotate"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                general: {
                    properties: {
                        shapeType: {
                            type: {
                                text: !0
                            }
                        }
                    }
                }
            },
            suppressDefaultTitle: !0,
            suppressDefaultPadding: !0,
            canRotate: !1,
            supportsSelection: !1
        }, visuals.basicShapeProps = {
            general: {
                shapeType: {
                    objectName: "general",
                    propertyName: "shapeType"
                }
            },
            line: {
                transparency: {
                    objectName: "line",
                    propertyName: "transparency"
                },
                weight: {
                    objectName: "line",
                    propertyName: "weight"
                },
                roundEdge: {
                    objectName: "line",
                    propertyName: "roundEdge"
                },
                lineColor: {
                    objectName: "line",
                    propertyName: "lineColor"
                }
            },
            fill: {
                transparency: {
                    objectName: "fill",
                    propertyName: "transparency"
                },
                fillColor: {
                    objectName: "fill",
                    propertyName: "fillColor"
                },
                show: {
                    objectName: "fill",
                    propertyName: "show"
                }
            },
            rotation: {
                angle: {
                    objectName: "rotation",
                    propertyName: "angle"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function getColumnChartCapabilities(transposeAxes) {
            return void 0 === transposeAxes && (transposeAxes = !1), {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription")
                }, {
                    name: "Series",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: "Gradient",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: !0
                                    }
                                }
                            }
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: !0
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                type: {
                                    enumeration: visuals.legendPosition.type
                                }
                            },
                            showTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            titleText: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                type: {
                                    text: !0
                                },
                                suppressFormatPainterCopy: !0
                            },
                            labelColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            fontSize: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                type: {
                                    formatting: {
                                        fontSize: !0
                                    }
                                }
                            }
                        }
                    },
                    categoryAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_YAxis") : powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: !0
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                description: powerbi.data.createDisplayNameGetter("Visual_YAxis_PositionDescription"),
                                type: {
                                    enumeration: visuals.yAxisPosition.type
                                }
                            },
                            axisScale: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                type: {
                                    enumeration: visuals.axisScale.type
                                }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                                type: {
                                    numeric: !0
                                },
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                suppressFormatPainterCopy: !0
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                type: {
                                    numeric: !0
                                },
                                suppressFormatPainterCopy: !0
                            },
                            axisType: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                                type: {
                                    enumeration: visuals.axisType.type
                                }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription") : powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                type: {
                                    enumeration: visuals.axisStyle.type
                                }
                            },
                            labelColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                type: {
                                    formatting: {
                                        labelDisplayUnits: !0
                                    }
                                }
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits_Auto"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    valueAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_XAxis") : powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: !0
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                description: powerbi.data.createDisplayNameGetter("Visual_YAxis_PositionDescription"),
                                type: {
                                    enumeration: visuals.yAxisPosition.type
                                }
                            },
                            axisScale: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                type: {
                                    enumeration: visuals.axisScale.type
                                }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                                type: {
                                    numeric: !0
                                },
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                suppressFormatPainterCopy: !0
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                                type: {
                                    numeric: !0
                                },
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                suppressFormatPainterCopy: !0
                            },
                            intersection: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Intersection"),
                                type: {
                                    numeric: !0
                                },
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto")
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription") : powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                type: {
                                    enumeration: visuals.axisStyle.type
                                }
                            },
                            labelColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                type: {
                                    formatting: {
                                        labelDisplayUnits: !0
                                    }
                                }
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits_Auto"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    y1AxisReferenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: !0
                                }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color_Description"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style_Description"),
                                type: {
                                    enumeration: visuals.lineStyle.type
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange_Description"),
                                type: {
                                    enumeration: visuals.referenceLinePosition.type
                                }
                            },
                            dataLabelShow: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Show_Description"),
                                type: {
                                    bool: !0
                                }
                            },
                            dataLabelColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            dataLabelDecimalPoints: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                type: {
                                    numeric: !0
                                }
                            },
                            dataLabelHorizontalPosition: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Horizontal_Position_Description"),
                                type: {
                                    enumeration: visuals.referenceLineDataLabelHorizontalPosition.type
                                }
                            },
                            dataLabelVerticalPosition: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Vertical_Position_Description"),
                                type: {
                                    enumeration: visuals.referenceLineDataLabelVerticalPosition.type
                                }
                            },
                            dataLabelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                type: {
                                    formatting: {
                                        labelDisplayUnits: !0
                                    }
                                },
                                suppressFormatPainterCopy: !0
                            }
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            showAllDataPoints: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                type: {
                                    bool: !0
                                }
                            },
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category" ]
                                    }
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: !0
                                }
                            },
                            showSeries: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: !0
                                }
                            },
                            color: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                type: {
                                    formatting: {
                                        labelDisplayUnits: !0
                                    }
                                },
                                suppressFormatPainterCopy: !0
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                type: {
                                    numeric: !0
                                },
                                suppressFormatPainterCopy: !0
                            },
                            showAll: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelSeriesShowAll"),
                                type: {
                                    bool: !0
                                }
                            },
                            fontSize: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                type: {
                                    formatting: {
                                        fontSize: !0
                                    }
                                }
                            }
                        }
                    },
                    plotArea: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                        properties: {
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                                type: {
                                    numeric: !0
                                }
                            },
                            image: {
                                type: {
                                    image: {}
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        Gradient: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Gradient: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        Y: {
                            min: 0,
                            max: 1
                        },
                        Gradient: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    "for": {
                                        "in": "Y"
                                    }
                                }, {
                                    bind: {
                                        to: "Gradient"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            },
                            supported: {
                                min: 0
                            }
                        }
                    }
                } ],
                supportsHighlight: !0,
                sorting: {
                    "default": {}
                },
                drilldown: {
                    roles: [ "Category" ]
                }
            };
        }
        visuals.getColumnChartCapabilities = getColumnChartCapabilities, visuals.columnChartProps = {
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                },
                showAllDataPoints: {
                    objectName: "dataPoint",
                    propertyName: "showAllDataPoints"
                }
            },
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            categoryAxis: {
                axisType: {
                    objectName: "categoryAxis",
                    propertyName: "axisType"
                }
            },
            legend: {
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            },
            plotArea: {
                image: {
                    objectName: "plotArea",
                    propertyName: "image"
                },
                transparency: {
                    objectName: "plotArea",
                    propertyName: "transparency"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.comboChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Category"),
                description: powerbi.data.createDisplayNameGetter("Role_ComboChart_CategoryDescription")
            }, {
                name: "Series",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Series")
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y"),
                description: powerbi.data.createDisplayNameGetter("Role_ComboChart_YDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: "Y2",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y2"),
                description: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y2Description"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        },
                        visualType1: {
                            type: {
                                text: !0
                            }
                        },
                        visualType2: {
                            type: {
                                text: !0
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                enumeration: visuals.legendPosition.type
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                            type: {
                                enumeration: visuals.axisScale.type
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        axisType: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                            type: {
                                enumeration: visuals.axisType.type
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        axisLabel: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_ColumnTitle"),
                            type: {
                                none: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            type: {
                                enumeration: visuals.yAxisPosition.type
                            }
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                            type: {
                                enumeration: visuals.axisScale.type
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        secShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_ShowSecondary"),
                            type: {
                                bool: !0
                            }
                        },
                        secAxisLabel: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_LineTitle"),
                            type: {
                                none: !0
                            }
                        },
                        secPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            type: {
                                enumeration: visuals.yAxisPosition.type
                            }
                        },
                        secAxisScale: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                            type: {
                                enumeration: visuals.axisScale.type
                            }
                        },
                        secStart: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            }
                        },
                        secEnd: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            }
                        },
                        secShowAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        secAxisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        secLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        secLabelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColumnColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: !0
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                            type: {
                                numeric: !0
                            }
                        },
                        image: {
                            type: {
                                image: {}
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        min: 1,
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                "for": {
                                    "in": "Y"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        },
                        supported: {
                            min: 0
                        }
                    }
                }
            }, {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    Y2: {
                        min: 1
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        min: 1,
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Y2: {
                        min: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        select: [ {
                            "for": {
                                "in": "Y2"
                            }
                        } ]
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        },
                        supported: {
                            min: 0
                        }
                    }
                }
            } ],
            supportsHighlight: !0,
            sorting: {
                "default": {}
            },
            drilldown: {
                roles: [ "Category" ]
            }
        }, visuals.comboChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            valueAxis: {
                secShow: {
                    objectName: "valueAxis",
                    propertyName: "secShow"
                }
            },
            legend: {
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            },
            dataPoint: {
                showAllDataPoints: {
                    objectName: "dataPoint",
                    propertyName: "showAllDataPoints"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.donutChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
            }, {
                name: "Series",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_DetailsDonutChartDescription")
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                enumeration: visuals.legendPosition.type
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DetailLabels"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelStyle"),
                            type: {
                                enumeration: visuals.labelStyle.type
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        min: 1,
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "Y"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        },
                        supported: {
                            min: 1
                        }
                    }
                }
            } ],
            sorting: {
                "default": {}
            },
            supportsHighlight: !0,
            drilldown: {
                roles: [ "Category" ]
            }
        }, visuals.donutChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                },
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.dataDotChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        select: [ {
                            "for": {
                                "in": "Y"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        } ]
                    }
                }
            } ]
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.filledMapCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LocationFilledMapDescription"),
                preferredTypes: [ {
                    geography: {
                        address: !0
                    }
                }, {
                    geography: {
                        city: !0
                    }
                }, {
                    geography: {
                        continent: !0
                    }
                }, {
                    geography: {
                        country: !0
                    }
                }, {
                    geography: {
                        county: !0
                    }
                }, {
                    geography: {
                        place: !0
                    }
                }, {
                    geography: {
                        postalCode: !0
                    }
                }, {
                    geography: {
                        region: !0
                    }
                }, {
                    geography: {
                        stateOrProvince: !0
                    }
                } ]
            }, {
                name: "Series",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
            }, {
                name: "X",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Longitude"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LongitudeFilledMapDescription"),
                preferredTypes: [ {
                    geography: {
                        longitude: !0
                    }
                } ]
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Latitude"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LatitudeFilledMapDescription"),
                preferredTypes: [ {
                    geography: {
                        latitude: !0
                    }
                } ]
            }, {
                name: "Size",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                formatting: {
                                    legendPosition: !0
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: !0
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                            description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Size",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 1
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "X"
                                }
                            }, {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "Size"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            } ],
            sorting: {
                custom: {}
            },
            drilldown: {
                roles: [ "Category" ]
            }
        }, visuals.filledMapProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                },
                showAllDataPoints: {
                    objectName: "dataPoint",
                    propertyName: "showAllDataPoints"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                }
            },
            labels: {
                show: {
                    objectName: "labels",
                    propertyName: "show"
                },
                color: {
                    objectName: "labels",
                    propertyName: "color"
                },
                labelDisplayUnits: {
                    objectName: "labels",
                    propertyName: "labelDisplayUnits"
                },
                labelPrecision: {
                    objectName: "labels",
                    propertyName: "labelPrecision"
                }
            },
            categoryLabels: {
                show: {
                    objectName: "categoryLabels",
                    propertyName: "show"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.funnelChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GroupFunnelDescription")
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: "Gradient",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 0
                    },
                    Gradient: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        select: [ {
                            "for": {
                                "in": "Y"
                            }
                        }, {
                            bind: {
                                to: "Gradient"
                            }
                        } ],
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 1
                        }
                    }
                }
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Position"),
                            type: {
                                enumeration: visuals.labelPosition.type
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                percentBarLabel: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_PercentBarLabel"),
                    description: powerbi.data.createDisplayNameGetter("Visual_PercentBarLabelDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                }
            },
            supportsHighlight: !0,
            sorting: {
                "default": {}
            },
            drilldown: {
                roles: [ "Category" ]
            }
        }, visuals.funnelChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.gaugeRoleNames = {
            y: "Y",
            minValue: "MinValue",
            maxValue: "MaxValue",
            targetValue: "TargetValue"
        }, visuals.gaugeCapabilities = {
            dataRoles: [ {
                name: visuals.gaugeRoleNames.y,
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValueDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: visuals.gaugeRoleNames.minValue,
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_MinValue"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_MinValueDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: visuals.gaugeRoleNames.maxValue,
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_MaxValue"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_MaxValueDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: visuals.gaugeRoleNames.targetValue,
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_TargetValue"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_TargetValueDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                axis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis"),
                    properties: {
                        min: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Min"),
                            type: {
                                numeric: !0
                            }
                        },
                        max: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Max"),
                            type: {
                                numeric: !0
                            }
                        },
                        target: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Target"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                calloutValue: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_CalloutValue"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        target: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Target"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Y: {
                        max: 1
                    },
                    MinValue: {
                        max: 1
                    },
                    MaxValue: {
                        max: 1
                    },
                    TargetValue: {
                        max: 1
                    }
                } ],
                categorical: {
                    values: {
                        select: [ {
                            bind: {
                                to: "Y"
                            }
                        }, {
                            bind: {
                                to: "MinValue"
                            }
                        }, {
                            bind: {
                                to: "MaxValue"
                            }
                        }, {
                            bind: {
                                to: "TargetValue"
                            }
                        } ]
                    }
                }
            } ],
            supportsSelection: !1
        }, visuals.gaugeProps = {
            dataPoint: {
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                },
                target: {
                    objectName: "dataPoint",
                    propertyName: "target"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.imageVisualCapabilities = {
            objects: {
                general: {
                    properties: {
                        imageUrl: {
                            type: {
                                misc: {
                                    imageUrl: !0
                                }
                            }
                        }
                    }
                },
                imageScaling: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Image_Scaling_Type"),
                    properties: {
                        imageScalingType: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Image_Scaling_Type"),
                            type: {
                                enumeration: visuals.imageScalingType.type
                            }
                        }
                    }
                }
            },
            suppressDefaultTitle: !0,
            supportsSelection: !1
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.scriptVisualCapabilities = {
            dataRoles: [ {
                name: "Values",
                kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
            } ],
            dataViewMappings: [ {
                scriptResult: {
                    dataInput: {
                        table: {
                            rows: {
                                "for": {
                                    "in": "Values"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        }
                    },
                    script: {
                        source: {
                            objectName: "script",
                            propertyName: "source"
                        },
                        provider: {
                            objectName: "script",
                            propertyName: "provider"
                        }
                    }
                }
            } ],
            objects: {
                script: {
                    properties: {
                        provider: {
                            type: {
                                text: !0
                            }
                        },
                        source: {
                            type: {
                                scripting: {
                                    source: !0
                                }
                            }
                        }
                    }
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.lineChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription"),
                cartesianKind: 0
            }, {
                name: "Series",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ],
                cartesianKind: 1
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                enumeration: visuals.legendPosition.type
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                trend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style_Description"),
                            type: {
                                enumeration: visuals.lineStyle.type
                            }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                            type: {
                                enumeration: visuals.axisScale.type
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        axisType: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                            type: {
                                enumeration: visuals.axisType.type
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_YAxis_PositionDescription"),
                            type: {
                                enumeration: visuals.yAxisPosition.type
                            }
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                            type: {
                                enumeration: visuals.axisScale.type
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style_Description"),
                            type: {
                                enumeration: visuals.lineStyle.type
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange_Description"),
                            type: {
                                enumeration: visuals.referenceLinePosition.type
                            }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Show_Description"),
                            type: {
                                bool: !0
                            }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Horizontal_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelHorizontalPosition.type
                            }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Vertical_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelVerticalPosition.type
                            }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        showSeries: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        showAll: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelSeriesShowAll"),
                            type: {
                                bool: !0
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        },
                        labelDensity: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelDensity"),
                            type: {
                                formatting: {
                                    labelDensity: !0
                                }
                            }
                        }
                    }
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                            type: {
                                numeric: !0
                            }
                        },
                        image: {
                            type: {
                                image: {}
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        min: 1,
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                "for": {
                                    "in": "Y"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    }
                }
            }, {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    Y: {
                        max: 1
                    }
                } ],
                requiredProperties: [ {
                    objectName: "trend",
                    propertyName: "show"
                } ],
                usage: {
                    regression: {}
                },
                categorical: {
                    categories: {
                        "for": {
                            "in": "regression.X"
                        }
                    },
                    values: {
                        "for": {
                            "in": "regression.Y"
                        }
                    }
                }
            } ],
            sorting: {
                "default": {}
            }
        }, visuals.lineChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            trend: {
                show: {
                    objectName: "trend",
                    propertyName: "show"
                }
            },
            categoryAxis: {
                axisType: {
                    objectName: "categoryAxis",
                    propertyName: "axisType"
                }
            },
            legend: {
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            },
            labels: {
                labelDensity: {
                    objectName: "labels",
                    propertyName: "labelDensity"
                }
            },
            plotArea: {
                image: {
                    objectName: "plotArea",
                    propertyName: "image"
                },
                transparency: {
                    objectName: "plotArea",
                    propertyName: "transparency"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.mapCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LocationMapDescription"),
                preferredTypes: [ {
                    geography: {
                        address: !0
                    }
                }, {
                    geography: {
                        city: !0
                    }
                }, {
                    geography: {
                        continent: !0
                    }
                }, {
                    geography: {
                        country: !0
                    }
                }, {
                    geography: {
                        county: !0
                    }
                }, {
                    geography: {
                        place: !0
                    }
                }, {
                    geography: {
                        postalCode: !0
                    }
                }, {
                    geography: {
                        region: !0
                    }
                }, {
                    geography: {
                        stateOrProvince: !0
                    }
                } ]
            }, {
                name: "Series",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
            }, {
                name: "X",
                kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Longitude"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LongitudeMapDescription"),
                preferredTypes: [ {
                    geography: {
                        longitude: !0
                    }
                } ]
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Latitude"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LatitudeMapDescription"),
                preferredTypes: [ {
                    geography: {
                        latitude: !0
                    }
                } ]
            }, {
                name: "Size",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: "Gradient",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                enumeration: visuals.legendPosition.type
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: !0
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        min: 1,
                        max: 1
                    },
                    Series: {
                        max: 1
                    },
                    X: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Measure
                    },
                    Y: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Measure
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    }
                }, {
                    Category: {
                        min: 1,
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Measure
                    },
                    Y: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Measure
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "X"
                                }
                            }, {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "Size"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            }, {
                conditions: [ {
                    Category: {
                        max: 0
                    },
                    Series: {
                        max: 1
                    },
                    X: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Grouping
                    },
                    Y: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Grouping
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 0
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Grouping
                    },
                    Y: {
                        max: 1,
                        kind: powerbi.VisualDataRoleKind.Grouping
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        select: [ {
                            bind: {
                                to: "X"
                            }
                        }, {
                            bind: {
                                to: "Y"
                            }
                        } ],
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "Size"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            } ],
            sorting: {
                custom: {}
            },
            drilldown: {
                roles: [ "Category" ]
            }
        }, visuals.mapProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                },
                showAllDataPoints: {
                    objectName: "dataPoint",
                    propertyName: "showAllDataPoints"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.multiRowCardCapabilities = {
            dataRoles: [ {
                name: "Values",
                kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Fields"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_FieldsDescription")
            } ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                cardTitle: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CardTitle"),
                    description: powerbi.data.createDisplayNameGetter("Visual_CardTitleDescription"),
                    properties: {
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                dataLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                    properties: {
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                table: {
                    rows: {
                        "for": {
                            "in": "Values"
                        },
                        dataReductionAlgorithm: {
                            window: {}
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 1
                        }
                    }
                }
            } ],
            suppressDefaultTitle: !0,
            supportsSelection: !1,
            disableVisualDetails: !0
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.textboxCapabilities = {
            objects: {
                general: {
                    properties: {
                        paragraphs: {
                            type: {
                                paragraphs: {}
                            },
                            suppressFormatPainterCopy: !0
                        }
                    }
                }
            },
            suppressDefaultTitle: !0,
            supportsSelection: !1
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.cheerMeterCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            dataViewMappings: [ {
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        }
                    }
                }
            } ],
            dataPoint: {
                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                properties: {
                    fill: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                        type: {
                            fill: {
                                solid: {
                                    color: !0
                                }
                            }
                        }
                    }
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.scatterChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_DetailsScatterChartDescription")
            }, {
                name: "Series",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
            }, {
                name: "X",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_X"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_XScatterChartDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ],
                cartesianKind: 0
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_YScatterChartDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ],
                cartesianKind: 1
            }, {
                name: "Size",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Size"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_SizeDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: "Gradient",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: "Play",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: "Play Axis"
            } ],
            objects: {
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: !0
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                trend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style_Description"),
                            type: {
                                enumeration: visuals.lineStyle.type
                            }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                            type: {
                                enumeration: visuals.axisScale.type
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_YAxis_PositionDescription"),
                            type: {
                                enumeration: visuals.yAxisPosition.type
                            }
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                            type: {
                                enumeration: visuals.axisScale.type
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                xAxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_X"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style_Description"),
                            type: {
                                enumeration: visuals.lineStyle.type
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange_Description"),
                            type: {
                                enumeration: visuals.referenceLinePosition.type
                            }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Show_Description"),
                            type: {
                                bool: !0
                            }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Horizontal_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelHorizontalPosition.type
                            }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Vertical_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelVerticalPosition.type
                            }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        }
                    }
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Y"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style_Description"),
                            type: {
                                enumeration: visuals.lineStyle.type
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange_Description"),
                            type: {
                                enumeration: visuals.referenceLinePosition.type
                            }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Show_Description"),
                            type: {
                                bool: !0
                            }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Horizontal_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelHorizontalPosition.type
                            }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Vertical_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelVerticalPosition.type
                            }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                enumeration: visuals.legendPosition.type
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                colorBorder: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_ColorBorder"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                },
                fillPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_FillPoint"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                },
                colorByCategory: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_ColorByCategory"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                },
                currentFrameIndex: {
                    properties: {
                        index: {
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                            type: {
                                numeric: !0
                            }
                        },
                        image: {
                            type: {
                                image: {}
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 1
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    },
                    Play: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    },
                    Play: {
                        max: 0
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "X"
                                }
                            }, {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "Size"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ]
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    },
                    dataReductionAlgorithm: {
                        sample: {}
                    },
                    dataVolume: 4
                }
            }, {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 1
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    },
                    Play: {
                        min: 1,
                        max: 1
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    },
                    Play: {
                        min: 1,
                        max: 1
                    }
                } ],
                matrix: {
                    rows: {
                        select: [ {
                            bind: {
                                to: "Play"
                            }
                        }, {
                            bind: {
                                to: "Category"
                            }
                        } ],
                        dataReductionAlgorithm: {
                            bottom: {
                                count: 5e3
                            }
                        }
                    },
                    columns: {
                        "for": {
                            "in": "Series"
                        },
                        dataReductionAlgorithm: {
                            top: {
                                count: 60
                            }
                        }
                    },
                    values: {
                        select: [ {
                            bind: {
                                to: "X"
                            }
                        }, {
                            bind: {
                                to: "Y"
                            }
                        }, {
                            bind: {
                                to: "Size"
                            }
                        } ]
                    }
                }
            }, {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 0
                    },
                    Gradient: {
                        max: 0
                    },
                    Play: {
                        max: 0
                    }
                } ],
                requiredProperties: [ {
                    objectName: "trend",
                    propertyName: "show"
                } ],
                usage: {
                    regression: {}
                },
                categorical: {
                    categories: {
                        "for": {
                            "in": "regression.X"
                        }
                    },
                    values: {
                        "for": {
                            "in": "regression.Y"
                        }
                    },
                    dataReductionAlgorithm: {
                        sample: {}
                    },
                    dataVolume: 4
                }
            } ],
            sorting: {
                custom: {},
                implicit: {
                    clauses: [ {
                        role: "Play",
                        direction: 1
                    } ]
                }
            },
            drilldown: {
                roles: [ "Category" ]
            }
        }, visuals.scatterChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            trend: {
                show: {
                    objectName: "trend",
                    propertyName: "show"
                }
            },
            colorBorder: {
                show: {
                    objectName: "colorBorder",
                    propertyName: "show"
                }
            },
            fillPoint: {
                show: {
                    objectName: "fillPoint",
                    propertyName: "show"
                }
            },
            colorByCategory: {
                show: {
                    objectName: "colorByCategory",
                    propertyName: "show"
                }
            },
            currentFrameIndex: {
                index: {
                    objectName: "currentFrameIndex",
                    propertyName: "index"
                }
            },
            legend: {
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            },
            plotArea: {
                image: {
                    objectName: "plotArea",
                    propertyName: "image"
                },
                transparency: {
                    objectName: "plotArea",
                    propertyName: "transparency"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.slicerCapabilities = {
            dataRoles: [ {
                name: "Values",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Field"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_FieldDescription")
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        filter: {
                            type: {
                                filter: {}
                            }
                        },
                        defaultValue: {
                            type: {
                                expression: {
                                    defaultValue: !0
                                }
                            }
                        },
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        },
                        outlineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        outlineWeight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight"),
                            type: {
                                numeric: !0
                            }
                        },
                        orientation: {
                            displayName: powerbi.data.createDisplayNameGetter("Slicer_Orientation"),
                            type: {
                                enumeration: visuals.slicerOrientation.type
                            }
                        },
                        count: {
                            type: {
                                integer: !0
                            }
                        }
                    }
                },
                selection: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_SelectionControls"),
                    properties: {
                        selectAllCheckboxEnabled: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_SelectAll"),
                            type: {
                                bool: !0
                            }
                        },
                        singleSelect: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_SingleSelect"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                },
                header: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Header"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_FontColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        background: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                items: {
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Items"),
                    properties: {
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_FontColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        background: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Values: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Values"
                        },
                        dataReductionAlgorithm: {
                            window: {}
                        }
                    },
                    includeEmptyGroups: !0
                }
            } ],
            sorting: {
                "default": {}
            },
            suppressDefaultTitle: !0,
            disableVisualDetails: !0
        }, visuals.slicerProps = {
            general: {
                outlineColor: {
                    objectName: "general",
                    propertyName: "outlineColor"
                },
                outlineWeight: {
                    objectName: "general",
                    propertyName: "outlineWeight"
                },
                orientation: {
                    objectName: "general",
                    propertyName: "orientation"
                },
                count: {
                    objectName: "general",
                    propertyName: "count"
                }
            },
            selection: {
                selectAllCheckboxEnabled: {
                    objectName: "selection",
                    propertyName: "selectAllCheckboxEnabled"
                },
                singleSelect: {
                    objectName: "selection",
                    propertyName: "singleSelect"
                }
            },
            header: {
                show: {
                    objectName: "header",
                    propertyName: "show"
                },
                fontColor: {
                    objectName: "header",
                    propertyName: "fontColor"
                },
                background: {
                    objectName: "header",
                    propertyName: "background"
                },
                outline: {
                    objectName: "header",
                    propertyName: "outline"
                },
                textSize: {
                    objectName: "header",
                    propertyName: "textSize"
                }
            },
            items: {
                fontColor: {
                    objectName: "items",
                    propertyName: "fontColor"
                },
                background: {
                    objectName: "items",
                    propertyName: "background"
                },
                outline: {
                    objectName: "items",
                    propertyName: "outline"
                },
                textSize: {
                    objectName: "items",
                    propertyName: "textSize"
                }
            },
            selectedPropertyIdentifier: {
                objectName: "general",
                propertyName: "selected"
            },
            filterPropertyIdentifier: {
                objectName: "general",
                propertyName: "filter"
            },
            formatString: {
                objectName: "general",
                propertyName: "formatString"
            },
            defaultValue: {
                objectName: "general",
                propertyName: "defaultValue"
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.tableCapabilities = {
            dataRoles: [ {
                name: "Values",
                kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        },
                        columnWidth: {
                            type: {
                                numeric: !0
                            }
                        },
                        totals: {
                            type: {
                                bool: !0
                            },
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Totals")
                        },
                        autoSizeColumnWidth: {
                            type: {
                                bool: !0
                            },
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Adjust_Column_Width")
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                grid: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Grid"),
                    properties: {
                        outlineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_OutlineColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        outlineWeight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight"),
                            description: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight_Desc"),
                            type: {
                                numeric: !0
                            }
                        },
                        gridVertical: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Desc"),
                            type: {
                                bool: !0
                            }
                        },
                        gridVerticalColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        gridVerticalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight_Desc"),
                            type: {
                                numeric: !0
                            }
                        },
                        gridHorizontal: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Desc"),
                            type: {
                                bool: !0
                            }
                        },
                        gridHorizontalColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        gridHorizontalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight_Desc"),
                            type: {
                                numeric: !0
                            }
                        },
                        rowPadding: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_RowPadding"),
                            description: powerbi.data.createDisplayNameGetter("Visual_RowPadding_Desc"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                columnHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_ColumnHeaders"),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                values: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_Values"),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        backgroundColorConditional: {
                            displayName: "Conditional Formatting",
                            type: {
                                bool: !0
                            }
                        },
                        fontColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        urlIcon: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_UrlIcon"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_UrlIcon_Desc"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                },
                total: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_TotalGrand"),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                table: {
                    rows: {
                        "for": {
                            "in": "Values"
                        },
                        dataReductionAlgorithm: {
                            window: {
                                count: 500
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 1
                        }
                    }
                }
            } ],
            sorting: {
                custom: {}
            },
            suppressDefaultTitle: !0,
            supportsSelection: !1,
            disableVisualDetails: !0
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.matrixRoleNames = {
            rows: "Rows",
            columns: "Columns",
            values: "Values"
        }, visuals.matrixCapabilities = {
            dataRoles: [ {
                name: visuals.matrixRoleNames.rows,
                kind: powerbi.VisualDataRoleKind.Grouping,
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_RowsDescription")
            }, {
                name: visuals.matrixRoleNames.columns,
                kind: powerbi.VisualDataRoleKind.Grouping,
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ColumnsDescription")
            }, {
                name: visuals.matrixRoleNames.values,
                kind: powerbi.VisualDataRoleKind.Measure
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        },
                        columnWidth: {
                            type: {
                                numeric: !0
                            }
                        },
                        rowSubtotals: {
                            type: {
                                bool: !0
                            },
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TotalRow")
                        },
                        columnSubtotals: {
                            type: {
                                bool: !0
                            },
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TotalColumn")
                        },
                        autoSizeColumnWidth: {
                            type: {
                                bool: !0
                            },
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Adjust_Column_Width")
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                grid: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Grid"),
                    properties: {
                        outlineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_OutlineColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        outlineWeight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight"),
                            description: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight_Desc"),
                            type: {
                                numeric: !0
                            }
                        },
                        gridVertical: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Desc"),
                            type: {
                                bool: !0
                            }
                        },
                        gridVerticalColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        gridVerticalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight_Desc"),
                            type: {
                                numeric: !0
                            }
                        },
                        gridHorizontal: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Desc"),
                            type: {
                                bool: !0
                            }
                        },
                        gridHorizontalColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        gridHorizontalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight"),
                            description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight_Desc"),
                            type: {
                                numeric: !0
                            }
                        },
                        rowPadding: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_RowPadding"),
                            description: powerbi.data.createDisplayNameGetter("Visual_RowPadding_Desc"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                columnHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_ColumnHeaders"),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                rowHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_RowHeaders"),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                values: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_Values"),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        fontColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                subTotals: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_TotalSub"),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                            type: {
                                enumeration: visuals.outline.type
                            }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor_Desc"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Rows: {
                        max: 0
                    },
                    Columns: {
                        max: 0
                    },
                    Values: {
                        min: 1
                    }
                }, {
                    Rows: {
                        min: 1
                    },
                    Columns: {
                        min: 0
                    },
                    Values: {
                        min: 0
                    }
                }, {
                    Rows: {
                        min: 0
                    },
                    Columns: {
                        min: 1
                    },
                    Values: {
                        min: 0
                    }
                } ],
                matrix: {
                    rows: {
                        "for": {
                            "in": "Rows"
                        },
                        dataReductionAlgorithm: {
                            window: {
                                count: 500
                            }
                        }
                    },
                    columns: {
                        "for": {
                            "in": "Columns"
                        },
                        dataReductionAlgorithm: {
                            top: {
                                count: 100
                            }
                        }
                    },
                    values: {
                        "for": {
                            "in": "Values"
                        }
                    }
                }
            } ],
            filterMappings: {
                measureFilter: {
                    targetRoles: [ visuals.matrixRoleNames.rows ]
                }
            },
            sorting: {
                custom: {}
            },
            suppressDefaultTitle: !0,
            supportsSelection: !1,
            disableVisualDetails: !0
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.treemapCapabilities = {
            dataRoles: [ {
                name: "Group",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GroupTreemapDescription")
            }, {
                name: "Details",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
            }, {
                name: "Values",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            }, {
                name: "Gradient",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                enumeration: visuals.legendPosition.type
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                    properties: {
                        fill: {
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Group" ]
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                    properties: {
                        show: {
                            type: {
                                bool: !0
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Group: {
                        max: 1
                    },
                    Details: {
                        max: 0
                    },
                    Gradient: {
                        max: 1
                    }
                }, {
                    Group: {
                        max: 1
                    },
                    Details: {
                        min: 1,
                        max: 1
                    },
                    Values: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Group"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Details",
                            select: [ {
                                bind: {
                                    to: "Values"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            } ],
            supportsHighlight: !0,
            sorting: {
                custom: {},
                implicit: {
                    clauses: [ {
                        role: "Values",
                        direction: 2
                    } ]
                }
            },
            drilldown: {
                roles: [ "Group" ]
            }
        }, visuals.treemapProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                },
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            },
            labels: {
                show: {
                    objectName: "labels",
                    propertyName: "show"
                },
                color: {
                    objectName: "labels",
                    propertyName: "color"
                },
                labelDisplayUnits: {
                    objectName: "labels",
                    propertyName: "labelDisplayUnits"
                },
                labelPrecision: {
                    objectName: "labels",
                    propertyName: "labelPrecision"
                }
            },
            categoryLabels: {
                show: {
                    objectName: "categoryLabels",
                    propertyName: "show"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.cardCapabilities = {
            dataRoles: [ {
                name: "Values",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Fields"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_FieldsDescription")
            } ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointLabel"),
                    properties: {
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabel"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                wordWrap: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_WordWrap"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Values: {
                        max: 1
                    }
                } ],
                single: {
                    role: "Values"
                }
            } ],
            suppressDefaultTitle: !0,
            supportsSelection: !1
        }, visuals.cardProps = {
            categoryLabels: {
                show: {
                    objectName: "categoryLabels",
                    propertyName: "show"
                },
                color: {
                    objectName: "categoryLabels",
                    propertyName: "color"
                },
                fontSize: {
                    objectName: "categoryLabels",
                    propertyName: "fontSize"
                }
            },
            labels: {
                color: {
                    objectName: "labels",
                    propertyName: "color"
                },
                labelPrecision: {
                    objectName: "labels",
                    propertyName: "labelPrecision"
                },
                labelDisplayUnits: {
                    objectName: "labels",
                    propertyName: "labelDisplayUnits"
                },
                fontSize: {
                    objectName: "labels",
                    propertyName: "fontSize"
                }
            },
            wordWrap: {
                show: {
                    objectName: "wordWrap",
                    propertyName: "show"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.waterfallChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: powerbi.VisualDataRoleKind.Grouping,
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_CategoryWaterfallDescription")
            }, {
                name: "Y",
                kind: powerbi.VisualDataRoleKind.Measure,
                requiredTypes: [ {
                    numeric: !0
                }, {
                    integer: !0
                } ]
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                            type: {
                                enumeration: visuals.legendPosition.type
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                            type: {
                                text: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                            type: {
                                formatting: {
                                    fontSize: !0
                                }
                            }
                        }
                    }
                },
                sentimentColors: {
                    displayName: powerbi.data.createDisplayNameGetter("Waterfall_SentimentColors"),
                    properties: {
                        increaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter("Waterfall_IncreaseLabel"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        decreaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter("Waterfall_DecreaseLabel"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        totalFill: {
                            displayName: powerbi.data.createDisplayNameGetter("Waterfall_TotalLabel"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_YAxis_PositionDescription"),
                            type: {
                                enumeration: visuals.yAxisPosition.type
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                            type: {
                                numeric: !0
                            },
                            suppressFormatPainterCopy: !0
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                            type: {
                                bool: !0
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                enumeration: visuals.axisStyle.type
                            }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        }
                    }
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                            type: {
                                numeric: !0
                            }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style_Description"),
                            type: {
                                enumeration: visuals.lineStyle.type
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange_Description"),
                            type: {
                                enumeration: visuals.referenceLinePosition.type
                            }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Show_Description"),
                            type: {
                                bool: !0
                            }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                            type: {
                                fill: {
                                    solid: {
                                        color: !0
                                    }
                                }
                            }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Horizontal_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelHorizontalPosition.type
                            }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Vertical_Position_Description"),
                            type: {
                                enumeration: visuals.referenceLineDataLabelVerticalPosition.type
                            }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            },
                            suppressFormatPainterCopy: !0
                        }
                    }
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                            type: {
                                numeric: !0
                            }
                        },
                        image: {
                            type: {
                                image: {}
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        select: [ {
                            bind: {
                                to: "Y"
                            }
                        } ]
                    }
                }
            } ],
            drilldown: {
                roles: [ "Category" ]
            }
        }, visuals.waterfallChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            sentimentColors: {
                increaseFill: {
                    objectName: "sentimentColors",
                    propertyName: "increaseFill"
                },
                decreaseFill: {
                    objectName: "sentimentColors",
                    propertyName: "decreaseFill"
                },
                totalFill: {
                    objectName: "sentimentColors",
                    propertyName: "totalFill"
                }
            },
            legend: {
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.KPIStatusWithHistoryCapabilities = {
            dataRoles: [ {
                name: "Indicator",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Indicator"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_IndicatorDescription")
            }, {
                name: "TrendLine",
                kind: powerbi.VisualDataRoleKind.Grouping,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_TrendLine"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Trendline_Description")
            }, {
                name: "Goal",
                kind: powerbi.VisualDataRoleKind.Measure,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Goal"),
                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_GoalDescription")
            } ],
            dataViewMappings: [ {
                conditions: [ {
                    Indicator: {
                        max: 1
                    },
                    TrendLine: {
                        max: 1
                    },
                    Goal: {
                        max: 2
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "TrendLine"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        select: [ {
                            bind: {
                                to: "Indicator"
                            }
                        }, {
                            bind: {
                                to: "Goal"
                            }
                        } ]
                    }
                }
            } ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: !0
                                }
                            }
                        }
                    }
                },
                indicator: {
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Indicator"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_IndicatorDescription"),
                    properties: {
                        indicatorDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: !0
                                }
                            }
                        },
                        indicatorPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                            placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                            type: {
                                numeric: !0
                            }
                        },
                        kpiFormat: {
                            displayName: powerbi.data.createDisplayNameGetter("TaskPane_Format"),
                            type: {
                                text: !0
                            }
                        }
                    }
                },
                trendline: {
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_TrendLine"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Trendline_Description"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                },
                goals: {
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Goals"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Goals"),
                    properties: {
                        showGoal: {
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Show_Goal"),
                            type: {
                                bool: !0
                            }
                        },
                        showDistance: {
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Show_Distance"),
                            type: {
                                bool: !0
                            }
                        }
                    }
                },
                status: {
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Status"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Status"),
                    properties: {
                        direction: {
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Direction"),
                            description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Direction"),
                            type: {
                                enumeration: visuals.kpiDirection.type
                            }
                        }
                    }
                }
            }
        };
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var capabilities;
        !function(capabilities) {
            capabilities.animatedNumber = powerbi.visuals.animatedNumberCapabilities, capabilities.areaChart = powerbi.visuals.lineChartCapabilities, 
            capabilities.barChart = powerbi.visuals.getColumnChartCapabilities(!0), capabilities.card = powerbi.visuals.cardCapabilities, 
            capabilities.multiRowCard = powerbi.visuals.multiRowCardCapabilities, capabilities.clusteredBarChart = powerbi.visuals.getColumnChartCapabilities(!0), 
            capabilities.clusteredColumnChart = powerbi.visuals.getColumnChartCapabilities(), 
            capabilities.columnChart = powerbi.visuals.getColumnChartCapabilities(), capabilities.comboChart = powerbi.visuals.comboChartCapabilities, 
            capabilities.dataDotChart = powerbi.visuals.dataDotChartCapabilities, capabilities.dataDotClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities, 
            capabilities.dataDotStackedColumnComboChart = powerbi.visuals.comboChartCapabilities, 
            capabilities.donutChart = powerbi.visuals.donutChartCapabilities, capabilities.funnel = powerbi.visuals.funnelChartCapabilities, 
            capabilities.gauge = powerbi.visuals.gaugeCapabilities, capabilities.hundredPercentStackedBarChart = powerbi.visuals.getColumnChartCapabilities(!0), 
            capabilities.hundredPercentStackedColumnChart = powerbi.visuals.getColumnChartCapabilities(), 
            capabilities.image = powerbi.visuals.imageVisualCapabilities, capabilities.lineChart = powerbi.visuals.lineChartCapabilities, 
            capabilities.lineStackedColumnComboChart = powerbi.visuals.comboChartCapabilities, 
            capabilities.lineClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities, 
            capabilities.map = powerbi.visuals.mapCapabilities, capabilities.filledMap = powerbi.visuals.filledMapCapabilities, 
            capabilities.treemap = powerbi.visuals.treemapCapabilities, capabilities.pieChart = powerbi.visuals.donutChartCapabilities, 
            capabilities.scatterChart = powerbi.visuals.scatterChartCapabilities, capabilities.table = powerbi.visuals.tableCapabilities, 
            capabilities.matrix = powerbi.visuals.matrixCapabilities, capabilities.slicer = powerbi.visuals.slicerCapabilities, 
            capabilities.textbox = powerbi.visuals.textboxCapabilities, capabilities.waterfallChart = powerbi.visuals.waterfallChartCapabilities, 
            capabilities.cheerMeter = powerbi.visuals.cheerMeterCapabilities, capabilities.scriptVisual = powerbi.visuals.scriptVisualCapabilities, 
            capabilities.kpi = powerbi.visuals.KPIStatusWithHistoryCapabilities;
        }(capabilities = visuals.capabilities || (visuals.capabilities = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var ColumnChartWebBehavior = function() {
            function ColumnChartWebBehavior() {}
            return ColumnChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.options = options;
                var eventGroup = options.eventGroup;
                eventGroup.on("click", function() {
                    var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
                }), eventGroup.on("contextmenu", function() {
                    if (!d3.event.ctrlKey) {
                        d3.event.preventDefault();
                        var d = ColumnChartWebBehavior.getDatumForLastInputEvent(), position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                        selectionHandler.handleContextMenu(d, position);
                    }
                });
            }, ColumnChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                var options = this.options;
                options.bars.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && options.hasHighlights);
                });
            }, ColumnChartWebBehavior.getDatumForLastInputEvent = function() {
                var target = d3.event.target;
                return d3.select(target).datum();
            }, ColumnChartWebBehavior;
        }();
        visuals.ColumnChartWebBehavior = ColumnChartWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var DataDotChartWebBehavior = function() {
            function DataDotChartWebBehavior() {}
            return DataDotChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var dots = this.dots = options.dots, dotLabels = options.dotLabels;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler), 
                dotLabels && visuals.InteractivityUtils.registerStandardInteractivityHandlers(dotLabels, selectionHandler);
            }, DataDotChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                this.dots.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                });
            }, DataDotChartWebBehavior;
        }();
        visuals.DataDotChartWebBehavior = DataDotChartWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var DonutChartWebBehavior = function() {
            function DonutChartWebBehavior() {}
            return DonutChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var slices = this.slices = options.slices, highlightSlices = this.highlightSlices = options.highlightSlices, clearCatcher = options.clearCatcher;
                this.hasHighlights = options.hasHighlights;
                var clickHandler = function(d) {
                    selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                }, contextMenuHandler = function(d) {
                    if (!d3.event.ctrlKey) {
                        var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                        selectionHandler.handleContextMenu(d.data, position), d3.event.preventDefault();
                    }
                };
                slices.on("click", clickHandler), slices.on("contextmenu", contextMenuHandler), 
                highlightSlices.on("click", clickHandler), highlightSlices.on("contextmenu", contextMenuHandler), 
                clearCatcher.on("click", function() {
                    selectionHandler.handleClearSelection();
                });
            }, DonutChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.slices.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, hasHighlights && !d.data.selected);
                }), this.highlightSlices.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, hasHighlights);
                });
            }, DonutChartWebBehavior;
        }();
        visuals.DonutChartWebBehavior = DonutChartWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var FunnelWebBehavior = function() {
            function FunnelWebBehavior() {}
            return FunnelWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var bars = this.bars = options.bars, interactors = this.interactors = options.interactors, clearCatcher = options.clearCatcher;
                this.hasHighlights = options.hasHighlights, visuals.InteractivityUtils.registerStandardInteractivityHandlers(bars, selectionHandler), 
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactors, selectionHandler), 
                clearCatcher.on("click", function() {
                    selectionHandler.handleClearSelection();
                });
            }, FunnelWebBehavior.prototype.renderSelection = function(hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.bars.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                });
            }, FunnelWebBehavior;
        }();
        visuals.FunnelWebBehavior = FunnelWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var LineChartWebBehavior = function() {
            function LineChartWebBehavior() {}
            return LineChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.lines = options.lines;
                var interactivityLines = options.interactivityLines, dots = this.dots = options.dots, areas = this.areas = options.areas, tooltipOverlay = this.tooltipOverlay = options.tooltipOverlay;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactivityLines, selectionHandler), 
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler), 
                areas && visuals.InteractivityUtils.registerStandardInteractivityHandlers(areas, selectionHandler), 
                tooltipOverlay && tooltipOverlay.on("click", function() {
                    return selectionHandler.handleClearSelection();
                });
            }, LineChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                this.lines.style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                }), this.dots.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                }), this.areas && this.areas.style("fill-opacity", function(d) {
                    return hasSelection && !d.selected ? visuals.LineChart.DimmedAreaFillOpacity : visuals.LineChart.AreaFillOpacity;
                });
            }, LineChartWebBehavior;
        }();
        visuals.LineChartWebBehavior = LineChartWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var MapBehavior = function() {
            function MapBehavior() {
                this.mapPointerEventsDisabled = !1, this.mapPointerTimeoutSet = !1, this.viewChangedSinceLastClearMouseDown = !1;
            }
            return MapBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var _this = this, bubbles = this.bubbles = options.bubbles, slices = this.slices = options.slices, shapes = this.shapes = options.shapes, clearCatcher = options.clearCatcher, clickHandler = function(d) {
                    bubbles && bubbles.style("pointer-events", "all"), shapes && shapes.style("pointer-events", "all"), 
                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
                };
                this.mapPointerEventsDisabled || (bubbles && bubbles.style("pointer-events", "all"), 
                slices && slices.style("pointer-events", "all"), shapes && shapes.style("pointer-events", "all")), 
                bubbles && (bubbles.on("click", clickHandler), bubbles.on("mousewheel", function() {
                    _this.mapPointerEventsDisabled || bubbles.style("pointer-events", "none"), _this.mapPointerEventsDisabled = !0, 
                    _this.mapPointerTimeoutSet || (_this.mapPointerTimeoutSet = !0, setTimeout(function() {
                        bubbles && bubbles.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1, 
                        _this.mapPointerTimeoutSet = !1;
                    }, 200));
                }), visuals.InteractivityUtils.registerStandardContextMenuHandler(bubbles, selectionHandler)), 
                slices && (slices.on("click", function(d) {
                    slices.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1, selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                }), slices.on("mousewheel", function() {
                    _this.mapPointerEventsDisabled || slices.style("pointer-events", "none"), _this.mapPointerEventsDisabled = !0, 
                    _this.mapPointerTimeoutSet || (_this.mapPointerTimeoutSet = !0, setTimeout(function() {
                        slices && slices.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1, 
                        _this.mapPointerTimeoutSet = !1;
                    }, 200));
                })), shapes && (shapes.on("click", clickHandler), shapes.on("mousewheel", function() {
                    _this.mapPointerEventsDisabled || shapes.style("pointer-events", "none"), _this.mapPointerEventsDisabled = !0, 
                    _this.mapPointerTimeoutSet || (_this.mapPointerTimeoutSet = !0, setTimeout(function() {
                        shapes && shapes.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1, 
                        _this.mapPointerTimeoutSet = !1;
                    }, 200));
                }), visuals.InteractivityUtils.registerStandardContextMenuHandler(shapes, selectionHandler)), 
                clearCatcher.on("mouseup", function() {
                    _this.viewChangedSinceLastClearMouseDown || selectionHandler.handleClearSelection();
                }), clearCatcher.on("mousedown", function() {
                    _this.viewChangedSinceLastClearMouseDown = !1;
                });
            }, MapBehavior.prototype.renderSelection = function(hasSelection) {
                this.bubbles && this.bubbles.style({
                    "fill-opacity": function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    },
                    "stroke-opacity": function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }
                }), this.slices && this.slices.style({
                    "fill-opacity": function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                    },
                    "stroke-opacity": function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                    }
                }), this.shapes && this.shapes.style({
                    "fill-opacity": function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    },
                    "stroke-opacity": function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }
                });
            }, MapBehavior.prototype.viewChanged = function() {
                this.viewChangedSinceLastClearMouseDown = !0;
            }, MapBehavior;
        }();
        visuals.MapBehavior = MapBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, ScatterChartWebBehavior = function() {
            function ScatterChartWebBehavior() {}
            return ScatterChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var bubbles = this.bubbles = options.dataPointsSelection, data = options.data, eventGroup = options.eventGroup;
                !this.playOptions || !this.playOptions.traceLineRenderer || options.playOptions && options.playOptions.traceLineRenderer || this.playOptions.traceLineRenderer.remove(), 
                this.playOptions = options.playOptions, this.shouldEnableFill = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint, 
                this.colorBorder = data.colorBorder, eventGroup ? visuals.InteractivityUtils.registerGroupInteractivityHandlers(eventGroup, selectionHandler) : visuals.InteractivityUtils.registerStandardInteractivityHandlers(bubbles, selectionHandler);
            }, ScatterChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                var shouldEnableFill = this.shouldEnableFill, colorBorder = this.colorBorder;
                if (this.bubbles.style("fill-opacity", function(d) {
                    return visuals.ScatterChart.getMarkerFillOpacity(null != d.size, shouldEnableFill, hasSelection, d.selected);
                }), this.bubbles.style("stroke-opacity", function(d) {
                    return visuals.ScatterChart.getMarkerStrokeOpacity(null != d.size, colorBorder, hasSelection, d.selected);
                }), this.playOptions && this.bubbles) {
                    var selectedPoints = this.bubbles.filter(function(d) {
                        return d.selected;
                    }).data(), traceLineRenderer = this.playOptions.traceLineRenderer;
                    selectedPoints && selectedPoints.length > 0 && null != traceLineRenderer ? traceLineRenderer.render(selectedPoints, !0) : traceLineRenderer.remove();
                }
            }, ScatterChartWebBehavior;
        }();
        visuals.ScatterChartWebBehavior = ScatterChartWebBehavior;
        var ScatterChartMobileBehavior = function() {
            function ScatterChartMobileBehavior() {}
            return ScatterChartMobileBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.setOptions(options), options.visualInitOptions && options.visualInitOptions.interactivity.isInteractiveLegend && (this.makeDataPointsSelectable(options.dataPointsSelection), 
                this.makeRootSelectable(options.root), this.makeDragable(options.root), this.disableDefaultTouchInteractions(options.root), 
                this.selectRoot());
            }, ScatterChartMobileBehavior.prototype.renderSelection = function(HasSelection) {}, 
            ScatterChartMobileBehavior.prototype.setSelectionHandler = function(selectionHandler) {}, 
            ScatterChartMobileBehavior.prototype.makeDataPointsSelectable = function() {
                for (var _this = this, selection = [], _i = 0; _i < arguments.length; _i++) selection[_i - 0] = arguments[_i];
                for (var i = 0, len = selection.length; len > i; i++) {
                    var sel = selection[i];
                    sel.on("click", function(d, i) {
                        _this.select(i);
                    });
                }
            }, ScatterChartMobileBehavior.prototype.makeRootSelectable = function(selection) {
                var _this = this;
                selection.on("click", function(d, i) {
                    _this.selectRoot();
                });
            }, ScatterChartMobileBehavior.prototype.makeDragable = function() {
                for (var _this = this, selection = [], _i = 0; _i < arguments.length; _i++) selection[_i - 0] = arguments[_i];
                for (var i = 0, len = selection.length; len > i; i++) {
                    var sel = selection[i], drag = d3.behavior.drag().on("drag", function(d) {
                        _this.drag(0);
                    }).on("dragend", function(d) {
                        _this.drag(1);
                    });
                    sel.call(drag);
                }
            }, ScatterChartMobileBehavior.prototype.disableDefaultTouchInteractions = function(selection) {
                selection.style("touch-action", "none");
            }, ScatterChartMobileBehavior.prototype.setOptions = function(options) {
                this.data = options.data, this.mainGraphicsContext = options.plotContext, this.xAxisProperties = options.xAxisProperties, 
                this.yAxisProperties = options.yAxisProperties, this.host = options.host;
            }, ScatterChartMobileBehavior.prototype.select = function(index) {
                this.selectDotByIndex(index);
            }, ScatterChartMobileBehavior.prototype.selectRoot = function() {
                var marker = jsCommon.PerformanceUtil.create("selectRoot");
                this.onClick(), marker.end();
            }, ScatterChartMobileBehavior.prototype.drag = function(t) {
                switch (t) {
                  case 0:
                    this.onDrag();
                    break;

                  case 1:
                    this.onClick();
                }
            }, ScatterChartMobileBehavior.prototype.onDrag = function() {
                var xy = this.getMouseCoordinates();
                this.moveCrosshairToXY(xy.x, xy.y);
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                this.selectDot(selectedIndex), this.updateLegend(selectedIndex);
            }, ScatterChartMobileBehavior.prototype.onClick = function() {
                var xy = this.getMouseCoordinates(), selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                -1 !== selectedIndex && this.selectDotByIndex(selectedIndex);
            }, ScatterChartMobileBehavior.prototype.getMouseCoordinates = function() {
                var mainGfxContext = this.mainGraphicsContext, x = 0, y = parseInt(mainGfxContext.attr("height"), 10);
                y = y || 0;
                try {
                    var mouse = d3.mouse(mainGfxContext.node());
                    x = mouse[0], y = mouse[1];
                } catch (e) {}
                return {
                    x: x,
                    y: y
                };
            }, ScatterChartMobileBehavior.prototype.selectDotByIndex = function(index) {
                this.selectDot(index), this.moveCrosshairToIndexDot(index), this.updateLegend(index);
            }, ScatterChartMobileBehavior.prototype.selectDot = function(dotIndex) {
                var _this = this, root = this.mainGraphicsContext;
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).classed({
                    selected: !1,
                    notSelected: !0
                }), root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).filter(function(d, i) {
                    var dataPoints = _this.data.dataPoints, currentPoint = dataPoints[dotIndex];
                    return d.x === currentPoint.x && d.y === currentPoint.y;
                }).classed({
                    selected: !0,
                    notSelected: !1
                });
            }, ScatterChartMobileBehavior.prototype.moveCrosshairToIndexDot = function(index) {
                var dataPoints = this.data.dataPoints, root = this.mainGraphicsContext, x = this.xAxisProperties.scale(dataPoints[index].x), y = this.yAxisProperties.scale(dataPoints[index].y);
                if (null == this.crosshair) {
                    var width = +root.attr("width"), height = +root.attr("height");
                    this.crosshair = this.drawCrosshair(root, x, y, width, height), this.crosshairHorizontal = this.crosshair.select(ScatterChartMobileBehavior.Horizontal.selector), 
                    this.crosshairVertical = this.crosshair.select(ScatterChartMobileBehavior.Vertical.selector);
                } else this.moveCrosshairToXY(x, y);
            }, ScatterChartMobileBehavior.prototype.moveCrosshairToXY = function(x, y) {
                this.crosshairHorizontal.attr({
                    y1: y,
                    y2: y
                }), this.crosshairVertical.attr({
                    x1: x,
                    x2: x
                });
            }, ScatterChartMobileBehavior.prototype.drawCrosshair = function(addTo, x, y, width, height) {
                var crosshair = addTo.append("g");
                return crosshair.classed(ScatterChartMobileBehavior.CrosshairClassName, !0), crosshair.append("line").classed(ScatterChartMobileBehavior.Horizontal["class"], !0).attr({
                    x1: 0,
                    x2: width,
                    y1: y,
                    y2: y
                }), crosshair.append("line").classed(ScatterChartMobileBehavior.Vertical["class"], !0).attr({
                    x1: x,
                    x2: x,
                    y1: height,
                    y2: 0
                }), crosshair;
            }, ScatterChartMobileBehavior.prototype.findClosestDotIndex = function(x, y) {
                var selectedIndex = -1, minDistance = Number.MAX_VALUE, dataPoints = this.data.dataPoints, xAxisPropertiesScale = this.xAxisProperties.scale, yAxisPropertiesScale = this.yAxisProperties.scale;
                for (var i in dataPoints) {
                    var currentPoint = dataPoints[i], circleX = xAxisPropertiesScale(currentPoint.x), circleY = yAxisPropertiesScale(currentPoint.y), horizontalDistance = circleX - x, verticalDistance = circleY - y, distanceSqrd = horizontalDistance * horizontalDistance + verticalDistance * verticalDistance;
                    minDistance === Number.MAX_VALUE ? (selectedIndex = i, minDistance = distanceSqrd) : minDistance && minDistance > distanceSqrd && (selectedIndex = i, 
                    minDistance = distanceSqrd);
                }
                return selectedIndex;
            }, ScatterChartMobileBehavior.prototype.updateLegend = function(dotIndex) {
                if (null == this.lastDotIndex || this.lastDotIndex !== dotIndex) {
                    var legendItems = this.createLegendDataPoints(dotIndex);
                    this.host.updateLegend(legendItems), this.lastDotIndex = dotIndex;
                }
            }, ScatterChartMobileBehavior.prototype.createLegendDataPoints = function(dotIndex) {
                var formatStringProp = visuals.scatterChartProps.general.formatString, legendItems = [], data = this.data, point = data.dataPoints[dotIndex], blank = visuals.valueFormatter.format(null), title = blank, legendData = data.legendData, legendDataPoints = legendData.dataPoints, category = point.formattedCategory.getValue();
                return category !== blank ? title = category : null != point.radius.sizeMeasure ? title = visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName) : legendDataPoints.length >= dotIndex && legendDataPoints[dotIndex].label !== blank && (title = legendDataPoints[dotIndex].label), 
                null != data.xCol && legendItems.push({
                    category: title,
                    color: point.fill,
                    identity: visuals.SelectionIdBuilder.builder().withMeasure(data.xCol.queryName).createSelectionId(),
                    selected: point.selected,
                    icon: visuals.LegendIcon.Box,
                    label: visuals.valueFormatter.format(this.data.axesLabels.x),
                    measure: visuals.valueFormatter.format(point.x, visuals.valueFormatter.getFormatString(data.xCol, formatStringProp)),
                    iconOnlyOnLabel: !0
                }), null != data.yCol && legendItems.push({
                    category: title,
                    color: point.fill,
                    identity: visuals.SelectionIdBuilder.builder().withMeasure(data.yCol.queryName).createSelectionId(),
                    selected: point.selected,
                    icon: visuals.LegendIcon.Box,
                    label: visuals.valueFormatter.format(data.axesLabels.y),
                    measure: visuals.valueFormatter.format(point.y, visuals.valueFormatter.getFormatString(data.yCol, formatStringProp)),
                    iconOnlyOnLabel: !0
                }), null != data.size && legendItems.push({
                    category: title,
                    color: point.fill,
                    identity: visuals.SelectionIdBuilder.builder().withMeasure(data.size.queryName).createSelectionId(),
                    selected: point.selected,
                    icon: visuals.LegendIcon.Box,
                    label: visuals.valueFormatter.format(data.size.displayName),
                    measure: visuals.valueFormatter.format(point.radius.sizeMeasure.values[point.radius.index], visuals.valueFormatter.getFormatString(data.size, formatStringProp)),
                    iconOnlyOnLabel: !0
                }), {
                    dataPoints: legendItems
                };
            }, ScatterChartMobileBehavior.CrosshairClassName = "crosshair", ScatterChartMobileBehavior.ScatterChartCircleTagName = "circle", 
            ScatterChartMobileBehavior.DotClassName = "dot", ScatterChartMobileBehavior.DotClassSelector = "." + ScatterChartMobileBehavior.DotClassName, 
            ScatterChartMobileBehavior.Horizontal = createClassAndSelector("horizontal"), ScatterChartMobileBehavior.Vertical = createClassAndSelector("vertical"), 
            ScatterChartMobileBehavior;
        }();
        visuals.ScatterChartMobileBehavior = ScatterChartMobileBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var HorizontalSlicerWebBehavior = function() {
            function HorizontalSlicerWebBehavior() {}
            return HorizontalSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.itemLabels = options.itemLabels, this.dataPoints = options.dataPoints, this.interactivityService = options.interactivityService, 
                this.slicerSettings = options.settings, visuals.SlicerWebBehavior.bindSlicerEvents(options.slicerContainer, this.itemLabels, options.clear, selectionHandler, this.slicerSettings, this.interactivityService);
            }, HorizontalSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemLabels, this.itemLabels, hasSelection, this.interactivityService, this.slicerSettings);
            }, HorizontalSlicerWebBehavior;
        }();
        visuals.HorizontalSlicerWebBehavior = HorizontalSlicerWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var VerticalSlicerWebBehavior = function() {
            function VerticalSlicerWebBehavior() {}
            return VerticalSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var slicers = options.itemContainers;
                this.itemLabels = options.itemLabels, this.itemInputs = options.itemInputs, this.dataPoints = options.dataPoints, 
                this.interactivityService = options.interactivityService, this.settings = options.settings, 
                visuals.SlicerWebBehavior.bindSlicerEvents(options.slicerContainer, slicers, options.clear, selectionHandler, this.settings, this.interactivityService);
            }, VerticalSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemInputs, this.itemLabels, hasSelection, this.interactivityService, this.settings);
            }, VerticalSlicerWebBehavior;
        }();
        visuals.VerticalSlicerWebBehavior = VerticalSlicerWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var SlicerWebBehavior = function() {
            function SlicerWebBehavior() {}
            return SlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.behavior = this.createWebBehavior(options), this.behavior.bindEvents(options.behaviorOptions, selectionHandler);
            }, SlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                this.behavior.renderSelection(hasSelection);
            }, SlicerWebBehavior.bindSlicerEvents = function(slicerContainer, slicers, slicerClear, selectionHandler, slicerSettings, interactivityService) {
                SlicerWebBehavior.bindSlicerItemSelectionEvent(slicers, selectionHandler, slicerSettings, interactivityService), 
                SlicerWebBehavior.bindSlicerClearEvent(slicerClear, selectionHandler), SlicerWebBehavior.styleSlicerContainer(slicerContainer, interactivityService);
            }, SlicerWebBehavior.setSelectionOnSlicerItems = function(selectableItems, itemLabel, hasSelection, interactivityService, slicerSettings) {
                if (hasSelection || interactivityService.isSelectionModeInverted()) SlicerWebBehavior.styleSlicerItems(selectableItems, hasSelection, interactivityService.isSelectionModeInverted()); else {
                    selectableItems.filter(".selected").classed("selected", !1), selectableItems.filter(".partiallySelected").classed("partiallySelected", !1);
                    var input = selectableItems.selectAll("input");
                    input && input.property("checked", !1), itemLabel.style("color", slicerSettings.slicerText.color);
                }
            }, SlicerWebBehavior.styleSlicerItems = function(slicerItems, hasSelection, isSelectionInverted) {
                slicerItems.each(function(d) {
                    var slicerItem = this, shouldCheck = !1;
                    d.isSelectAllDataPoint ? hasSelection ? (slicerItem.classList.add("partiallySelected"), 
                    shouldCheck = !1) : (slicerItem.classList.remove("partiallySelected"), shouldCheck = isSelectionInverted) : shouldCheck = jsCommon.LogicExtensions.XOR(d.selected, isSelectionInverted), 
                    shouldCheck ? slicerItem.classList.add("selected") : slicerItem.classList.remove("selected");
                    var input = slicerItem.getElementsByTagName("input")[0];
                    input && (input.checked = shouldCheck);
                });
            }, SlicerWebBehavior.bindSlicerItemSelectionEvent = function(slicers, selectionHandler, slicerSettings, interactivityService) {
                SlicerWebBehavior.isTouch = !1, slicers.on("touchstart", function(d) {
                    SlicerWebBehavior.isTouch = !0;
                }), slicers.on("pointerdown", function(d) {
                    var e = d3.event;
                    e && "touch" === e.pointerType && (SlicerWebBehavior.isTouch = !0);
                }), slicers.on("click", function(d) {
                    d3.event.preventDefault(), d.isSelectAllDataPoint ? selectionHandler.toggleSelectionModeInversion() : selectionHandler.handleSelection(d, SlicerWebBehavior.isTouch || SlicerWebBehavior.isMultiSelect(d3.event, slicerSettings, interactivityService)), 
                    selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier), 
                    SlicerWebBehavior.isTouch = !1;
                });
            }, SlicerWebBehavior.bindSlicerClearEvent = function(slicerClear, selectionHandler) {
                slicerClear && slicerClear.on("click", function(d) {
                    selectionHandler.handleClearSelection(), selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
                });
            }, SlicerWebBehavior.styleSlicerContainer = function(slicerContainer, interactivityService) {
                var hasSelection = interactivityService.hasSelection() && void 0 === interactivityService.isDefaultValueEnabled() || interactivityService.isDefaultValueEnabled() === !1;
                slicerContainer.classed("hasSelection", hasSelection);
            }, SlicerWebBehavior.isMultiSelect = function(event, settings, interactivityService) {
                return interactivityService.isSelectionModeInverted() || !settings.selection.singleSelect || event.ctrlKey;
            }, SlicerWebBehavior.prototype.createWebBehavior = function(options) {
                var behavior, orientation = options.orientation;
                switch (orientation) {
                  case 1:
                    behavior = new visuals.HorizontalSlicerWebBehavior();
                    break;

                  case 0:
                  default:
                    behavior = new visuals.VerticalSlicerWebBehavior();
                }
                return behavior;
            }, SlicerWebBehavior;
        }();
        visuals.SlicerWebBehavior = SlicerWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var LegendBehavior = function() {
            function LegendBehavior() {}
            return LegendBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var legendItems = options.legendItems;
                this.legendIcons = options.legendIcons;
                var clearCatcher = options.clearCatcher;
                visuals.InteractivityUtils.registerStandardSelectionHandler(legendItems, selectionHandler), 
                clearCatcher.on("click", function() {
                    selectionHandler.handleClearSelection();
                });
            }, LegendBehavior.prototype.renderSelection = function(hasSelection) {
                hasSelection ? this.legendIcons.style({
                    fill: function(d) {
                        return d.selected ? d.color : LegendBehavior.dimmedLegendColor;
                    }
                }) : this.legendIcons.style({
                    fill: function(d) {
                        return d.color;
                    }
                });
            }, LegendBehavior.dimmedLegendColor = "#A6A6A6", LegendBehavior;
        }();
        visuals.LegendBehavior = LegendBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var TreemapWebBehavior = function() {
            function TreemapWebBehavior() {}
            return TreemapWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var shapes = this.shapes = options.shapes, highlightShapes = this.highlightShapes = options.highlightShapes, majorLabels = options.majorLabels, minorLabels = options.minorLabels;
                this.hasHighlights = options.hasHighlights, visuals.InteractivityUtils.registerStandardInteractivityHandlers(shapes, selectionHandler), 
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(highlightShapes, selectionHandler), 
                majorLabels && visuals.InteractivityUtils.registerStandardInteractivityHandlers(majorLabels, selectionHandler), 
                minorLabels && visuals.InteractivityUtils.registerStandardInteractivityHandlers(minorLabels, selectionHandler);
            }, TreemapWebBehavior.prototype.renderSelection = function(hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.shapes.style("fill", function(d) {
                    return visuals.Treemap.getFill(d, !1);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, !1);
                }), this.highlightShapes.style("fill", function(d) {
                    return visuals.Treemap.getFill(d, !0);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, !0);
                });
            }, TreemapWebBehavior;
        }();
        visuals.TreemapWebBehavior = TreemapWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var WaterfallChartWebBehavior = function() {
            function WaterfallChartWebBehavior() {}
            return WaterfallChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                var bars = this.bars = options.bars;
                bars.on("click", function(d) {
                    d.isTotal || selectionHandler.handleSelection(d, d3.event.ctrlKey);
                }), bars.on("contextmenu", function(d) {
                    if (!d3.event.ctrlKey && (d3.event.preventDefault(), !d.isTotal)) {
                        var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                        selectionHandler.handleContextMenu(d, position);
                    }
                });
            }, WaterfallChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                this.bars.style("fill-opacity", function(d) {
                    return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                });
            }, WaterfallChartWebBehavior;
        }();
        visuals.WaterfallChartWebBehavior = WaterfallChartWebBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var LabelsBehavior = function() {
            function LabelsBehavior() {}
            return LabelsBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.labelItems = options.labelItems, visuals.InteractivityUtils.registerStandardSelectionHandler(this.labelItems, selectionHandler);
            }, LabelsBehavior.prototype.renderSelection = function(hasSelection) {
                hasSelection ? this.labelItems.style({
                    opacity: function(d) {
                        return d.selected ? LabelsBehavior.DefaultLabelOpacity : LabelsBehavior.DimmedLabelOpacity;
                    }
                }) : this.labelItems.style({
                    opacity: LabelsBehavior.DefaultLabelOpacity
                });
            }, LabelsBehavior.DefaultLabelOpacity = 1, LabelsBehavior.DimmedLabelOpacity = .6, 
            LabelsBehavior;
        }();
        visuals.LabelsBehavior = LabelsBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var CartesianChartBehavior = function() {
            function CartesianChartBehavior(behaviors) {
                this.behaviors = behaviors;
            }
            return CartesianChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                for (var behaviors = this.behaviors, i = 0, ilen = behaviors.length; ilen > i; i++) behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                options.clearCatcher.on("click", function() {
                    selectionHandler.handleClearSelection();
                });
            }, CartesianChartBehavior.prototype.renderSelection = function(hasSelection) {
                for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    behavior.renderSelection(hasSelection);
                }
            }, CartesianChartBehavior;
        }();
        visuals.CartesianChartBehavior = CartesianChartBehavior;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        visuals.emptyDomain = [ 0, 0 ];
        var AxisHelper;
        !function(AxisHelper) {
            function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                return 300 > availableWidth ? 3 : 500 > availableWidth ? 5 : 8;
            }
            function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                return 150 > availableWidth ? 3 : 300 > availableWidth ? 5 : 8;
            }
            function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
                return isNaN(min) || isNaN(max) ? DefaultBestTickCount : 1 >= maxTickCount || 1 >= max && min >= -1 ? maxTickCount : min === max ? isDateTime ? 1 : DefaultBestTickCount : hasNonIntegerData(valuesMetadata) ? maxTickCount : Math.min(max - min + 1, maxTickCount);
            }
            function hasNonIntegerData(valuesMetadata) {
                for (var i = 0, len = valuesMetadata.length; len > i; i++) {
                    var currentMetadata = valuesMetadata[i];
                    if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) return !0;
                }
                return !1;
            }
            function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
                return !isScalar || isOrdinalScale(scale) ? getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain()) : isDateTime(axisType) ? getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain()) : getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
            }
            function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                var tickLabels = [];
                if (0 >= maxTicks) return tickLabels;
                var len = labels.length;
                if (maxTicks > len) return labels;
                for (var i = 0, step = Math.ceil(len / maxTicks); len > i; i += step) tickLabels.push(labels[i]);
                return tickLabels;
            }
            function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
                var tickLabels = [];
                if (0 === maxTicks) return tickLabels;
                var quantitiveScale = scale;
                if (quantitiveScale.ticks) {
                    if (tickLabels = quantitiveScale.ticks(maxTicks), tickLabels.length > maxTicks && maxTicks > 1 && (tickLabels = quantitiveScale.ticks(maxTicks - 1)), 
                    tickLabels.length < MinTickCount && (tickLabels = quantitiveScale.ticks(maxTicks + 1)), 
                    tickLabels = createTrueZeroTickLabel(tickLabels), minInterval && tickLabels.length > 1) {
                        for (var tickInterval = tickLabels[1] - tickLabels[0]; tickInterval > 0 && minInterval > tickInterval; ) {
                            for (var i = 1; i < tickLabels.length; i++) tickLabels.splice(i, 1);
                            tickInterval = 2 * tickInterval;
                        }
                        1 === tickLabels.length && tickLabels.push(tickLabels[0] + minInterval);
                    }
                    return tickLabels;
                }
                return tickLabels;
            }
            function createTrueZeroTickLabel(ticks, epsilon) {
                if (void 0 === epsilon && (epsilon = 1e-5), !ticks || ticks.length < 2) return ticks;
                var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
                return ticks.map(function(tick) {
                    return Math.abs(tick) <= closeZero ? 0 : tick;
                });
            }
            function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                var tickLabels = [];
                if (0 === dataDomain[0] && 0 === dataDomain[1]) return [];
                var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                return tickLabels = dateTimeTickLabels.map(function(d) {
                    return d.getTime();
                }), tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
            }
            function normalizeLinearDomain(domain) {
                return isNaN(domain.min) || isNaN(domain.max) ? (domain.min = visuals.emptyDomain[0], 
                domain.max = visuals.emptyDomain[1]) : domain.min === domain.max ? (domain.min = domain.min < 0 ? 1.2 * domain.min : .8 * domain.min, 
                domain.max = domain.max < 0 ? .8 * domain.max : 1.2 * domain.max) : Math.abs(domain.min) < 1e-4 && domain.min / (domain.max - domain.min) < 1e-4 && (domain.min = 0), 
                domain;
            }
            function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
                return 0 === getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) || 0 === getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) ? {
                    top: 0,
                    right: xMargin,
                    bottom: yMargin,
                    left: 0
                } : {
                    top: 20,
                    right: 30,
                    bottom: 40,
                    left: 30
                };
            }
            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, properties, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                var xAxisProperties = axes.x, y1AxisProperties = axes.y1, y2AxisProperties = axes.y2, xLabels = xAxisProperties.values, y1Labels = y1AxisProperties.values, leftOverflow = 0, rightOverflow = 0, maxWidthY1 = 0, maxWidthY2 = 0, xMax = 0, ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0, scaleIsOrdinal = isOrdinalScale(xAxisProperties.scale), xLabelOuterPadding = 0;
                if (void 0 !== xAxisProperties.outerPadding ? xLabelOuterPadding = xAxisProperties.outerPadding : void 0 !== xAxisProperties.xLabelMaxWidth && (xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2)), 
                0 !== getRecommendedNumberOfTicksForXAxis(viewport.width) || 0 !== getRecommendedNumberOfTicksForYAxis(viewport.height)) {
                    var rotation = void 0;
                    if (rotation = scrollbarVisible ? LabelLayoutStrategy.DefaultRotationWithScrollbar : LabelLayoutStrategy.DefaultRotation, 
                    renderY1Axis) for (var i = 0, len = y1Labels.length; len > i; i++) properties.text = y1Labels[i], 
                    maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(properties));
                    if (y2AxisProperties && renderY2Axis) for (var y2Labels = y2AxisProperties.values, i = 0, len = y2Labels.length; len > i; i++) properties.text = y2Labels[i], 
                    maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(properties));
                    var textHeight = textHeightMeasurer(properties), maxNumLines = Math.floor(bottomMarginLimit / textHeight), xScale = xAxisProperties.scale, xDomain = xScale.domain();
                    if (renderXAxis && xLabels.length > 0) {
                        for (var i = 0, len = xLabels.length; len > i; i++) {
                            var height = void 0;
                            properties.text = xLabels[i];
                            var width = textWidthMeasurer(properties);
                            if (xAxisProperties.willLabelsWordBreak) {
                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(properties.text, properties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                height = wordBreaks.length * textHeight, width = xAxisProperties.xLabelMaxWidth;
                            } else !xAxisProperties.willLabelsFit && scaleIsOrdinal ? (height = width * rotation.sine, 
                            width *= rotation.cosine) : height = TextHeightConstant;
                            if (0 === i) {
                                if (scaleIsOrdinal) leftOverflow = xAxisProperties.willLabelsFit ? width / 2 - ordinalLabelOffset - xLabelOuterPadding : width - ordinalLabelOffset - xLabelOuterPadding, 
                                leftOverflow = Math.max(leftOverflow, 0); else if (xDomain.length > 1) {
                                    var xPos = xScale(xDomain[0]);
                                    leftOverflow = width / 2 - xPos, leftOverflow = Math.max(leftOverflow, 0);
                                }
                            } else if (i === len - 1) if (scaleIsOrdinal) (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) && (rightOverflow = width / 2 - ordinalLabelOffset - xLabelOuterPadding, 
                            rightOverflow = Math.max(rightOverflow, 0)); else if (xDomain.length > 1) {
                                var xPos = xScale(xDomain[1]);
                                rightOverflow = width / 2 - (viewport.width - xPos), rightOverflow = Math.max(rightOverflow, 0);
                            }
                            xMax = Math.max(xMax, height);
                        }
                        leftOverflow = Math.min(leftOverflow, XLabelMaxAllowedOverflow), rightOverflow = Math.min(rightOverflow, XLabelMaxAllowedOverflow);
                    }
                }
                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                return showOnRight ? (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit), 
                rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit)) : (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit), 
                rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit)), {
                    xMax: Math.ceil(bottomMargin),
                    yLeft: Math.ceil(leftMargin),
                    yRight: Math.ceil(rightMargin)
                };
            }
            function columnDataTypeHasValue(dataType) {
                return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
            }
            function createOrdinalType() {
                return powerbi.ValueType.fromDescriptor({
                    text: !0
                });
            }
            function isOrdinal(type) {
                return !(!type || !type.text && !type.bool);
            }
            function isOrdinalScale(scale) {
                return "undefined" == typeof scale.invert;
            }
            function isDateTime(type) {
                return !(!type || !type.dateTime);
            }
            function invertScale(scale, x) {
                return isOrdinalScale(scale) ? invertOrdinalScale(scale, x) : scale.invert(x);
            }
            function extent(scale) {
                return isOrdinalScale(scale) ? scale.rangeExtent() : scale.range();
            }
            function invertOrdinalScale(scale, x) {
                var leftEdges = scale.range();
                if (leftEdges.length < 2) return 0;
                var j, width = scale.rangeBand(), halfInnerPadding = (leftEdges[1] - leftEdges[0] - width) / 2;
                for (j = 0; x > leftEdges[j] + width + halfInnerPadding && j < leftEdges.length - 1; j++) ;
                return scale.domain()[j];
            }
            function findClosestXAxisIndex(categoryValue, categoryAxisValues) {
                var closestValueIndex = -1, minDistance = Number.MAX_VALUE;
                for (var i in categoryAxisValues) {
                    var distance = Math.abs(categoryValue - categoryAxisValues[i].categoryValue);
                    minDistance > distance && (minDistance = distance, closestValueIndex = parseInt(i, 10));
                }
                return closestValueIndex;
            }
            function lookupOrdinalIndex(scale, pixelValue) {
                var closestValueIndex = -1, minDistance = Number.MAX_VALUE, domain = scale.domain();
                if (domain.length < 2) return 0;
                var halfWidth = (scale(1) - scale(0)) / 2;
                for (var idx in domain) {
                    var leftEdgeInPixels = scale(idx), midPoint = leftEdgeInPixels + halfWidth, distance = Math.abs(pixelValue - midPoint);
                    minDistance > distance && (minDistance = distance, closestValueIndex = parseInt(idx, 10));
                }
                return closestValueIndex;
            }
            function diffScaled(scale, value1, value2) {
                var value = scale(value1) - scale(value2);
                return 0 === value ? 0 : 0 > value ? Math.min(value, -1) : Math.max(value, 1);
            }
            function createDomain(data, axisType, isScalar, forcedScalarDomain, ensureDomain) {
                if (isScalar && !isOrdinal(axisType)) {
                    var userMin = void 0, userMax = void 0;
                    return forcedScalarDomain && 2 === forcedScalarDomain.length && (userMin = forcedScalarDomain[0], 
                    userMax = forcedScalarDomain[1]), createScalarDomain(data, userMin, userMax, axisType, ensureDomain);
                }
                return createOrdinalDomain(data);
            }
            function ensureValuesInRange(values, min, max) {
                var filteredValues = values.filter(function(v) {
                    return v >= min && max >= v;
                });
                return filteredValues.length < 2 && (filteredValues = [ min, max ]), filteredValues;
            }
            function getCategoryValueType(metadataColumn, isScalar) {
                return metadataColumn && columnDataTypeHasValue(metadataColumn.type) ? metadataColumn.type : isScalar ? powerbi.ValueType.fromDescriptor({
                    numeric: !0
                }) : powerbi.ValueType.fromDescriptor({
                    text: !0
                });
            }
            function createAxis(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct, dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar), scaleResult = AxisHelper.createScale(options), scale = scaleResult.scale, bestTickCount = scaleResult.bestTickCount, scaleDomain = scale.domain(), isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);
                if (categoryThickness && isScalar && dataDomain && 2 === dataDomain.length) {
                    var oldSpan = dataDomain[1] - dataDomain[0], newSpan = scaleDomain[1] - scaleDomain[0];
                    oldSpan > 0 && newSpan > 0 && (categoryThickness = categoryThickness * oldSpan / newSpan);
                }
                var tickValues;
                if (isScalar && 1 === bestTickCount) tickValues = [ dataDomain[0] ]; else {
                    var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : void 0;
                    tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
                }
                options.scaleType && options.scaleType === visuals.axisScale.log && isLogScaleAllowed && (tickValues = tickValues.filter(function(d) {
                    return AxisHelper.powerOfTen(d);
                }));
                var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision), axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(tickValues), formattedTickValues = [];
                metaDataColumn && (formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn));
                var xLabelMaxWidth;
                return !isScalar && categoryThickness ? xLabelMaxWidth = Math.max(1, categoryThickness - 2 * visuals.CartesianChart.TickLabelPadding) : (xLabelMaxWidth = tickValues.length > 1 ? getScalarLabelMaxWidth(scale, tickValues) : pixelSpan, 
                xLabelMaxWidth -= 2 * ScalarTickLabelPadding), {
                    scale: scale,
                    axis: axis,
                    formatter: formatter,
                    values: formattedTickValues,
                    axisType: dataType,
                    axisLabel: null,
                    isCategoryAxis: isCategoryAxis,
                    xLabelMaxWidth: xLabelMaxWidth,
                    categoryThickness: categoryThickness,
                    outerPadding: outerPadding,
                    usingDefaultDomain: scaleResult.usingDefaultDomain,
                    isLogScaleAllowed: isLogScaleAllowed,
                    dataDomain: dataDomain
                };
            }
            function getScalarLabelMaxWidth(scale, tickValues) {
                return scale && !_.isEmpty(tickValues) ? Math.abs(scale(tickValues[1]) - scale(tickValues[0])) : 1;
            }
            function createScale(options) {
                var scale, pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp, dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar), maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan), scalarDomain = dataDomain ? dataDomain.slice() : null, bestTickCount = maxTicks, usingDefaultDomain = !1;
                if (null == dataDomain || 2 === dataDomain.length && null == dataDomain[0] && null == dataDomain[1] || 2 !== dataDomain.length && isScalar) usingDefaultDomain = !0, 
                dataDomain = dataType.dateTime || !isOrdinal(dataType) ? visuals.emptyDomain : [], 
                scale = isOrdinal(dataType) ? createOrdinalScale(pixelSpan, dataDomain, categoryThickness ? outerPadding / categoryThickness : 0) : createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount); else {
                    if (isScalar && dataDomain.length > 0) {
                        bestTickCount = void 0 !== forcedTickCount ? 0 !== maxTicks ? forcedTickCount : 0 : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [ metaDataColumn ], maxTicks, dataType.dateTime);
                        var normalizedRange = normalizeLinearDomain({
                            min: dataDomain[0],
                            max: dataDomain[dataDomain.length - 1]
                        });
                        scalarDomain = [ normalizedRange.min, normalizedRange.max ];
                    }
                    isScalar && dataType.numeric && !dataType.dateTime ? scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, bestTickCount, shouldClamp) : isScalar && dataType.dateTime ? scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp) : (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) && (scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0), 
                    bestTickCount = 0 === maxTicks ? 0 : Math.min(scalarDomain.length, (pixelSpan - 2 * outerPadding) / visuals.CartesianChart.MinOrdinalRectThickness));
                }
                return isVertical && isScalar && scale.range(scale.range().reverse()), visuals.ColumnUtil.normalizeInfinityInScale(scale), 
                {
                    scale: scale,
                    bestTickCount: bestTickCount,
                    usingDefaultDomain: usingDefaultDomain
                };
            }
            function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
                void 0 === useTickIntervalForDisplayUnits && (useTickIntervalForDisplayUnits = !1);
                var formatter;
                if (dataType.dateTime) if (isScalar) {
                    var value = new Date(scaleDomain[0]), value2 = new Date(scaleDomain[1]);
                    1 === bestTickCount && (value = value2 = new Date(dataDomain[0])), formatter = visuals.valueFormatter.create({
                        format: formatString,
                        value: value,
                        value2: value2,
                        tickCount: bestTickCount
                    });
                } else formatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0); else if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                    var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0], options = {
                        format: formatString,
                        value: value1,
                        value2: 0,
                        allowFormatBeautification: !0
                    };
                    axisPrecision ? options.precision = axisPrecision : options.detectAxisPrecision = !0, 
                    formatter = visuals.valueFormatter.create(options);
                } else formatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0);
                return formatter;
            }
            function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
                var formattedTickValues = [];
                return getValueFn || (getValueFn = function(data) {
                    return data;
                }), formatter ? (axis.tickFormat(function(d) {
                    return formatter.format(getValueFn(d, dataType));
                }), formattedTickValues = tickValues.map(function(d) {
                    return formatter.format(getValueFn(d, dataType));
                })) : formattedTickValues = tickValues.map(function(d) {
                    return getValueFn(d, dataType);
                }), formattedTickValues;
            }
            function getMinTickValueInterval(formatString, columnType, is100Pct) {
                var isCustomFormat = formatString && !powerbi.NumberFormat.isStandardFormat(formatString);
                if (isCustomFormat) {
                    var precision = powerbi.NumberFormat.getCustomFormatMetadata(formatString, !0).precision;
                    return formatString.indexOf("%") > -1 && (precision += 2), Math.pow(10, -precision);
                }
                return is100Pct ? .01 : columnType.integer ? 1 : 0;
            }
            function createScalarDomain(data, userMin, userMax, axisType, ensureDomain) {
                if (0 === data.length) return null;
                var defaultMinX = d3.min(data, function(kv) {
                    return d3.min(kv.data, function(d) {
                        return d.categoryValue;
                    });
                }), defaultMaxX = d3.max(data, function(kv) {
                    return d3.max(kv.data, function(d) {
                        return d.categoryValue;
                    });
                });
                return combineDomain([ userMin, userMax ], [ defaultMinX, defaultMaxX ], ensureDomain);
            }
            function createValueDomain(data, includeZero) {
                if (0 === data.length) return null;
                var minY = d3.min(data, function(kv) {
                    return d3.min(kv.data, function(d) {
                        return d.value;
                    });
                }), maxY = d3.max(data, function(kv) {
                    return d3.max(kv.data, function(d) {
                        return d.value;
                    });
                });
                return includeZero ? [ Math.min(minY, 0), Math.max(maxY, 0) ] : [ minY, maxY ];
            }
            function createOrdinalDomain(data) {
                if (_.isEmpty(data)) return [];
                for (var domain = [], firstSeries = data[0], _i = 0, _a = firstSeries.data; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    dp.highlight || domain.push(dp.categoryIndex);
                }
                return domain;
            }
            function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio) {
                void 0 === outerPaddingRatio && (outerPaddingRatio = 0);
                var scale = d3.scale.ordinal().rangeBands([ 0, pixelSpan ], visuals.CartesianChart.InnerPaddingRatio, outerPaddingRatio).domain(dataDomain);
                return scale;
            }
            function isLogScalePossible(domain, axisType) {
                return null == domain ? !1 : isDateTime(axisType) ? !1 : domain[0] > 0 && domain[1] > 0 || domain[0] < 0 && domain[1] < 0;
            }
            function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
                return void 0 === outerPadding && (outerPadding = 0), axisScaleType === visuals.axisScale.log && isLogScalePossible(dataDomain, dataType) ? createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) : createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
            }
            function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                void 0 === outerPadding && (outerPadding = 0);
                var scale = d3.scale.log().range([ outerPadding, pixelSpan - outerPadding ]).domain([ dataDomain[0], dataDomain[1] ]).clamp(!0);
                return niceCount && scale.nice(niceCount), scale;
            }
            function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
                void 0 === outerPadding && (outerPadding = 0);
                var scale = d3.scale.linear().range([ outerPadding, pixelSpan - outerPadding ]).domain([ dataDomain[0], dataDomain[1] ]).clamp(shouldClamp);
                return niceCount && scale.nice(niceCount), scale;
            }
            function getRangeForColumn(sizeColumn) {
                var result = {};
                return sizeColumn && (result.min = null == sizeColumn.min ? null == sizeColumn.minLocal ? d3.min(sizeColumn.values) : sizeColumn.minLocal : sizeColumn.min, 
                result.max = null == sizeColumn.max ? null == sizeColumn.maxLocal ? d3.max(sizeColumn.values) : sizeColumn.maxLocal : sizeColumn.max), 
                result;
            }
            function applyCustomizedDomain(customizedDomain, forcedDomain) {
                var domain = [ void 0, void 0 ];
                return forcedDomain && 2 === forcedDomain.length && (domain = [ forcedDomain[0], forcedDomain[1] ]), 
                customizedDomain && 2 === customizedDomain.length && (null != customizedDomain[0] && (domain[0] = customizedDomain[0]), 
                null != customizedDomain[1] && (domain[1] = customizedDomain[1])), null == domain[0] && null == domain[1] ? forcedDomain : null != domain[0] && null != domain[1] && domain[0] > domain[1] ? forcedDomain : domain;
            }
            function combineDomain(forcedDomain, domain, ensureDomain) {
                var combinedDomain = domain ? [ domain[0], domain[1] ] : [];
                ensureDomain && ((null == combinedDomain[0] || ensureDomain.min < combinedDomain[0]) && (combinedDomain[0] = ensureDomain.min), 
                (null == combinedDomain[1] || ensureDomain.max > combinedDomain[1]) && (combinedDomain[1] = ensureDomain.max));
                var domainBeforeForced = [ combinedDomain[0], combinedDomain[1] ];
                return forcedDomain && 2 === forcedDomain.length && (null != forcedDomain[0] && (combinedDomain[0] = forcedDomain[0]), 
                null != forcedDomain[1] && (combinedDomain[1] = forcedDomain[1]), combinedDomain[0] > combinedDomain[1] && (combinedDomain = domainBeforeForced)), 
                combinedDomain;
            }
            function createAxisLabel(properties, label, unitType, y2) {
                void 0 === y2 && (y2 = !1);
                var propertyName = y2 ? "secAxisStyle" : "axisStyle";
                if (!properties || !properties[propertyName]) return label;
                var modifiedLabel;
                return modifiedLabel = properties[propertyName] === visuals.axisStyle.showBoth ? label + " (" + unitType + ")" : properties[propertyName] === visuals.axisStyle.showUnitOnly ? unitType : label;
            }
            function scaleShouldClamp(combinedDomain, domain) {
                return !combinedDomain || !domain || combinedDomain.length < 2 || domain.length < 2 ? !1 : combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1];
            }
            function normalizeNonFiniteNumber(value) {
                return isNaN(value) ? null : value === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : value === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : value;
            }
            function powerOfTen(d) {
                return d / Math.pow(10, Math.ceil(Math.log(d) / Math.LN10 - 1e-12)) === 1;
            }
            var XLabelMaxAllowedOverflow = 35, TextHeightConstant = 10, MinTickCount = 2, DefaultBestTickCount = 3, LeftPadding = 10, ScalarTickLabelPadding = 3;
            AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis, 
            AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis, 
            AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks, AxisHelper.hasNonIntegerData = hasNonIntegerData, 
            AxisHelper.getRecommendedTickValues = getRecommendedTickValues, AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange, 
            AxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange, 
            AxisHelper.getMargin = getMargin, AxisHelper.getTickLabelMargins = getTickLabelMargins, 
            AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue, AxisHelper.createOrdinalType = createOrdinalType, 
            AxisHelper.isOrdinal = isOrdinal, AxisHelper.isOrdinalScale = isOrdinalScale, AxisHelper.isDateTime = isDateTime, 
            AxisHelper.invertScale = invertScale, AxisHelper.extent = extent, AxisHelper.invertOrdinalScale = invertOrdinalScale, 
            AxisHelper.findClosestXAxisIndex = findClosestXAxisIndex, AxisHelper.lookupOrdinalIndex = lookupOrdinalIndex, 
            AxisHelper.diffScaled = diffScaled, AxisHelper.createDomain = createDomain, AxisHelper.ensureValuesInRange = ensureValuesInRange, 
            AxisHelper.getCategoryValueType = getCategoryValueType, AxisHelper.createAxis = createAxis, 
            AxisHelper.createScale = createScale, AxisHelper.createFormatter = createFormatter, 
            AxisHelper.getMinTickValueInterval = getMinTickValueInterval, AxisHelper.createValueDomain = createValueDomain;
            var LabelLayoutStrategy;
            !function(LabelLayoutStrategy) {
                function willLabelsFit(axisProperties, availableWidth, textMeasurer, properties) {
                    var labels = axisProperties.values;
                    if (0 === labels.length) return !1;
                    var labelMaxWidth = void 0 !== axisProperties.xLabelMaxWidth ? axisProperties.xLabelMaxWidth : availableWidth / labels.length;
                    return !labels.some(function(d) {
                        return properties.text = d, textMeasurer(properties) > labelMaxWidth;
                    });
                }
                function willLabelsWordBreak(axisProperties, margin, availableWidth, textWidthMeasurer, textHeightMeasurer, textTruncator, properties) {
                    var labels = axisProperties.values, labelMaxWidth = void 0 !== axisProperties.xLabelMaxWidth ? axisProperties.xLabelMaxWidth : availableWidth / labels.length, maxRotatedLength = margin.bottom / LabelLayoutStrategy.DefaultRotation.sine, height = textHeightMeasurer(properties), maxNumLines = Math.max(1, Math.floor(margin.bottom / height));
                    if (0 === labels.length) return !1;
                    var mustRotate = labels.some(function(label) {
                        return properties.text = label, !jsCommon.WordBreaker.hasBreakers(label) && textWidthMeasurer(properties) > labelMaxWidth;
                    });
                    if (mustRotate) return !1;
                    var moreWordBreakChars = labels.filter(function(label, index) {
                        var allowedLengthProjectedOnXAxis = margin.left + axisProperties.outerPadding + axisProperties.categoryThickness * (index + .5) - LeftPadding, allowedLength = allowedLengthProjectedOnXAxis / LabelLayoutStrategy.DefaultRotation.cosine, rotatedLength = Math.min(allowedLength, maxRotatedLength), wordBreakChars = jsCommon.WordBreaker.splitByWidth(label, properties, textWidthMeasurer, labelMaxWidth, maxNumLines, textTruncator).join(" ");
                        properties.text = label;
                        var rotateChars = textTruncator(properties, rotatedLength);
                        return visuals.TextUtil.removeEllipses(wordBreakChars).length >= visuals.TextUtil.removeEllipses(rotateChars).length;
                    });
                    return moreWordBreakChars.length >= Math.floor(labels.length / 2);
                }
                function rotate(text, maxBottomMargin, svgEllipsis, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
                    var rotatedLength, defaultRotation;
                    defaultRotation = scrollbarVisible ? LabelLayoutStrategy.DefaultRotationWithScrollbar : LabelLayoutStrategy.DefaultRotation, 
                    needRotate && (rotatedLength = maxBottomMargin / defaultRotation.sine), text.each(function() {
                        var text = d3.select(this);
                        if (needRotate) {
                            var textContentIndex = axisProperties.values.indexOf(this.textContent), allowedLengthProjectedOnXAxis = margin.left + axisProperties.outerPadding + axisProperties.categoryThickness * (textContentIndex + .5);
                            scrollbarVisible || (allowedLengthProjectedOnXAxis -= LeftPadding);
                            var allowedLength = allowedLengthProjectedOnXAxis / defaultRotation.cosine;
                            (scrollbarVisible || needEllipsis || rotatedLength > allowedLength) && svgEllipsis(text[0][0], Math.min(allowedLength, rotatedLength)), 
                            text.style("text-anchor", "end").attr({
                                dx: "-0.5em",
                                dy: defaultRotation.dy,
                                transform: defaultRotation.transform
                            });
                        } else svgEllipsis(text[0][0], axisProperties.xLabelMaxWidth), text.style("text-anchor", "middle").attr({
                            dx: "0em",
                            dy: "1em",
                            transform: "rotate(0)"
                        });
                    });
                }
                function wordBreak(text, axisProperties, maxHeight) {
                    var allowedLength = axisProperties.xLabelMaxWidth;
                    text.each(function() {
                        var node = d3.select(this);
                        node.style("text-anchor", "middle").attr({
                            dx: "0em",
                            dy: "1em",
                            transform: "rotate(0)"
                        }), powerbi.TextMeasurementService.wordBreak(this, allowedLength, maxHeight);
                    });
                }
                function clip(text, availableWidth, svgEllipsis) {
                    0 !== text.size() && text.each(function() {
                        var text = d3.select(this);
                        svgEllipsis(text[0][0], availableWidth);
                    });
                }
                LabelLayoutStrategy.willLabelsFit = willLabelsFit, LabelLayoutStrategy.willLabelsWordBreak = willLabelsWordBreak, 
                LabelLayoutStrategy.DefaultRotation = {
                    sine: Math.sin(Math.PI * (35 / 180)),
                    cosine: Math.cos(Math.PI * (35 / 180)),
                    tangent: Math.tan(Math.PI * (35 / 180)),
                    transform: "rotate(-35)",
                    dy: "-0.5em"
                }, LabelLayoutStrategy.DefaultRotationWithScrollbar = {
                    sine: Math.sin(.5 * Math.PI),
                    cosine: Math.cos(.5 * Math.PI),
                    tangent: Math.tan(.5 * Math.PI),
                    transform: "rotate(-90)",
                    dy: "-0.8em"
                }, LabelLayoutStrategy.rotate = rotate, LabelLayoutStrategy.wordBreak = wordBreak, 
                LabelLayoutStrategy.clip = clip;
            }(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {})), 
            AxisHelper.createOrdinalScale = createOrdinalScale, AxisHelper.isLogScalePossible = isLogScalePossible, 
            AxisHelper.createNumericalScale = createNumericalScale, AxisHelper.createLinearScale = createLinearScale, 
            AxisHelper.getRangeForColumn = getRangeForColumn, AxisHelper.applyCustomizedDomain = applyCustomizedDomain, 
            AxisHelper.combineDomain = combineDomain, AxisHelper.createAxisLabel = createAxisLabel, 
            AxisHelper.scaleShouldClamp = scaleShouldClamp, AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber, 
            AxisHelper.powerOfTen = powerOfTen;
        }(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var ShapeFactory;
        !function(ShapeFactory) {
            function createRectangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var x = viewportWidth * ShapeFactoryConsts.PaddingConstRatio + data.lineWeight / 2, y = viewportHeight * ShapeFactoryConsts.PaddingConstRatio + data.lineWeight / 2, width = viewportWidth * ShapeFactoryConsts.ShapeConstRatio - data.lineWeight, height = viewportHeight * ShapeFactoryConsts.ShapeConstRatio - data.lineWeight, attrs = {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    rx: data.roundEdge,
                    ry: data.roundEdge
                }, scale = getScale(width, height, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, "rect", attrs);
            }
            function createOval(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var widthForCircle = (viewportWidth / ShapeFactoryConsts.OvalRadiusConst).toString(), heightForCircle = (viewportHeight / ShapeFactoryConsts.OvalRadiusConst).toString(), radiusXForCircle = viewportWidth / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding) - data.lineWeight, radiusYForCircle = viewportHeight / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding) - data.lineWeight, attrs = {
                    cx: widthForCircle,
                    cy: heightForCircle,
                    rx: radiusXForCircle,
                    ry: radiusYForCircle
                }, scale = getScale(viewportWidth, viewportHeight, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, "ellipse", attrs);
            }
            function createLine(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var x1, y1, x2, y2, ratio, width = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue - ShapeFactoryConsts.SmallPaddingConstValue, height = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - ShapeFactoryConsts.SmallPaddingConstValue;
                45 >= degrees ? (ratio = degrees / 90, x1 = viewportWidth / 2 + width * ratio, y1 = ShapeFactoryConsts.SmallPaddingConstValue, 
                x2 = viewportWidth / 2 - width * ratio, y2 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : 135 >= degrees ? (ratio = (degrees - 45) / 90, 
                x1 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue, y1 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio, 
                x2 = ShapeFactoryConsts.SmallPaddingConstValue, y2 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - height * ratio) : 225 >= degrees ? (ratio = (degrees - 135) / 90, 
                x1 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue - width * ratio, 
                y1 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue, x2 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio, 
                y2 = ShapeFactoryConsts.SmallPaddingConstValue) : 315 >= degrees ? (ratio = (degrees - 225) / 90, 
                x1 = ShapeFactoryConsts.SmallPaddingConstValue, y1 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - height * ratio, 
                x2 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue, y2 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio) : 360 >= degrees && (ratio = (degrees - 315) / 90, 
                x1 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio, y1 = ShapeFactoryConsts.SmallPaddingConstValue, 
                x2 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue - width * ratio, 
                y2 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue), selectedElement.append("svg").attr({
                    width: viewportWidth,
                    height: viewportHeight
                }).append("line").attr({
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2
                }).style({
                    "vector-effect": "non-scaling-stroke",
                    "stroke-width": data.lineWeight + "px",
                    "stroke-opacity": (100 - data.lineTransparency) / 100,
                    stroke: data.lineColor
                });
            }
            function createUpArrow(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var lineWeight = data.lineWeight, viewportHeightWeight = viewportHeight - lineWeight, viewportWidthWeight = viewportWidth - lineWeight, arrowPoints = [ {
                    x: (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.x).toString(),
                    y: (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.y).toString()
                }, {
                    x: (viewportWidthWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.x).toString(),
                    y: (viewportHeightWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.y).toString()
                }, {
                    x: (viewportWidthWeight * ShapeFactoryConsts.ArrowRightHeadPoint.x).toString(),
                    y: (viewportHeightWeight * ShapeFactoryConsts.ArrowRightHeadPoint.y).toString()
                }, {
                    x: (viewportWidthWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.x).toString(),
                    y: (viewportHeightWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.y).toString()
                }, {
                    x: (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomRightPoint.x).toString(),
                    y: (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomRightPoint.y).toString()
                }, {
                    x: (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.x).toString(),
                    y: (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.y).toString()
                }, {
                    x: (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.x).toString(),
                    y: (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.y).toString()
                } ];
                createPathFromArray(data, arrowPoints, selectedElement, viewportHeight, viewportWidth, degrees);
            }
            function createTriangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var lineWeight = data.lineWeight;
                lineWeight > 3 && (lineWeight -= 3);
                var firstPointX = (viewportWidth + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio, firstPointY = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight < 0 ? viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue : viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight, secondPointY = (viewportHeight + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio, thirdPointX = (viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio < 0 ? viewportWidth * ShapeFactoryConsts.TriangleEndPaddingConstRatio : (viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio, thirdPointY = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight < 0 ? viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue : viewportHeight - lineWeight - ShapeFactoryConsts.SmallPaddingConstValue, secondPointX = (firstPointX + thirdPointX) / 2;
                10 > firstPointX && (firstPointX = ShapeFactoryConsts.SmallPaddingConstValue), 10 > secondPointY && (secondPointY = ShapeFactoryConsts.SmallPaddingConstValue);
                var trianglePoints = [ {
                    x: firstPointX,
                    y: firstPointY
                }, {
                    x: secondPointX,
                    y: secondPointY
                }, {
                    x: thirdPointX,
                    y: thirdPointY
                } ];
                createPathFromArray(data, trianglePoints, selectedElement, viewportHeight, viewportWidth, degrees);
            }
            function createPathFromArray(data, points, selectedElement, viewportHeight, viewportWidth, degrees) {
                var lineFunction = d3.svg.line().x(function(d) {
                    return d.x;
                }).y(function(d) {
                    return d.y;
                }).interpolate("linear"), attrs = {
                    d: lineFunction(points) + " Z"
                }, scale = getScale(viewportWidth, viewportHeight, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, "path", attrs);
            }
            function createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, shapeType, shapeAttrs) {
                selectedElement.append("div").style({
                    transform: "rotate(" + degrees + "deg) scale(" + scale + ")",
                    "transform-origin": "center",
                    "-webkit-transform": "rotate(" + degrees + "deg) scale(" + scale + ")",
                    "-webkit-transform-origin": "center",
                    width: viewportWidth + "px",
                    height: viewportHeight + "px"
                }).append("svg").attr({
                    width: viewportWidth,
                    height: viewportHeight
                }).append(shapeType).attr(shapeAttrs).style({
                    "vector-effect": "non-scaling-stroke",
                    "stroke-width": data.lineWeight + "px",
                    stroke: data.lineColor,
                    "stroke-opacity": (100 - data.lineTransparency) / 100,
                    fill: data.fillColor,
                    "fill-opacity": data.showFill === !0 ? (100 - data.shapeTransparency) / 100 : 0
                });
            }
            function getScale(width, height, degrees) {
                var originalWidth = width, originalHeight = height, offsetAngle = Math.atan2(height, width), originalFactor = Math.sqrt(Math.pow(height, 2) + Math.pow(width, 2)), radians = degrees / 180 * Math.PI;
                return width >= height ? (90 > degrees ? radians += offsetAngle : 180 > degrees ? radians -= offsetAngle : 270 > degrees ? radians += offsetAngle : radians -= offsetAngle, 
                originalHeight / Math.abs(Math.sin(radians)) / originalFactor) : (90 > degrees ? radians -= offsetAngle : 180 > degrees ? radians += offsetAngle : 270 > degrees ? radians -= offsetAngle : radians += offsetAngle, 
                originalWidth / Math.abs(Math.cos(radians)) / originalFactor);
            }
            var ShapeFactoryConsts;
            !function(ShapeFactoryConsts) {
                ShapeFactoryConsts.PaddingConstRatio = .01, ShapeFactoryConsts.TrianglePaddingConstRatio = .15, 
                ShapeFactoryConsts.TriangleEndPaddingConstRatio = .85, ShapeFactoryConsts.ShapeConstRatio = 1 - 2 * ShapeFactoryConsts.PaddingConstRatio, 
                ShapeFactoryConsts.SmallPaddingConstValue = 10, ShapeFactoryConsts.OvalRadiusConst = 2, 
                ShapeFactoryConsts.OvalRadiusConstPadding = .2, ShapeFactoryConsts.ArrowLeftHeadPoint = {
                    x: .05,
                    y: .42
                }, ShapeFactoryConsts.ArrowMiddleHeadPoint = {
                    x: .5,
                    y: .016
                }, ShapeFactoryConsts.ArrowRightHeadPoint = {
                    x: .95,
                    y: .42
                }, ShapeFactoryConsts.ArrowRightMiddleHeadPoint = {
                    x: .764,
                    y: .42
                }, ShapeFactoryConsts.ArrowBottomRightPoint = {
                    x: .764,
                    y: .993
                }, ShapeFactoryConsts.ArrowBottomLeftPoint = {
                    x: .246,
                    y: .993
                }, ShapeFactoryConsts.ArrowLeftMiddleHeadPoint = {
                    x: .246,
                    y: .42
                };
            }(ShapeFactoryConsts = ShapeFactory.ShapeFactoryConsts || (ShapeFactory.ShapeFactoryConsts = {})), 
            ShapeFactory.createRectangle = createRectangle, ShapeFactory.createOval = createOval, 
            ShapeFactory.createLine = createLine, ShapeFactory.createUpArrow = createUpArrow, 
            ShapeFactory.createTriangle = createTriangle;
        }(ShapeFactory = visuals.ShapeFactory || (visuals.ShapeFactory = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var CartesianHelper;
        !function(CartesianHelper) {
            function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata) return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var categoryAxisObject = objects.categoryAxis;
                    categoryAxisObject && (toReturn = {
                        show: categoryAxisObject.show,
                        axisType: categoryAxisObject.axisType,
                        axisScale: categoryAxisObject.axisScale,
                        start: categoryAxisObject.start,
                        end: categoryAxisObject.end,
                        showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                        axisStyle: categoryAxisObject.axisStyle,
                        labelColor: categoryAxisObject.labelColor,
                        labelDisplayUnits: categoryAxisObject.labelDisplayUnits,
                        labelPrecision: categoryAxisObject.labelPrecision
                    });
                }
                return toReturn;
            }
            function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata) return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var valueAxisObject = objects.valueAxis;
                    valueAxisObject && (toReturn = {
                        show: valueAxisObject.show,
                        position: valueAxisObject.position,
                        axisScale: valueAxisObject.axisScale,
                        start: valueAxisObject.start,
                        end: valueAxisObject.end,
                        showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                        axisStyle: valueAxisObject.axisStyle,
                        labelColor: valueAxisObject.labelColor,
                        labelDisplayUnits: valueAxisObject.labelDisplayUnits,
                        labelPrecision: valueAxisObject.labelPrecision,
                        secShow: valueAxisObject.secShow,
                        secPosition: valueAxisObject.secPosition,
                        secAxisScale: valueAxisObject.secAxisScale,
                        secStart: valueAxisObject.secStart,
                        secEnd: valueAxisObject.secEnd,
                        secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                        secAxisStyle: valueAxisObject.secAxisStyle,
                        secLabelColor: valueAxisObject.secLabelColor,
                        secLabelDisplayUnits: valueAxisObject.secLabelDisplayUnits,
                        secLabelPrecision: valueAxisObject.secLabelPrecision
                    });
                }
                return toReturn;
            }
            function isScalar(isScalar, xAxisCardProperties) {
                return isScalar && (isScalar = xAxisCardProperties && xAxisCardProperties.axisType ? xAxisCardProperties.axisType === visuals.axisType.scalar : !0), 
                isScalar;
            }
            function getPrecision(precision) {
                return null != precision ? 0 > precision ? 0 : precision : null;
            }
            function lookupXValue(data, index, type, isScalar) {
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isScalar) return isDateTime ? new Date(index) : index;
                if (type.text) return data.categories[index];
                if (data && data.series && data.series.length > 0) {
                    var firstSeries = data.series[0];
                    if (firstSeries) {
                        var seriesValues = firstSeries.data;
                        if (seriesValues) {
                            data.hasHighlights && (index = 2 * index);
                            var dataAtIndex = seriesValues[index];
                            if (dataAtIndex) return isDateTime && null != dataAtIndex.categoryValue ? new Date(dataAtIndex.categoryValue) : dataAtIndex.categoryValue;
                        }
                    }
                }
                return index;
            }
            function findMaxCategoryIndex(series) {
                if (_.isEmpty(series)) return 0;
                for (var maxCategoryIndex = 0, _i = 0, series_1 = series; _i < series_1.length; _i++) {
                    var singleSeries = series_1[_i];
                    if (!_.isEmpty(singleSeries.data)) {
                        var lastIndex = singleSeries.data[singleSeries.data.length - 1].categoryIndex;
                        maxCategoryIndex = Math.max(lastIndex, maxCategoryIndex);
                    }
                }
                return maxCategoryIndex;
            }
            CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties, CartesianHelper.getValueAxisProperties = getValueAxisProperties, 
            CartesianHelper.isScalar = isScalar, CartesianHelper.getPrecision = getPrecision, 
            CartesianHelper.lookupXValue = lookupXValue, CartesianHelper.findMaxCategoryIndex = findMaxCategoryIndex;
        }(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var SQExprShortSerializer = powerbi.data.SQExprShortSerializer, ColorHelper = function() {
            function ColorHelper(colors, fillProp, defaultDataPointColor) {
                this.colors = colors, this.fillProp = fillProp, this.defaultDataPointColor = defaultDataPointColor, 
                this.defaultColorScale = colors.getNewColorScale();
            }
            return ColorHelper.prototype.getColorForSeriesValue = function(objects, fieldIds, value) {
                return this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp) || this.defaultDataPointColor || this.getColorScaleForSeries(fieldIds).getColor(value).value;
            }, ColorHelper.prototype.getColorScaleForSeries = function(fieldIds) {
                return this.colors.getColorScaleByKey(SQExprShortSerializer.serializeArray(fieldIds || []));
            }, ColorHelper.prototype.getColorForMeasure = function(objects, measureKey) {
                var scaleColor = this.defaultColorScale.getColor(measureKey).value;
                return this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp) || this.defaultDataPointColor || scaleColor;
            }, ColorHelper.normalizeSelector = function(selector, isSingleSeries) {
                return selector && (isSingleSeries || selector.data) ? {
                    data: selector.data
                } : selector;
            }, ColorHelper;
        }();
        visuals.ColorHelper = ColorHelper;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var ColumnUtil, rectName = "rect";
        !function(ColumnUtil) {
            function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
                if (isScalar) {
                    var min = xAxisCardProperties.start, max = xAxisCardProperties.end;
                    return ColumnUtil.transformDomain(dataView, min, max);
                }
                return dataView;
            }
            function transformDomain(dataView, min, max) {
                if (!dataView.categories || !dataView.values || 0 === dataView.categories.length || 0 === dataView.values.length) return dataView;
                if ("number" != typeof min && "number" != typeof max) return dataView;
                var category = dataView.categories[0], categoryValues = category.values, categoryObjects = category.objects;
                if (!categoryValues || !categoryObjects) return dataView;
                var newcategoryValues = [], newValues = [], newObjects = [];
                if ("number" != typeof min && (min = categoryValues[0]), "number" != typeof max && (max = categoryValues[categoryValues.length - 1]), 
                min > max) return dataView;
                for (var j = 0, len = dataView.values.length; len > j; j++) newValues.push([]);
                for (var t = 0, len = categoryValues.length; len > t; t++) if (categoryValues[t] >= min && categoryValues[t] <= max && (newcategoryValues.push(categoryValues[t]), 
                categoryObjects && newObjects.push(categoryObjects[t]), dataView.values)) for (var k = 0; k < dataView.values.length; k++) newValues[k].push(dataView.values[k].values[t]);
                var resultDataView = powerbi.Prototype.inherit(dataView), resultDataViewValues = resultDataView.values = powerbi.Prototype.inherit(resultDataView.values), resultDataViewCategories = resultDataView.categories = powerbi.Prototype.inherit(dataView.categories), resultDataViewCategories0 = resultDataView.categories[0] = powerbi.Prototype.inherit(resultDataViewCategories[0]);
                resultDataViewCategories0.values = newcategoryValues, resultDataViewCategories0.objects && (resultDataViewCategories0.objects = newObjects);
                for (var t = 0, len = dataView.values.length; len > t; t++) {
                    var measureArray = resultDataViewValues[t] = powerbi.Prototype.inherit(resultDataViewValues[t]);
                    measureArray.values = newValues[t];
                }
                return resultDataView;
            }
            function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var categoryThickness = layout.categoryThickness, isScalar = layout.isScalar, outerPaddingRatio = layout.outerPaddingRatio, domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({
                    text: !0
                }), isScalar, [ forcedXMin, forcedXMax ], ensureXDomain), axisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: size,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, visuals.columnChartProps.general.formatString),
                    outerPadding: categoryThickness * outerPaddingRatio,
                    isCategoryAxis: !0,
                    isScalar: isScalar,
                    isVertical: isVertical,
                    categoryThickness: categoryThickness,
                    useTickIntervalForDisplayUnits: !0,
                    getValueFn: function(index, type) {
                        return visuals.CartesianHelper.lookupXValue(data, index, type, isScalar);
                    },
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision
                });
                return layout.categoryThickness = axisProperties.categoryThickness, axisProperties;
            }
            function applyInteractivity(columns, onDragStart) {
                onDragStart && columns.attr("draggable", "true").on("dragstart", onDragStart);
            }
            function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                return hasPartialHighlights && !highlight || hasSelection && !selected ? ColumnUtil.DimmedOpacity : ColumnUtil.DefaultOpacity;
            }
            function getClosestColumnIndex(coordinate, columnsCenters) {
                for (var currentIndex = 0, distance = Number.MAX_VALUE, i = 0, ilen = columnsCenters.length; ilen > i; i++) {
                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                    distance > currentDistance && (distance = currentDistance, currentIndex = i);
                }
                return currentIndex;
            }
            function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
                var series = mainGraphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector), lastColumnUndefined = "undefined" == typeof lastColumnIndex;
                series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                    return d.categoryIndex !== selectedColumnIndex && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
                }).transition().style("fill-opacity", ColumnUtil.DimmedOpacity), series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                    return d.categoryIndex === selectedColumnIndex;
                }).style("fill-opacity", ColumnUtil.DefaultOpacity);
            }
            function drawSeries(data, graphicsContext, axisOptions) {
                var colGroupSelection = graphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector), series = colGroupSelection.data(data.series, function(d) {
                    return d.key;
                });
                return series.enter().append("g").classed(visuals.ColumnChart.SeriesClasses["class"], !0), 
                series.style({
                    fill: function(d) {
                        return d.color;
                    }
                }), series.exit().remove(), series;
            }
            function drawDefaultShapes(data, series, layout, itemCS, filterZeros, hasSelection) {
                var dataSelector;
                dataSelector = filterZeros ? function(d) {
                    var filteredData = _.filter(d.data, function(datapoint) {
                        return !!datapoint.value;
                    });
                    return filteredData;
                } : function(d) {
                    return d.data;
                };
                var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(dataSelector, function(d) {
                    return d.key;
                });
                return shapes.enter().append(rectName).attr("class", function(d) {
                    return itemCS["class"].concat(d.highlight ? " highlight" : "");
                }), shapes.style("fill-opacity", function(d) {
                    return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights);
                }).style("fill", function(d) {
                    return d.color !== data.series[d.seriesIndex].color ? d.color : null;
                }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
            }
            function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
                if (void 0 === isAnimator && (isAnimator = !1), series) {
                    for (var seriesData = series.data(), dataPoints = [], i = 0, len = seriesData.length; len > i; i++) Array.prototype.push.apply(dataPoints, seriesData[i].data);
                    return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
                }
                visuals.dataLabelUtils.cleanDataLabels(context);
            }
            function normalizeInfinityInScale(scale) {
                for (var scaledDomain = scale.domain(), i = 0, len = scaledDomain.length; len > i; ++i) scaledDomain[i] === Number.POSITIVE_INFINITY ? scaledDomain[i] = Number.MAX_VALUE : scaledDomain[i] === Number.NEGATIVE_INFINITY && (scaledDomain[i] = -Number.MAX_VALUE);
                scale.domain(scaledDomain);
            }
            function calculatePosition(d, axisOptions) {
                var xScale = axisOptions.xScale, yScale = axisOptions.yScale, scaledY0 = yScale(0), scaledX0 = xScale(0);
                switch (d.chartType) {
                  case visuals.ColumnChartType.stackedBar:
                  case visuals.ColumnChartType.hundredPercentStackedBar:
                    return scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.valueAbsolute)) + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;

                  case visuals.ColumnChartType.clusteredBar:
                    return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;

                  case visuals.ColumnChartType.stackedColumn:
                  case visuals.ColumnChartType.hundredPercentStackedColumn:
                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;

                  case visuals.ColumnChartType.clusteredColumn:
                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                }
            }
            ColumnUtil.DimmedOpacity = .4, ColumnUtil.DefaultOpacity = 1, ColumnUtil.applyUserMinMax = applyUserMinMax, 
            ColumnUtil.transformDomain = transformDomain, ColumnUtil.getCategoryAxis = getCategoryAxis, 
            ColumnUtil.applyInteractivity = applyInteractivity, ColumnUtil.getFillOpacity = getFillOpacity, 
            ColumnUtil.getClosestColumnIndex = getClosestColumnIndex, ColumnUtil.setChosenColumnOpacity = setChosenColumnOpacity, 
            ColumnUtil.drawSeries = drawSeries, ColumnUtil.drawDefaultShapes = drawDefaultShapes, 
            ColumnUtil.drawDefaultLabels = drawDefaultLabels, ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale, 
            ColumnUtil.calculatePosition = calculatePosition;
        }(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
        var ClusteredUtil;
        !function(ClusteredUtil) {
            function clearColumns(mainGraphicsContext, itemCS) {
                var cols = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                cols.exit().remove();
            }
            ClusteredUtil.clearColumns = clearColumns;
        }(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
        var StackedUtil;
        !function(StackedUtil) {
            function getSize(scale, size, zeroVal) {
                return void 0 === zeroVal && (zeroVal = 0), visuals.AxisHelper.diffScaled(scale, zeroVal, size);
            }
            function calcValueDomain(data, is100pct) {
                var defaultNumberRange = {
                    min: 0,
                    max: 10
                };
                if (0 === data.length) return defaultNumberRange;
                var min = d3.min(data, function(d) {
                    return d3.min(d.data, function(e) {
                        return e.position - e.valueAbsolute;
                    });
                }), max = d3.max(data, function(d) {
                    return d3.max(d.data, function(e) {
                        return e.position;
                    });
                });
                return is100pct && (min = powerbi.Double.roundToPrecision(min, PctRoundingError), 
                max = powerbi.Double.roundToPrecision(max, PctRoundingError)), {
                    min: min,
                    max: max
                };
            }
            function getStackedMultiplier(dataView, rowIdx, seriesCount, categoryCount, converterStrategy) {
                for (var pos = 0, neg = 0, i = 0; seriesCount > i; i++) {
                    var value = converterStrategy.getValueBySeriesAndCategory(i, rowIdx);
                    value = visuals.AxisHelper.normalizeNonFiniteNumber(value), value > 0 ? pos += value : 0 > value && (neg -= value);
                }
                var absTotal = pos + neg;
                return {
                    pos: pos ? pos / absTotal / pos : 1,
                    neg: neg ? neg / absTotal / neg : 1
                };
            }
            function clearColumns(mainGraphicsContext, itemCS) {
                var bars = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                bars.exit().remove();
            }
            var PctRoundingError = 1e-4;
            StackedUtil.getSize = getSize, StackedUtil.calcValueDomain = calcValueDomain, StackedUtil.getStackedMultiplier = getStackedMultiplier, 
            StackedUtil.clearColumns = clearColumns;
        }(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var converterHelper, DataRoleHelper = powerbi.data.DataRoleHelper;
        !function(converterHelper) {
            function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = dataView.categories[0];
                    return category.source && DataRoleHelper.hasRole(category.source, seriesRoleName) && DataRoleHelper.hasRole(category.source, categoryRoleName);
                }
                return !1;
            }
            function getPivotedCategories(dataView, formatStringProp) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = dataView.categories[0], categoryValues = category.values;
                    return category.values.length > 0 ? {
                        categories: categoryValues,
                        categoryFormatter: visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
                            value: categoryValues[0],
                            value2: categoryValues[categoryValues.length - 1],
                            displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose
                        }),
                        categoryIdentities: category.identity,
                        categoryObjects: category.objects
                    } : {
                        categories: [],
                        categoryFormatter: {
                            format: visuals.valueFormatter.format
                        }
                    };
                }
                return defaultCategories();
            }
            function getSeriesName(source) {
                return void 0 !== source.groupName ? source.groupName : source.queryName;
            }
            function getFormattedLegendLabel(source, values, formatStringProp) {
                var sourceForFormat = source, nameForFormat = source.displayName;
                return void 0 !== source.groupName && (sourceForFormat = values.source, nameForFormat = source.groupName), 
                visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
            }
            function defaultCategories() {
                return {
                    categories: [ null ],
                    categoryFormatter: {
                        format: visuals.valueFormatter.format
                    }
                };
            }
            function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
                var xAxisLabel = null, yAxisLabel = null;
                if (categoryAxisProperties && category && category.displayName && (xAxisLabel = category.displayName), 
                valueAxisProperties) {
                    var valuesNames = [];
                    values && (valuesNames = values.map(function(v) {
                        return v ? v.displayName : "";
                    }).filter(function(value, index, self) {
                        return "" !== value && self.indexOf(value) === index;
                    }), yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames));
                }
                return {
                    xAxisLabel: xAxisLabel,
                    yAxisLabel: yAxisLabel
                };
            }
            function isImageUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return null != misc && misc.imageUrl === !0;
            }
            function isWebUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return null != misc && misc.webUrl === !0;
            }
            function getMiscellaneousTypeDescriptor(column) {
                return column && column.type && column.type.misc;
            }
            function hasImageUrlColumn(dataView) {
                return dataView && dataView.metadata && !_.isEmpty(dataView.metadata.columns) ? _.any(dataView.metadata.columns, function(column) {
                    return isImageUrlColumn(column) === !0;
                }) : !1;
            }
            function formatFromMetadataColumn(value, column, formatStringProp) {
                var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, !0);
                return formatString = formatString || column ? column.format : void 0, visuals.valueFormatter.format(value, formatString);
            }
            converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole, converterHelper.getPivotedCategories = getPivotedCategories, 
            converterHelper.getSeriesName = getSeriesName, converterHelper.getFormattedLegendLabel = getFormattedLegendLabel, 
            converterHelper.createAxesLabels = createAxesLabels, converterHelper.isImageUrlColumn = isImageUrlColumn, 
            converterHelper.isWebUrlColumn = isWebUrlColumn, converterHelper.hasImageUrlColumn = hasImageUrlColumn, 
            converterHelper.formatFromMetadataColumn = formatFromMetadataColumn;
        }(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var dataLabelUtils, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, LabelStyle = visuals.labelStyle;
        !function(dataLabelUtils) {
            function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                labelsObj && (void 0 !== labelsObj.show && (labelSettings.show = labelsObj.show), 
                void 0 !== labelsObj.showSeries && (labelSettings.show = labelsObj.showSeries), 
                void 0 !== labelsObj.color && (labelSettings.labelColor = labelsObj.color.solid.color), 
                void 0 !== labelsObj.labelDisplayUnits && (labelSettings.displayUnits = labelsObj.labelDisplayUnits), 
                void 0 !== labelsObj.labelPrecision && (labelSettings.precision = labelsObj.labelPrecision >= 0 ? labelsObj.labelPrecision : dataLabelUtils.defaultLabelPrecision), 
                void 0 !== labelsObj.fontSize && (labelSettings.fontSize = labelsObj.fontSize), 
                void 0 !== labelsObj.showAll && (labelSettings.showLabelPerSeries = labelsObj.showAll), 
                void 0 !== labelsObj.labelStyle && (labelSettings.labelStyle = labelsObj.labelStyle));
            }
            function updateLineChartLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                updateLabelSettingsFromLabelsObject(labelsObj, labelSettings), labelsObj && void 0 !== labelsObj.labelDensity && (labelSettings.labelDensity = labelsObj.labelDensity);
            }
            function getDefaultLabelSettings(show, labelColor, fontSize) {
                return void 0 === show && (show = !1), {
                    show: show,
                    position: 0,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: fontSize || dataLabelUtils.DefaultFontSizeInPt
                };
            }
            function getDefaultCardLabelSettings(labelColor, categoryLabelColor, fontSize) {
                var labelSettings = getDefaultLabelSettings(!0, labelColor, fontSize);
                return labelSettings.showCategory = !0, labelSettings.categoryLabelColor = categoryLabelColor, 
                labelSettings;
            }
            function getDefaultTreemapLabelSettings() {
                return {
                    show: !1,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    showCategory: !0,
                    formatterOptions: null
                };
            }
            function getDefaultSunburstLabelSettings() {
                return {
                    show: !1,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    showCategory: !0
                };
            }
            function getDefaultColumnLabelSettings(isLabelPositionInside) {
                var labelSettings = getDefaultLabelSettings(!1, void 0);
                return labelSettings.position = null, labelSettings.labelColor = void 0, labelSettings;
            }
            function getDefaultPointLabelSettings() {
                return {
                    show: !1,
                    position: 0,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt
                };
            }
            function getDefaultLineChartLabelSettings(isComboChart) {
                return {
                    show: !1,
                    position: 0,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    labelDensity: isComboChart ? visuals.NewDataLabelUtils.LabelDensityMax : visuals.NewDataLabelUtils.LabelDensityMin
                };
            }
            function getDefaultMapLabelSettings() {
                return {
                    show: !1,
                    showCategory: !1,
                    position: 0,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt
                };
            }
            function getDefaultDonutLabelSettings() {
                var labelSettings = dataLabelUtils.getDefaultLabelSettings(!0, dataLabelUtils.defaultLabelColor, dataLabelUtils.DefaultFontSizeInPt);
                return labelSettings.labelStyle = LabelStyle.category, labelSettings;
            }
            function getDefaultGaugeLabelSettings() {
                return {
                    show: !0,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: null,
                    position: null,
                    fontSize: dataLabelUtils.minLabelFontSize,
                    formatterOptions: null
                };
            }
            function getDefaultFunnelLabelSettings() {
                return {
                    show: !0,
                    position: powerbi.visuals.labelPosition.insideCenter,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt
                };
            }
            function getDefaultKpiLabelSettings() {
                return {
                    show: !1,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    position: null,
                    showCategory: !0,
                    formatterOptions: null
                };
            }
            function getLabelPrecision(precision, format) {
                if (precision !== dataLabelUtils.defaultLabelPrecision) return precision;
                if ("g" !== format && "G" !== format) {
                    if (format) {
                        var positiveFormat = format.split(";")[0], formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, !0);
                        if (formatMetadata.hasDots) return formatMetadata.precision;
                    }
                    return defaultCountLabelPrecision;
                }
            }
            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection) {
                void 0 === isAnimator && (isAnimator = !1);
                var dataLabelManager = new powerbi.DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout), hasAnimation = isAnimator && !!animationDuration, labels = selectLabels(filteredData, context, !1, hasAnimation);
                return labels ? (hasAnimation ? (labels.text(function(d) {
                    return d.labeltext;
                }).transition().duration(animationDuration).style(layout.style).style("opacity", hasSelection ? function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                } : 1).attr({
                    x: function(d) {
                        return d.labelX;
                    },
                    y: function(d) {
                        return d.labelY;
                    }
                }), labels.exit().transition().duration(animationDuration).style("opacity", 0).remove()) : (labels.attr({
                    x: function(d) {
                        return d.labelX;
                    },
                    y: function(d) {
                        return d.labelY;
                    }
                }).text(function(d) {
                    return d.labeltext;
                }).style(layout.style), labels.exit().remove()), labels) : void 0;
            }
            function drawDefaultLabelsForFunnelChart(data, context, layout, isAnimator, animationDuration) {
                void 0 === isAnimator && (isAnimator = !1);
                var filteredData = data.filter(layout.filter), labels = selectLabels(filteredData, context);
                return labels ? (labels.attr(layout.labelLayout).text(layout.labelText).style(layout.style), 
                isAnimator && animationDuration && labels.transition().duration(animationDuration), 
                labels.exit().remove(), labels) : void 0;
            }
            function selectLabels(filteredData, context, isDonut, forAnimation) {
                if (void 0 === isDonut && (isDonut = !1), void 0 === forAnimation && (forAnimation = !1), 
                0 === filteredData.length) return cleanDataLabels(context, !0), null;
                context.select(labelGraphicsContextClass.selector).empty() && context.append("g").classed(labelGraphicsContextClass["class"], !0);
                var hasKey = null != filteredData[0].key, hasDataPointIdentity = null != filteredData[0].identity, getIdentifier = hasKey ? function(d) {
                    return d.key;
                } : hasDataPointIdentity ? function(d) {
                    return d.identity.getKey();
                } : void 0, labels = isDonut ? context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, function(d) {
                    return d.data.identity.getKey();
                }) : null != getIdentifier ? context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, getIdentifier) : context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData), newLabels = labels.enter().append("text").classed(labelsClass["class"], !0);
                return forAnimation && newLabels.style("opacity", 0), labels;
            }
            function cleanDataLabels(context, removeLines) {
                void 0 === removeLines && (removeLines = !1);
                var empty = [], labels = context.selectAll(labelsClass.selector).data(empty);
                if (labels.exit().remove(), context.selectAll(labelGraphicsContextClass.selector).remove(), 
                removeLines) {
                    var lines = context.selectAll(lineClass.selector).data(empty);
                    lines.exit().remove(), context.selectAll(linesGraphicsContextClass.selector).remove();
                }
            }
            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                context.selectAll(labelsClass.selector).style("fill-opacity", function(d) {
                    var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
                    return labelOpacity;
                });
            }
            function getLabelFormattedText(options) {
                var properties = {
                    text: options.formatter ? options.formatter.format(options.label) : powerbi.formattingService.formatValue(options.label, options.format),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: PixelConverter.fromPoint(options.fontSize),
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, options.maxWidth ? options.maxWidth : dataLabelUtils.maxLabelWidth);
            }
            function getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
                return {
                    x: function(d) {
                        return xAxisProperties.scale(d.categoryIndex) + categoryWidth / 2;
                    },
                    y: function(d) {
                        return getWaterfallLabelYPosition(yAxisProperties.scale, d, dataDomain);
                    }
                };
            }
            function getWaterfallLabelYPosition(scale, d, dataDomain) {
                var yValue = scale(0) - scale(Math.abs(d.value)), yPos = scale(d.position), scaleMinDomain = scale(dataDomain[0]), endPosition = scale(d.position + d.value);
                if (d.value < 0) {
                    var properties = {
                        text: d.labeltext,
                        fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                    }, outsideBelowPosition = yPos + yValue + powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    if (scaleMinDomain > outsideBelowPosition) return outsideBelowPosition;
                } else {
                    var outsideAbovePosition = yPos - yValue - dataLabelUtils.labelMargin;
                    if (outsideAbovePosition > 0) return outsideAbovePosition;
                }
                return d.isLabelInside = !0, getWaterfallInsideLabelYPosition(yPos, endPosition, scaleMinDomain);
            }
            function getWaterfallInsideLabelYPosition(startPosition, endPosition, scaleMinDomain) {
                return startPosition = 0 > startPosition ? 0 : startPosition, startPosition = startPosition > scaleMinDomain ? scaleMinDomain : startPosition, 
                endPosition = 0 > endPosition ? 0 : endPosition, endPosition = endPosition > scaleMinDomain ? scaleMinDomain : endPosition, 
                Math.abs(endPosition - startPosition) / 2 + Math.min(startPosition, endPosition);
            }
            function doesDataLabelFitInShape(d, yAxisProperties, layout) {
                if (null == d || null === d.value) return !1;
                var properties = {
                    text: layout.labelText(d),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                }, outsidePosition = visuals.WaterfallChart.getRectTop(yAxisProperties.scale, d.position, d.value) - dataLabelUtils.labelMargin;
                if (outsidePosition > 0) return !0;
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties), shapeWidth = layout.categoryWidth, shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yAxisProperties.scale, Math.max(0, Math.abs(d.value)), 0));
                return !(textWidth > shapeWidth || textHeight > shapeHeight);
            }
            function getMapLabelLayout(labelSettings) {
                return {
                    labelText: function(d) {
                        return getLabelFormattedText({
                            label: d.labeltext,
                            fontSize: labelSettings.fontSize
                        });
                    },
                    labelLayout: {
                        x: function(d) {
                            return d.x;
                        },
                        y: function(d) {
                            var margin = d.radius + dataLabelUtils.labelMargin;
                            return 0 === labelSettings.position ? d.y - margin : d.y + margin;
                        }
                    },
                    filter: function(d) {
                        return null != d && null != d.labeltext;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "font-size": PixelConverter.fromPoint(labelSettings.fontSize)
                    }
                };
            }
            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth) {
                var formatOverride = isHundredPercent ? dataLabelUtils.hundredPercentFormat : null, formattersCache = createColumnFormatterCacheManager(), hasSelection = interactivityService ? interactivityService.hasSelection() : !1;
                return {
                    labelText: function(d) {
                        var formatString = null != formatOverride ? formatOverride : d.labelFormatString, value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings), formatter = formattersCache.getOrCreate(formatString, d.labelSettings, value2);
                        return getLabelFormattedText({
                            label: formatter.format(d.value),
                            maxWidth: dataLabelUtils.maxLabelWidth
                        });
                    },
                    labelLayout: labelLayoutXY,
                    filter: function(d) {
                        return dataLabelUtils.getColumnChartLabelFilter(d, hasSelection, data.hasHighlights, axisOptions, visualWidth);
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "text-anchor": isColumn ? "middle" : "start"
                    }
                };
            }
            function validateLabelsSize(d, axisOptions, visualWidth) {
                var shapeWidth, shapeHeight, xScale = axisOptions.xScale, yScale = axisOptions.yScale, columnWidth = axisOptions.columnWidth, properties = {
                    text: d.labeltext,
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties), inside = !1, outsidePosition = visuals.ColumnUtil.calculatePosition(d, axisOptions);
                switch (d.chartType) {
                  case visuals.ColumnChartType.stackedBar:
                  case visuals.ColumnChartType.hundredPercentStackedBar:
                    (!d.lastSeries || outsidePosition + textWidth > visualWidth || d.chartType === visuals.ColumnChartType.hundredPercentStackedBar) && (shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute), 
                    shapeHeight = columnWidth, inside = !0);
                    break;

                  case visuals.ColumnChartType.clusteredBar:
                    outsidePosition + textWidth > visualWidth && (shapeWidth = Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value)), 
                    shapeHeight = columnWidth, inside = !0);
                    break;

                  case visuals.ColumnChartType.stackedColumn:
                  case visuals.ColumnChartType.hundredPercentStackedColumn:
                    (!d.lastSeries || 0 >= outsidePosition || d.chartType === visuals.ColumnChartType.hundredPercentStackedColumn) && (shapeWidth = columnWidth, 
                    shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute), inside = !0);
                    break;

                  case visuals.ColumnChartType.clusteredColumn:
                    0 >= outsidePosition && (shapeWidth = columnWidth, shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value)), 
                    inside = !0);
                    break;

                  default:
                    return !0;
                }
                return !inside || !(textWidth > shapeWidth || textHeight > shapeHeight);
            }
            function getColumnChartLabelFilter(d, hasSelection, hasHighlights, axisOptions, visualWidth) {
                var shapesOpacity = hasSelection ? visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                return null != d && null != d.value && validateLabelsSize(d, axisOptions, visualWidth) && 1 === shapesOpacity;
            }
            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                return {
                    labelText: function(d) {
                        return getLabelFormattedText({
                            label: d.formattedCategory.getValue(),
                            maxWidth: 2 * dataLabelUtils.maxLabelWidth
                        });
                    },
                    labelLayout: {
                        x: function(d) {
                            return xScale(d.x);
                        },
                        y: function(d) {
                            var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
                            return 0 === labelSettings.position ? yScale(d.y) - margin : yScale(d.y) + margin;
                        }
                    },
                    filter: function(d) {
                        return null != d && null != d.formattedCategory.getValue();
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        }
                    }
                };
            }
            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar, axisFormatter) {
                var formattersCache = createColumnFormatterCacheManager();
                return {
                    labelText: function(d) {
                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings), formatter = formattersCache.getOrCreate(d.labelFormatString, d.labelSettings, value2);
                        return getLabelFormattedText({
                            label: formatter.format(d.value)
                        });
                    },
                    labelLayout: {
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex);
                        },
                        y: function(d) {
                            return 0 === labelSettings.position ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin;
                        }
                    },
                    filter: function(d) {
                        return null != d && null != d.value;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "font-size": function(d) {
                            return PixelConverter.fromPoint(d.labelSettings.fontSize);
                        }
                    }
                };
            }
            function getFunnelChartLabelLayout(data, axisOptions, textMinimumPadding, labelSettings, currentViewport) {
                var yScale = axisOptions.yScale, xScale = axisOptions.xScale, marginLeft = axisOptions.margin.left, innerTextHeightRate = .7, rangeBand = axisOptions.xScale.rangeBand(), pixelSpan = axisOptions.verticalRange / 2, formatString = visuals.valueFormatter.getFormatString(data.valuesMetadata[0], visuals.funnelChartProps.general.formatString), textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth, value2 = null;
                if (0 === labelSettings.displayUnits) {
                    var minY = d3.min(data.slices, function(d) {
                        return d.value;
                    }), maxY = d3.max(data.slices, function(d) {
                        return d.value;
                    });
                    value2 = Math.max(Math.abs(minY), Math.abs(maxY));
                }
                var formattersCache = createColumnFormatterCacheManager();
                return {
                    labelText: function(d) {
                        var barWidth = Math.abs(yScale(d.value) - yScale(0)), insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - 2 * textMinimumPadding, outsideAvailableSpace = pixelSpan - barWidth / 2 - textMinimumPadding, labelFormatString = null != formatString ? formatString : d.labelFormatString, maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace), formatter = formattersCache.getOrCreate(labelFormatString, labelSettings, value2), labelText = formatter.format(visuals.FunnelChart.getFunnelSliceValue(d, !0));
                        return getLabelFormattedText({
                            label: labelText,
                            maxWidth: maximumTextSize,
                            fontSize: labelSettings.fontSize
                        });
                    },
                    labelLayout: {
                        y: function(d, i) {
                            var properties = {
                                text: d.labeltext,
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                            }, labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                            return xScale(i) + rangeBand / 2 + labelHeight / 2;
                        },
                        x: function(d) {
                            var barWidth = Math.abs(yScale(d.value) - yScale(0)), insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - 2 * textMinimumPadding, outsideAvailableSpace = pixelSpan - barWidth / 2 - textMinimumPadding, maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace), labelFormatString = null != formatString ? formatString : d.labelFormatString, formatter = formattersCache.getOrCreate(labelFormatString, labelSettings, value2), labelText = formatter.format(visuals.FunnelChart.getFunnelSliceValue(d, !0)), properties = {
                                text: getLabelFormattedText({
                                    label: labelText,
                                    maxWidth: maximumTextSize
                                }),
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                            }, textLength = textMeasurer(properties), labelPositionValue = labelSettings.position;
                            switch (labelPositionValue === visuals.labelPosition.outsideEnd && textLength > outsideAvailableSpace || 0 === d.value ? labelPositionValue = visuals.labelPosition.insideCenter : labelPositionValue === visuals.labelPosition.insideCenter && textLength > insideAvailableSpace && (labelPositionValue = visuals.labelPosition.outsideEnd), 
                            labelPositionValue) {
                              case visuals.labelPosition.outsideEnd:
                                return marginLeft + pixelSpan + barWidth / 2 + textMinimumPadding + textLength / 2;

                              default:
                                return d.labelFill = 0 !== d.value ? dataLabelUtils.defaultInsideLabelColor : d.labelFill, 
                                marginLeft + pixelSpan;
                            }
                        },
                        dy: "-0.15em"
                    },
                    filter: function(d) {
                        if (null == d || null == d.value || data.hasHighlights !== !!d.highlight) return !1;
                        var properties = {
                            text: d.labeltext,
                            fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                            fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                        }, labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties) * innerTextHeightRate;
                        return rangeBand > labelHeight;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, !1, !1, !1);
                        },
                        "font-size": function(d) {
                            return PixelConverter.fromPoint(labelSettings.fontSize);
                        }
                    }
                };
            }
            function enumerateDataLabels(options) {
                if (options.dataLabelsSettings) {
                    var instance = {
                        objectName: "labels",
                        selector: options.selector,
                        properties: {}
                    };
                    if (options.show && options.selector ? instance.properties.showSeries = options.dataLabelsSettings.show : options.show && (instance.properties.show = options.dataLabelsSettings.show), 
                    instance.properties.color = options.dataLabelsSettings.labelColor || dataLabelUtils.defaultLabelColor, 
                    options.displayUnits && (instance.properties.labelDisplayUnits = options.dataLabelsSettings.displayUnits), 
                    options.precision) {
                        var precision = options.dataLabelsSettings.precision;
                        instance.properties.labelPrecision = precision === dataLabelUtils.defaultLabelPrecision ? null : precision;
                    }
                    if (options.position && (instance.properties.labelPosition = options.dataLabelsSettings.position, 
                    options.positionObject && (instance.validValues = {
                        labelPosition: options.positionObject
                    })), options.labelStyle && (instance.properties.labelStyle = options.dataLabelsSettings.labelStyle), 
                    options.fontSize && (instance.properties.fontSize = options.dataLabelsSettings.fontSize), 
                    options.labelDensity) {
                        var lineChartSettings = options.dataLabelsSettings;
                        lineChartSettings && (instance.properties.labelDensity = lineChartSettings.labelDensity);
                    }
                    return options.showAll && (instance.properties.showAll = options.dataLabelsSettings.showLabelPerSeries), 
                    options.enumeration.pushInstance(instance);
                }
            }
            function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory, fontSize) {
                void 0 === isShowCategory && (isShowCategory = !1);
                var labelSettings = dataLabelsSettings ? dataLabelsSettings : getDefaultPointLabelSettings(), instance = {
                    objectName: "categoryLabels",
                    selector: null,
                    properties: {
                        show: isShowCategory ? labelSettings.showCategory : labelSettings.show,
                        fontSize: dataLabelsSettings ? dataLabelsSettings.fontSize : dataLabelUtils.DefaultFontSizeInPt
                    }
                };
                withFill && (instance.properties.color = labelSettings.categoryLabelColor ? labelSettings.categoryLabelColor : labelSettings.labelColor), 
                fontSize && (instance.properties.fontSize = fontSize), enumeration.pushInstance(instance);
            }
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                return axisFormatter && axisFormatter.displayUnit && 0 === labelSettings.displayUnits ? axisFormatter.displayUnit.value : null;
            }
            function createColumnFormatterCacheManager() {
                return {
                    cache: {
                        defaultFormatter: null
                    },
                    getOrCreate: function(formatString, labelSetting, value2) {
                        if (formatString) {
                            var cacheKeyObject = {
                                formatString: formatString,
                                displayUnits: labelSetting.displayUnits,
                                precision: getLabelPrecision(labelSetting.precision, formatString),
                                value2: value2
                            }, cacheKey = JSON.stringify(cacheKeyObject);
                            return this.cache[cacheKey] || (this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision))), 
                            this.cache[cacheKey];
                        }
                        return this.cache.defaultFormatter || (this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision))), 
                        this.cache.defaultFormatter;
                    }
                };
            }
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: !0
                };
            }
            function isTextWidthOverflows(textWidth, maxTextWidth) {
                return textWidth > maxTextWidth;
            }
            function isTextHeightOverflows(textHeight, innerChordLength) {
                return textHeight > innerChordLength;
            }
            dataLabelUtils.minLabelFontSize = 8, dataLabelUtils.labelMargin = 8, dataLabelUtils.maxLabelWidth = 50, 
            dataLabelUtils.defaultColumnLabelMargin = 5, dataLabelUtils.defaultColumnHalfLabelHeight = 4, 
            dataLabelUtils.DefaultDy = "-0.15em", dataLabelUtils.DefaultFontSizeInPt = 9, dataLabelUtils.StandardFontFamily = "wf_segoe-ui_normal", 
            dataLabelUtils.LabelTextProperties = {
                fontFamily: "wf_standard-font",
                fontSize: PixelConverter.fromPoint(dataLabelUtils.DefaultFontSizeInPt),
                fontWeight: "normal"
            }, dataLabelUtils.defaultLabelColor = "#777777", dataLabelUtils.defaultInsideLabelColor = "#ffffff", 
            dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %", dataLabelUtils.defaultLabelPrecision = void 0;
            var defaultCountLabelPrecision = 0, labelGraphicsContextClass = createClassAndSelector("labels"), linesGraphicsContextClass = createClassAndSelector("lines"), labelsClass = createClassAndSelector("data-labels"), lineClass = createClassAndSelector("line-label");
            dataLabelUtils.updateLabelSettingsFromLabelsObject = updateLabelSettingsFromLabelsObject, 
            dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject = updateLineChartLabelSettingsFromLabelsObject, 
            dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings, dataLabelUtils.getDefaultCardLabelSettings = getDefaultCardLabelSettings, 
            dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings, 
            dataLabelUtils.getDefaultSunburstLabelSettings = getDefaultSunburstLabelSettings, 
            dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings, dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings, 
            dataLabelUtils.getDefaultLineChartLabelSettings = getDefaultLineChartLabelSettings, 
            dataLabelUtils.getDefaultMapLabelSettings = getDefaultMapLabelSettings, dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings, 
            dataLabelUtils.getDefaultGaugeLabelSettings = getDefaultGaugeLabelSettings, dataLabelUtils.getDefaultFunnelLabelSettings = getDefaultFunnelLabelSettings, 
            dataLabelUtils.getDefaultKpiLabelSettings = getDefaultKpiLabelSettings, dataLabelUtils.getLabelPrecision = getLabelPrecision, 
            dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart, 
            dataLabelUtils.drawDefaultLabelsForFunnelChart = drawDefaultLabelsForFunnelChart, 
            dataLabelUtils.cleanDataLabels = cleanDataLabels, dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity, 
            dataLabelUtils.getLabelFormattedText = getLabelFormattedText, dataLabelUtils.getLabelLayoutXYForWaterfall = getLabelLayoutXYForWaterfall, 
            dataLabelUtils.doesDataLabelFitInShape = doesDataLabelFitInShape, dataLabelUtils.getMapLabelLayout = getMapLabelLayout, 
            dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout, dataLabelUtils.getColumnChartLabelFilter = getColumnChartLabelFilter, 
            dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout, dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout, 
            dataLabelUtils.getFunnelChartLabelLayout = getFunnelChartLabelLayout, dataLabelUtils.enumerateDataLabels = enumerateDataLabels, 
            dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels, dataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager, 
            dataLabelUtils.getOptionsForLabelFormatter = getOptionsForLabelFormatter, dataLabelUtils.isTextWidthOverflows = isTextWidthOverflows, 
            dataLabelUtils.isTextHeightOverflows = isTextHeightOverflows;
        }(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var DonutLabelUtils;
        !function(DonutLabelUtils) {
            function getLabelLeaderLineForDonutChart(donutArcDescriptor, donutProperties, parentPoint, sliceArc) {
                void 0 === sliceArc && (sliceArc = 0);
                var textPoint, midPoint, chartPoint, innerLinePointMultiplier = 2.05;
                if (sliceArc) {
                    var arc = sliceArc, outerRadius = donutProperties.radius * donutProperties.outerArcRadiusRatio, innerRadius = donutProperties.radius / 2 * donutProperties.innerArcRadiusRatio;
                    midPoint = [ Math.cos(arc) * outerRadius, Math.sin(arc) * outerRadius ], chartPoint = [ Math.cos(arc) * innerRadius, Math.sin(arc) * innerRadius ];
                } else midPoint = donutProperties.outerArc.centroid(donutArcDescriptor), chartPoint = donutProperties.arc.centroid(donutArcDescriptor);
                var textPointX = parentPoint.x, lineMargin = visuals.NewDataLabelUtils.maxLabelOffset / 2;
                return textPointX += 0 > textPointX ? -lineMargin : lineMargin, textPoint = [ textPointX, parentPoint.y ], 
                chartPoint[0] *= innerLinePointMultiplier, chartPoint[1] *= innerLinePointMultiplier, 
                [ chartPoint, midPoint, textPoint ];
            }
            function getLabelLeaderLinesSizeForDonutChart(leaderLinePoints) {
                if (leaderLinePoints && leaderLinePoints.length > 2) {
                    var diagonalLineSize = {
                        width: Math.abs(leaderLinePoints[1][0] - leaderLinePoints[0][0]),
                        height: Math.abs(leaderLinePoints[1][1] - leaderLinePoints[0][1])
                    }, horizontalLineSize = {
                        width: Math.abs(leaderLinePoints[2][0] - leaderLinePoints[1][0]),
                        height: DonutLabelUtils.LineStrokeWidth
                    };
                    return [ diagonalLineSize, horizontalLineSize ];
                }
                return null;
            }
            function getXPositionForDonutLabel(textPointX) {
                var margin = 0 > textPointX ? -visuals.NewDataLabelUtils.maxLabelOffset : visuals.NewDataLabelUtils.maxLabelOffset;
                return textPointX += margin;
            }
            function getSpaceAvailableForDonutLabels(labelXPos, viewport) {
                return viewport.width / 2 - Math.abs(labelXPos) - visuals.NewDataLabelUtils.maxLabelOffset;
            }
            DonutLabelUtils.LineStrokeWidth = 1, DonutLabelUtils.DiagonalLineIndex = 0, DonutLabelUtils.HorizontalLineIndex = 1, 
            DonutLabelUtils.getLabelLeaderLineForDonutChart = getLabelLeaderLineForDonutChart, 
            DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart = getLabelLeaderLinesSizeForDonutChart, 
            DonutLabelUtils.getXPositionForDonutLabel = getXPositionForDonutLabel, DonutLabelUtils.getSpaceAvailableForDonutLabels = getSpaceAvailableForDonutLabels;
        }(DonutLabelUtils = visuals.DonutLabelUtils || (visuals.DonutLabelUtils = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var NewDataLabelUtils, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter;
        !function(NewDataLabelUtils) {
            function drawDefaultLabels(context, dataLabels, numeric, twoRows, hasTooltip) {
                void 0 === numeric && (numeric = !1), void 0 === twoRows && (twoRows = !1), void 0 === hasTooltip && (hasTooltip = !1);
                var filteredDataLabels = _.filter(dataLabels, function(d) {
                    return d.isVisible;
                }), labels = context.selectAll(labelsClass.selector).data(filteredDataLabels, labelKeyFunction);
                labels.enter().append("text").classed(labelsClass["class"], !0);
                var labelAttr = {
                    x: function(d) {
                        return d.boundingBox.left + d.boundingBox.width / 2;
                    },
                    y: function(d) {
                        return d.hasBackground ? d.boundingBox.top + d.boundingBox.height - NewDataLabelUtils.verticalLabelBackgroundPadding : d.boundingBox.top + d.boundingBox.height;
                    },
                    dy: "-0.15em"
                };
                numeric && (labelAttr.dy = void 0), labels.text(function(d) {
                    return d.text;
                }).attr(labelAttr).style({
                    fill: function(d) {
                        return d.fill;
                    },
                    "font-size": function(d) {
                        return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt);
                    },
                    "text-anchor": function(d) {
                        return d.textAnchor;
                    }
                }), labels.exit().remove();
                var filteredCategoryLabels = _.filter(twoRows ? dataLabels : [], function(d) {
                    return d.isVisible && !_.isEmpty(d.secondRowText);
                }), secondLineLabels = context.selectAll(secondLineLabelClass.selector).data(filteredCategoryLabels, function(d, index) {
                    return d.identity ? d.identity.getKeyWithoutHighlight() : index;
                });
                return secondLineLabels.enter().append("text").classed(secondLineLabelClass["class"], !0), 
                labelAttr = {
                    x: function(d) {
                        return d.boundingBox.left + d.boundingBox.width / 2;
                    },
                    y: function(d) {
                        var boundingBoxHeight = void 0 !== d.text ? d.boundingBox.height / 2 : d.boundingBox.height;
                        return d.hasBackground ? d.boundingBox.top + boundingBoxHeight - NewDataLabelUtils.verticalLabelBackgroundPadding : d.boundingBox.top + boundingBoxHeight;
                    },
                    dy: "-0.15em"
                }, numeric && (labelAttr.dy = void 0), secondLineLabels.text(function(d) {
                    return d.secondRowText;
                }).attr(labelAttr).style({
                    fill: function(d) {
                        return d.fill;
                    },
                    "font-size": function(d) {
                        return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt);
                    },
                    "text-anchor": function(d) {
                        return d.textAnchor;
                    }
                }), secondLineLabels.exit().remove(), hasTooltip && (labels.append("title").text(function(d) {
                    return d.tooltip;
                }), secondLineLabels.append("title").text(function(d) {
                    return d.tooltip;
                }), labels.style("pointer-events", "all"), secondLineLabels.style("pointer-events", "all")), 
                labels;
            }
            function animateDefaultLabels(context, dataLabels, duration, numeric, easeType) {
                void 0 === numeric && (numeric = !1), void 0 === easeType && (easeType = "cubic-in-out");
                var labels = context.selectAll(labelsClass.selector).data(_.filter(dataLabels, function(d) {
                    return d.isVisible;
                }), labelKeyFunction);
                labels.enter().append("text").classed(labelsClass["class"], !0).style("opacity", 0);
                var labelAttr = {
                    x: function(d) {
                        return d.boundingBox.left + d.boundingBox.width / 2;
                    },
                    y: function(d) {
                        return d.boundingBox.top + d.boundingBox.height;
                    },
                    dy: "-0.15em"
                };
                return numeric && (labelAttr.dy = void 0), labels.text(function(d) {
                    return d.text;
                }).style({
                    fill: function(d) {
                        return d.fill;
                    },
                    "font-size": function(d) {
                        return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt);
                    }
                }).transition().ease(easeType).duration(duration).attr(labelAttr).style("opacity", 1), 
                labels.exit().transition().duration(duration).style("opacity", 0).remove(), labels;
            }
            function drawLabelBackground(context, dataLabels, fill, fillOpacity) {
                var labelRects = context.selectAll("rect").data(_.filter(dataLabels, function(d) {
                    return d.isVisible;
                }), labelKeyFunction);
                return labelRects.enter().append("rect"), labelRects.attr({
                    x: function(d) {
                        return d.boundingBox.left - NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    y: function(d) {
                        return d.boundingBox.top - NewDataLabelUtils.verticalLabelBackgroundPadding;
                    },
                    rx: labelBackgroundRounding,
                    ry: labelBackgroundRounding,
                    width: function(d) {
                        return d.boundingBox.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    height: function(d) {
                        return void 0 === d.text && void 0 === d.secondRowText ? 0 : d.boundingBox.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding;
                    }
                }).style("fill", fill ? fill : "#000000").style("fill-opacity", null != fillOpacity ? fillOpacity : 1), 
                labelRects.exit().remove(), labelRects;
            }
            function drawLabelLeaderLines(context, filteredDataLabels, key, leaderLineColor) {
                context.select(linesGraphicsContextClass.selector).empty() && context.append("g").classed(linesGraphicsContextClass["class"], !0);
                var lines = context.select(linesGraphicsContextClass.selector).selectAll("polyline").data(filteredDataLabels, key);
                lines.enter().append("polyline").classed(lineClass["class"], !0), lines.attr("points", function(d) {
                    return d.leaderLinePoints;
                }).style({
                    stroke: function(d) {
                        return leaderLineColor ? leaderLineColor : d.fill;
                    },
                    "stroke-width": visuals.DonutLabelUtils.LineStrokeWidth
                }), lines.exit().remove();
            }
            function getLabelFormattedText(label, format, formatter) {
                return formatter ? formatter.format(label) : powerbi.formattingService.formatValue(label, format);
            }
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                return axisFormatter && axisFormatter.displayUnit && 0 === labelSettings.displayUnits ? axisFormatter.displayUnit.value : null;
            }
            function getLabelPrecision(precision, format) {
                if (precision !== defaultLabelPrecision) return precision;
                if (format) {
                    var positiveFormat = format.split(";")[0], formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, !0);
                    if (formatMetadata.hasDots) return formatMetadata.precision;
                }
                return defaultCountLabelPrecision;
            }
            function createColumnFormatterCacheManager() {
                return {
                    cache: {
                        defaultFormatter: null
                    },
                    getOrCreate: function(formatString, labelSetting, value2) {
                        if (formatString) {
                            var cacheKeyObject = {
                                formatString: formatString,
                                displayUnits: labelSetting.displayUnits,
                                precision: getLabelPrecision(labelSetting.precision, formatString),
                                value2: value2
                            }, cacheKey = JSON.stringify(cacheKeyObject);
                            return this.cache[cacheKey] || (this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision))), 
                            this.cache[cacheKey];
                        }
                        return this.cache.defaultFormatter || (this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision))), 
                        this.cache.defaultFormatter;
                    }
                };
            }
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: !0
                };
            }
            function removeDuplicates(labelDataPoints) {
                for (var uniqueLabelDataPoints = [], labelDataPointMap = {}, sameParentIsInArray = function(newValue, array, parentIsRect) {
                    return array.some(function(arrayValue) {
                        return parentIsRect ? visuals.shapes.Rect.equals(newValue.parentShape.rect, arrayValue.rect) : visuals.shapes.Point.equals(newValue.parentShape.point, arrayValue.point);
                    });
                }, _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                    var dataPoint = labelDataPoints_1[_i], parentIsRect = 1 === dataPoint.parentType, resultsFromMap = labelDataPointMap[dataPoint.text];
                    resultsFromMap ? sameParentIsInArray(dataPoint, resultsFromMap, parentIsRect) || (uniqueLabelDataPoints.push(dataPoint), 
                    resultsFromMap.push(dataPoint.parentShape)) : (uniqueLabelDataPoints.push(dataPoint), 
                    labelDataPointMap[dataPoint.text] = [ dataPoint.parentShape ]);
                }
                return uniqueLabelDataPoints;
            }
            function getDataLabelLayoutOptions(type) {
                switch (type) {
                  case 9:
                    return {
                        maximumOffset: visuals.ScatterChart.dataLabelLayoutMaximumOffset,
                        startingOffset: visuals.ScatterChart.dataLabelLayoutStartingOffset,
                        offsetIterationDelta: visuals.ScatterChart.dataLabelLayoutOffsetIterationDelta,
                        allowLeaderLines: !0,
                        attemptToMoveLabelsIntoViewport: !0
                    };

                  default:
                    return {
                        maximumOffset: NewDataLabelUtils.maxLabelOffset,
                        startingOffset: NewDataLabelUtils.startingLabelOffset,
                        attemptToMoveLabelsIntoViewport: !0
                    };
                }
            }
            function getTextSize(text, fontSize) {
                var labelTextProperties = NewDataLabelUtils.LabelTextProperties, properties = {
                    text: text,
                    fontFamily: labelTextProperties.fontFamily,
                    fontSize: jsCommon.PixelConverter.fromPoint(fontSize),
                    fontWeight: labelTextProperties.fontWeight
                };
                return {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties)
                };
            }
            function labelKeyFunction(label, index) {
                return label.key ? label.key : label.identity ? label.identity.getKeyWithoutHighlight() : index;
            }
            NewDataLabelUtils.DefaultLabelFontSizeInPt = 9, NewDataLabelUtils.MapPolylineOpacity = .5, 
            NewDataLabelUtils.LabelDensityBufferFactor = 3, NewDataLabelUtils.LabelDensityPadding = 6, 
            NewDataLabelUtils.LabelDensityMin = 0, NewDataLabelUtils.LabelDensityMax = 6, NewDataLabelUtils.startingLabelOffset = 8, 
            NewDataLabelUtils.maxLabelOffset = 8, NewDataLabelUtils.maxLabelWidth = 50, NewDataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %", 
            NewDataLabelUtils.LabelTextProperties = {
                fontFamily: "wf_standard-font",
                fontSize: PixelConverter.fromPoint(NewDataLabelUtils.DefaultLabelFontSizeInPt),
                fontWeight: "normal"
            }, NewDataLabelUtils.defaultLabelColor = "#777777", NewDataLabelUtils.defaultInsideLabelColor = "#ffffff", 
            NewDataLabelUtils.horizontalLabelBackgroundPadding = 4, NewDataLabelUtils.verticalLabelBackgroundPadding = 2;
            var labelBackgroundRounding = 4, defaultLabelPrecision = void 0, defaultCountLabelPrecision = 0;
            NewDataLabelUtils.labelGraphicsContextClass = createClassAndSelector("labelGraphicsContext"), 
            NewDataLabelUtils.labelBackgroundGraphicsContextClass = createClassAndSelector("labelBackgroundGraphicsContext");
            var labelsClass = createClassAndSelector("label"), secondLineLabelClass = createClassAndSelector("label-second-line"), linesGraphicsContextClass = createClassAndSelector("leader-lines"), lineClass = createClassAndSelector("line-label");
            NewDataLabelUtils.drawDefaultLabels = drawDefaultLabels, NewDataLabelUtils.animateDefaultLabels = animateDefaultLabels, 
            NewDataLabelUtils.drawLabelBackground = drawLabelBackground, NewDataLabelUtils.drawLabelLeaderLines = drawLabelLeaderLines, 
            NewDataLabelUtils.getLabelFormattedText = getLabelFormattedText, NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter, 
            NewDataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager, 
            NewDataLabelUtils.removeDuplicates = removeDuplicates, NewDataLabelUtils.getDataLabelLayoutOptions = getDataLabelLayoutOptions, 
            NewDataLabelUtils.getTextSize = getTextSize;
        }(NewDataLabelUtils = visuals.NewDataLabelUtils || (visuals.NewDataLabelUtils = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var KpiUtil;
        !function(KpiUtil) {
            function getKpiIcon(kpi, value) {
                var numValue = parseFloat(value);
                if (kpi) {
                    var statusGraphicFormat = statusGraphicFormatStrings[kpi.graphic.toUpperCase()];
                    if (statusGraphicFormat && !isNaN(numValue)) {
                        var statusValues = statusGraphicFormat.statusValues;
                        kpi.normalizedFiveStateKpiRange && 5 === statusValues.length && (numValue = 2 * numValue);
                        var num = numValue + Math.floor(statusValues.length / 2);
                        return [ statusGraphicFormat.kpiIconClass, statusValues[num] ].join(" ").trim();
                    }
                }
            }
            function getKpiIconClassName(kpiIcon, kpiImageSize) {
                return kpiIcon ? 1 === kpiImageSize ? [ KPIImageClassName, BigImageClassName, kpiIcon ].join(" ") : [ KPIImageClassName, kpiIcon ].join(" ") : void 0;
            }
            function getClassForKpi(kpi, value, kpiImageSize) {
                var kpiIcon = getKpiIcon(kpi, value);
                return getKpiIconClassName(kpiIcon, kpiImageSize);
            }
            function getKpiImageMetadata(metaDataColumn, value, kpiImageSize) {
                var kpi = metaDataColumn && metaDataColumn.kpi;
                if (kpi) {
                    var kpiIcon = getKpiIcon(kpi, value);
                    if (kpiIcon) return {
                        caption: kpiIcon,
                        statusGraphic: kpi.graphic,
                        "class": getKpiIconClassName(kpiIcon, kpiImageSize)
                    };
                }
            }
            var KPIImageClassName = "powervisuals-glyph", BigImageClassName = "big-kpi", RYGStatusIconClassNames = [ "kpi-red", "kpi-yellow", "kpi-green" ], threeLights = {
                kpiIconClass: "circle",
                statusValues: RYGStatusIconClassNames
            }, roadSigns = {
                kpiIconClass: "",
                statusValues: [ "circle-x kpi-red", "circle-exclamation kpi-yellow", "circle-checkmark kpi-green" ]
            }, trafficLight = {
                kpiIconClass: "traffic-light",
                statusValues: RYGStatusIconClassNames
            }, shapes = {
                kpiIconClass: "",
                statusValues: [ "rhombus kpi-red", "triangle kpi-yellow", "circle kpi-green" ]
            }, gauge = {
                kpiIconClass: "",
                statusValues: [ "circle-empty", "circle-one-quarter", "circle-half", "circle-three-quarters", "circle-full" ]
            }, statusGraphicFormatStrings = {
                "THREE CIRCLES COLORED": threeLights,
                "TRAFFIC LIGHT - SINGLE": threeLights,
                "THREE FLAGS COLORED": {
                    kpiIconClass: "flag",
                    statusValues: RYGStatusIconClassNames
                },
                "ROAD SIGNS": roadSigns,
                "THREE SYMBOLS CIRCLED COLORED": roadSigns,
                "TRAFFIC LIGHT": trafficLight,
                "THREE TRAFFIC LIGHTS RIMMED COLORED": trafficLight,
                "THREE SYMBOLS UNCIRCLED COLORED": {
                    kpiIconClass: "",
                    statusValues: [ "x kpi-red", "exclamation kpi-yellow", "checkmark kpi-green" ]
                },
                SHAPES: shapes,
                "SMILEY FACE": shapes,
                THERMOMETER: shapes,
                CYLINDER: shapes,
                "THREE SIGNS COLORED": shapes,
                "THREE STARS COLORED": {
                    kpiIconClass: "star-stacked",
                    statusValues: [ "star-empty", "star-half-full", "star-full" ]
                },
                "FIVE BARS COLORED": {
                    kpiIconClass: "bars-stacked",
                    statusValues: [ "bars-zero", "bars-one", "bars-two", "bars-three", "bars-four" ]
                },
                "FIVE BOXES COLORED": {
                    kpiIconClass: "boxes-stacked",
                    statusValues: [ "boxes-zero", "boxes-one", "boxes-two", "boxes-three", "boxes-four" ]
                },
                "FIVE QUARTERS COLORED": gauge,
                "GAUGE - ASCENDING": gauge,
                "GAUGE - DESCENDING": {
                    kpiIconClass: "",
                    statusValues: [ "circle-full", "circle-three-quarters", "circle-half", "circle-one-quarter", "circle-empty" ]
                },
                "STANDARD ARROW": {
                    kpiIconClass: "",
                    statusValues: [ "arrow-down", "arrow-right-down", "arrow-right", "arrow-right-up", "arrow-up" ]
                },
                "VARIANCE ARROW": {
                    kpiIconClass: "",
                    statusValues: [ "arrow-down kpi-red", "arrow-right kpi-yellow", "arrow-up kpi-green" ]
                },
                "STATUS ARROW - ASCENDING": {
                    kpiIconClass: "",
                    statusValues: [ "arrow-down kpi-red", "arrow-right-down kpi-yellow", "arrow-right kpi-yellow", "arrow-right-up kpi-yellow", "arrow-up kpi-green" ]
                },
                "STATUS ARROW - DESCENDING": {
                    kpiIconClass: "",
                    statusValues: [ "arrow-up kpi-green", "arrow-right-up kpi-yellow", "arrow-right kpi-yellow", "arrow-right-down kpi-yellow", "arrow-down kpi-red" ]
                }
            };
            KpiUtil.getClassForKpi = getClassForKpi, KpiUtil.getKpiImageMetadata = getKpiImageMetadata;
        }(KpiUtil = visuals.KpiUtil || (visuals.KpiUtil = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var ReferenceLineHelper;
        !function(ReferenceLineHelper) {
            function enumerateObjectInstances(enumeration, referenceLines, defaultColor, objectName) {
                if (_.isEmpty(referenceLines)) {
                    var instance = {
                        selector: {
                            id: "0"
                        },
                        properties: {
                            show: !1,
                            value: "",
                            lineColor: {
                                solid: {
                                    color: defaultColor
                                }
                            },
                            transparency: 50,
                            style: visuals.lineStyle.dashed,
                            position: visuals.referenceLinePosition.back,
                            dataLabelShow: !1
                        },
                        objectName: objectName
                    };
                    return void enumeration.pushInstance(instance);
                }
                for (var _i = 0, referenceLines_1 = referenceLines; _i < referenceLines_1.length; _i++) {
                    var referenceLine = referenceLines_1[_i], referenceLineProperties = referenceLine.object, show = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, !1), value = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value), lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, {
                        solid: {
                            color: defaultColor
                        }
                    }), transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency, 50), style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed), position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back), dataLabelShow = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelShow, !1), instance = {
                        selector: {
                            id: referenceLine.id
                        },
                        properties: {
                            show: show,
                            value: value,
                            lineColor: lineColor,
                            transparency: transparency,
                            style: style,
                            position: position,
                            dataLabelShow: dataLabelShow
                        },
                        objectName: objectName
                    };
                    if (dataLabelShow) {
                        var dataLabelColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, {
                            solid: {
                                color: defaultColor
                            }
                        }), dataLabelHorizontalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition, visuals.referenceLineDataLabelHorizontalPosition.left), dataLabelVerticalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition, visuals.referenceLineDataLabelVerticalPosition.above), dataLabelDecimalPoints = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, void 0) < 0 ? void 0 : powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, void 0), dataLabelDisplayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelColor] = dataLabelColor, 
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] = dataLabelHorizontalPosition, 
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] = dataLabelVerticalPosition, 
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] = dataLabelDecimalPoints, 
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits] = dataLabelDisplayUnits;
                    }
                    enumeration.pushInstance(instance);
                }
            }
            function render(options) {
                var graphicContext = options.graphicContext, axes = options.axes, referenceLineProperties = options.referenceLineProperties, isHorizontal = options.isHorizontal, viewport = options.viewport, classAndSelector = options.classAndSelector, xScale = axes.x.scale, yScale = axes.y1.scale, refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0), lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, {
                    solid: {
                        color: options.defaultColor
                    }
                }), transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency), style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed), position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back), refLine = graphicContext.select(classAndSelector.selector), index = $(refLine[0]).index(), currentPosition = index > 1 ? visuals.referenceLinePosition.front : visuals.referenceLinePosition.back, isRefLineExists = -1 !== index, isPositionChanged = currentPosition !== position;
                isRefLineExists && isPositionChanged && refLine.remove(), isRefLineExists && !isPositionChanged || (refLine = position === visuals.referenceLinePosition.back ? graphicContext.insert("line", ":first-child") : graphicContext.append("line"));
                var refLineX1 = isHorizontal ? 0 : xScale(refValue), refLineY1 = isHorizontal ? yScale(refValue) : 0, refLineX2 = isHorizontal ? viewport.width : xScale(refValue), refLineY2 = isHorizontal ? yScale(refValue) : viewport.height;
                refLine.attr({
                    "class": classAndSelector["class"],
                    x1: refLineX1,
                    y1: refLineY1,
                    x2: refLineX2,
                    y2: refLineY2
                }).style({
                    stroke: lineColor.solid.color
                }), null != transparency && refLine.style("stroke-opacity", (100 - transparency) / 100), 
                style === visuals.lineStyle.dashed ? refLine.style("stroke-dasharray", "5, 5") : style === visuals.lineStyle.dotted ? refLine.style({
                    "stroke-dasharray": "1, 5",
                    "stroke-linecap": "round"
                }) : style === visuals.lineStyle.solid && refLine.style({
                    "stroke-dasharray": null,
                    "stroke-linecap": null
                });
            }
            function createLabelDataPoint(options) {
                var offsetRefLine = 5, axes = options.axes, referenceLineProperties = options.referenceLineProperties, isHorizontal = options.isHorizontal, viewport = options.viewport, xScale = axes.x.scale, yScale = axes.y1.scale, refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0), color = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, {
                    solid: {
                        color: options.defaultColor
                    }
                }), decimalPoints = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] < 0 ? void 0 : referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints], horizontalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] || visuals.referenceLineDataLabelHorizontalPosition.left, verticalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] || visuals.referenceLineDataLabelVerticalPosition.above, displayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0), axisFormatter = isHorizontal ? axes.y1.formatter : axes.x.formatter, formatterForReferenceLineDataLabel = axisFormatter;
                if (null != axisFormatter.options) {
                    var formatterOptions = powerbi.Prototype.inherit(axisFormatter.options);
                    formatterOptions.precision = decimalPoints, formatterOptions.value = displayUnits, 
                    formatterForReferenceLineDataLabel = visuals.valueFormatter.create(formatterOptions);
                }
                var dataLabelX, dataLabelY, text = visuals.NewDataLabelUtils.getLabelFormattedText(formatterForReferenceLineDataLabel.format(refValue)), properties = {
                    text: text,
                    fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight
                }, rectWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), rectHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties), x1 = isHorizontal ? 0 : xScale(refValue), y1 = isHorizontal ? yScale(refValue) : 0, x2 = isHorizontal ? viewport.width : xScale(refValue), y2 = isHorizontal ? yScale(refValue) : viewport.height, validPositions = [ 1 ];
                isHorizontal ? (dataLabelX = horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left ? x1 + offsetRefLine : x2 - rectWidth / 2 - offsetRefLine, 
                dataLabelY = y1, validPositions = verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above ? [ 1 ] : [ 2 ]) : (dataLabelX = x1, 
                dataLabelY = verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above ? y1 + rectHeight / 2 + offsetRefLine : y2 - rectHeight / 2 - offsetRefLine, 
                validPositions = horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left ? [ 4 ] : [ 8 ]);
                var parentShape, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                return parentShape = {
                    point: {
                        x: dataLabelX,
                        y: dataLabelY
                    },
                    radius: 0,
                    validPositions: validPositions
                }, {
                    isPreferred: !0,
                    text: text,
                    textSize: {
                        width: textWidth,
                        height: textHeight
                    },
                    outsideFill: color.solid.color,
                    insideFill: null,
                    parentShape: parentShape,
                    parentType: 0,
                    fontSize: 9,
                    identity: null,
                    secondRowText: null,
                    key: options.key
                };
            }
            function extractReferenceLineValue(referenceLineProperties) {
                var referenceLineValue = null;
                return referenceLineProperties && powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, !1) && (referenceLineValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, null)), 
                referenceLineValue;
            }
            ReferenceLineHelper.referenceLineProps = {
                show: "show",
                lineColor: "lineColor",
                transparency: "transparency",
                value: "value",
                style: "style",
                position: "position",
                dataLabelShow: "dataLabelShow",
                dataLabelColor: "dataLabelColor",
                dataLabelDecimalPoints: "dataLabelDecimalPoints",
                dataLabelHorizontalPosition: "dataLabelHorizontalPosition",
                dataLabelVerticalPosition: "dataLabelVerticalPosition",
                dataLabelDisplayUnits: "dataLabelDisplayUnits"
            }, ReferenceLineHelper.enumerateObjectInstances = enumerateObjectInstances, ReferenceLineHelper.render = render, 
            ReferenceLineHelper.createLabelDataPoint = createLabelDataPoint, ReferenceLineHelper.extractReferenceLineValue = extractReferenceLineValue;
        }(ReferenceLineHelper = visuals.ReferenceLineHelper || (visuals.ReferenceLineHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var InteractivityUtils;
        !function(InteractivityUtils) {
            function getPositionOfLastInputEvent() {
                return {
                    x: d3.event.clientX,
                    y: d3.event.clientY
                };
            }
            function registerStandardInteractivityHandlers(selection, selectionHandler) {
                registerStandardSelectionHandler(selection, selectionHandler), registerStandardContextMenuHandler(selection, selectionHandler);
            }
            function registerStandardSelectionHandler(selection, selectionHandler) {
                selection.on("click", function(d) {
                    return handleSelection(d, selectionHandler);
                });
            }
            function registerStandardContextMenuHandler(selection, selectionHandler) {
                selection.on("contextmenu", function(d) {
                    return handleContextMenu(d, selectionHandler);
                });
            }
            function registerGroupInteractivityHandlers(group, selectionHandler) {
                registerGroupSelectionHandler(group, selectionHandler), registerGroupContextMenuHandler(group, selectionHandler);
            }
            function registerGroupSelectionHandler(group, selectionHandler) {
                group.on("click", function() {
                    var target = d3.event.target, d = d3.select(target).datum();
                    handleSelection(d, selectionHandler);
                });
            }
            function registerGroupContextMenuHandler(group, selectionHandler) {
                group.on("contextmenu", function() {
                    var target = d3.event.target, d = d3.select(target).datum();
                    handleContextMenu(d, selectionHandler);
                });
            }
            function handleContextMenu(d, selectionHandler) {
                if (!d3.event.ctrlKey) {
                    d3.event.preventDefault();
                    var position = InteractivityUtils.getPositionOfLastInputEvent();
                    selectionHandler.handleContextMenu(d, position);
                }
            }
            function handleSelection(d, selectionHandler) {
                selectionHandler.handleSelection(d, d3.event.ctrlKey);
            }
            InteractivityUtils.getPositionOfLastInputEvent = getPositionOfLastInputEvent, InteractivityUtils.registerStandardInteractivityHandlers = registerStandardInteractivityHandlers, 
            InteractivityUtils.registerStandardSelectionHandler = registerStandardSelectionHandler, 
            InteractivityUtils.registerStandardContextMenuHandler = registerStandardContextMenuHandler, 
            InteractivityUtils.registerGroupInteractivityHandlers = registerGroupInteractivityHandlers, 
            InteractivityUtils.registerGroupSelectionHandler = registerGroupSelectionHandler, 
            InteractivityUtils.registerGroupContextMenuHandler = registerGroupContextMenuHandler;
        }(InteractivityUtils = visuals.InteractivityUtils || (visuals.InteractivityUtils = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
            var checker = new InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity);
            return checker.getWarningMessages(dataViews);
        }
        visuals.getInvalidValueWarnings = getInvalidValueWarnings;
        var InvalidDataValuesChecker = function() {
            function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
                this.supportsNaN = supportsNaN, this.supportsNegativeInfinity = supportsNegativeInfinity, 
                this.supportsPositiveInfinity = supportsPositiveInfinity;
            }
            return InvalidDataValuesChecker.prototype.getWarningMessages = function(dataViews) {
                this.loadWarningStatus(dataViews);
                var warnings = [];
                return this.hasNaN && !this.supportsNaN && warnings.push(new visuals.NaNNotSupportedWarning()), 
                (this.hasNegativeInfinity && !this.supportsNegativeInfinity || this.hasPositiveInfinity && !this.supportsPositiveInfinity) && warnings.push(new visuals.InfinityValuesNotSupportedWarning()), 
                this.hasOutOfRange && warnings.push(new visuals.ValuesOutOfRangeWarning()), warnings;
            }, InvalidDataValuesChecker.prototype.loadWarningStatus = function(dataViews) {
                this.hasNaN = !1, this.hasNegativeInfinity = !1, this.hasOutOfRange = !1, this.hasPositiveInfinity = !1;
                for (var k = 0; k < dataViews.length; k++) {
                    var dataView = dataViews[k], values = dataView && dataView.categorical && dataView.categorical.values ? dataView.categorical.values : null;
                    if (!values) return;
                    for (var valueLength = values.length, i = 0; valueLength > i; i++) {
                        var value = values[i];
                        if (value.values) for (var valueValueLength = value.values.length, j = 0; valueValueLength > j; j++) {
                            var v = value.values[j];
                            isNaN(v) ? this.hasNaN = !0 : v === Number.POSITIVE_INFINITY ? this.hasPositiveInfinity = !0 : v === Number.NEGATIVE_INFINITY ? this.hasNegativeInfinity = !0 : (-1e300 > v || v > 1e300) && (this.hasOutOfRange = !0);
                        }
                    }
                }
            }, InvalidDataValuesChecker;
        }();
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var ListViewFactory;
        !function(ListViewFactory) {
            function createListView(options) {
                return new ListView(options);
            }
            ListViewFactory.createListView = createListView;
        }(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
        var ListView = function() {
            function ListView(options) {
                var _this = this;
                this.options = $.extend(!0, {}, options), this.scrollbarInner = options.baseContainer.append("div").classed("scrollbar-inner", !0).on("scroll", function() {
                    return _this.renderImpl(_this.options.rowHeight);
                }), this.scrollContainer = this.scrollbarInner.append("div").classed("scrollRegion", !0).on("touchstart", function() {
                    return _this.stopTouchProp();
                }).on("touchmove", function() {
                    return _this.stopTouchProp();
                }), this.visibleGroupContainer = this.scrollContainer.append("div").classed("visibleGroup", !0), 
                $(options.baseContainer.node()).find(".scroll-element").attr("drag-resize-disabled", "true"), 
                ListView.SetDefaultOptions(options);
            }
            return ListView.SetDefaultOptions = function(options) {
                options.rowHeight = options.rowHeight || ListView.defaultRowHeight;
            }, ListView.prototype.rowHeight = function(rowHeight) {
                return this.options.rowHeight = Math.ceil(rowHeight), this;
            }, ListView.prototype.data = function(data, getDatumIndex, dataReset) {
                return void 0 === dataReset && (dataReset = !1), this._data = data, this.getDatumIndex = getDatumIndex, 
                this.setTotalRows(), dataReset && $(this.scrollbarInner.node()).scrollTop(0), this.render(), 
                this;
            }, ListView.prototype.viewport = function(viewport) {
                return this.options.viewport = viewport, this.render(), this;
            }, ListView.prototype.empty = function() {
                this._data = [], this.render();
            }, ListView.prototype.render = function() {
                var _this = this;
                this.renderTimeoutId && window.clearTimeout(this.renderTimeoutId), this.renderTimeoutId = window.setTimeout(function() {
                    _this.getRowHeight().then(function(rowHeight) {
                        _this.renderImpl(rowHeight);
                    }), _this.renderTimeoutId = void 0;
                }, 0);
            }, ListView.prototype.renderImpl = function(rowHeight) {
                var totalHeight = this.options.scrollEnabled ? Math.max(0, this._totalRows * rowHeight) : this.options.viewport.height;
                this.scrollContainer.style("height", totalHeight + "px").attr("height", totalHeight), 
                this.scrollToFrame(!0);
            }, ListView.prototype.stopTouchProp = function() {
                if (this.options.isReadMode()) {
                    if ("touchstart" === d3.event.type) {
                        var event = d3.event;
                        event.touches && 1 === event.touches.length && d3.event.stopPropagation();
                    }
                    "touchmove" === d3.event.type && d3.event.stopPropagation();
                }
            }, ListView.prototype.scrollToFrame = function(loadMoreData) {
                var options = this.options, visibleGroupContainer = this.visibleGroupContainer, totalRows = this._totalRows, rowHeight = options.rowHeight || ListView.defaultRowHeight, visibleRows = this.getVisibleRows() || 1, scrollTop = this.scrollbarInner.node().scrollTop, scrollPosition = 0 === scrollTop ? 0 : Math.floor(scrollTop / rowHeight), transformAttr = visuals.SVGUtil.translateWithPixels(0, scrollPosition * rowHeight);
                visibleGroupContainer.style({
                    transform: function(d) {
                        return transformAttr;
                    },
                    "-webkit-transform": transformAttr
                });
                var position0 = Math.max(0, Math.min(scrollPosition, totalRows - visibleRows + 1)), position1 = position0 + visibleRows, rowSelection = visibleGroupContainer.selectAll(".row").data(this._data.slice(position0, Math.min(position1, totalRows)), this.getDatumIndex);
                rowSelection.enter().append("div").classed("row", !0).call(function(d) {
                    return options.enter(d);
                }), rowSelection.order();
                var rowUpdateSelection = visibleGroupContainer.selectAll(".row:not(.transitioning)");
                rowUpdateSelection.call(function(d) {
                    return options.update(d);
                }), rowSelection.exit().call(function(d) {
                    return options.exit(d);
                }).remove(), loadMoreData && visibleRows !== totalRows && position1 >= totalRows * ListView.loadMoreDataThreshold && options.loadMoreData();
            }, ListView.prototype.setTotalRows = function() {
                var data = this._data;
                this._totalRows = data ? data.length : 0;
            }, ListView.prototype.getVisibleRows = function() {
                var minimumVisibleRows = 1, rowHeight = this.options.rowHeight, viewportHeight = this.options.viewport.height;
                return !rowHeight || 1 > rowHeight ? minimumVisibleRows : this.options.scrollEnabled ? Math.min(Math.ceil(viewportHeight / rowHeight), this._totalRows) || minimumVisibleRows : Math.min(Math.floor(viewportHeight / rowHeight), this._totalRows) || minimumVisibleRows;
            }, ListView.prototype.getRowHeight = function() {
                var deferred = $.Deferred(), listView = this, options = listView.options;
                if (this.cancelMeasurePass && this.cancelMeasurePass(), !(this._data && this._data.length && options)) return listView.rowHeight(ListView.defaultRowHeight), 
                deferred.resolve(options.rowHeight).promise();
                this.scrollToFrame(!1);
                var requestAnimationFrameId = window.requestAnimationFrame(function() {
                    var rows = listView.visibleGroupContainer.select(".row");
                    if (rows.length > 0) {
                        var firstRow = rows.node().firstChild, rowHeight = $(firstRow).outerHeight(!0);
                        listView.rowHeight(rowHeight), deferred.resolve(rowHeight);
                    }
                    listView.cancelMeasurePass = void 0, window.cancelAnimationFrame(requestAnimationFrameId);
                });
                return this.cancelMeasurePass = function() {
                    window.cancelAnimationFrame(requestAnimationFrameId), deferred.reject();
                }, deferred.promise();
            }, ListView.loadMoreDataThreshold = .8, ListView.defaultRowHeight = 1, ListView;
        }();
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var MapUtil, defaultLevelOfDetail = 11;
        !function(MapUtil) {
            function clip(n, minValue, maxValue) {
                return Math.min(Math.max(n, minValue), maxValue);
            }
            function getMapSize(levelOfDetail) {
                return 23 === levelOfDetail ? 2147483648 : Math.floor(levelOfDetail) === levelOfDetail ? 256 << levelOfDetail : 256 * Math.pow(2, levelOfDetail);
            }
            function latLongToPixelXYArray(latLongArray, levelOfDetail) {
                for (var result = new Float64Array(latLongArray.length), i = 0; i < latLongArray.length; i += 2) {
                    var latitude = clip(latLongArray[i], MapUtil.MinAllowedLatitude, MapUtil.MaxAllowedLatitude), longitude = clip(latLongArray[i + 1], MapUtil.MinAllowedLongitude, MapUtil.MaxAllowedLongitude), x = (longitude + 180) / 360, sinLatitude = Math.sin(latitude * Math.PI / 180), y = .5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI), mapSize = getMapSize(levelOfDetail);
                    result[i] = clip(x * mapSize + .5, 0, mapSize - 1), result[i + 1] = clip(y * mapSize + .5, 0, mapSize - 1);
                }
                return result;
            }
            function pointArrayToString(array) {
                var maxLength = 8e4;
                if (array.length > maxLength) {
                    for (var result = "", i = 0; i < array.length; i += maxLength) {
                        var array1 = Array.apply([], array.subarray(i, i + maxLength));
                        result += array1.join(" ") + " ";
                    }
                    return result;
                }
                return Array.apply([], array).join(" ");
            }
            function pointArrayToArray(array) {
                var maxLength = 8e4, result = [];
                if (array.length > maxLength) {
                    for (var i = 0; i < array.length; i += maxLength) {
                        var array1 = Array.apply([], array.subarray(i, i + maxLength));
                        result.concat(array1);
                    }
                    return result;
                }
                return Array.apply([], array);
            }
            function getLocationBoundaries(latLongArray) {
                for (var northWest = {
                    latitude: -90,
                    longitude: 180
                }, southEast = {
                    latitude: 90,
                    longitude: -180
                }, i = 0; i < latLongArray.length; i += 2) northWest.latitude = Math.max(latLongArray[i], northWest.latitude), 
                northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude), southEast.latitude = Math.min(latLongArray[i], southEast.latitude), 
                southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
                return northWest.longitude = clip(northWest.longitude, -180, 180), southEast.longitude = clip(southEast.longitude, -180, 180), 
                Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
            }
            function parseEncodedSpatialValueArray(value) {
                for (var list = [], index = 0, xsum = 0, ysum = 0, max = 4294967296; index < value.length; ) {
                    for (var n = 0, k = 0; ;) {
                        if (index >= value.length) return null;
                        var b = safeCharacters.indexOf(value.charAt(index++));
                        if (-1 === b) return null;
                        var tmp = (31 & b) * Math.pow(2, k), ht = tmp / max, lt = tmp % max, hn = n / max, ln = n % max, nl = (lt | ln) >>> 0;
                        if (n = (ht | hn) * max + nl, k += 5, 32 > b) break;
                    }
                    var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
                    n -= diagonal * (diagonal + 1) / 2;
                    var ny = Math.floor(n), nx = diagonal - ny;
                    nx = nx >> 1 ^ -(1 & nx), ny = ny >> 1 ^ -(1 & ny), xsum += nx, ysum += ny;
                    var lat = 1e-5 * ysum, lon = 1e-5 * xsum;
                    list.push(lat), list.push(lon);
                }
                return new Float64Array(list);
            }
            function calcGeoData(data) {
                for (var locations = data.locations, i = 0; i < locations.length; i++) {
                    var location_1 = locations[i];
                    location_1.geographic || (location_1.geographic = MapUtil.parseEncodedSpatialValueArray(location_1.nativeBing));
                    var polygon = location_1.geographic;
                    if (polygon && !location_1.absolute) {
                        location_1.absolute = MapUtil.latLongToPixelXYArray(polygon, MapUtil.DefaultLevelOfDetail), 
                        location_1.absoluteString = MapUtil.pointArrayToString(location_1.absolute);
                        var geographicBounds = MapUtil.getLocationBoundaries(polygon);
                        location_1.absoluteBounds = MapUtil.locationRectToRectXY(geographicBounds, MapUtil.DefaultLevelOfDetail);
                    }
                }
            }
            function locationToPixelXY(location, levelOfDetail) {
                return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
            }
            function locationRectToRectXY(locationRect, levelOfDetail) {
                var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail), bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
                return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
            }
            function latLongToPixelXY(latitude, longitude, levelOfDetail) {
                var array = latLongToPixelXYArray(new Float64Array([ latitude, longitude ]), levelOfDetail);
                return new powerbi.visuals.Point(array[0], array[1]);
            }
            function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
                var mapSize = getMapSize(levelOfDetail), x = clip(pixelX, 0, mapSize - 1) / mapSize - .5, y = .5 - clip(pixelY, 0, mapSize - 1) / mapSize, latitude = 90 - 360 * Math.atan(Math.exp(2 * -y * Math.PI)) / Math.PI, longitude = 360 * x;
                return new Microsoft.Maps.Location(latitude, longitude);
            }
            MapUtil.Settings = {
                MaxBingRequest: 6,
                MaxCacheSize: 3e3,
                MaxCacheSizeOverflow: 100,
                BingKey: "insert your key",
                BingUrl: "https://dev.virtualearth.net/REST/v1/Locations?",
                BingUrlGeodata: "https://platform.bing.com/geo/spatial/v1/public/Geodata?",
                UseDoubleArrayGeodataResult: !0,
                UseDoubleArrayDequeueTimeout: 0
            }, MapUtil.MinAllowedLatitude = -85.05112878, MapUtil.MaxAllowedLatitude = 85.05112878, 
            MapUtil.MinAllowedLongitude = -180, MapUtil.MaxAllowedLongitude = 180, MapUtil.TileSize = 256, 
            MapUtil.MaxLevelOfDetail = 23, MapUtil.MinLevelOfDetail = 1, MapUtil.MaxAutoZoomLevel = 5, 
            MapUtil.DefaultLevelOfDetail = 11, MapUtil.WorkerErrorName = "___error___", MapUtil.CategoryTypes = {
                Address: "Address",
                City: "City",
                Continent: "Continent",
                CountryRegion: "Country",
                County: "County",
                Longitude: "Longitude",
                Latitude: "Latitude",
                Place: "Place",
                PostalCode: "PostalCode",
                StateOrProvince: "StateOrProvince"
            };
            var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
            MapUtil.clip = clip, MapUtil.getMapSize = getMapSize, MapUtil.latLongToPixelXYArray = latLongToPixelXYArray, 
            MapUtil.pointArrayToString = pointArrayToString, MapUtil.pointArrayToArray = pointArrayToArray, 
            MapUtil.getLocationBoundaries = getLocationBoundaries, MapUtil.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray, 
            MapUtil.calcGeoData = calcGeoData, MapUtil.locationToPixelXY = locationToPixelXY, 
            MapUtil.locationRectToRectXY = locationRectToRectXY, MapUtil.latLongToPixelXY = latLongToPixelXY, 
            MapUtil.pixelXYToLocation = pixelXYToLocation;
            var CurrentLocation;
            !function(CurrentLocation) {
                function createPushpin(location) {
                    var template = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle fill="#FF5F00" cx="12" cy="12" r="6"/><circle fill="none" stroke="#FF5F00" stroke-width="2" cx="12" cy="12" r="10"/></svg>', options = {
                        draggable: !1,
                        htmlContent: template,
                        height: 24,
                        width: 24
                    };
                    return new Microsoft.Maps.Pushpin(location, options);
                }
                CurrentLocation.createPushpin = createPushpin;
            }(CurrentLocation = MapUtil.CurrentLocation || (MapUtil.CurrentLocation = {}));
        }(MapUtil = visuals.MapUtil || (visuals.MapUtil = {}));
        var MapPolygonInfo = function() {
            function MapPolygonInfo() {
                this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
            }
            return MapPolygonInfo.prototype.reCalc = function(mapControl, width, height) {
                var baseLocations = [ this._locationRect.getNorthwest(), this._locationRect.getSoutheast() ];
                if (width /= 2, height /= 2, !this._baseRect) {
                    var l0 = MapUtil.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail), l1 = MapUtil.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
                    this._baseRect = new visuals.Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
                }
                var l = mapControl.tryLocationToPixel(baseLocations);
                this._currentRect = new visuals.Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
            }, Object.defineProperty(MapPolygonInfo.prototype, "scale", {
                get: function() {
                    return this._baseRect ? this._currentRect.width / this._baseRect.width : 1;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MapPolygonInfo.prototype, "transform", {
                get: function() {
                    var base = this._baseRect, current = this._currentRect, transform = new visuals.Transform();
                    return transform.translate(current.left, current.top), transform.scale(current.width / base.width, current.height / base.height), 
                    transform.translate(-base.left, -base.top), transform;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
                get: function() {
                    var base = this._baseRect, current = this._currentRect, transform = new visuals.Transform();
                    transform.translate(current.left, current.top);
                    var scale = Math.sqrt(current.width / base.width);
                    return transform.scale(scale, scale), transform;
                },
                enumerable: !0,
                configurable: !0
            }), MapPolygonInfo.prototype.setViewBox = function(svg) {
                var rect = svg.getBoundingClientRect(), current = this._currentRect;
                svg.setAttribute("viewBox", [ -current.left, -current.top, rect.width, rect.height ].join(" "));
            }, Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
                get: function() {
                    var base = this._baseRect, current = this._currentRect, transform = new visuals.Transform(), scale = current.width / base.width;
                    return transform.scale(scale, scale), transform.translate(-base.left, -base.top), 
                    transform;
                },
                enumerable: !0,
                configurable: !0
            }), MapPolygonInfo.prototype.transformToString = function(transform) {
                var m = transform.matrix;
                return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
            }, MapPolygonInfo;
        }();
        visuals.MapPolygonInfo = MapPolygonInfo;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var utility;
        !function(utility) {
            var SelectionManager = function() {
                function SelectionManager(options) {
                    this.hostServices = options.hostServices, this.selectedIds = [];
                }
                return SelectionManager.prototype.select = function(selectionId, multiSelect) {
                    void 0 === multiSelect && (multiSelect = !1);
                    var defered = $.Deferred();
                    return this.hostServices.shouldRetainSelection() ? this.sendSelectionToHost([ selectionId ]) : (this.selectInternal(selectionId, multiSelect), 
                    this.sendSelectionToHost(this.selectedIds)), defered.resolve(this.selectedIds), 
                    defered;
                }, SelectionManager.prototype.hasSelection = function() {
                    return this.selectedIds.length > 0;
                }, SelectionManager.prototype.clear = function() {
                    var defered = $.Deferred();
                    return this.selectedIds = [], this.sendSelectionToHost([]), defered.resolve(), defered;
                }, SelectionManager.prototype.getSelectionIds = function() {
                    return this.selectedIds;
                }, SelectionManager.prototype.sendSelectionToHost = function(ids) {
                    var selectArgs = {
                        data: ids.filter(function(value) {
                            return value.hasIdentity();
                        }).map(function(value) {
                            return value.getSelector();
                        })
                    }, data2 = ids.filter(function(value) {
                        return value.getSelectorsByColumn() && value.hasIdentity();
                    }).map(function(value) {
                        return value.getSelectorsByColumn();
                    });
                    data2 && data2.length > 0 && (selectArgs.data2 = data2), this.hostServices.onSelect(selectArgs);
                }, SelectionManager.prototype.selectInternal = function(selectionId, multiSelect) {
                    SelectionManager.containsSelection(this.selectedIds, selectionId) ? this.selectedIds = multiSelect ? this.selectedIds.filter(function(d) {
                        return !powerbi.data.Selector.equals(d, selectionId);
                    }) : this.selectedIds.length > 1 ? [ selectionId ] : [] : multiSelect ? this.selectedIds.push(selectionId) : this.selectedIds = [ selectionId ];
                }, SelectionManager.containsSelection = function(list, id) {
                    return list.some(function(d) {
                        return powerbi.data.Selector.equals(d.getSelector(), id.getSelector());
                    });
                }, SelectionManager;
            }();
            utility.SelectionManager = SelectionManager;
        }(utility = visuals.utility || (visuals.utility = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        "use strict";
        var shapes;
        !function(shapes) {
            var Utility = jsCommon.Utility, Polygon = function() {
                function Polygon(absolutePoints) {
                    this.polygonPoints = this.convertArrayPathToPoints(absolutePoints);
                }
                return Polygon.prototype.absoluteCentroid = function() {
                    return null == this._absoluteCentroid && (this._absoluteCentroid = this.calculatePolygonCentroid()), 
                    this._absoluteCentroid;
                }, Polygon.prototype.absoluteBoundingRect = function() {
                    return null == this._absoluteBoundingRect && (this._absoluteBoundingRect = this.calculateBoundingRect()), 
                    this._absoluteBoundingRect;
                }, Polygon.prototype.contains = function(rect) {
                    var topLeft = {
                        x: rect.left,
                        y: rect.top
                    }, topRight = {
                        x: rect.left + rect.width,
                        y: rect.top
                    }, bottomLeft = {
                        x: rect.left,
                        y: rect.top + rect.height
                    }, bottomRight = {
                        x: rect.left + rect.width,
                        y: rect.top + rect.height
                    };
                    return this.inside(topLeft) && this.inside(topRight) && this.inside(bottomLeft) && this.inside(bottomRight);
                }, Polygon.prototype.conflicts = function(rect) {
                    if (!this.isConflictWithBoundingBox(rect)) return !1;
                    var topLeft = {
                        x: rect.left,
                        y: rect.top
                    }, topCenter = {
                        x: rect.left + rect.width / 2,
                        y: rect.top
                    }, topRight = {
                        x: rect.left + rect.width,
                        y: rect.top
                    }, bottomLeft = {
                        x: rect.left,
                        y: rect.top + rect.height
                    }, bottomCenter = {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height
                    }, bottomRight = {
                        x: rect.left + rect.width,
                        y: rect.top + rect.height
                    }, middleLeft = {
                        x: rect.left,
                        y: rect.top + rect.height / 2
                    }, middleRight = {
                        x: rect.left + rect.width,
                        y: rect.top + rect.height / 2
                    };
                    return this.inside(topLeft) || this.inside(topCenter) || this.inside(topRight) || this.inside(bottomLeft) || this.inside(bottomCenter) || this.inside(bottomRight) || this.inside(middleLeft) || this.inside(middleRight);
                }, Polygon.prototype.lineIntersectionPoint = function(p0, p1) {
                    for (var i = 0; i < this.polygonPoints.length; i++) {
                        var p2 = this.polygonPoints[i], p3 = i === this.polygonPoints.length - 1 ? this.polygonPoints[0] : this.polygonPoints[i + 1], intersection = this.getLineIntersection(p0, p1, p2, p3);
                        if (null !== intersection) return intersection;
                    }
                    return null;
                }, Polygon.calculateAbsolutePolygonArea = function(polygonPoints) {
                    var i, j = 1, area = 0;
                    for (i = 0; i < polygonPoints.length; i++) area += polygonPoints[i].x * polygonPoints[j].y - polygonPoints[j].x * polygonPoints[i].y, 
                    j = (j + 1) % polygonPoints.length;
                    return area *= .5;
                }, Polygon.prototype.isConflictWithBoundingBox = function(rect) {
                    return Rect.isIntersecting(this.absoluteBoundingRect(), rect);
                }, Polygon.prototype.calculatePolygonCentroid = function() {
                    var area, tempPoint, cx, cy, i, j;
                    for (area = Polygon.calculateAbsolutePolygonArea(this.polygonPoints), cx = cy = 0, 
                    j = 1, i = 0; i < this.polygonPoints.length; i++) tempPoint = this.polygonPoints[i].x * this.polygonPoints[j].y - this.polygonPoints[j].x * this.polygonPoints[i].y, 
                    cx += (this.polygonPoints[i].x + this.polygonPoints[j].x) * tempPoint, cy += (this.polygonPoints[i].y + this.polygonPoints[j].y) * tempPoint, 
                    j = (j + 1) % this.polygonPoints.length;
                    return cx /= 6 * area, cy /= 6 * area, {
                        x: cx,
                        y: cy
                    };
                }, Polygon.prototype.calculateBoundingRect = function() {
                    for (var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, i = 0; i < this.polygonPoints.length; i++) this.polygonPoints[i].x < minX ? minX = this.polygonPoints[i].x : this.polygonPoints[i].x > maxX && (maxX = this.polygonPoints[i].x), 
                    this.polygonPoints[i].y < minY ? minY = this.polygonPoints[i].y : this.polygonPoints[i].y > maxY && (maxY = this.polygonPoints[i].y);
                    return {
                        left: minX,
                        top: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                }, Polygon.prototype.inside = function(point) {
                    for (var x = point.x, y = point.y, insideVar = !1, i = 0, j = this.polygonPoints.length - 1; i < this.polygonPoints.length; j = i++) {
                        var xi = this.polygonPoints[i].x, yi = this.polygonPoints[i].y, xj = this.polygonPoints[j].x, yj = this.polygonPoints[j].y, intersect = yi > y != yj > y && (xj - xi) * (y - yi) / (yj - yi) + xi > x;
                        intersect && (insideVar = !insideVar);
                    }
                    return insideVar;
                }, Polygon.prototype.getLineIntersection = function(line0p1, line0p2, line1p1, line1p2) {
                    var p0_x = line0p1.x, p0_y = line0p1.y, p1_x = line0p2.x, p1_y = line0p2.y, p2_x = line1p1.x, p2_y = line1p1.y, p3_x = line1p2.x, p3_y = line1p2.y, s1_x = p1_x - p0_x, s1_y = p1_y - p0_y, s2_x = p3_x - p2_x, s2_y = p3_y - p2_y, s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y), t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
                    return s >= 0 && 1 >= s && t >= 0 && 1 >= t ? {
                        x: p0_x + t * s1_x,
                        y: p0_y + t * s1_y
                    } : null;
                }, Polygon.prototype.convertArrayPathToPoints = function(path) {
                    for (var pointsRes = [], i = 0; i < path.length; i += 2) {
                        var x = path[i], y = path[i + 1], newPoint = {
                            x: x,
                            y: y
                        };
                        pointsRes.push(newPoint);
                    }
                    return pointsRes;
                }, Polygon;
            }();
            shapes.Polygon = Polygon;
            var Point;
            !function(Point) {
                function offset(point, offsetX, offsetY) {
                    var newPointX = point.x + offsetX >= 0 ? point.x + offsetX : 0, newPointY = point.y + offsetY >= 0 ? point.y + offsetY : 0;
                    return {
                        x: newPointX,
                        y: newPointY
                    };
                }
                function equals(point, other) {
                    return void 0 !== point && null !== point && void 0 !== other && null !== other && point.x === other.x && point.y === other.y;
                }
                function clone(point) {
                    return null !== point ? {
                        x: point.x,
                        y: point.y
                    } : null;
                }
                function toString(point) {
                    return "{x:" + point.x + ", y:" + point.y + "}";
                }
                function serialize(point) {
                    return point.x + "," + point.y;
                }
                function getDistance(point, other) {
                    if (null === point || null === other) return null;
                    var diffX = other.x - point.x, diffY = other.y - point.y;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
                }
                function equalWithPrecision(point1, point2) {
                    return point1 === point2 || void 0 !== point1 && void 0 !== point2 && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y);
                }
                function parsePoint(value, defaultValue) {
                    if (null === value) return void 0 === defaultValue ? null : defaultValue;
                    if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                    if (2 === value.length) return {
                        x: Utility.parseNumber(value[0]),
                        y: Utility.parseNumber(value[1])
                    };
                    if ("string" == typeof value) {
                        var parts = value.split(",");
                        return 2 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                            x: Utility.parseNumber(parts[0]),
                            y: Utility.parseNumber(parts[1])
                        };
                    }
                    return 2 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                        x: Utility.parseNumber(value.x),
                        y: Utility.parseNumber(value.y)
                    };
                }
                Point.offset = offset, Point.equals = equals, Point.clone = clone, Point.toString = toString, 
                Point.serialize = serialize, Point.getDistance = getDistance, Point.equalWithPrecision = equalWithPrecision, 
                Point.parsePoint = parsePoint;
            }(Point = shapes.Point || (shapes.Point = {}));
            var Size;
            !function(Size) {
                function isEmpty(size) {
                    return 0 === size.width && 0 === size.height;
                }
                function equals(size, other) {
                    return void 0 !== size && null !== size && void 0 !== other && null !== other && size.width === other.width && size.height === other.height;
                }
                function clone(size) {
                    return null !== size ? {
                        width: size.width,
                        height: size.height
                    } : null;
                }
                function inflate(size, padding) {
                    var result = clone(size);
                    return padding && (result.width += padding.left + padding.right, result.height += padding.top + padding.bottom), 
                    result;
                }
                function deflate(size, padding) {
                    var result = clone(size);
                    return padding && (result.width = result.width - padding.left - padding.right, result.width < 0 && (result.width = 0), 
                    result.height = result.height - padding.top - padding.bottom, result.height < 0 && (result.height = 0)), 
                    result;
                }
                function combine(size, other) {
                    return other && (size.width = Math.max(size.width, other.width), size.height = Math.max(size.height, other.height)), 
                    size;
                }
                function toRect(size) {
                    return {
                        left: 0,
                        top: 0,
                        width: size.width,
                        height: size.height
                    };
                }
                function toString(size) {
                    return "{width:" + size.width + ", height:" + size.height + "}";
                }
                function equal(size1, size2) {
                    return size1 === size2 || void 0 !== size1 && void 0 !== size2 && size1.width === size2.width && size1.height === size2.height;
                }
                function equalWithPrecision(size1, size2) {
                    return size1 === size2 || void 0 !== size1 && void 0 !== size2 && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height);
                }
                function parseSize(value, defaultValue) {
                    if (null === value) return void 0 === defaultValue ? null : defaultValue;
                    if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                    if (2 === value.length) return {
                        width: Utility.parseNumber(value[0]),
                        height: Utility.parseNumber(value[1])
                    };
                    if ("string" == typeof value) {
                        var parts = value.split(",");
                        return 2 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                            width: Utility.parseNumber(parts[0]),
                            height: Utility.parseNumber(parts[1])
                        };
                    }
                    return 2 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                        width: Utility.parseNumber(value.width),
                        height: Utility.parseNumber(value.height)
                    };
                }
                Size.isEmpty = isEmpty, Size.equals = equals, Size.clone = clone, Size.inflate = inflate, 
                Size.deflate = deflate, Size.combine = combine, Size.toRect = toRect, Size.toString = toString, 
                Size.equal = equal, Size.equalWithPrecision = equalWithPrecision, Size.parseSize = parseSize;
            }(Size = shapes.Size || (shapes.Size = {}));
            var Rect;
            !function(Rect) {
                function getOffset(rect) {
                    return {
                        x: rect.left,
                        y: rect.top
                    };
                }
                function getSize(rect) {
                    return {
                        width: rect.width,
                        height: rect.height
                    };
                }
                function setSize(rect, value) {
                    rect.width = value.width, rect.height = value.height;
                }
                function right(rect) {
                    return rect.left + rect.width;
                }
                function bottom(rect) {
                    return rect.top + rect.height;
                }
                function topLeft(rect) {
                    return {
                        x: rect.left,
                        y: rect.top
                    };
                }
                function topRight(rect) {
                    return {
                        x: rect.left + rect.width,
                        y: rect.top
                    };
                }
                function bottomLeft(rect) {
                    return {
                        x: rect.left,
                        y: rect.top + rect.height
                    };
                }
                function bottomRight(rect) {
                    return {
                        x: rect.left + rect.width,
                        y: rect.top + rect.height
                    };
                }
                function equals(rect, other) {
                    return void 0 !== other && null !== other && rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
                }
                function clone(rect) {
                    return null !== rect ? {
                        left: rect.left,
                        top: rect.top,
                        width: rect.width,
                        height: rect.height
                    } : null;
                }
                function toString(rect) {
                    return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
                }
                function offset(rect, offsetX, offsetY) {
                    var newLeft = rect.left + offsetX >= 0 ? rect.left + offsetX : 0, newTop = rect.top + offsetY >= 0 ? rect.top + offsetY : 0;
                    return {
                        left: newLeft,
                        top: newTop,
                        width: rect.width,
                        height: rect.height
                    };
                }
                function inflate(rect, padding) {
                    var result = clone(rect);
                    return padding && (result.left -= padding.left, result.top -= padding.top, result.width += padding.left + padding.right, 
                    result.height += padding.top + padding.bottom), result;
                }
                function deflate(rect, padding) {
                    var result = clone(rect);
                    return padding && (result.left += padding.left, result.top += padding.top, result.width -= padding.left + padding.right, 
                    result.height -= padding.top + padding.bottom), result;
                }
                function inflateBy(rect, padding) {
                    return {
                        left: rect.left - padding,
                        top: rect.top - padding,
                        width: rect.width + padding + padding,
                        height: rect.height + padding + padding
                    };
                }
                function deflateBy(rect, padding) {
                    return {
                        left: rect.left + padding,
                        top: rect.top + padding,
                        width: rect.width - padding - padding,
                        height: rect.height - padding - padding
                    };
                }
                function getClosestPoint(rect, x, y) {
                    return {
                        x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
                        y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
                    };
                }
                function equal(rect1, rect2) {
                    return rect1 === rect2 || void 0 !== rect1 && void 0 !== rect2 && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height;
                }
                function equalWithPrecision(rect1, rect2) {
                    return rect1 === rect2 || void 0 !== rect1 && void 0 !== rect2 && powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) && powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height);
                }
                function isEmpty(rect) {
                    return void 0 === rect || null === rect || 0 === rect.width && 0 === rect.height;
                }
                function containsPoint(rect, point) {
                    return null === rect || null === point ? !1 : powerbi.Double.lessOrEqualWithPrecision(rect.left, point.x) && powerbi.Double.lessOrEqualWithPrecision(point.x, rect.left + rect.width) && powerbi.Double.lessOrEqualWithPrecision(rect.top, point.y) && powerbi.Double.lessOrEqualWithPrecision(point.y, rect.top + rect.height);
                }
                function isIntersecting(rect1, rect2) {
                    if (!rect1 || !rect2) return !1;
                    var left = Math.max(rect1.left, rect2.left), right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    if (left > right) return !1;
                    var top = Math.max(rect1.top, rect2.top), bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    return bottom >= top;
                }
                function intersect(rect1, rect2) {
                    if (!rect1) return rect2;
                    if (!rect2) return rect1;
                    var left = Math.max(rect1.left, rect2.left), top = Math.max(rect1.top, rect2.top), right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width), bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    return right >= left && bottom >= top ? {
                        left: left,
                        top: top,
                        width: right - left,
                        height: bottom - top
                    } : {
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0
                    };
                }
                function combine(rect1, rect2) {
                    if (!rect1) return rect2;
                    if (!rect2) return rect1;
                    var left = Math.min(rect1.left, rect2.left), top = Math.min(rect1.top, rect2.top), right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width), bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
                    return {
                        left: left,
                        top: top,
                        width: right - left,
                        height: bottom - top
                    };
                }
                function parseRect(value, defaultValue) {
                    if (null === value) return void 0 === defaultValue ? null : defaultValue;
                    if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                    if (4 === value.length) return {
                        left: Utility.parseNumber(value[0]),
                        top: Utility.parseNumber(value[1]),
                        width: Utility.parseNumber(value[2]),
                        height: Utility.parseNumber(value[3])
                    };
                    if ("string" == typeof value) {
                        var parts = value.split(",");
                        return 4 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                            left: Utility.parseNumber(parts[0]),
                            top: Utility.parseNumber(parts[1]),
                            width: Utility.parseNumber(parts[2]),
                            height: Utility.parseNumber(parts[3])
                        };
                    }
                    return 4 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                        left: Utility.parseNumber(value.left),
                        top: Utility.parseNumber(value.top),
                        width: Utility.parseNumber(value.width),
                        height: Utility.parseNumber(value.height)
                    };
                }
                Rect.getOffset = getOffset, Rect.getSize = getSize, Rect.setSize = setSize, Rect.right = right, 
                Rect.bottom = bottom, Rect.topLeft = topLeft, Rect.topRight = topRight, Rect.bottomLeft = bottomLeft, 
                Rect.bottomRight = bottomRight, Rect.equals = equals, Rect.clone = clone, Rect.toString = toString, 
                Rect.offset = offset, Rect.inflate = inflate, Rect.deflate = deflate, Rect.inflateBy = inflateBy, 
                Rect.deflateBy = deflateBy, Rect.getClosestPoint = getClosestPoint, Rect.equal = equal, 
                Rect.equalWithPrecision = equalWithPrecision, Rect.isEmpty = isEmpty, Rect.containsPoint = containsPoint, 
                Rect.isIntersecting = isIntersecting, Rect.intersect = intersect, Rect.combine = combine, 
                Rect.parseRect = parseRect;
            }(Rect = shapes.Rect || (shapes.Rect = {}));
            var Thickness;
            !function(Thickness) {
                function inflate(thickness, other) {
                    var result = clone(thickness);
                    return other && (result.left = thickness.left + other.left, result.right = thickness.right + other.right, 
                    result.bottom = thickness.bottom + other.bottom, result.top = thickness.top + other.top), 
                    result;
                }
                function getWidth(thickness) {
                    return thickness.left + thickness.right;
                }
                function getHeight(thickness) {
                    return thickness.top + thickness.bottom;
                }
                function clone(thickness) {
                    return null !== thickness ? {
                        left: thickness.left,
                        top: thickness.top,
                        right: thickness.right,
                        bottom: thickness.bottom
                    } : null;
                }
                function equals(thickness, other) {
                    return void 0 !== thickness && null !== thickness && void 0 !== other && null !== other && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
                }
                function flipHorizontal(thickness) {
                    var temp = thickness.right;
                    thickness.right = thickness.left, thickness.left = temp;
                }
                function flipVertical(thickness) {
                    var top = thickness.top;
                    thickness.top = thickness.bottom, thickness.bottom = top;
                }
                function toString(thickness) {
                    return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
                }
                function toCssString(thickness) {
                    return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
                }
                function isEmpty(thickness) {
                    return 0 === thickness.left && 0 === thickness.top && 0 === thickness.right && 0 === thickness.bottom;
                }
                function equal(thickness1, thickness2) {
                    return thickness1 === thickness2 || void 0 !== thickness1 && void 0 !== thickness2 && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom;
                }
                function equalWithPrecision(thickness1, thickness2) {
                    return thickness1 === thickness2 || void 0 !== thickness1 && void 0 !== thickness2 && powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) && powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom);
                }
                function parseThickness(value, defaultValue, resetValue) {
                    if (null === value) return void 0 === defaultValue ? null : defaultValue;
                    if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                    if (4 === value.length) return {
                        left: Utility.parseNumber(value[0]),
                        top: Utility.parseNumber(value[1]),
                        right: Utility.parseNumber(value[2]),
                        bottom: Utility.parseNumber(value[3])
                    };
                    if ("string" == typeof value) {
                        var parts = value.split(",");
                        return 4 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                            left: Utility.parseNumber(parts[0]),
                            top: Utility.parseNumber(parts[1]),
                            right: Utility.parseNumber(parts[2]),
                            bottom: Utility.parseNumber(parts[3])
                        };
                    }
                    return 4 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                        left: Utility.parseNumber(value.left),
                        top: Utility.parseNumber(value.top),
                        right: Utility.parseNumber(value.right),
                        bottom: Utility.parseNumber(value.bottom)
                    };
                }
                Thickness.inflate = inflate, Thickness.getWidth = getWidth, Thickness.getHeight = getHeight, 
                Thickness.clone = clone, Thickness.equals = equals, Thickness.flipHorizontal = flipHorizontal, 
                Thickness.flipVertical = flipVertical, Thickness.toString = toString, Thickness.toCssString = toCssString, 
                Thickness.isEmpty = isEmpty, Thickness.equal = equal, Thickness.equalWithPrecision = equalWithPrecision, 
                Thickness.parseThickness = parseThickness;
            }(Thickness = shapes.Thickness || (shapes.Thickness = {}));
            var Vector;
            !function(Vector) {
                function isEmpty(vector) {
                    return 0 === vector.x && 0 === vector.y;
                }
                function equals(vector, other) {
                    return void 0 !== vector && null !== vector && void 0 !== other && null !== other && vector.x === other.x && vector.y === other.y;
                }
                function clone(vector) {
                    return null !== vector ? {
                        x: vector.x,
                        y: vector.y
                    } : null;
                }
                function toString(vector) {
                    return "{x:" + vector.x + ", y:" + vector.y + "}";
                }
                function getLength(vector) {
                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                }
                function getLengthSqr(vector) {
                    return vector.x * vector.x + vector.y * vector.y;
                }
                function scale(vector, scalar) {
                    return {
                        x: vector.x * scalar,
                        y: vector.y * scalar
                    };
                }
                function normalize(vector) {
                    return isEmpty(vector) ? vector : scale(vector, 1 / getLength(vector));
                }
                function rotate90DegCW(vector) {
                    return {
                        x: vector.y,
                        y: -vector.x
                    };
                }
                function rotate90DegCCW(vector) {
                    return {
                        x: -vector.y,
                        y: vector.x
                    };
                }
                function rotate(vector, angle) {
                    var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle), newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
                    return {
                        x: newX,
                        y: newY
                    };
                }
                function equal(vector1, vector2) {
                    return vector1 === vector2 || void 0 !== vector1 && void 0 !== vector2 && vector1.x === vector2.x && vector1.y === vector2.y;
                }
                function equalWithPrecision(vector1, vector2) {
                    return vector1 === vector2 || void 0 !== vector1 && void 0 !== vector2 && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y);
                }
                function add(vect1, vect2) {
                    return vect1 && vect2 ? {
                        x: vect1.x + vect2.x,
                        y: vect1.y + vect2.y
                    } : void 0;
                }
                function subtract(vect1, vect2) {
                    return vect1 && vect2 ? {
                        x: vect1.x - vect2.x,
                        y: vect1.y - vect2.y
                    } : void 0;
                }
                function dotProduct(vect1, vect2) {
                    return vect1 && vect2 ? vect1.x * vect2.x + vect1.y * vect2.y : void 0;
                }
                function getDeltaVector(p0, p1) {
                    return p0 && p1 ? {
                        x: p1.x - p0.x,
                        y: p1.y - p0.y
                    } : void 0;
                }
                Vector.isEmpty = isEmpty, Vector.equals = equals, Vector.clone = clone, Vector.toString = toString, 
                Vector.getLength = getLength, Vector.getLengthSqr = getLengthSqr, Vector.scale = scale, 
                Vector.normalize = normalize, Vector.rotate90DegCW = rotate90DegCW, Vector.rotate90DegCCW = rotate90DegCCW, 
                Vector.rotate = rotate, Vector.equal = equal, Vector.equalWithPrecision = equalWithPrecision, 
                Vector.add = add, Vector.subtract = subtract, Vector.dotProduct = dotProduct, Vector.getDeltaVector = getDeltaVector;
            }(Vector = shapes.Vector || (shapes.Vector = {}));
        }(shapes = visuals.shapes || (visuals.shapes = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var SlicerUtil, PixelConverter = jsCommon.PixelConverter;
        !function(SlicerUtil) {
            function tryRemoveValueFromRetainedList(value, selectedScopeIds, caseInsensitive) {
                if (!value || _.isEmpty(selectedScopeIds)) return !1;
                for (var i = 0, len = selectedScopeIds.length; len > i; i++) {
                    var retainedValueScopeId = selectedScopeIds[i];
                    if (powerbi.DataViewScopeIdentity.equals(value, retainedValueScopeId, caseInsensitive)) return selectedScopeIds.splice(i, 1), 
                    !0;
                }
                return !1;
            }
            var Selectors;
            !function(Selectors) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                Selectors.HeaderContainer = createClassAndSelector("headerContainer"), Selectors.Header = createClassAndSelector("slicerHeader"), 
                Selectors.HeaderText = createClassAndSelector("headerText"), Selectors.Body = createClassAndSelector("slicerBody"), 
                Selectors.Label = createClassAndSelector("slicerLabel"), Selectors.LabelText = createClassAndSelector("slicerText"), 
                Selectors.LabelImage = createClassAndSelector("slicerImage"), Selectors.CountText = createClassAndSelector("slicerCountText"), 
                Selectors.Clear = createClassAndSelector("clear"), Selectors.MultiSelectEnabled = createClassAndSelector("isMultiSelectEnabled");
            }(Selectors = SlicerUtil.Selectors || (SlicerUtil.Selectors = {}));
            var DisplayNameKeys;
            !function(DisplayNameKeys) {
                DisplayNameKeys.Clear = "Slicer_Clear", DisplayNameKeys.SelectAll = "Slicer_SelectAll";
            }(DisplayNameKeys = SlicerUtil.DisplayNameKeys || (SlicerUtil.DisplayNameKeys = {}));
            var SettingsHelper;
            !function(SettingsHelper) {
                function areSettingsDefined(data) {
                    return null != data && null != data.slicerSettings;
                }
                SettingsHelper.areSettingsDefined = areSettingsDefined;
            }(SettingsHelper = SlicerUtil.SettingsHelper || (SlicerUtil.SettingsHelper = {}));
            var DefaultValueHandler;
            !function(DefaultValueHandler) {
                function getIdentityFields(dataView) {
                    if (dataView) {
                        var dataViewCategorical = dataView.categorical;
                        if (dataViewCategorical && !_.isEmpty(dataViewCategorical.categories)) return dataViewCategorical.categories[0].identityFields;
                    }
                }
                DefaultValueHandler.getIdentityFields = getIdentityFields;
            }(DefaultValueHandler = SlicerUtil.DefaultValueHandler || (SlicerUtil.DefaultValueHandler = {})), 
            SlicerUtil.tryRemoveValueFromRetainedList = tryRemoveValueFromRetainedList;
            var DOMHelper = function() {
                function DOMHelper() {}
                return DOMHelper.prototype.createSlicerHeader = function(hostServices) {
                    var slicerHeaderDiv = document.createElement("div");
                    slicerHeaderDiv.className = Selectors.Header["class"];
                    var slicerHeader = d3.select(slicerHeaderDiv);
                    return slicerHeader.append("span").classed(Selectors.Clear["class"], !0).attr("title", hostServices.getLocalizedString(DisplayNameKeys.Clear)), 
                    slicerHeader.append("div").classed(Selectors.HeaderText["class"], !0), slicerHeaderDiv;
                }, DOMHelper.prototype.getHeaderTextProperties = function(settings) {
                    var headerTextProperties = {
                        fontFamily: "wf_segoe-ui_normal",
                        fontSize: "10px"
                    };
                    return settings.header.show && (headerTextProperties.fontSize = PixelConverter.fromPoint(settings.header.textSize)), 
                    headerTextProperties;
                }, DOMHelper.prototype.getSlicerBodyViewport = function(currentViewport, settings, headerTextProperties) {
                    var headerHeight = settings.header.show ? this.getHeaderHeight(settings, headerTextProperties) : 0, slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                    return {
                        height: slicerBodyHeight,
                        width: currentViewport.width
                    };
                }, DOMHelper.prototype.updateSlicerBodyDimensions = function(currentViewport, slicerBody, settings) {
                    var slicerViewport = this.getSlicerBodyViewport(currentViewport, settings, this.getHeaderTextProperties(settings));
                    slicerBody.style({
                        height: PixelConverter.toString(slicerViewport.height),
                        width: PixelConverter.toString(slicerViewport.width)
                    });
                }, DOMHelper.prototype.getHeaderHeight = function(settings, textProperties) {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.header.textSize, textProperties)) + settings.general.outlineWeight;
                }, DOMHelper.prototype.getRowHeight = function(settings, textProperties) {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.slicerText.textSize, textProperties)) + this.getRowsOutlineWidth(settings.slicerText.outline, settings.general.outlineWeight);
                }, DOMHelper.prototype.styleSlicerHeader = function(slicerHeader, settings, headerText) {
                    if (settings.header.show) {
                        slicerHeader.style("display", "block");
                        var headerTextElement = slicerHeader.select(Selectors.HeaderText.selector).text(headerText);
                        this.setSlicerHeaderTextStyle(headerTextElement, settings);
                    } else slicerHeader.style("display", "none");
                }, DOMHelper.prototype.setSlicerTextStyle = function(slicerText, settings) {
                    slicerText.style({
                        color: settings.slicerText.color,
                        "background-color": settings.slicerText.background,
                        "border-style": "solid",
                        "border-color": settings.general.outlineColor,
                        "border-width": visuals.VisualBorderUtil.getBorderWidth(settings.slicerText.outline, settings.general.outlineWeight),
                        "font-size": PixelConverter.fromPoint(settings.slicerText.textSize)
                    });
                }, DOMHelper.prototype.getRowsOutlineWidth = function(outlineElement, outlineWeight) {
                    switch (outlineElement) {
                      case visuals.outline.none:
                      case visuals.outline.leftRight:
                        return 0;

                      case visuals.outline.bottomOnly:
                      case visuals.outline.topOnly:
                        return outlineWeight;

                      case visuals.outline.topBottom:
                      case visuals.outline.frame:
                        return 2 * outlineWeight;

                      default:
                        return 0;
                    }
                }, DOMHelper.prototype.setSlicerHeaderTextStyle = function(slicerHeader, settings) {
                    slicerHeader.style({
                        "border-style": "solid",
                        "border-color": settings.general.outlineColor,
                        "border-width": visuals.VisualBorderUtil.getBorderWidth(settings.header.outline, settings.general.outlineWeight),
                        color: settings.header.fontColor,
                        "background-color": settings.header.background,
                        "font-size": PixelConverter.fromPoint(settings.header.textSize)
                    });
                }, DOMHelper.prototype.getTextProperties = function(textSize, textProperties) {
                    return textProperties.fontSize = PixelConverter.fromPoint(textSize), textProperties;
                }, DOMHelper;
            }();
            SlicerUtil.DOMHelper = DOMHelper;
        }(SlicerUtil = visuals.SlicerUtil || (visuals.SlicerUtil = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var tooltipUtils;
        !function(tooltipUtils) {
            function tooltipUpdate(selection, tooltips) {
                if (0 !== tooltips.length) {
                    var titles = selection.selectAll("title"), titlesUpdate = titles.data(function(d, i) {
                        return [ tooltips[i] ];
                    });
                    titlesUpdate.enter().append("title"), titlesUpdate.exit().remove(), titlesUpdate.text(function(d) {
                        return d;
                    });
                }
            }
            tooltipUtils.tooltipUpdate = tooltipUpdate;
        }(tooltipUtils = visuals.tooltipUtils || (visuals.tooltipUtils = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var SVGUtil;
        !function(SVGUtil) {
            function translate(x, y) {
                return "translate(" + x + "," + y + ")";
            }
            function translateXWithPixels(x) {
                return "translateX(" + x + "px)";
            }
            function translateWithPixels(x, y) {
                return "translate(" + x + "px," + y + "px)";
            }
            function translateAndRotate(x, y, px, py, angle) {
                return "translate(" + x + "," + y + ") rotate(" + angle + "," + px + "," + py + ")";
            }
            function scale(scale) {
                return "scale(" + scale + ")";
            }
            function translateAndScale(x, y, ratio) {
                return "translate(" + x + "," + y + ") scale(" + ratio + ")";
            }
            function transformOrigin(xOffset, yOffset) {
                return xOffset + " " + yOffset;
            }
            function flushAllD3Transitions() {
                var now = Date.now;
                Date.now = function() {
                    return 1 / 0;
                }, d3.timer.flush(), Date.now = now;
            }
            function flushAllD3TransitionsIfNeeded(options) {
                if (options) {
                    var animationOptions = options, asVisualInitOptions = options;
                    asVisualInitOptions.animation && (animationOptions = asVisualInitOptions.animation), 
                    animationOptions && animationOptions.transitionImmediate && flushAllD3Transitions();
                }
            }
            function ensureDAttribute(pathElement) {
                pathElement.getAttribute("d") || pathElement.setAttribute("d", "");
            }
            function ensureValidSVGPoint(point) {
                isNaN(point.x) && (point.x = 0), isNaN(point.y) && (point.y = 0);
            }
            function parseTranslateTransform(input) {
                if (!input || 0 === input.length) return {
                    x: "0",
                    y: "0"
                };
                var xValue, translateCoordinates = input.split(/[\s,]+/), yValue = "0", xCoord = translateCoordinates[0];
                if (1 === translateCoordinates.length) xValue = xCoord.substring(10, xCoord.length - 1); else {
                    var yCoord = translateCoordinates[1];
                    yValue = yCoord.substring(0, yCoord.length - 1), xValue = xCoord.substring(10, xCoord.length);
                }
                return {
                    x: xValue,
                    y: yValue
                };
            }
            function createArrow(width, height, rotate) {
                var transform = "rotate(" + rotate + " " + width / 2 + " " + height / 2 + ")", path = "M0 0";
                return path += "L0 " + height, path += "L" + width + " " + height / 2 + " Z", {
                    path: path,
                    transform: transform
                };
            }
            function getTransformScaleRatios(svgElement) {
                if (null != svgElement) {
                    var scaledRect = svgElement.getBoundingClientRect(), domRect = svgElement.getBBox();
                    if (domRect.height > 0 && domRect.width > 0) return {
                        x: scaledRect.width / domRect.width,
                        y: scaledRect.height / domRect.height
                    };
                }
                return {
                    x: 1,
                    y: 1
                };
            }
            SVGUtil.AlmostZero = 1e-6, SVGUtil.translate = translate, SVGUtil.translateXWithPixels = translateXWithPixels, 
            SVGUtil.translateWithPixels = translateWithPixels, SVGUtil.translateAndRotate = translateAndRotate, 
            SVGUtil.scale = scale, SVGUtil.translateAndScale = translateAndScale, SVGUtil.transformOrigin = transformOrigin, 
            SVGUtil.flushAllD3Transitions = flushAllD3Transitions, SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded, 
            SVGUtil.ensureDAttribute = ensureDAttribute, SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint, 
            SVGUtil.parseTranslateTransform = parseTranslateTransform, SVGUtil.createArrow = createArrow, 
            SVGUtil.getTransformScaleRatios = getTransformScaleRatios;
        }(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var TextUtil;
        !function(TextUtil) {
            function removeBreakingSpaces(str) {
                return str.toString().replace(new RegExp(" ", "g"), "&nbsp");
            }
            function removeEllipses(str) {
                return str.replace(/â€¦/g, "");
            }
            function replaceSpaceWithNBSP(txt) {
                return null != txt ? txt.replace(/ /g, "Â ") : void 0;
            }
            TextUtil.removeBreakingSpaces = removeBreakingSpaces, TextUtil.removeEllipses = removeEllipses, 
            TextUtil.replaceSpaceWithNBSP = replaceSpaceWithNBSP;
        }(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var GradientUtils, DataRoleHelper = powerbi.data.DataRoleHelper;
        !function(GradientUtils) {
            function getFillRuleRole(objectDescs) {
                if (objectDescs) for (var objectName in objectDescs) {
                    var objectDesc = objectDescs[objectName];
                    for (var propertyName in objectDesc.properties) {
                        var propertyDesc = objectDesc.properties[propertyName];
                        if (propertyDesc.type && propertyDesc.type[FillRulePropertyIdentifier]) return propertyDesc.rule.inputRole;
                    }
                }
            }
            function shouldShowGradient(visualConfig) {
                var isShowGradienCard = !!(visualConfig && visualConfig.query && visualConfig.query.projections && visualConfig.query.projections.Gradient);
                return isShowGradienCard;
            }
            function getUpdatedGradientSettings(gradientObject) {
                var gradientSettings;
                if (gradientObject && !$.isEmptyObject(gradientObject)) {
                    gradientSettings = getDefaultGradientSettings();
                    for (var propertyName in gradientSettings) {
                        var hasProperty = gradientObject.hasOwnProperty(propertyName);
                        if (hasProperty) {
                            var value = gradientObject[propertyName];
                            value && value.solid && value.solid.color && (value = value.solid.color), gradientSettings[propertyName] = value;
                        }
                    }
                }
                return gradientSettings;
            }
            function getGradientMeasureIndex(dataViewCategorical) {
                if (dataViewCategorical && dataViewCategorical.values && dataViewCategorical.values.grouped) {
                    var grouped = dataViewCategorical.values.grouped();
                    return DataRoleHelper.getMeasureIndexOfRole(grouped, "Gradient");
                }
                return -1;
            }
            function getGradientValueColumn(dataViewCategorical) {
                if (null == dataViewCategorical) return null;
                var gradientMeasureIndex = GradientUtils.getGradientMeasureIndex(dataViewCategorical), gradientValueColumn = -1 === gradientMeasureIndex ? null : dataViewCategorical.values[gradientMeasureIndex];
                return gradientValueColumn;
            }
            function hasGradientRole(dataViewCategorical) {
                var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
                return gradientMeasureIndex >= 0;
            }
            function getDefaultGradientSettings() {
                var colors = getDefaultColors(), gradientSettings = {
                    diverging: !1,
                    minColor: colors.minColor,
                    midColor: DefaultMidColor,
                    maxColor: colors.maxColor,
                    minValue: void 0,
                    midValue: void 0,
                    maxValue: void 0
                };
                return gradientSettings;
            }
            function getDefaultFillRuleDefinition() {
                return getLinearGradien2FillRuleDefinition();
            }
            function updateFillRule(propertyName, propertyValue, definitions) {
                var numericValueExpr, colorValueExpr, dataPointObjectDefinition = powerbi.data.DataViewObjectDefinitions.ensure(definitions, DataPointPropertyIdentifier, null), fillRule = getFillRule(definitions);
                fillRule && ($.isNumeric(propertyValue) && (numericValueExpr = void 0 !== propertyValue ? SQExprBuilder["double"](+propertyValue) : void 0), 
                "minColor" !== propertyName && "midColor" !== propertyName && "maxColor" !== propertyName || (colorValueExpr = getColorExpressionValue(fillRule, propertyName, propertyValue)), 
                "minColor" === propertyName ? updateMinColor(fillRule, colorValueExpr) : "midColor" === propertyName ? updateMidColor(fillRule, colorValueExpr) : "maxColor" === propertyName ? updateMaxColor(fillRule, colorValueExpr) : "minValue" === propertyName ? updateMinValue(fillRule, numericValueExpr) : "midValue" === propertyName ? updateMidValue(fillRule, numericValueExpr) : "maxValue" === propertyName ? updateMaxValue(fillRule, numericValueExpr) : "diverging" === propertyName ? (fillRule = propertyValue ? getLinearGradien3FillRuleDefinition(fillRule) : getLinearGradien2FillRuleDefinition(fillRule), 
                dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule) : "revertToDefault" === propertyName && (fillRule = this.getDefaultFillRuleDefinition(), 
                dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule));
            }
            function getGradientSettings(baseFillRule) {
                return baseFillRule ? getGradientSettingsFromRule(baseFillRule) : getDefaultGradientSettings();
            }
            function getFillRule(objectDefinitions) {
                var fillRuleDefinition = powerbi.data.DataViewObjectDefinitions.getValue(objectDefinitions, {
                    objectName: DataPointPropertyIdentifier,
                    propertyName: FillRulePropertyIdentifier
                }, null);
                return fillRuleDefinition;
            }
            function getDefaultColors() {
                var dataColors = new powerbi.visuals.DataColorPalette(), maxColorInfo = dataColors.getColorByIndex(0), colors = d3.scale.linear().domain([ 0, 100 ]).range([ "#ffffff", maxColorInfo.value ]), maxColor = maxColorInfo.value, minColor = colors(20), midColor = DefaultMidColor;
                return {
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor
                };
            }
            function getGradientSettingsFromRule(fillRule) {
                var maxColor, minColor, maxValue, midValue, minValue, midColor = DefaultMidColor, diverging = void 0 !== fillRule.linearGradient3;
                if (fillRule.linearGradient2) {
                    var maxColorExpr = fillRule.linearGradient2.max.color, minColorExpr = fillRule.linearGradient2.min.color, maxValueExpr = fillRule.linearGradient2.max.value, minValueExpr = fillRule.linearGradient2.min.value;
                    maxColor = maxColorExpr.value, minColor = minColorExpr.value, maxValueExpr && (maxValue = maxValueExpr.value), 
                    minValueExpr && (minValue = minValueExpr.value);
                } else if (fillRule.linearGradient3) {
                    var maxColorExpr = fillRule.linearGradient3.max.color, midColorExpr = fillRule.linearGradient3.mid.color, minColorExpr = fillRule.linearGradient3.min.color, maxValueExpr = fillRule.linearGradient3.max.value, midValueExpr = fillRule.linearGradient3.mid.value, minValueExpr = fillRule.linearGradient3.min.value;
                    maxColor = maxColorExpr.value, midColor = midColorExpr.value, minColor = minColorExpr.value, 
                    maxValueExpr && (maxValue = maxValueExpr.value), midValueExpr && (midValue = midValueExpr.value), 
                    minValueExpr && (minValue = minValueExpr.value);
                }
                return {
                    diverging: diverging,
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                    minValue: minValue,
                    midValue: midValue,
                    maxValue: maxValue
                };
            }
            function getLinearGradien2FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule), fillRuleDefinition = {
                    linearGradient2: {
                        max: {
                            color: SQExprBuilder.text(gradientSettings.maxColor)
                        },
                        min: {
                            color: SQExprBuilder.text(gradientSettings.minColor)
                        }
                    }
                };
                return fillRuleDefinition;
            }
            function getLinearGradien3FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule), fillRuleDefinition = {
                    linearGradient3: {
                        max: {
                            color: SQExprBuilder.text(gradientSettings.maxColor)
                        },
                        mid: {
                            color: SQExprBuilder.text(gradientSettings.midColor)
                        },
                        min: {
                            color: SQExprBuilder.text(gradientSettings.minColor)
                        }
                    }
                };
                return fillRuleDefinition;
            }
            function getDefaultColorExpression(fillRule, propertyName) {
                var defaultColor, defaultFillRule;
                return fillRule.linearGradient3 ? (defaultFillRule = getLinearGradien3FillRuleDefinition(), 
                "minColor" === propertyName ? defaultColor = defaultFillRule.linearGradient3.min.color : "midColor" === propertyName ? defaultColor = defaultFillRule.linearGradient3.mid.color : "maxColor" === propertyName && (defaultColor = defaultFillRule.linearGradient3.max.color)) : fillRule.linearGradient2 && (defaultFillRule = getLinearGradien2FillRuleDefinition(), 
                "minColor" === propertyName ? defaultColor = defaultFillRule.linearGradient2.min.color : "maxColor" === propertyName && (defaultColor = defaultFillRule.linearGradient2.max.color)), 
                defaultColor;
            }
            function getColorExpressionValue(fillRule, propertyName, propertyValue) {
                var colorExpressionValue;
                return colorExpressionValue = propertyValue ? SQExprBuilder.text(propertyValue) : getDefaultColorExpression(fillRule, propertyName);
            }
            function updateMinColor(fillRule, colorExpressionValue) {
                fillRule.linearGradient2 ? fillRule.linearGradient2.min.color = colorExpressionValue : fillRule.linearGradient3 && (fillRule.linearGradient3.min.color = colorExpressionValue);
            }
            function updateMidColor(fillRule, colorExpressionValue) {
                fillRule.linearGradient3 && (fillRule.linearGradient3.mid.color = colorExpressionValue);
            }
            function updateMaxColor(fillRule, colorExpressionValue) {
                fillRule.linearGradient2 ? fillRule.linearGradient2.max.color = colorExpressionValue : fillRule.linearGradient3 && (fillRule.linearGradient3.max.color = colorExpressionValue);
            }
            function updateMinValue(fillRule, value) {
                fillRule.linearGradient2 ? fillRule.linearGradient2.min.value = value : fillRule.linearGradient3 && (fillRule.linearGradient3.min.value = value);
            }
            function updateMidValue(fillRule, value) {
                fillRule.linearGradient3 && (fillRule.linearGradient3.mid.value = value);
            }
            function updateMaxValue(fillRule, value) {
                fillRule.linearGradient2 ? fillRule.linearGradient2.max.value = value : fillRule.linearGradient3 && (fillRule.linearGradient3.max.value = value);
            }
            var SQExprBuilder = powerbi.data.SQExprBuilder, DefaultMidColor = "#ffffff", DataPointPropertyIdentifier = "dataPoint", FillRulePropertyIdentifier = "fillRule";
            GradientUtils.getFillRuleRole = getFillRuleRole, GradientUtils.shouldShowGradient = shouldShowGradient, 
            GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings, GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex, 
            GradientUtils.getGradientValueColumn = getGradientValueColumn, GradientUtils.hasGradientRole = hasGradientRole, 
            GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings, GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition, 
            GradientUtils.updateFillRule = updateFillRule, GradientUtils.getGradientSettings = getGradientSettings, 
            GradientUtils.getFillRule = getFillRule, GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule;
        }(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var visualBackgroundHelper;
        !function(visualBackgroundHelper) {
            function getDefaultColor() {
                return "#FFF";
            }
            function getDefaultTransparency() {
                return 50;
            }
            function getDefaultShow() {
                return !1;
            }
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                    transparency: getDefaultTransparency(),
                    show: getDefaultShow()
                };
            }
            function enumeratePlot(enumeration, background) {
                var transparency = background && background.transparency;
                null == transparency && (transparency = getDefaultTransparency());
                var backgroundObject = {
                    selector: null,
                    properties: {
                        transparency: transparency,
                        image: background && background.image
                    },
                    objectName: "plotArea"
                };
                enumeration.pushInstance(backgroundObject);
            }
            function renderBackgroundImage(background, visualElement, layout) {
                var image = background && background.image, imageUrl = image && image.url, imageFit = image && image.scaling, imageTransparency = background && background.transparency, backgroundImage = visualElement.children(".background-image");
                if (!imageUrl) return void (0 !== backgroundImage.length && backgroundImage.remove());
                switch (0 === backgroundImage.length && (visualElement.prepend('<div class="background-image"></div>'), 
                backgroundImage = visualElement.children(".background-image"), backgroundImage.css("position", "absolute")), 
                backgroundImage.css({
                    width: layout.width,
                    height: layout.height,
                    "margin-left": layout.left,
                    "margin-top": layout.top
                }), backgroundImage.css({
                    "background-image": "url(" + imageUrl + ")",
                    "background-repeat": "no-repeat",
                    opacity: (100 - imageTransparency) / 100
                }), imageFit) {
                  case visuals.imageScalingType.normal:
                    backgroundImage.css({
                        "background-size": "",
                        "background-position": "50% 50%"
                    });
                    break;

                  case visuals.imageScalingType.fit:
                    backgroundImage.css({
                        "background-size": "100% 100%",
                        "background-position": ""
                    });
                    break;

                  case visuals.imageScalingType.fill:
                    backgroundImage.css({
                        "background-size": "100%",
                        "background-position": "50% 50%"
                    });
                    break;

                  default:
                    backgroundImage.css({
                        "background-size": "",
                        "background-position": "50% 50%"
                    });
                }
            }
            visualBackgroundHelper.getDefaultColor = getDefaultColor, visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency, 
            visualBackgroundHelper.getDefaultShow = getDefaultShow, visualBackgroundHelper.getDefaultValues = getDefaultValues, 
            visualBackgroundHelper.enumeratePlot = enumeratePlot, visualBackgroundHelper.renderBackgroundImage = renderBackgroundImage;
        }(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var Selector = powerbi.data.Selector, ObjectEnumerationBuilder = function() {
            function ObjectEnumerationBuilder() {}
            return ObjectEnumerationBuilder.prototype.pushInstance = function(instance) {
                var instances = this.instances;
                instances || (instances = this.instances = []);
                var containerIdx = this.containerIdx;
                null != containerIdx && (instance.containerIdx = containerIdx);
                for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
                    var existingInstance = instances_1[_i];
                    if (this.canMerge(existingInstance, instance)) return this.extend(existingInstance, instance, "properties"), 
                    this.extend(existingInstance, instance, "validValues"), this;
                }
                return instances.push(instance), this;
            }, ObjectEnumerationBuilder.prototype.pushContainer = function(container) {
                var containers = this.containers;
                containers || (containers = this.containers = []);
                var updatedLen = containers.push(container);
                return this.containerIdx = updatedLen - 1, this;
            }, ObjectEnumerationBuilder.prototype.popContainer = function() {
                return this.containerIdx = void 0, this;
            }, ObjectEnumerationBuilder.prototype.complete = function() {
                if (this.instances) {
                    var result = {
                        instances: this.instances
                    }, containers = this.containers;
                    return containers && (result.containers = containers), result;
                }
            }, ObjectEnumerationBuilder.prototype.canMerge = function(x, y) {
                return x.objectName === y.objectName && x.containerIdx === y.containerIdx && Selector.equals(x.selector, y.selector);
            }, ObjectEnumerationBuilder.prototype.extend = function(target, source, propertyName) {
                var sourceValues = source[propertyName];
                if (sourceValues) {
                    var targetValues = target[propertyName];
                    targetValues || (targetValues = target[propertyName] = {});
                    for (var valuePropertyName in sourceValues) targetValues[valuePropertyName] || (targetValues[valuePropertyName] = sourceValues[valuePropertyName]);
                }
            }, ObjectEnumerationBuilder.merge = function(x, y) {
                var xNormalized = ObjectEnumerationBuilder.normalize(x), yNormalized = ObjectEnumerationBuilder.normalize(y);
                if (!xNormalized || !yNormalized) return xNormalized || yNormalized;
                for (var xCategoryCount = xNormalized.containers ? xNormalized.containers.length : 0, _i = 0, _a = yNormalized.instances; _i < _a.length; _i++) {
                    var yInstance = _a[_i];
                    xNormalized.instances.push(yInstance), null != yInstance.containerIdx && (yInstance.containerIdx += xCategoryCount);
                }
                var yContainers = yNormalized.containers;
                return _.isEmpty(yContainers) || (xNormalized.containers ? Array.prototype.push.apply(xNormalized.containers, yContainers) : xNormalized.containers = yContainers), 
                xNormalized;
            }, ObjectEnumerationBuilder.normalize = function(x) {
                return _.isArray(x) ? {
                    instances: x
                } : x;
            }, ObjectEnumerationBuilder.getContainerForInstance = function(enumeration, instance) {
                return enumeration.containers[instance.containerIdx];
            }, ObjectEnumerationBuilder;
        }();
        visuals.ObjectEnumerationBuilder = ObjectEnumerationBuilder;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var VisualBorderUtil;
        !function(VisualBorderUtil) {
            function getBorderWidth(outlineType, outlineWeight) {
                switch (outlineType) {
                  case visuals.outline.none:
                    return "0px";

                  case visuals.outline.bottomOnly:
                    return "0px 0px " + outlineWeight + "px 0px";

                  case visuals.outline.topOnly:
                    return outlineWeight + "px 0px 0px 0px";

                  case visuals.outline.leftOnly:
                    return "0px 0px 0px " + outlineWeight + "px";

                  case visuals.outline.rightOnly:
                    return "0px " + outlineWeight + "px 0px 0px";

                  case visuals.outline.topBottom:
                    return outlineWeight + "px 0px";

                  case visuals.outline.leftRight:
                    return "0px " + outlineWeight + "px";

                  case visuals.outline.frame:
                    return outlineWeight + "px";

                  default:
                    return "0px";
                }
            }
            VisualBorderUtil.getBorderWidth = getBorderWidth;
        }(VisualBorderUtil = visuals.VisualBorderUtil || (visuals.VisualBorderUtil = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function createTranslateMatrix(xOffset, yOffset) {
            return {
                m00: 1,
                m01: 0,
                m02: xOffset,
                m10: 0,
                m11: 1,
                m12: yOffset
            };
        }
        function createScaleMatrix(xScale, yScale) {
            return {
                m00: xScale,
                m01: 0,
                m02: 0,
                m10: 0,
                m11: yScale,
                m12: 0
            };
        }
        function createRotationMatrix(angleInRads) {
            var a = angleInRads, sinA = Math.sin(a), cosA = Math.cos(a);
            return {
                m00: cosA,
                m01: -sinA,
                m02: 0,
                m10: sinA,
                m11: cosA,
                m12: 0
            };
        }
        function createInverseMatrix(m) {
            var determinant = m.m00 * m.m11 - m.m01 * m.m10, invdet = 1 / determinant;
            return {
                m00: m.m11 * invdet,
                m01: -m.m01 * invdet,
                m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
                m10: -m.m10 * invdet,
                m11: m.m00 * invdet,
                m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
            };
        }
        function multiplyMatrices(a, b) {
            return {
                m00: a.m00 * b.m00 + a.m01 * b.m10,
                m01: a.m00 * b.m01 + a.m01 * b.m11,
                m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
                m10: a.m10 * b.m00 + a.m11 * b.m10,
                m11: a.m10 * b.m01 + a.m11 * b.m11,
                m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12
            };
        }
        var Transform = function() {
            function Transform(m) {
                this.matrix = m || {
                    m00: 1,
                    m01: 0,
                    m02: 0,
                    m10: 0,
                    m11: 1,
                    m12: 0
                };
            }
            return Transform.prototype.applyToPoint = function(point) {
                if (!point) return point;
                var m = this.matrix;
                return {
                    x: m.m00 * point.x + m.m01 * point.y + m.m02,
                    y: m.m10 * point.x + m.m11 * point.y + m.m12
                };
            }, Transform.prototype.applyToRect = function(rect) {
                if (!rect) return rect;
                var x0 = rect.left, y0 = rect.top, m = this.matrix, isScaled = 1 !== m.m00 || 1 !== m.m11, isRotated = 0 !== m.m01 || 0 !== m.m10;
                if (!isRotated && !isScaled) return {
                    left: x0 + m.m02,
                    top: y0 + m.m12,
                    width: rect.width,
                    height: rect.height
                };
                var minX, maxX, minY, maxY, x1 = rect.left + rect.width, y1 = rect.top + rect.height;
                if (isRotated) {
                    var p0x = m.m00 * x0 + m.m01 * y0 + m.m02, p0y = m.m10 * x0 + m.m11 * y0 + m.m12, p1x = m.m00 * x0 + m.m01 * y1 + m.m02, p1y = m.m10 * x0 + m.m11 * y1 + m.m12, p2x = m.m00 * x1 + m.m01 * y0 + m.m02, p2y = m.m10 * x1 + m.m11 * y0 + m.m12, p3x = m.m00 * x1 + m.m01 * y1 + m.m02, p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p1x, p2x, p3x), maxX = Math.max(p0x, p1x, p2x, p3x), minY = Math.min(p0y, p1y, p2y, p3y), 
                    maxY = Math.max(p0y, p1y, p2y, p3y);
                } else {
                    var p0x = m.m00 * x0 + m.m02, p0y = m.m11 * y0 + m.m12, p3x = m.m00 * x1 + m.m02, p3y = m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p3x), maxX = Math.max(p0x, p3x), minY = Math.min(p0y, p3y), 
                    maxY = Math.max(p0y, p3y);
                }
                return {
                    left: minX,
                    top: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }, Transform.prototype.translate = function(xOffset, yOffset) {
                if (0 !== xOffset || 0 !== yOffset) {
                    var m = createTranslateMatrix(xOffset, yOffset);
                    this.matrix = multiplyMatrices(this.matrix, m), this._inverse = null;
                }
            }, Transform.prototype.scale = function(xScale, yScale) {
                if (1 !== xScale || 1 !== yScale) {
                    var m = createScaleMatrix(xScale, yScale);
                    this.matrix = multiplyMatrices(this.matrix, m), this._inverse = null;
                }
            }, Transform.prototype.rotate = function(angleInRadians) {
                if (0 !== angleInRadians) {
                    var m = createRotationMatrix(angleInRadians);
                    this.matrix = multiplyMatrices(this.matrix, m), this._inverse = null;
                }
            }, Transform.prototype.add = function(other) {
                other && (this.matrix = multiplyMatrices(this.matrix, other.matrix), this._inverse = null);
            }, Transform.prototype.getInverse = function() {
                return this._inverse || (this._inverse = new Transform(createInverseMatrix(this.matrix))), 
                this._inverse;
            }, Transform;
        }();
        visuals.Transform = Transform, visuals.createTranslateMatrix = createTranslateMatrix, 
        visuals.createScaleMatrix = createScaleMatrix, visuals.createRotationMatrix = createRotationMatrix, 
        visuals.createInverseMatrix = createInverseMatrix;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var TrendLineHelper;
        !function(TrendLineHelper) {
            function enumerateObjectInstances(enumeration, trendLine) {
                return null == trendLine ? void enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: !1
                    },
                    objectName: trendObjectName
                }) : void enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: trendLine.show,
                        lineColor: trendLine.lineColor,
                        transparency: trendLine.transparency,
                        style: trendLine.style
                    },
                    objectName: trendObjectName
                });
            }
            function readDataView(dataView) {
                if (dataView && dataView.categorical) {
                    var categorical = dataView.categorical;
                    if (!_.isEmpty(categorical.categories) && !_.isEmpty(categorical.values)) {
                        var categories = categorical.categories[0].values, values = categorical.values[0].values;
                        if (categories && values) {
                            for (var points = [], i = 0; i < categories.length; i++) {
                                var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]), y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
                                null != x && null != y && points.push({
                                    x: x,
                                    y: y
                                });
                            }
                            var trendProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, trendObjectName, {}), show = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.show, !1), lineColor = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.lineColor, TrendLineHelper.defaults.color), transparency = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.transparency, TrendLineHelper.defaults.transparency), style = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.style, TrendLineHelper.defaults.lineStyle), legacyColor = powerbi.DataViewObjects.getValue(categorical.values[0].source.objects, visuals.lineChartProps.dataPoint.fill);
                            return legacyColor && (lineColor = legacyColor), {
                                points: points,
                                show: show,
                                lineColor: lineColor,
                                transparency: transparency,
                                style: style
                            };
                        }
                    }
                }
            }
            function render(trendLine, graphicsContext, axes, viewport) {
                var xScale = axes.x.scale, yScale = axes.y1.scale, lines = graphicsContext.selectAll(TrendLineClassSelector.selector).data(trendLine ? [ trendLine ] : []);
                lines.enter().append("path").classed(TrendLineClassSelector["class"], !0);
                var pathGen = d3.svg.line().x(function(point) {
                    return xScale(point.x);
                }).y(function(point) {
                    return yScale(point.y);
                });
                lines.attr("d", function(d) {
                    return pathGen(d.points);
                }), lines.each(function(d) {
                    var line = d3.select(this), style = {};
                    style.stroke = d.lineColor.solid.color, null != d.transparency && (style["stroke-opacity"] = (100 - d.transparency) / 100), 
                    d.style === visuals.lineStyle.dashed ? style["stroke-dasharray"] = "5, 5" : d.style === visuals.lineStyle.dotted ? (style["stroke-dasharray"] = "1, 5", 
                    style["stroke-linecap"] = "round") : d.style === visuals.lineStyle.solid && (style["stroke-dasharray"] = null, 
                    style["stroke-linecap"] = null), line.style(style);
                }), lines.exit().remove();
            }
            var trendLinePropertyNames = {
                show: "show",
                lineColor: "lineColor",
                transparency: "transparency",
                style: "style"
            }, trendObjectName = "trend";
            TrendLineHelper.defaults = {
                color: {
                    solid: {
                        color: "#000"
                    }
                },
                lineStyle: visuals.lineStyle.solid,
                transparency: 0
            };
            var TrendLineClassSelector = jsCommon.CssConstants.createClassAndSelector("trend-line");
            TrendLineHelper.enumerateObjectInstances = enumerateObjectInstances, TrendLineHelper.readDataView = readDataView, 
            TrendLineHelper.render = render;
        }(TrendLineHelper = visuals.TrendLineHelper || (visuals.TrendLineHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var visibilityHelper;
        !function(visibilityHelper) {
            function partiallyVisible(element) {
                return element.is(":visible");
            }
            visibilityHelper.partiallyVisible = partiallyVisible;
        }(visibilityHelper = visuals.visibilityHelper || (visuals.visibilityHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var DataConversion, SemanticFilter = powerbi.data.SemanticFilter, UrlUtils = jsCommon.UrlUtils;
        !function(DataConversion) {
            function convert(dataView, localizedSelectAllText, interactivityService, hostServices) {
                if (dataView && dataView.categorical && !_.isEmpty(dataView.categorical.categories)) {
                    var identityFields = dataView.categorical.categories[0].identityFields;
                    if (identityFields) {
                        var filter = dataView.metadata && dataView.metadata.objects && powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.slicerProps.filterPropertyIdentifier), analyzer = hostServices.analyzeFilter({
                            dataView: dataView,
                            defaultValuePropertyId: visuals.slicerProps.defaultValue,
                            filter: filter,
                            fieldSQExprs: identityFields
                        });
                        if (analyzer) {
                            var analyzedSemanticFilter = analyzer.filter;
                            if (analyzedSemanticFilter && !SemanticFilter.isSameFilter(analyzedSemanticFilter, filter)) {
                                interactivityService.handleClearSelection();
                                var filterPropertyIdentifier = visuals.slicerProps.filterPropertyIdentifier, properties = {};
                                properties[filterPropertyIdentifier.propertyName] = analyzer.filter;
                                var instance = {
                                    objectName: filterPropertyIdentifier.objectName,
                                    selector: void 0,
                                    properties: properties
                                }, changes = {
                                    merge: [ instance ]
                                };
                                hostServices.persistProperties(changes);
                            }
                            var slicerData = getSlicerData(analyzer, dataView.metadata, dataView.categorical, localizedSelectAllText, interactivityService, hostServices);
                            return slicerData;
                        }
                    }
                }
            }
            function getSlicerData(analyzer, dataViewMetadata, categorical, localizedSelectAllText, interactivityService, hostServices) {
                var isInvertedSelectionMode = interactivityService && interactivityService.isSelectionModeInverted(), selectedScopeIds = analyzer.selectedIdentities, hasSelectionOverride = !_.isEmpty(selectedScopeIds) || isInvertedSelectionMode === !0;
                !isInvertedSelectionMode && analyzer.filter && (isInvertedSelectionMode = analyzer.isNotFilter), 
                interactivityService && (interactivityService.setSelectionModeInverted(isInvertedSelectionMode), 
                interactivityService.setDefaultValueMode(SemanticFilter.isDefaultFilter(analyzer.filter)));
                var category = categorical.categories[0], categoryValuesLen = category && category.values ? category.values.length : 0, slicerDataPoints = [], formatString = visuals.valueFormatter.getFormatString(category.source, visuals.slicerProps.formatString), numOfSelected = 0, valueCounts = categorical.values && categorical.values[0] && categorical.values[0].values;
                valueCounts && _.isEmpty(valueCounts) && (valueCounts = void 0);
                for (var isImageData = dataViewMetadata && !_.isEmpty(dataViewMetadata.columns) && visuals.converterHelper.isImageUrlColumn(dataViewMetadata.columns[0]), displayNameIdentityPairs = [], i = 0; categoryValuesLen > i; i++) {
                    var scopeId = category.identity && category.identity[i], value = category.values && category.values[i], count = valueCounts && valueCounts[i], isRetained = hasSelectionOverride ? visuals.SlicerUtil.tryRemoveValueFromRetainedList(scopeId, selectedScopeIds) : !1, label = visuals.valueFormatter.format(value, formatString), isImage = isImageData === !0 && UrlUtils.isValidImageUrl(label), slicerData_1 = {
                        value: label,
                        tooltip: label,
                        identity: visuals.SelectionId.createWithId(scopeId),
                        selected: isRetained,
                        count: count,
                        isImage: isImage
                    };
                    if (isRetained) {
                        var displayNameIdentityPair = {
                            displayName: label,
                            identity: scopeId
                        };
                        displayNameIdentityPairs.push(displayNameIdentityPair);
                    }
                    slicerDataPoints.push(slicerData_1), slicerData_1.selected && numOfSelected++;
                }
                if (_.isEmpty(displayNameIdentityPairs) || hostServices.setIdentityDisplayNames(displayNameIdentityPairs), 
                hasSelectionOverride && !_.isEmpty(selectedScopeIds)) {
                    var displayNamesIdentityPairs = hostServices.getIdentityDisplayNames(selectedScopeIds);
                    if (!_.isEmpty(displayNamesIdentityPairs)) for (var _i = 0, displayNamesIdentityPairs_1 = displayNamesIdentityPairs; _i < displayNamesIdentityPairs_1.length; _i++) {
                        var pair = displayNamesIdentityPairs_1[_i], slicerData_2 = {
                            value: pair.displayName,
                            tooltip: pair.displayName,
                            identity: visuals.SelectionId.createWithId(pair.identity),
                            selected: !0,
                            count: null != valueCounts ? 0 : void 0
                        };
                        slicerDataPoints.push(slicerData_2), numOfSelected++;
                    }
                }
                var defaultSettings = createDefaultSettings(dataViewMetadata);
                if (defaultSettings.selection.selectAllCheckboxEnabled) {
                    if (numOfSelected > 0 && !dataViewMetadata.segment && numOfSelected === slicerDataPoints.length) {
                        isInvertedSelectionMode = !isInvertedSelectionMode, interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
                        for (var _a = 0, slicerDataPoints_1 = slicerDataPoints; _a < slicerDataPoints_1.length; _a++) {
                            var item = slicerDataPoints_1[_a];
                            item.selected = !1;
                        }
                        hasSelectionOverride = !1, numOfSelected = 0;
                    }
                    slicerDataPoints.unshift({
                        value: localizedSelectAllText,
                        tooltip: localizedSelectAllText,
                        identity: visuals.SelectionId.createWithMeasure(localizedSelectAllText),
                        selected: !!isInvertedSelectionMode && 0 === numOfSelected,
                        isSelectAllDataPoint: !0,
                        count: void 0
                    });
                }
                var slicerData = {
                    categorySourceName: category.source.displayName,
                    slicerSettings: defaultSettings,
                    slicerDataPoints: slicerDataPoints,
                    hasSelectionOverride: hasSelectionOverride,
                    defaultValue: analyzer.defaultValue
                };
                return slicerData;
            }
            function createDefaultSettings(dataViewMetadata) {
                var defaultSettings = visuals.Slicer.DefaultStyleProperties(), objects = dataViewMetadata.objects, forceSingleSelect = dataViewMetadata.columns && _.some(dataViewMetadata.columns, function(column) {
                    return column.discourageAggregationAcrossGroups;
                });
                if (objects) {
                    defaultSettings.general.outlineColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.general.outlineColor, defaultSettings.general.outlineColor), 
                    defaultSettings.general.outlineWeight = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.outlineWeight, defaultSettings.general.outlineWeight), 
                    defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.orientation, defaultSettings.general.orientation), 
                    defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.show, defaultSettings.header.show), 
                    defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.fontColor, defaultSettings.header.fontColor);
                    var headerBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.background);
                    headerBackground && (defaultSettings.header.background = headerBackground), defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.outline, defaultSettings.header.outline), 
                    defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.textSize, defaultSettings.header.textSize), 
                    defaultSettings.slicerText.color = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.fontColor, defaultSettings.slicerText.color);
                    var textBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.background);
                    textBackground && (defaultSettings.slicerText.background = textBackground), defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.outline, defaultSettings.slicerText.outline), 
                    defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.textSize, defaultSettings.slicerText.textSize), 
                    defaultSettings.selection.selectAllCheckboxEnabled = !forceSingleSelect && powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.selectAllCheckboxEnabled, defaultSettings.selection.selectAllCheckboxEnabled), 
                    defaultSettings.selection.singleSelect = forceSingleSelect || powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.singleSelect, defaultSettings.selection.singleSelect);
                }
                return defaultSettings;
            }
            DataConversion.convert = convert;
        }(DataConversion = visuals.DataConversion || (visuals.DataConversion = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var shapes = powerbi.visuals.shapes;
    !function(RectOrientation) {
        RectOrientation[RectOrientation.None = 0] = "None", RectOrientation[RectOrientation.VerticalBottomTop = 1] = "VerticalBottomTop", 
        RectOrientation[RectOrientation.VerticalTopBottom = 2] = "VerticalTopBottom", RectOrientation[RectOrientation.HorizontalLeftRight = 3] = "HorizontalLeftRight", 
        RectOrientation[RectOrientation.HorizontalRightLeft = 4] = "HorizontalRightLeft";
    }(powerbi.RectOrientation || (powerbi.RectOrientation = {}));
    var RectOrientation = powerbi.RectOrientation;
    !function(OutsidePlacement) {
        OutsidePlacement[OutsidePlacement.Allowed = 0] = "Allowed", OutsidePlacement[OutsidePlacement.Disallowed = 1] = "Disallowed", 
        OutsidePlacement[OutsidePlacement.Partial = 2] = "Partial";
    }(powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
    var OutsidePlacement = powerbi.OutsidePlacement, DataLabelManager = function() {
        function DataLabelManager() {
            this.movingStep = 3, this.hideOverlapped = !0, this.defaultDataLabelSettings = {
                anchorMargin: DataLabelManager.DefaultAnchorMargin,
                anchorRectOrientation: RectOrientation.None,
                contentPosition: 128,
                outsidePlacement: OutsidePlacement.Disallowed,
                maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
                minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
                validContentPositions: 128,
                opacity: 1
            };
        }
        return Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
            get: function() {
                return this.defaultDataLabelSettings;
            },
            enumerable: !0,
            configurable: !0
        }), DataLabelManager.prototype.hideCollidedLabels = function(viewport, data, layout, addTransform) {
            void 0 === addTransform && (addTransform = !1);
            var arrangeGrid = new DataLabelArrangeGrid(viewport, data, layout), filteredData = [], transform = {
                x: 0,
                y: 0
            };
            addTransform && (transform.x = viewport.width / 2, transform.y = viewport.height / 2);
            for (var i = 0, len = data.length; len > i; i++) if (layout.filter(data[i])) {
                var info = this.getLabelInfo(data[i]);
                info.anchorPoint = {
                    x: layout.labelLayout.x(data[i]) + transform.x,
                    y: layout.labelLayout.y(data[i]) + transform.y
                };
                var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
                DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, viewport) && (data[i].labelX = position.left - transform.x, 
                data[i].labelY = position.top - transform.y, arrangeGrid.add(info, position), filteredData.push(data[i]));
            }
            return filteredData;
        }, DataLabelManager.prototype.getLabelInfo = function(source) {
            var settings = this.defaultDataLabelSettings;
            return source.anchorMargin = void 0 !== source.anchorMargin ? source.anchorMargin : settings.anchorMargin, 
            source.anchorRectOrientation = void 0 !== source.anchorRectOrientation ? source.anchorRectOrientation : settings.anchorRectOrientation, 
            source.contentPosition = void 0 !== source.contentPosition ? source.contentPosition : settings.contentPosition, 
            source.maximumMovingDistance = void 0 !== source.maximumMovingDistance ? source.maximumMovingDistance : settings.maximumMovingDistance, 
            source.minimumMovingDistance = void 0 !== source.minimumMovingDistance ? source.minimumMovingDistance : settings.minimumMovingDistance, 
            source.outsidePlacement = void 0 !== source.outsidePlacement ? source.outsidePlacement : settings.outsidePlacement, 
            source.validContentPositions = void 0 !== source.validContentPositions ? source.validContentPositions : settings.validContentPositions, 
            source.opacity = void 0 !== source.opacity ? source.opacity : settings.opacity, 
            source.maximumMovingDistance += source.anchorMargin, source;
        }, DataLabelManager.prototype.calculateContentPositionFromPoint = function(anchorPoint, contentPosition, contentSize, offset) {
            var position = {
                x: 0,
                y: 0
            };
            if (anchorPoint) {
                if (void 0 !== anchorPoint.x && isFinite(anchorPoint.x)) switch (position.x = anchorPoint.x, 
                contentPosition) {
                  case 1:
                  case 8:
                  case 64:
                    position.x -= contentSize.width / 2;
                    break;

                  case 4:
                  case 32:
                  case 256:
                    position.x += contentSize.width / 2;
                }
                if (void 0 !== anchorPoint.y && isFinite(anchorPoint.y)) switch (position.y = anchorPoint.y, 
                contentPosition) {
                  case 8:
                  case 16:
                  case 32:
                    position.y -= contentSize.height / 2;
                    break;

                  case 4:
                  case 1:
                  case 2:
                    position.y -= contentSize.height;
                }
                if (void 0 !== offset && isFinite(offset)) switch (contentPosition) {
                  case 1:
                    position.x -= offset, position.y -= offset;
                    break;

                  case 8:
                    position.x -= offset;
                    break;

                  case 64:
                    position.x -= offset, position.y += offset;
                    break;

                  case 2:
                    position.y -= offset;
                    break;

                  case 16:
                    break;

                  case 128:
                    position.y += offset;
                    break;

                  case 4:
                    position.x += offset, position.y -= offset;
                    break;

                  case 32:
                    position.x += offset;
                    break;

                  case 256:
                    position.x += offset, position.y += offset;
                }
            }
            return {
                left: position.x,
                top: position.y,
                width: contentSize.width,
                height: contentSize.height
            };
        }, DataLabelManager.prototype.calculateContentPositionFromRect = function(anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
            switch (contentPosition) {
              case 512:
                return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 2048:
                return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 1024:
                return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 8192:
                return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 4096:
                return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
            }
            return {
                left: 0,
                top: 0,
                width: -1,
                height: -1
            };
        }, DataLabelManager.prototype.handleInsideCenterPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case RectOrientation.VerticalBottomTop:
              case RectOrientation.VerticalTopBottom:
                return LocationConverter.middleVertical(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalLeftRight:
              case RectOrientation.HorizontalRightLeft:
              default:
                return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
            }
        }, DataLabelManager.prototype.handleInsideEndPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case RectOrientation.VerticalBottomTop:
                return LocationConverter.topInside(contentSize, anchorRect, offset);

              case RectOrientation.VerticalTopBottom:
                return LocationConverter.bottomInside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalRightLeft:
                return LocationConverter.leftInside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalLeftRight:
              default:
                return LocationConverter.rightInside(contentSize, anchorRect, offset);
            }
        }, DataLabelManager.prototype.handleInsideBasePosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case RectOrientation.VerticalBottomTop:
                return LocationConverter.bottomInside(contentSize, anchorRect, offset);

              case RectOrientation.VerticalTopBottom:
                return LocationConverter.topInside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalRightLeft:
                return LocationConverter.rightInside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalLeftRight:
              default:
                return LocationConverter.leftInside(contentSize, anchorRect, offset);
            }
        }, DataLabelManager.prototype.handleOutsideEndPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case RectOrientation.VerticalBottomTop:
                return LocationConverter.topOutside(contentSize, anchorRect, offset);

              case RectOrientation.VerticalTopBottom:
                return LocationConverter.bottomOutside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalRightLeft:
                return LocationConverter.leftOutside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalLeftRight:
              default:
                return LocationConverter.rightOutside(contentSize, anchorRect, offset);
            }
        }, DataLabelManager.prototype.handleOutsideBasePosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case RectOrientation.VerticalBottomTop:
                return LocationConverter.bottomOutside(contentSize, anchorRect, offset);

              case RectOrientation.VerticalTopBottom:
                return LocationConverter.topOutside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalRightLeft:
                return LocationConverter.rightOutside(contentSize, anchorRect, offset);

              case RectOrientation.HorizontalLeftRight:
              default:
                return LocationConverter.leftOutside(contentSize, anchorRect, offset);
            }
        }, DataLabelManager.prototype.calculateContentPosition = function(anchoredElementInfo, contentPosition, contentSize, offset) {
            return 2048 !== contentPosition && 512 !== contentPosition && 1024 !== contentPosition && 4096 !== contentPosition && 8192 !== contentPosition ? this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset) : this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
        }, DataLabelManager.prototype.hasCollisions = function(arrangeGrid, info, position, size) {
            var rect = shapes.Rect;
            if (arrangeGrid.hasConflict(position)) return !0;
            var intersection = {
                left: 0,
                top: position.height / 2,
                width: size.width,
                height: size.height
            };
            if (intersection = rect.inflate(intersection, {
                left: DataLabelManager.InflateAmount,
                top: 0,
                right: DataLabelManager.InflateAmount,
                bottom: 0
            }), intersection = rect.intersect(intersection, position), rect.isEmpty(intersection)) return !0;
            var lessWithPrecision = powerbi.Double.lessWithPrecision;
            switch (info.outsidePlacement) {
              case OutsidePlacement.Disallowed:
                return lessWithPrecision(intersection.width, position.width) || lessWithPrecision(intersection.height, position.height / 2);

              case OutsidePlacement.Partial:
                return lessWithPrecision(intersection.width, position.width / 2) || lessWithPrecision(intersection.height, position.height / 4);
            }
            return !1;
        }, DataLabelManager.isValid = function(rect) {
            return !shapes.Rect.isEmpty(rect) && rect.width > 0 && rect.height > 0;
        }, DataLabelManager.DefaultAnchorMargin = 0, DataLabelManager.DefaultMaximumMovingDistance = 12, 
        DataLabelManager.DefaultMinimumMovingDistance = 3, DataLabelManager.InflateAmount = 5, 
        DataLabelManager;
    }();
    powerbi.DataLabelManager = DataLabelManager;
    var DataLabelArrangeGrid = function() {
        function DataLabelArrangeGrid(size, elements, layout) {
            this.grid = [], 0 !== size.width && 0 !== size.height || (this.cellSize = size, 
            this.rowCount = this.colCount = 0);
            var baseProperties = {
                fontFamily: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                fontSize: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize,
                fontWeight: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontWeight
            };
            this.cellSize = {
                width: 0,
                height: 0
            };
            for (var i = 0, len = elements.length; len > i; i++) {
                var child = elements[i];
                child.labeltext = layout.labelText(child);
                var properties = powerbi.Prototype.inherit(baseProperties);
                properties.text = child.labeltext, properties.fontSize = child.data ? child.data.labelFontSize : child.labelFontSize ? child.labelFontSize : powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize, 
                child.size = {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties)
                };
                var w = 2 * child.size.width, h = 2 * child.size.height;
                w > this.cellSize.width && (this.cellSize.width = w), h > this.cellSize.height && (this.cellSize.height = h);
            }
            0 === this.cellSize.width && (this.cellSize.width = size.width), 0 === this.cellSize.height && (this.cellSize.height = size.height), 
            this.colCount = this.getGridRowColCount(this.cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT), 
            this.rowCount = this.getGridRowColCount(this.cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT), 
            this.cellSize.width = size.width / this.colCount, this.cellSize.height = size.height / this.rowCount;
            for (var grid = this.grid, x = 0; x < this.colCount; x++) {
                grid[x] = [];
                for (var y = 0; y < this.rowCount; y++) grid[x][y] = [];
            }
        }
        return DataLabelArrangeGrid.prototype.add = function(element, rect) {
            for (var indexRect = this.getGridIndexRect(rect), grid = this.grid, x = indexRect.left; x < indexRect.right; x++) for (var y = indexRect.top; y < indexRect.bottom; y++) grid[x][y].push({
                element: element,
                rect: rect
            });
        }, DataLabelArrangeGrid.prototype.hasConflict = function(rect) {
            for (var indexRect = this.getGridIndexRect(rect), grid = this.grid, isIntersecting = shapes.Rect.isIntersecting, x = indexRect.left; x < indexRect.right; x++) for (var y = indexRect.top; y < indexRect.bottom; y++) for (var z = 0; z < grid[x][y].length; z++) {
                var item = grid[x][y][z];
                if (isIntersecting(item.rect, rect)) return !0;
            }
            return !1;
        }, DataLabelArrangeGrid.prototype.getGridRowColCount = function(step, length, minCount, maxCount) {
            return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
        }, DataLabelArrangeGrid.prototype.getGridIndexRect = function(rect) {
            var restrict = function(n, min, max) {
                return Math.min(Math.max(n, min), max);
            };
            return {
                left: restrict(Math.floor(rect.left / this.cellSize.width), 0, this.colCount),
                top: restrict(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                right: restrict(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.colCount),
                bottom: restrict(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
            };
        }, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100, 
        DataLabelArrangeGrid;
    }();
    powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
    var LocationConverter;
    !function(LocationConverter) {
        function topInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + offset,
                width: size.width,
                height: size.height
            };
        }
        function bottomInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + rect.height - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        function rightInside(size, rect, offset) {
            return {
                left: rect.left + rect.width - size.width - offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        function leftInside(size, rect, offset) {
            return {
                left: rect.left + offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        function topOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        function bottomOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + rect.height + offset,
                width: size.width,
                height: size.height
            };
        }
        function rightOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width + offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        function leftOutside(size, rect, offset) {
            return {
                left: rect.left - size.width - offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        function middleHorizontal(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2 + offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        function middleVertical(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + rect.height / 2 - size.height / 2 + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topInside = topInside, LocationConverter.bottomInside = bottomInside, 
        LocationConverter.rightInside = rightInside, LocationConverter.leftInside = leftInside, 
        LocationConverter.topOutside = topOutside, LocationConverter.bottomOutside = bottomOutside, 
        LocationConverter.rightOutside = rightOutside, LocationConverter.leftOutside = leftOutside, 
        LocationConverter.middleHorizontal = middleHorizontal, LocationConverter.middleVertical = middleVertical;
    }(LocationConverter || (LocationConverter = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var shapes = powerbi.visuals.shapes, Rect = powerbi.visuals.shapes.Rect, NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, LabelArrangeGrid = function() {
        function LabelArrangeGrid(labelDataPointsGroups, viewport) {
            this.viewport = viewport;
            for (var maxLabelWidth = 0, maxLabelHeight = 0, _i = 0, labelDataPointsGroups_1 = labelDataPointsGroups; _i < labelDataPointsGroups_1.length; _i++) for (var labelDataPointsGroup = labelDataPointsGroups_1[_i], _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                var labelDataPoint = _b[_a];
                if (labelDataPoint.isPreferred) {
                    var dataLabelSize = labelDataPoint.labelSize;
                    dataLabelSize.width > maxLabelWidth && (maxLabelWidth = dataLabelSize.width), dataLabelSize.height > maxLabelHeight && (maxLabelHeight = dataLabelSize.height);
                }
            }
            0 === maxLabelWidth && (maxLabelWidth = viewport.width), 0 === maxLabelHeight && (maxLabelHeight = viewport.height);
            var cellSize = this.cellSize = {
                width: maxLabelWidth * LabelArrangeGrid.cellSizeMultiplier,
                height: maxLabelHeight * LabelArrangeGrid.cellSizeMultiplier
            };
            this.columnCount = LabelArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100), 
            this.rowCount = LabelArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            for (var grid = [], i = 0, ilen = this.columnCount; ilen > i; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; jlen > j; j++) grid[i][j] = [];
            }
            this.grid = grid;
        }
        return LabelArrangeGrid.prototype.add = function(rect) {
            for (var containingIndexRect = this.getContainingGridSubsection(rect), x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) this.grid[x][y].push(rect);
        }, LabelArrangeGrid.prototype.hasConflict = function(rect) {
            return this.isWithinGridViewport(rect) ? this.hasCollision(rect) : !0;
        }, LabelArrangeGrid.prototype.tryPositionInViewport = function(rect) {
            return this.isCloseToGridViewport(rect) ? (this.isWithinGridViewport(rect) || (rect = this.tryMoveInsideViewport(rect)), 
            rect && !this.hasCollision(rect) ? rect : void 0) : void 0;
        }, LabelArrangeGrid.prototype.hasCollision = function(rect) {
            for (var containingIndexRect = this.getContainingGridSubsection(rect), grid = this.grid, isIntersecting = shapes.Rect.isIntersecting, x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                var currentGridRect = _a[_i];
                if (isIntersecting(currentGridRect, rect)) return !0;
            }
            return !1;
        }, LabelArrangeGrid.prototype.isWithinGridViewport = function(rect) {
            return rect.left >= 0 && rect.top >= 0 && rect.left + rect.width <= this.viewport.width && rect.top + rect.height <= this.viewport.height;
        }, LabelArrangeGrid.prototype.isCloseToGridViewport = function(rect) {
            return rect.left + rect.width >= 0 - rect.width && rect.top + rect.height >= -rect.height && rect.left <= this.viewport.width + rect.width && rect.top <= this.viewport.height + rect.height;
        }, LabelArrangeGrid.prototype.tryMoveInsideViewport = function(rect) {
            var result = Rect.clone(rect), viewport = this.viewport;
            return rect.width > viewport.width || rect.height > viewport.height ? void 0 : (rect.left < 0 ? result.left = 0 : rect.left + rect.width > viewport.width && (result.left -= rect.left + rect.width - viewport.width), 
            rect.top < 0 ? result.top = 0 : rect.top + rect.height > viewport.height && (result.top -= rect.top + rect.height - viewport.height), 
            result);
        }, LabelArrangeGrid.prototype.getContainingGridSubsection = function(rect) {
            return {
                xMin: LabelArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
            };
        }, LabelArrangeGrid.getCellCount = function(step, length, minCount, maxCount) {
            return LabelArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        }, LabelArrangeGrid.bound = function(value, min, max) {
            return Math.max(Math.min(value, max), min);
        }, LabelArrangeGrid.cellSizeMultiplier = 2, LabelArrangeGrid;
    }();
    powerbi.LabelArrangeGrid = LabelArrangeGrid;
    var LabelLayout = function() {
        function LabelLayout(options) {
            this.startingOffset = options.startingOffset, this.maximumOffset = options.maximumOffset, 
            null != options.offsetIterationDelta ? this.offsetIterationDelta = options.offsetIterationDelta : this.offsetIterationDelta = LabelLayout.defaultOffsetIterationDelta, 
            null != options.horizontalPadding ? this.horizontalPadding = options.horizontalPadding : this.horizontalPadding = LabelLayout.defaultHorizontalPadding, 
            null != options.verticalPadding ? this.verticalPadding = options.verticalPadding : this.verticalPadding = LabelLayout.defaultVerticalPadding, 
            this.allowLeaderLines = !!options.allowLeaderLines, this.attemptToMoveLabelsIntoViewport = !!options.attemptToMoveLabelsIntoViewport;
        }
        return LabelLayout.prototype.layout = function(labelDataPointsGroups, viewport) {
            for (var _i = 0, labelDataPointsGroups_2 = labelDataPointsGroups; _i < labelDataPointsGroups_2.length; _i++) for (var labelDataPointsGroup = labelDataPointsGroups_2[_i], _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                var labelPoint = _b[_a];
                labelPoint.hasBeenRendered = !1, labelPoint.hasBackground ? labelPoint.labelSize = {
                    width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                    height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding
                } : labelPoint.labelSize = labelPoint.textSize;
            }
            for (var resultingDataLabels = [], grid = new LabelArrangeGrid(labelDataPointsGroups, viewport), _c = 0, labelDataPointsGroups_3 = labelDataPointsGroups; _c < labelDataPointsGroups_3.length; _c++) {
                for (var labelDataPointsGroup = labelDataPointsGroups_3[_c], maxLabelsToRender = labelDataPointsGroup.maxNumberOfLabels, labelDataPoints = _.clone(labelDataPointsGroup.labelDataPoints), preferredLabels = [], j = labelDataPoints.length - 1, localMax = maxLabelsToRender; j >= 0 && localMax > 0; j--) {
                    var labelPoint = labelDataPoints[j];
                    labelPoint.isPreferred && (preferredLabels.unshift(labelDataPoints.splice(j, 1)[0]), 
                    localMax--);
                }
                if (preferredLabels.length > 0) {
                    var positionedLabels = this.positionDataLabels(preferredLabels, viewport, grid, maxLabelsToRender);
                    maxLabelsToRender -= positionedLabels.length, resultingDataLabels = resultingDataLabels.concat(positionedLabels);
                }
                if (labelDataPoints.length > 0) {
                    var labels = this.positionDataLabels(labelDataPoints, viewport, grid, maxLabelsToRender);
                    resultingDataLabels = resultingDataLabels.concat(labels);
                }
            }
            return resultingDataLabels;
        }, LabelLayout.prototype.positionDataLabels = function(labelDataPoints, viewport, grid, maxLabelsToRender) {
            for (var drawLeaderLinesOnIteration, resultingDataLabels = [], offsetDelta = this.offsetIterationDelta, currentOffset = this.startingOffset, currentCenteredOffset = 0; currentOffset <= this.maximumOffset && maxLabelsToRender > 0; ) {
                drawLeaderLinesOnIteration = this.allowLeaderLines && currentOffset > this.startingOffset;
                for (var _i = 0, labelDataPoints_2 = labelDataPoints; _i < labelDataPoints_2.length; _i++) {
                    var labelPoint = labelDataPoints_2[_i];
                    if (0 === maxLabelsToRender) break;
                    if (!labelPoint.hasBeenRendered) {
                        var dataLabel = void 0;
                        dataLabel = 1 === labelPoint.parentType ? this.tryPositionForRectPositions(labelPoint, grid, currentOffset, currentCenteredOffset) : this.tryPositionForPointPositions(labelPoint, grid, currentOffset, drawLeaderLinesOnIteration), 
                        dataLabel && (resultingDataLabels.push(dataLabel), maxLabelsToRender--);
                    }
                }
                currentOffset += offsetDelta, currentCenteredOffset += offsetDelta;
            }
            return resultingDataLabels;
        }, LabelLayout.prototype.tryPositionForRectPositions = function(labelPoint, grid, currentLabelOffset, currentCenteredLabelOffset) {
            for (var _this = this, tryPosition = function(position, adjustForViewport) {
                var isPositionInside = 7 & position;
                if (!isPositionInside || DataLabelRectPositioner.canFitWithinParent(labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
                    var resultingBoundingBox = LabelLayout.tryPositionRect(grid, position, labelPoint, currentLabelOffset, currentCenteredLabelOffset, adjustForViewport);
                    if (resultingBoundingBox) {
                        if (isPositionInside && !DataLabelRectPositioner.isLabelWithinParent(resultingBoundingBox, labelPoint, _this.horizontalPadding, _this.verticalPadding)) return;
                        return grid.add(resultingBoundingBox), labelPoint.hasBeenRendered = !0, {
                            boundingBox: resultingBoundingBox,
                            text: labelPoint.text,
                            tooltip: labelPoint.tooltip,
                            isVisible: !0,
                            fill: isPositionInside ? labelPoint.insideFill : labelPoint.outsideFill,
                            identity: labelPoint.identity,
                            key: labelPoint.key,
                            fontSize: labelPoint.fontSize,
                            selected: !1,
                            hasBackground: !!labelPoint.hasBackground
                        };
                    }
                }
            }, _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                var position = _a[_i], label = tryPosition(position, !1);
                if (label) return label;
            }
            if (this.attemptToMoveLabelsIntoViewport) for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                var position = _c[_b], label = tryPosition(position, !0);
                if (label) return label;
            }
            return null;
        }, LabelLayout.tryPositionRect = function(grid, position, labelDataPoint, offset, centerOffset, adjustForViewport) {
            var offsetForPosition = offset;
            1 & position && (offsetForPosition = centerOffset);
            var labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, offsetForPosition);
            if (1 !== position || 0 === labelDataPoint.parentShape.orientation) {
                if (!grid.hasConflict(labelRect)) return labelRect;
                if (adjustForViewport) return grid.tryPositionInViewport(labelRect);
            } else {
                if (!grid.hasConflict(labelRect)) return labelRect;
                if (labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, -offsetForPosition), 
                !grid.hasConflict(labelRect)) return labelRect;
            }
            return null;
        }, LabelLayout.prototype.tryPositionForPointPositions = function(labelPoint, grid, currentLabelOffset, drawLeaderLines) {
            for (var tryPosition = function(position, parentShape, adjustForViewport) {
                var resultingBoundingBox = LabelLayout.tryPositionPoint(grid, position, labelPoint, currentLabelOffset, adjustForViewport);
                return resultingBoundingBox ? (grid.add(resultingBoundingBox), labelPoint.hasBeenRendered = !0, 
                {
                    boundingBox: resultingBoundingBox,
                    text: labelPoint.text,
                    tooltip: labelPoint.tooltip,
                    isVisible: !0,
                    fill: 256 === position ? labelPoint.insideFill : labelPoint.outsideFill,
                    isInsideParent: 256 === position,
                    identity: labelPoint.identity,
                    key: labelPoint.key,
                    fontSize: labelPoint.fontSize,
                    selected: !1,
                    leaderLinePoints: drawLeaderLines ? DataLabelPointPositioner.getLabelLeaderLineEndingPoint(resultingBoundingBox, position, parentShape) : null,
                    hasBackground: !!labelPoint.hasBackground
                }) : void 0;
            }, parentShape = labelPoint.parentShape, validPositions = parentShape.validPositions, _i = 0, validPositions_1 = validPositions; _i < validPositions_1.length; _i++) {
                var position = validPositions_1[_i], label = tryPosition(position, parentShape, !1);
                if (label) return label;
            }
            if (this.attemptToMoveLabelsIntoViewport && !_.isEmpty(validPositions)) {
                var label = tryPosition(validPositions[0], parentShape, !0);
                if (label) return label;
            }
            return null;
        }, LabelLayout.tryPositionPoint = function(grid, position, labelDataPoint, offset, adjustForViewport) {
            var labelRect = DataLabelPointPositioner.getLabelRect(labelDataPoint.labelSize, labelDataPoint.parentShape, position, offset);
            return grid.hasConflict(labelRect) ? adjustForViewport ? grid.tryPositionInViewport(labelRect) : null : labelRect;
        }, LabelLayout.defaultOffsetIterationDelta = 2, LabelLayout.defaultHorizontalPadding = 2, 
        LabelLayout.defaultVerticalPadding = 2, LabelLayout;
    }();
    powerbi.LabelLayout = LabelLayout;
    var DataLabelRectPositioner;
    !function(DataLabelRectPositioner) {
        function getLabelRect(labelDataPoint, position, offset) {
            var parentRect = labelDataPoint.parentShape;
            if (null != parentRect) switch (position) {
              case 1:
                switch (parentRect.orientation) {
                  case 1:
                  case 2:
                    return DataLabelRectPositioner.middleVertical(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 3:
                  case 4:
                    return DataLabelRectPositioner.middleHorizontal(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 0:                }

              case 2:
                switch (parentRect.orientation) {
                  case 1:
                    return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 2:
                    return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 3:
                    return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 4:
                    return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 0:                }

              case 4:
                switch (parentRect.orientation) {
                  case 1:
                    return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 2:
                    return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 3:
                    return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 4:
                    return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 0:                }

              case 8:
                switch (parentRect.orientation) {
                  case 1:
                    return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 2:
                    return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 3:
                    return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 4:
                    return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 0:                }

              case 16:
                switch (parentRect.orientation) {
                  case 1:
                    return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 2:
                    return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 3:
                    return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 4:
                    return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                  case 0:                }
            }
            return null;
        }
        function canFitWithinParent(labelDataPoint, horizontalPadding, verticalPadding) {
            return labelDataPoint.labelSize.width + 2 * horizontalPadding < labelDataPoint.parentShape.rect.width || labelDataPoint.labelSize.height + 2 * verticalPadding < labelDataPoint.parentShape.rect.height;
        }
        function isLabelWithinParent(labelRect, labelPoint, horizontalPadding, verticalPadding) {
            var parentRect = labelPoint.parentShape.rect, labelRectWithPadding = shapes.Rect.inflate(labelRect, {
                left: horizontalPadding,
                right: horizontalPadding,
                top: verticalPadding,
                bottom: verticalPadding
            });
            return shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left,
                y: labelRectWithPadding.top
            }) && shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left + labelRectWithPadding.width,
                y: labelRectWithPadding.top + labelRectWithPadding.height
            });
        }
        function topInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                top: parentRect.top + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function bottomInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                top: parentRect.top + parentRect.height - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function rightInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function leftInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + offset,
                top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function topOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                top: parentRect.top - labelSize.height - offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function bottomOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                top: parentRect.top + parentRect.height + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function rightOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width + offset,
                top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function leftOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function middleHorizontal(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2 - labelSize.width / 2 + offset,
                top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function middleVertical(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                top: parentRect.top + parentRect.height / 2 - labelSize.height / 2 + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.getLabelRect = getLabelRect, DataLabelRectPositioner.canFitWithinParent = canFitWithinParent, 
        DataLabelRectPositioner.isLabelWithinParent = isLabelWithinParent, DataLabelRectPositioner.topInside = topInside, 
        DataLabelRectPositioner.bottomInside = bottomInside, DataLabelRectPositioner.rightInside = rightInside, 
        DataLabelRectPositioner.leftInside = leftInside, DataLabelRectPositioner.topOutside = topOutside, 
        DataLabelRectPositioner.bottomOutside = bottomOutside, DataLabelRectPositioner.rightOutside = rightOutside, 
        DataLabelRectPositioner.leftOutside = leftOutside, DataLabelRectPositioner.middleHorizontal = middleHorizontal, 
        DataLabelRectPositioner.middleVertical = middleVertical;
    }(DataLabelRectPositioner = powerbi.DataLabelRectPositioner || (powerbi.DataLabelRectPositioner = {}));
    var DataLabelPointPositioner;
    !function(DataLabelPointPositioner) {
        function getLabelRect(labelSize, parentPoint, position, offset) {
            switch (position) {
              case 1:
                return DataLabelPointPositioner.above(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 2:
                return DataLabelPointPositioner.below(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 4:
                return DataLabelPointPositioner.left(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 8:
                return DataLabelPointPositioner.right(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 32:
                return DataLabelPointPositioner.belowLeft(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 16:
                return DataLabelPointPositioner.belowRight(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 128:
                return DataLabelPointPositioner.aboveLeft(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 64:
                return DataLabelPointPositioner.aboveRight(labelSize, parentPoint.point, parentPoint.radius + offset);

              case 256:
                return DataLabelPointPositioner.center(labelSize, parentPoint.point);
            }
            return null;
        }
        function above(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - labelSize.width / 2,
                top: parentPoint.y - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function below(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - labelSize.width / 2,
                top: parentPoint.y + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function left(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - offset - labelSize.width,
                top: parentPoint.y - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function right(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + offset,
                top: parentPoint.y - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function belowLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - DataLabelPointPositioner.sin45 * offset - labelSize.width,
                top: parentPoint.y + DataLabelPointPositioner.cos45 * offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function belowRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + DataLabelPointPositioner.sin45 * offset,
                top: parentPoint.y + DataLabelPointPositioner.cos45 * offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function aboveLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - DataLabelPointPositioner.sin45 * offset - labelSize.width,
                top: parentPoint.y - DataLabelPointPositioner.cos45 * offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function aboveRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + DataLabelPointPositioner.sin45 * offset,
                top: parentPoint.y - DataLabelPointPositioner.cos45 * offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function center(labelSize, parentPoint) {
            return {
                left: parentPoint.x - labelSize.width / 2,
                top: parentPoint.y - labelSize.height / 2,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        function getLabelLeaderLineEndingPoint(boundingBox, position, parentShape) {
            var x = boundingBox.left, y = boundingBox.top;
            switch (position) {
              case 1:
                x += boundingBox.width / 2, y += boundingBox.height;
                break;

              case 2:
                x += boundingBox.width / 2;
                break;

              case 4:
                x += boundingBox.width, y += 2 * boundingBox.height / 3;
                break;

              case 8:
                y += 2 * boundingBox.height / 3;
                break;

              case 32:
                x += boundingBox.width, y += boundingBox.height / 2;
                break;

              case 16:
                y += boundingBox.height / 2;
                break;

              case 128:
                x += boundingBox.width, y += boundingBox.height;
                break;

              case 64:
                y += boundingBox.height;
            }
            return [ [ parentShape.point.x, parentShape.point.y ], [ x, y ] ];
        }
        DataLabelPointPositioner.cos45 = Math.cos(45), DataLabelPointPositioner.sin45 = Math.sin(45), 
        DataLabelPointPositioner.getLabelRect = getLabelRect, DataLabelPointPositioner.above = above, 
        DataLabelPointPositioner.below = below, DataLabelPointPositioner.left = left, DataLabelPointPositioner.right = right, 
        DataLabelPointPositioner.belowLeft = belowLeft, DataLabelPointPositioner.belowRight = belowRight, 
        DataLabelPointPositioner.aboveLeft = aboveLeft, DataLabelPointPositioner.aboveRight = aboveRight, 
        DataLabelPointPositioner.center = center, DataLabelPointPositioner.getLabelLeaderLineEndingPoint = getLabelLeaderLineEndingPoint;
    }(DataLabelPointPositioner = powerbi.DataLabelPointPositioner || (powerbi.DataLabelPointPositioner = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var DateTimeSequence = function() {
        function DateTimeSequence(unit) {
            this.unit = unit, this.sequence = [], this.min = new Date("9999-12-31T23:59:59.999"), 
            this.max = new Date("0001-01-01T00:00:00.000");
        }
        return DateTimeSequence.prototype.add = function(date) {
            date < this.min && (this.min = date), date > this.max && (this.max = date), this.sequence.push(date);
        }, DateTimeSequence.prototype.extendToCover = function(min, max) {
            for (var x = this.min; x > min; ) x = DateTimeSequence.addInterval(x, -this.interval, this.unit), 
            this.sequence.splice(0, 0, x);
            for (this.min = x, x = this.max; max > x; ) x = DateTimeSequence.addInterval(x, this.interval, this.unit), 
            this.sequence.push(x);
            this.max = x;
        }, DateTimeSequence.prototype.moveToCover = function(min, max) {
            var delta = DateTimeSequence.getDelta(min, max, this.unit), count = Math.floor(delta / this.interval);
            for (this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit), 
            this.sequence = [], this.sequence.push(this.min), this.max = this.min; this.max < max; ) this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit), 
            this.sequence.push(this.max);
        }, DateTimeSequence.calculate = function(dataMin, dataMax, expectedCount, unit) {
            switch (unit || (unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount)), 
            unit) {
              case powerbi.DateTimeUnit.Year:
                return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);

              case powerbi.DateTimeUnit.Month:
                return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);

              case powerbi.DateTimeUnit.Week:
                return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);

              case powerbi.DateTimeUnit.Day:
                return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);

              case powerbi.DateTimeUnit.Hour:
                return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);

              case powerbi.DateTimeUnit.Minute:
                return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);

              case powerbi.DateTimeUnit.Second:
                return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);

              case powerbi.DateTimeUnit.Millisecond:
                return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);
            }
        }, DateTimeSequence.calculateYears = function(dataMin, dataMax, expectedCount) {
            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), !1), sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [ 1, 2, 5 ]), newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval, date = new Date(newMinYear, 0, 1), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);
            return result;
        }, DateTimeSequence.calculateMonths = function(dataMin, dataMax, expectedCount) {
            var minYear = dataMin.getFullYear(), maxYear = dataMax.getFullYear(), minMonth = dataMin.getMonth(), maxMonth = 12 * (maxYear - minYear) + dataMax.getMonth(), date = new Date(minYear, 0, 1), sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [ 1, 2, 3, 6, 12 ]), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);
            return result;
        }, DateTimeSequence.calculateWeeks = function(dataMin, dataMax, expectedCount) {
            var firstDayOfWeek = 0, minDayOfWeek = dataMin.getDay(), dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7, minDay = dataMin.getDate() - dayOffset, date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay), min = 0, max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week)), sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 4, 8 ]), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);
            return result;
        }, DateTimeSequence.calculateDays = function(dataMin, dataMax, expectedCount) {
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate()), min = 0, max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day)), sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 7, 14 ]), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);
            return result;
        }, DateTimeSequence.calculateHours = function(dataMin, dataMax, expectedCount) {
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate()), min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour)), max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour)), sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 3, 6, 12, 24 ]), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);
            return result;
        }, DateTimeSequence.calculateMinutes = function(dataMin, dataMax, expectedCount) {
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours()), min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute)), max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute)), sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 5, 10, 15, 30, 60, 120, 180, 360, 720, 1440 ]), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);
            return result;
        }, DateTimeSequence.calculateSeconds = function(dataMin, dataMax, expectedCount) {
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes()), min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second)), max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second)), sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600 ]), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);
            return result;
        }, DateTimeSequence.calculateMilliseconds = function(dataMin, dataMax, expectedCount) {
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds()), min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond), max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond), sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0), result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);
            return result;
        }, DateTimeSequence.fromNumericSequence = function(date, sequence, unit) {
            for (var result = new DateTimeSequence(unit), i = 0; i < sequence.sequence.length; i++) {
                var x = sequence.sequence[i], d = DateTimeSequence.addInterval(date, x, unit);
                result.add(d);
            }
            return result.interval = sequence.interval, result.intervalOffset = sequence.intervalOffset, 
            result;
        }, DateTimeSequence.addInterval = function(value, interval, unit) {
            switch (interval = Math.round(interval), unit) {
              case powerbi.DateTimeUnit.Year:
                return DateUtils.addYears(value, interval);

              case powerbi.DateTimeUnit.Month:
                return DateUtils.addMonths(value, interval);

              case powerbi.DateTimeUnit.Week:
                return DateUtils.addWeeks(value, interval);

              case powerbi.DateTimeUnit.Day:
                return DateUtils.addDays(value, interval);

              case powerbi.DateTimeUnit.Hour:
                return DateUtils.addHours(value, interval);

              case powerbi.DateTimeUnit.Minute:
                return DateUtils.addMinutes(value, interval);

              case powerbi.DateTimeUnit.Second:
                return DateUtils.addSeconds(value, interval);

              case powerbi.DateTimeUnit.Millisecond:
                return DateUtils.addMilliseconds(value, interval);
            }
        }, DateTimeSequence.getDelta = function(min, max, unit) {
            var delta = 0;
            switch (unit) {
              case powerbi.DateTimeUnit.Year:
                delta = max.getFullYear() - min.getFullYear();
                break;

              case powerbi.DateTimeUnit.Month:
                delta = 12 * (max.getFullYear() - min.getFullYear()) + max.getMonth() - min.getMonth();
                break;

              case powerbi.DateTimeUnit.Week:
                delta = (max.getTime() - min.getTime()) / 6048e5;
                break;

              case powerbi.DateTimeUnit.Day:
                delta = (max.getTime() - min.getTime()) / 864e5;
                break;

              case powerbi.DateTimeUnit.Hour:
                delta = (max.getTime() - min.getTime()) / 36e5;
                break;

              case powerbi.DateTimeUnit.Minute:
                delta = (max.getTime() - min.getTime()) / 6e4;
                break;

              case powerbi.DateTimeUnit.Second:
                delta = (max.getTime() - min.getTime()) / 1e3;
                break;

              case powerbi.DateTimeUnit.Millisecond:
                delta = max.getTime() - min.getTime();
            }
            return delta;
        }, DateTimeSequence.getIntervalUnit = function(min, max, maxCount) {
            maxCount = Math.max(maxCount, 2);
            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);
            if (totalDays > 356 && totalDays >= 180 * maxCount) return powerbi.DateTimeUnit.Year;
            if (totalDays > 60 && totalDays > 7 * maxCount) return powerbi.DateTimeUnit.Month;
            if (totalDays > 14 && totalDays > 2 * maxCount) return powerbi.DateTimeUnit.Week;
            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);
            if (totalDays > 2 && totalHours > 12 * maxCount) return powerbi.DateTimeUnit.Day;
            if (totalHours >= 24 && totalHours >= maxCount) return powerbi.DateTimeUnit.Hour;
            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);
            if (totalMinutes > 2 && totalMinutes >= maxCount) return powerbi.DateTimeUnit.Minute;
            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);
            if (totalSeconds > 2 && totalSeconds >= .8 * maxCount) return powerbi.DateTimeUnit.Second;
            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);
            if (totalMilliseconds > 0) return powerbi.DateTimeUnit.Millisecond;
            var date = min;
            return 0 !== date.getMilliseconds() ? powerbi.DateTimeUnit.Millisecond : 0 !== date.getSeconds() ? powerbi.DateTimeUnit.Second : 0 !== date.getMinutes() ? powerbi.DateTimeUnit.Minute : 0 !== date.getHours() ? powerbi.DateTimeUnit.Hour : 1 !== date.getDate() ? powerbi.DateTimeUnit.Day : 0 !== date.getMonth() ? powerbi.DateTimeUnit.Month : powerbi.DateTimeUnit.Year;
        }, DateTimeSequence.MIN_COUNT = 1, DateTimeSequence.MAX_COUNT = 1e3, DateTimeSequence;
    }();
    powerbi.DateTimeSequence = DateTimeSequence;
    var DateUtils;
    !function(DateUtils) {
        function isLeap(year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function getMonthDays(year, month) {
            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];
        }
        function addYears(date, yearDelta) {
            var year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), isLeapDay = 2 === month && 29 === day, result = new Date(date.getTime());
            return year += yearDelta, isLeapDay && !isLeap(year) && (day = 28), result.setFullYear(year, month, day), 
            result;
        }
        function addMonths(date, monthDelta) {
            var year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), result = new Date(date.getTime());
            return year += (monthDelta - monthDelta % 12) / 12, month += monthDelta % 12, month > 11 && (month %= 12, 
            year++), day = Math.min(day, getMonthDays(year, month)), result.setFullYear(year, month, day), 
            result;
        }
        function addWeeks(date, weeks) {
            return addDays(date, 7 * weeks);
        }
        function addDays(date, days) {
            var year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), result = new Date(date.getTime());
            return result.setFullYear(year, month, day + days), result;
        }
        function addHours(date, hours) {
            return new Date(date.getTime() + 36e5 * hours);
        }
        function addMinutes(date, minutes) {
            return new Date(date.getTime() + 6e4 * minutes);
        }
        function addSeconds(date, seconds) {
            return new Date(date.getTime() + 1e3 * seconds);
        }
        function addMilliseconds(date, milliseconds) {
            return new Date(date.getTime() + milliseconds);
        }
        var MonthDays = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ], MonthDaysLeap = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
        DateUtils.addYears = addYears, DateUtils.addMonths = addMonths, DateUtils.addWeeks = addWeeks, 
        DateUtils.addDays = addDays, DateUtils.addHours = addHours, DateUtils.addMinutes = addMinutes, 
        DateUtils.addSeconds = addSeconds, DateUtils.addMilliseconds = addMilliseconds;
    }(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {
        for (var units = [], i = 3; maxExponent > i; i++) {
            var names = unitLookup(i);
            names && addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);
        }
        return units;
    }
    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {
        if (title || labelFormat) {
            var min = value;
            if (units.length > 0) {
                var previousUnit = units[units.length - 1];
                adjustMinBasedOnPreviousUnit && (min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min)), 
                previousUnit.applicableRangeMax = min;
            }
            var unit = new DisplayUnit();
            unit.value = value, unit.applicableRangeMin = min, unit.applicableRangeMax = 1e3 * min, 
            unit.title = title, unit.labelFormat = labelFormat, units.push(unit);
        }
    }
    var maxExponent = 24, defaultScientificBigNumbersBoundary = 1e15, scientificSmallNumbersBoundary = 1e-4, PERCENTAGE_FORMAT = "%", SCIENTIFIC_FORMAT = "E+0", DEFAULT_SCIENTIFIC_FORMAT = "0.##" + SCIENTIFIC_FORMAT, SUPPORTED_SCIENTIFIC_FORMATS = /^([0\#,]*\.[0\#]+|[0\#,]+|g)$/i, DisplayUnit = function() {
        function DisplayUnit() {}
        return DisplayUnit.prototype.project = function(value) {
            return this.value ? powerbi.Double.removeDecimalNoise(value / this.value) : value;
        }, DisplayUnit.prototype.reverseProject = function(value) {
            return this.value ? value * this.value : value;
        }, DisplayUnit.prototype.isApplicableTo = function(value) {
            value = Math.abs(value);
            var precision = powerbi.Double.getPrecision(value, 3);
            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);
        }, DisplayUnit.prototype.isScaling = function() {
            return this.value > 1;
        }, DisplayUnit;
    }();
    powerbi.DisplayUnit = DisplayUnit;
    var DisplayUnitSystem = function() {
        function DisplayUnitSystem(units) {
            this.units = units ? units : [];
        }
        return Object.defineProperty(DisplayUnitSystem.prototype, "title", {
            get: function() {
                return this.displayUnit ? this.displayUnit.title : void 0;
            },
            enumerable: !0,
            configurable: !0
        }), DisplayUnitSystem.prototype.update = function(value) {
            void 0 !== value && (this.unitBaseValue = value, this.displayUnit = this.findApplicableDisplayUnit(value));
        }, DisplayUnitSystem.prototype.findApplicableDisplayUnit = function(value) {
            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {
                var unit = _a[_i];
                if (unit.isApplicableTo(value)) return unit;
            }
        }, DisplayUnitSystem.prototype.format = function(value, format, decimals, trailingZeros) {
            if (this.isFormatSupported(format)) {
                if (decimals = this.getNumberOfDecimalsForFormatting(format, decimals), this.hasScientitifcFormat(format)) return this.formatHelper(value, "", format, decimals, trailingZeros);
                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);
                if (null != decimals) return this.formatHelper(value, "", format, decimals, trailingZeros);
            }
            return powerbi.formattingService.formatValue(value, format);
        }, DisplayUnitSystem.prototype.isFormatSupported = function(format) {
            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        }, DisplayUnitSystem.prototype.isPercentageFormat = function(format) {
            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;
        }, DisplayUnitSystem.prototype.shouldRespectScalingUnit = function(format) {
            return !this.isPercentageFormat(format);
        }, DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function(format, decimals) {
            return decimals;
        }, DisplayUnitSystem.prototype.isScalingUnit = function() {
            return this.displayUnit && this.displayUnit.isScaling();
        }, DisplayUnitSystem.prototype.formatHelper = function(value, nonScientificFormat, format, decimals, trailingZeros) {
            if ("g" !== format && "G" !== format || null == decimals || (format = powerbi.visuals.valueFormatter.DefaultNumericFormat), 
            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros), 
            format && !powerbi.formattingService.isStandardNumberFormat(format)) return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);
            format || (format = "G"), nonScientificFormat || (nonScientificFormat = "{0}");
            var text = powerbi.formattingService.formatValue(value, format);
            return powerbi.formattingService.format(nonScientificFormat, [ text ]);
        }, DisplayUnitSystem.prototype.formatSingleValue = function(value, format, decimals, trailingZeros) {
            return this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value), 
            this.format(value, format, decimals, trailingZeros);
        }, DisplayUnitSystem.prototype.shouldUseValuePrecision = function(value) {
            if (0 === this.units.length) return !0;
            for (var applicableRangeMin = 0, i = 0; i < this.units.length; i++) if (this.units[i].isScaling()) {
                applicableRangeMin = this.units[i].applicableRangeMin;
                break;
            }
            return Math.abs(value) < applicableRangeMin;
        }, DisplayUnitSystem.prototype.isScientific = function(value) {
            return -defaultScientificBigNumbersBoundary > value || value > defaultScientificBigNumbersBoundary || value > -scientificSmallNumbersBoundary && scientificSmallNumbersBoundary > value && 0 !== value;
        }, DisplayUnitSystem.prototype.hasScientitifcFormat = function(format) {
            return format && -1 !== format.toUpperCase().indexOf("E");
        }, DisplayUnitSystem.prototype.supportsScientificFormat = function(format) {
            return format ? SUPPORTED_SCIENTIFIC_FORMATS.test(format) : !0;
        }, DisplayUnitSystem.prototype.shouldFallbackToScientific = function(value, format) {
            return !this.hasScientitifcFormat(format) && this.supportsScientificFormat(format) && this.isScientific(value);
        }, DisplayUnitSystem.prototype.getScientificFormat = function(data, format, decimals, trailingZeros) {
            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {
                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);
                return decimals && (numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : "0", Math.abs(decimals), trailingZeros)), 
                numericFormat ? numericFormat + SCIENTIFIC_FORMAT : DEFAULT_SCIENTIFIC_FORMAT;
            }
            return format;
        }, DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\d*)|(.*\%)|(e\d*)$/i, DisplayUnitSystem;
    }();
    powerbi.DisplayUnitSystem = DisplayUnitSystem;
    var NoDisplayUnitSystem = function(_super) {
        function NoDisplayUnitSystem() {
            _super.call(this, []);
        }
        return __extends(NoDisplayUnitSystem, _super), NoDisplayUnitSystem;
    }(DisplayUnitSystem);
    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;
    var DefaultDisplayUnitSystem = function(_super) {
        function DefaultDisplayUnitSystem(unitLookup) {
            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));
        }
        return __extends(DefaultDisplayUnitSystem, _super), DefaultDisplayUnitSystem.prototype.format = function(data, format, decimals, trailingZeros) {
            return format = this.getScientificFormat(data, format, decimals, trailingZeros), 
            _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        }, DefaultDisplayUnitSystem.reset = function() {
            DefaultDisplayUnitSystem.units = null;
        }, DefaultDisplayUnitSystem.getUnits = function(unitLookup) {
            return DefaultDisplayUnitSystem.units || (DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function(value, previousUnitValue, min) {
                return value - previousUnitValue >= 1e3 ? value / 10 : min;
            }), DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = 1 / 0), 
            DefaultDisplayUnitSystem.units;
        }, DefaultDisplayUnitSystem;
    }(DisplayUnitSystem);
    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;
    var WholeUnitsDisplayUnitSystem = function(_super) {
        function WholeUnitsDisplayUnitSystem(unitLookup) {
            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));
        }
        return __extends(WholeUnitsDisplayUnitSystem, _super), WholeUnitsDisplayUnitSystem.reset = function() {
            WholeUnitsDisplayUnitSystem.units = null;
        }, WholeUnitsDisplayUnitSystem.getUnits = function(unitLookup) {
            return WholeUnitsDisplayUnitSystem.units || (WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup), 
            WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = 1 / 0), 
            WholeUnitsDisplayUnitSystem.units;
        }, WholeUnitsDisplayUnitSystem.prototype.format = function(data, format, decimals, trailingZeros) {
            return format = this.getScientificFormat(data, format, decimals, trailingZeros), 
            _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        }, WholeUnitsDisplayUnitSystem;
    }(DisplayUnitSystem);
    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;
    var DataLabelsDisplayUnitSystem = function(_super) {
        function DataLabelsDisplayUnitSystem(unitLookup) {
            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));
        }
        return __extends(DataLabelsDisplayUnitSystem, _super), DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function(format) {
            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        }, DataLabelsDisplayUnitSystem.getUnits = function(unitLookup) {
            if (!DataLabelsDisplayUnitSystem.units) {
                var units = [], adjustMinBasedOnPreviousUnit = function(value, previousUnitValue, min) {
                    return -1 === value && value - previousUnitValue >= 1e3 ? value / 10 : min;
                }, names = unitLookup(-1);
                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit), 
                names = unitLookup(0), addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit), 
                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit)), 
                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = 1 / 0;
            }
            return DataLabelsDisplayUnitSystem.units;
        }, DataLabelsDisplayUnitSystem.prototype.format = function(data, format, decimals, trailingZeros) {
            return format = this.getScientificFormat(data, format, decimals, trailingZeros), 
            _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        }, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1, 
        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\d*)$/i, DataLabelsDisplayUnitSystem;
    }(DisplayUnitSystem);
    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var NumericSequence = function() {
        function NumericSequence() {}
        return NumericSequence.calculate = function(range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {
            var result = new NumericSequence();
            if (expectedCount = void 0 === expectedCount ? 10 : powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT), 
            void 0 === minPower && (minPower = powerbi.Double.MIN_EXP), void 0 === useZeroRefPoint && (useZeroRefPoint = !1), 
            void 0 === maxAllowedMargin && (maxAllowedMargin = 1), void 0 === steps && (steps = [ 1, 2, 5 ]), 
            range.forcedSingleStop) return result.interval = range.getSize(), result.intervalOffset = result.interval - (range.forcedSingleStop - range.min), 
            result.min = range.min, result.max = range.max, result.sequence = [ range.forcedSingleStop ], 
            result;
            var interval = 0, min = 0, max = 9, canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin, canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax, size = range.getSize(), exp = powerbi.Double.log10(size), stepExp = powerbi.Double.log10(steps[0]);
            exp -= stepExp;
            var expectedCountExp = powerbi.Double.log10(expectedCount);
            exp -= expectedCountExp, exp = Math.max(exp, minPower - stepExp + 1);
            var count = void 0;
            if (0 !== interval) {
                var power = powerbi.Double.pow10(exp), roundMin = powerbi.Double.floorToPrecision(range.min, power), roundMax = powerbi.Double.ceilToPrecision(range.max, power), roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);
                roundRange.shrinkByStep(range, interval), min = roundRange.min, max = roundRange.max, 
                count = Math.floor(roundRange.getSize() / interval);
            } else {
                var dexp = void 0;
                for (dexp = 0; 3 > dexp; dexp++) {
                    for (var e = exp + dexp, power = powerbi.Double.pow10(e), roundMin = powerbi.Double.floorToPrecision(range.min, power), roundMax = powerbi.Double.ceilToPrecision(range.max, power), stepsCount = steps.length, stepPower = powerbi.Double.pow10(e - 1), i = 0; stepsCount > i; i++) {
                        var step = steps[i] * stepPower, roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);
                        if (roundRange.shrinkByStep(range, step), canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1 && (roundRange.min -= step), 
                        canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1 && (roundRange.max += step), 
                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step), expectedCount >= count || 2 === dexp && i === stepsCount - 1 || 1 === expectedCount && 2 === count && (step > range.getSize() || range.min < 0 && range.max > 0 && 2 * step >= range.getSize())) {
                            interval = step, min = roundRange.min, max = roundRange.max;
                            break;
                        }
                    }
                    if (0 !== interval) break;
                }
            }
            (count > 32 * expectedCount || count > NumericSequence.MAX_COUNT) && (count = Math.min(32 * expectedCount, NumericSequence.MAX_COUNT), 
            interval = (max - min) / count), result.min = min, result.max = max, result.interval = interval, 
            result.intervalOffset = min - range.min, result.maxAllowedMargin = maxAllowedMargin, 
            result.canExtendMin = canExtendMin, result.canExtendMax = canExtendMax;
            var precision = powerbi.Double.getPrecision(interval, 0);
            result.precision = precision;
            var sequence = [], x = powerbi.Double.roundToPrecision(min, precision);
            sequence.push(x);
            for (var i = 0; count > i; i++) x = powerbi.Double.roundToPrecision(x + interval, precision), 
            sequence.push(x);
            return result.sequence = sequence, result.trimMinMax(range.min, range.max), result;
        }, NumericSequence.calculateUnits = function(min, max, maxCount, steps) {
            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT), 
            min === max && (max = min + 1);
            for (var stepCount = 0, step = 0, i = 0; i < steps.length; i++) {
                step = steps[i];
                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step), minStepCount = powerbi.Double.floorWithPrecision(min / step);
                if (stepCount = maxStepCount - minStepCount, maxCount >= stepCount) break;
            }
            var offset = -min;
            offset %= step;
            var result = new NumericSequence();
            result.sequence = [];
            for (var x = min + offset; result.sequence.push(x), !(x >= max); x += step) ;
            return result.interval = step, result.intervalOffset = offset, result.min = result.sequence[0], 
            result.max = result.sequence[result.sequence.length - 1], result;
        }, NumericSequence.prototype.trimMinMax = function(min, max) {
            var minMargin = (min - this.min) / this.interval, maxMargin = (this.max - max) / this.interval, marginPrecision = .001;
            (!this.canExtendMin || minMargin > this.maxAllowedMargin && minMargin > marginPrecision) && (this.min = min), 
            (!this.canExtendMax || maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision) && (this.max = max);
        }, NumericSequence.MIN_COUNT = 1, NumericSequence.MAX_COUNT = 1e3, NumericSequence;
    }();
    powerbi.NumericSequence = NumericSequence;
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var NumericSequenceRange = function() {
        function NumericSequenceRange() {}
        return NumericSequenceRange.prototype._ensureIncludeZero = function() {
            this.includeZero && (this.min > 0 && !this.hasFixedMin && (this.min = 0), this.max < 0 && !this.hasFixedMax && (this.max = 0));
        }, NumericSequenceRange.prototype._ensureNotEmpty = function() {
            if (this.min === this.max) if (this.min) {
                var value = this.min, exp = powerbi.Double.log10(Math.abs(value)), step = void 0;
                exp >= 0 && 4 > exp ? (step = .5, this.forcedSingleStop = value) : (step = powerbi.Double.pow10(exp) / 2, 
                this.forcedSingleStop = null), this.min = value - step, this.max = value + step;
            } else this.min = 0, this.max = NumericSequenceRange.DEFAULT_MAX, this.hasFixedMin = !0, 
            this.hasFixedMax = !0;
        }, NumericSequenceRange.prototype._ensureDirection = function() {
            if (this.min > this.max) {
                var temp = this.min;
                this.min = this.max, this.max = temp;
            }
        }, NumericSequenceRange.prototype.getSize = function() {
            return this.max - this.min;
        }, NumericSequenceRange.prototype.shrinkByStep = function(range, step) {
            var oldCount = this.min / step, newCount = range.min / step, deltaCount = Math.floor(newCount - oldCount);
            this.min += deltaCount * step, oldCount = this.max / step, newCount = range.max / step, 
            deltaCount = Math.ceil(newCount - oldCount), this.max += deltaCount * step;
        }, NumericSequenceRange.calculate = function(dataMin, dataMax, fixedMin, fixedMax, includeZero) {
            var result = new NumericSequenceRange();
            return result.includeZero = !!includeZero, result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax), 
            result.hasFixedMin = ValueUtil.hasValue(fixedMin), result.hasFixedMax = ValueUtil.hasValue(fixedMax), 
            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE), 
            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE), 
            result.hasFixedMin && result.hasFixedMax ? (result.min = fixedMin, result.max = fixedMax) : result.hasFixedMin ? (result.min = fixedMin, 
            result.max = dataMax > fixedMin ? dataMax : fixedMin) : result.hasFixedMax ? (result.min = fixedMax > dataMin ? dataMin : fixedMax, 
            result.max = fixedMax) : result.hasDataRange ? (result.min = dataMin, result.max = dataMax) : (result.min = 0, 
            result.max = 0), result._ensureIncludeZero(), result._ensureNotEmpty(), result._ensureDirection(), 
            0 === result.min ? result.hasFixedMin = !0 : 0 === result.max && (result.hasFixedMax = !0), 
            result;
        }, NumericSequenceRange.calculateDataRange = function(dataMin, dataMax, includeZero) {
            return ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax) ? NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero) : NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);
        }, NumericSequenceRange.calculateFixedRange = function(fixedMin, fixedMax, includeZero) {
            var result = new NumericSequenceRange();
            return result.hasDataRange = !1, result.includeZero = includeZero, result.min = fixedMin, 
            result.max = fixedMax, result._ensureIncludeZero(), result._ensureNotEmpty(), result._ensureDirection(), 
            result.hasFixedMin = !0, result.hasFixedMax = !0, result;
        }, NumericSequenceRange.DEFAULT_MAX = 10, NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1e307, 
        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1e307, NumericSequenceRange;
    }();
    powerbi.NumericSequenceRange = NumericSequenceRange;
    var ValueUtil;
    !function(ValueUtil) {
        function hasValue(value) {
            return void 0 !== value && null !== value;
        }
        ValueUtil.hasValue = hasValue;
    }(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var valueFormatter;
        !function(valueFormatter) {
            function beautify(format) {
                var key = BeautifiedFormat[format];
                return key ? defaultLocalizedStrings[key] || format : format;
            }
            function describeUnit(exponent) {
                var exponentLookup = -1 === exponent ? "Auto" : exponent.toString(), title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"], format = 0 >= exponent ? "{0}" : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                return title || format ? {
                    title: title,
                    format: format
                } : void 0;
            }
            function getLocalizedString(stringId) {
                return defaultLocalizedStrings[stringId];
            }
            function getFormatMetadata(format) {
                return powerbi.NumberFormat.getCustomFormatMetadata(format);
            }
            function setLocaleOptions(options) {
                locale = options, powerbi.DefaultDisplayUnitSystem.reset(), powerbi.WholeUnitsDisplayUnitSystem.reset();
            }
            function createDefaultFormatter(formatString, allowFormatBeautification) {
                void 0 === allowFormatBeautification && (allowFormatBeautification = !1);
                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;
                return {
                    format: function(value) {
                        return null == value ? locale["null"] : formatCore(value, formatBeaut);
                    }
                };
            }
            function create(options) {
                var format = options.allowFormatBeautification ? locale.beautify(options.format) : options.format;
                if (shouldUseNumericDisplayUnits(options)) {
                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType), singleValueFormattingMode_1 = !!options.formatSingleValues;
                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));
                    var decimals_1, forcePrecision_1 = null != options.precision;
                    if (forcePrecision_1 ? decimals_1 = -options.precision : displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1 && (decimals_1 = -MaxScaledDecimalPlaces), 
                    options.detectAxisPrecision) {
                        forcePrecision_1 = !0;
                        var axisValue = options.value;
                        displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0 && (axisValue /= displayUnitSystem_1.displayUnit.value), 
                        decimals_1 = powerbi.Double.isInteger(axisValue) ? 0 : powerbi.Double.log10(axisValue);
                    }
                    return {
                        format: function(value) {
                            var formattedValue = getStringFormat(value, !0);
                            return StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue) ? (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1 && (value = powerbi.Double.roundToPrecision(value)), 
                            singleValueFormattingMode_1 ? displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) : displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1)) : formattedValue;
                        },
                        displayUnit: displayUnitSystem_1.displayUnit,
                        options: options
                    };
                }
                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {
                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value, options.value2, options.tickCount);
                    return {
                        format: function(value) {
                            if (null == value) return locale["null"];
                            var formatString = powerbi.formattingService.dateFormatString(unit_1);
                            return formatCore(value, formatString);
                        },
                        options: options
                    };
                }
                return createDefaultFormatter(format);
            }
            function format(value, format, allowFormatBeautification) {
                return null == value ? locale["null"] : formatCore(value, allowFormatBeautification ? locale.beautify(format) : format);
            }
            function getValueFormat(value, columnType) {
                return columnType && columnType.dateTime || !(value instanceof Date) ? void 0 : getFormatString(DateTimeMetadataColumn, null, !1);
            }
            function formatValueColumn(value, column, formatStringProp) {
                var valueFormat = getValueFormat(value, column.type);
                return valueFormat ? formatCore(value, valueFormat) : formatCore(value, getFormatString(column, formatStringProp));
            }
            function createDisplayUnitSystem(displayUnitSystemType) {
                if (null == displayUnitSystemType) return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                switch (displayUnitSystemType) {
                  case powerbi.DisplayUnitSystemType.Default:
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);

                  case powerbi.DisplayUnitSystemType.WholeUnits:
                    return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);

                  case powerbi.DisplayUnitSystemType.Verbose:
                    return new powerbi.NoDisplayUnitSystem();

                  case powerbi.DisplayUnitSystemType.DataLabels:
                    return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);

                  default:
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                }
            }
            function shouldUseNumericDisplayUnits(options) {
                var value = options.value, value2 = options.value2, format = options.format;
                if (options.formatSingleValues && format && Math.abs(value) < MinIntegerValueForDisplayUnits) {
                    var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);
                    if (isCustomFormat) {
                        var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, !0).precision;
                        if (MinPrecisionForDisplayUnits > precision) return !1;
                    } else if (powerbi.Double.isInteger(value)) return !1;
                }
                return "number" == typeof value || "number" == typeof value2 ? !0 : void 0;
            }
            function shouldUseDateUnits(value, value2, tickCount) {
                return value instanceof Date && value2 instanceof Date && void 0 !== tickCount && null !== tickCount;
            }
            function getFormatString(column, formatStringProperty, suppressTypeFallback) {
                if (column) {
                    if (formatStringProperty) {
                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);
                        if (propertyValue) return propertyValue;
                    }
                    if (!suppressTypeFallback) {
                        var columnType = column.type;
                        if (columnType) {
                            if (columnType.dateTime) return valueFormatter.DefaultDateFormat;
                            if (columnType.integer) return valueFormatter.DefaultIntegerFormat;
                            if (columnType.numeric) return valueFormatter.DefaultNumericFormat;
                        }
                    }
                }
            }
            function formatListCompound(strings, conjunction) {
                var result;
                if (!strings) return null;
                var length = strings.length;
                if (length > 0) {
                    result = strings[0];
                    for (var lastIndex = length - 1, i = 1, len = lastIndex; len > i; i++) {
                        var value = strings[i];
                        result = StringExtensions.format(locale.restatementComma, result, value);
                    }
                    if (length > 1) {
                        var value = strings[lastIndex];
                        result = StringExtensions.format(conjunction, result, value);
                    }
                } else result = null;
                return result;
            }
            function formatListAnd(strings) {
                return formatListCompound(strings, locale.restatementCompoundAnd);
            }
            function formatListOr(strings) {
                return formatListCompound(strings, locale.restatementCompoundOr);
            }
            function formatCore(value, format) {
                var formattedValue = getStringFormat(value, !1);
                return StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue) ? powerbi.formattingService.formatValue(value, format) : formattedValue;
            }
            function getStringFormat(value, nullsAreBlank) {
                return null == value && nullsAreBlank ? locale["null"] : value === !0 ? locale["true"] : value === !1 ? locale["false"] : "number" == typeof value && isNaN(value) ? locale.NaN : value === Number.NEGATIVE_INFINITY ? locale.negativeInfinity : value === Number.POSITIVE_INFINITY ? locale.infinity : "";
            }
            function getDisplayUnits(displayUnitSystemType) {
                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);
                return displayUnitSystem.units;
            }
            var StringExtensions = jsCommon.StringExtensions, BeautifiedFormat = {
                "0.00 %;-0.00 %;0.00 %": "Percentage",
                "0.0 %;-0.0 %;0.0 %": "Percentage1"
            };
            valueFormatter.DefaultIntegerFormat = "g", valueFormatter.DefaultNumericFormat = "#,0.00", 
            valueFormatter.DefaultDateFormat = "d";
            var defaultLocalizedStrings = {
                NullValue: "(Blank)",
                BooleanTrue: "True",
                BooleanFalse: "False",
                NaNValue: "NaN",
                InfinityValue: "+Infinity",
                NegativeInfinityValue: "-Infinity",
                RestatementComma: "{0}, {1}",
                RestatementCompoundAnd: "{0} and {1}",
                RestatementCompoundOr: "{0} or {1}",
                DisplayUnitSystem_EAuto_Title: "Auto",
                DisplayUnitSystem_E0_Title: "None",
                DisplayUnitSystem_E3_LabelFormat: "{0}K",
                DisplayUnitSystem_E3_Title: "Thousands",
                DisplayUnitSystem_E6_LabelFormat: "{0}M",
                DisplayUnitSystem_E6_Title: "Millions",
                DisplayUnitSystem_E9_LabelFormat: "{0}bn",
                DisplayUnitSystem_E9_Title: "Billions",
                DisplayUnitSystem_E12_LabelFormat: "{0}T",
                DisplayUnitSystem_E12_Title: "Trillions",
                Percentage: "#,0.##%",
                Percentage1: "#,0.#%",
                TableTotalLabel: "Total",
                Tooltip_HighlightedValueDisplayName: "Highlighted",
                Funnel_PercentOfFirst: "Percent of first",
                Funnel_PercentOfPrevious: "Percent of previous",
                Funnel_PercentOfFirst_Highlight: "Percent of first (highlight)",
                Funnel_PercentOfPrevious_Highlight: "Percent of previous (highlight)",
                GeotaggingString_Continent: "continent",
                GeotaggingString_Continents: "continents",
                GeotaggingString_Country: "country",
                GeotaggingString_Countries: "countries",
                GeotaggingString_State: "state",
                GeotaggingString_States: "states",
                GeotaggingString_City: "city",
                GeotaggingString_Cities: "cities",
                GeotaggingString_Town: "town",
                GeotaggingString_Towns: "towns",
                GeotaggingString_Province: "province",
                GeotaggingString_Provinces: "provinces",
                GeotaggingString_County: "county",
                GeotaggingString_Counties: "counties",
                GeotaggingString_Village: "village",
                GeotaggingString_Villages: "villages",
                GeotaggingString_Post: "post",
                GeotaggingString_Zip: "zip",
                GeotaggingString_Code: "code",
                GeotaggingString_Place: "place",
                GeotaggingString_Places: "places",
                GeotaggingString_Address: "address",
                GeotaggingString_Addresses: "addresses",
                GeotaggingString_Street: "street",
                GeotaggingString_Streets: "streets",
                GeotaggingString_Longitude: "longitude",
                GeotaggingString_Longitude_Short: "lon",
                GeotaggingString_Latitude: "latitude",
                GeotaggingString_Latitude_Short: "lat",
                GeotaggingString_PostalCode: "postal code",
                GeotaggingString_PostalCodes: "postal codes",
                GeotaggingString_ZipCode: "zip code",
                GeotaggingString_ZipCodes: "zip codes",
                GeotaggingString_Territory: "territory",
                GeotaggingString_Territories: "territories"
            };
            valueFormatter.getLocalizedString = getLocalizedString;
            var locale = {
                "null": defaultLocalizedStrings.NullValue,
                "true": defaultLocalizedStrings.BooleanTrue,
                "false": defaultLocalizedStrings.BooleanFalse,
                NaN: defaultLocalizedStrings.NaNValue,
                infinity: defaultLocalizedStrings.InfinityValue,
                negativeInfinity: defaultLocalizedStrings.NegativeInfinityValue,
                beautify: function(format) {
                    return beautify(format);
                },
                describe: function(exponent) {
                    return describeUnit(exponent);
                },
                restatementComma: defaultLocalizedStrings.RestatementComma,
                restatementCompoundAnd: defaultLocalizedStrings.RestatementCompoundAnd,
                restatementCompoundOr: defaultLocalizedStrings.RestatementCompoundOr
            }, MaxScaledDecimalPlaces = 2, MaxValueForDisplayUnitRounding = 1e3, MinIntegerValueForDisplayUnits = 1e4, MinPrecisionForDisplayUnits = 2, DateTimeMetadataColumn = {
                displayName: "",
                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime)
            };
            valueFormatter.getFormatMetadata = getFormatMetadata, valueFormatter.setLocaleOptions = setLocaleOptions, 
            valueFormatter.createDefaultFormatter = createDefaultFormatter, valueFormatter.create = create, 
            valueFormatter.format = format, valueFormatter.formatValueColumn = formatValueColumn, 
            valueFormatter.getFormatString = getFormatString, valueFormatter.formatListAnd = formatListAnd, 
            valueFormatter.formatListOr = formatListOr, valueFormatter.getDisplayUnits = getDisplayUnits;
        }(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, labelStyle = powerbi.visuals.labelStyle, DonutLabelUtils = powerbi.visuals.DonutLabelUtils, DonutLabelLayout = function() {
        function DonutLabelLayout(options, donutChartProperties) {
            this.startingOffset = options.startingOffset, this.maximumOffset = options.maximumOffset, 
            null != options.offsetIterationDelta && (this.offsetIterationDelta = options.offsetIterationDelta), 
            this.donutChartProperties = donutChartProperties, this.center = {
                x: donutChartProperties.viewport.width / 2,
                y: donutChartProperties.viewport.height / 2
            }, this.outerRadius = this.donutChartProperties.radius * this.donutChartProperties.outerArcRadiusRatio, 
            this.innerRadius = this.donutChartProperties.radius / 2 * this.donutChartProperties.innerArcRadiusRatio, 
            this.additionalCharsWidth = powerbi.TextMeasurementService.measureSvgTextWidth({
                text: " ()",
                fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                fontSize: jsCommon.PixelConverter.fromPoint(donutChartProperties.dataLabelsSettings.fontSize),
                fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight
            });
        }
        return DonutLabelLayout.prototype.layout = function(labelDataPoints) {
            for (var _i = 0, labelDataPoints_3 = labelDataPoints; _i < labelDataPoints_3.length; _i++) {
                var donutLabel = labelDataPoints_3[_i];
                donutLabel.hasBeenRendered = !1, donutLabel.labelSize = donutLabel.textSize;
            }
            for (var resultingLabels = [], preferredLabels = [], viewport = this.donutChartProperties.viewport, labelDataPointsGroup = {
                labelDataPoints: labelDataPoints,
                maxNumberOfLabels: labelDataPoints.length
            }, grid = new powerbi.LabelArrangeGrid([ labelDataPointsGroup ], viewport), i = labelDataPoints.length - 1; i >= 0; i--) {
                var labelPoint = labelDataPoints[i];
                if (labelPoint.isPreferred) {
                    var label = labelDataPoints.splice(i, 1);
                    preferredLabels = label.concat(preferredLabels);
                }
            }
            if (preferredLabels.length > 0 && (resultingLabels = this.positionLabels(preferredLabels, grid)), 
            labelDataPoints.length > 0) {
                var labels = this.positionLabels(labelDataPoints, grid);
                resultingLabels = resultingLabels.concat(labels);
            }
            return resultingLabels;
        }, DonutLabelLayout.prototype.positionLabels = function(labelDataPoints, grid) {
            for (var resultingLabels = [], offsetDelta = this.offsetIterationDelta, currentOffset = this.startingOffset, currentCenteredOffset = 0; currentOffset <= this.maximumOffset; ) {
                for (var _i = 0, labelDataPoints_4 = labelDataPoints; _i < labelDataPoints_4.length; _i++) {
                    var labelPoint = labelDataPoints_4[_i];
                    if (!labelPoint.hasBeenRendered) {
                        var label = this.tryPositionForDonut(labelPoint, grid, currentOffset);
                        label && resultingLabels.push(label);
                    }
                }
                currentOffset += offsetDelta, currentCenteredOffset += offsetDelta;
            }
            return resultingLabels;
        }, DonutLabelLayout.prototype.tryPositionForDonut = function(labelPoint, grid, currentLabelOffset) {
            var parentShape = labelPoint.parentShape;
            if (!_.isEmpty(parentShape.validPositions) && 0 !== parentShape.validPositions[0]) {
                var defaultPosition = parentShape.validPositions[0], bestCandidate = this.tryAllPositions(labelPoint, grid, defaultPosition, currentLabelOffset);
                if (bestCandidate && 0 === bestCandidate.score) return this.buildLabel(bestCandidate, grid);
                if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both) {
                    var splitLabelDataPoint = this.splitDonutDataPoint(labelPoint), bestSplitCandidate = this.tryAllPositions(splitLabelDataPoint, grid, defaultPosition, currentLabelOffset);
                    if (bestSplitCandidate && (!bestCandidate || bestSplitCandidate.score < bestCandidate.score)) return this.buildLabel(bestSplitCandidate, grid);
                }
                return bestCandidate ? this.buildLabel(bestCandidate, grid) : void 0;
            }
        }, DonutLabelLayout.prototype.generateCandidate = function(labelDataPoint, candidatePosition, grid, currentLabelOffset) {
            var angle = this.generateCandidateAngleForPosition(labelDataPoint.donutArcDescriptor, candidatePosition), parentShape = this.getPointPositionForAngle(angle), parentPoint = parentShape.point, score = this.score(labelDataPoint, parentPoint), leaderLinePoints = DonutLabelUtils.getLabelLeaderLineForDonutChart(labelDataPoint.donutArcDescriptor, this.donutChartProperties, parentPoint, angle), leaderLinesSize = DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints), newLabelDataPoint = _.clone(labelDataPoint);
            newLabelDataPoint.angle = angle, newLabelDataPoint.parentShape = parentShape, newLabelDataPoint.leaderLinePoints = leaderLinePoints, 
            newLabelDataPoint.linesSize = leaderLinesSize;
            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, parentShape.validPositions[0], newLabelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
            return {
                angle: angle,
                point: parentShape,
                score: score,
                labelRects: boundingBoxs,
                labelDataPoint: newLabelDataPoint
            };
        }, DonutLabelLayout.prototype.tryAllPositions = function(labelDataPoint, grid, defaultPosition, currentLabelOffset) {
            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, defaultPosition, labelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport), originalPoint = labelDataPoint.parentShape, originalCandidate = {
                point: originalPoint,
                angle: labelDataPoint.angle,
                score: this.score(labelDataPoint, originalPoint.point),
                labelRects: boundingBoxs,
                labelDataPoint: labelDataPoint
            };
            if (boundingBoxs && boundingBoxs.textRect && 0 === originalCandidate.score) return originalCandidate;
            var bestCandidate, positions = [];
            boundingBoxs && boundingBoxs.textRect ? (positions = this.getLabelPointPositions(labelDataPoint, !0), 
            bestCandidate = originalCandidate) : positions = this.getLabelPointPositions(labelDataPoint, !1);
            for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                var position = positions_1[_i], candidate = this.generateCandidate(labelDataPoint, position, grid, currentLabelOffset);
                if (candidate.labelRects && candidate.labelRects.textRect && (null == bestCandidate || candidate.score < bestCandidate.score) && (bestCandidate = candidate, 
                0 === bestCandidate.score)) return bestCandidate;
            }
            return bestCandidate;
        }, DonutLabelLayout.prototype.buildLabel = function(labelLayout, grid) {
            var resultingBoundingBox = labelLayout.labelRects.textRect, labelPoint = labelLayout.labelDataPoint;
            grid.add(resultingBoundingBox), grid.add(labelLayout.labelRects.horizontalLineRect), 
            grid.add(labelLayout.labelRects.diagonalLineRect), labelPoint.hasBeenRendered = !0;
            var left = resultingBoundingBox.left - this.center.x;
            0 > left ? left += resultingBoundingBox.width / 2 : left -= resultingBoundingBox.width / 2;
            var formattedDataLabel, formattedCategoryLabel, text, textAnchor = 8 === labelPoint.parentShape.validPositions[0] ? "start" : "end", boundingBox = {
                left: left,
                top: resultingBoundingBox.top - this.center.y,
                height: resultingBoundingBox.height,
                width: resultingBoundingBox.width
            }, labelSettingsStyle = this.donutChartProperties.dataLabelsSettings.labelStyle, spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(labelPoint.parentShape.point.x, this.donutChartProperties.viewport), getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText, fontSize = labelPoint.fontSize, hasOneLabelRow = labelSettingsStyle === labelStyle.both && null == labelPoint.secondRowText;
            switch (hasOneLabelRow && (labelPoint.dataLabel = " (" + labelPoint.dataLabel + ")", 
            spaceAvailableForLabels /= 2), labelSettingsStyle !== labelStyle.both && labelSettingsStyle !== labelStyle.data || (formattedDataLabel = getLabelFormattedText({
                label: labelPoint.dataLabel,
                maxWidth: spaceAvailableForLabels,
                fontSize: fontSize
            })), labelSettingsStyle !== labelStyle.both && labelSettingsStyle !== labelStyle.category || (formattedCategoryLabel = getLabelFormattedText({
                label: labelPoint.categoryLabel,
                maxWidth: spaceAvailableForLabels,
                fontSize: fontSize
            })), labelSettingsStyle) {
              case labelStyle.both:
                null == labelPoint.secondRowText ? text = formattedCategoryLabel + formattedDataLabel : (text = formattedDataLabel, 
                labelPoint.secondRowText = formattedCategoryLabel);
                break;

              case labelStyle.data:
                text = formattedDataLabel;
                break;

              case labelStyle.category:
                text = formattedCategoryLabel;
            }
            return labelPoint.textSize.width = Math.min(labelPoint.textSize.width, hasOneLabelRow ? 2 * spaceAvailableForLabels : spaceAvailableForLabels), 
            {
                boundingBox: boundingBox,
                text: text,
                tooltip: labelPoint.tooltip,
                isVisible: !0,
                fill: labelPoint.outsideFill,
                identity: labelPoint.identity,
                fontSize: fontSize,
                selected: !1,
                textAnchor: textAnchor,
                leaderLinePoints: labelPoint.leaderLinePoints,
                hasBackground: !1,
                secondRowText: labelPoint.secondRowText
            };
        }, DonutLabelLayout.tryPositionPoint = function(grid, position, labelDataPoint, offset, center, viewport) {
            var parentPoint = labelDataPoint.parentShape, textSize = _.clone(labelDataPoint.textSize);
            textSize.width = Math.min(textSize.width, DonutLabelUtils.getSpaceAvailableForDonutLabels(parentPoint.point.x, viewport));
            var labelRect = powerbi.DataLabelPointPositioner.getLabelRect(textSize, parentPoint, position, offset), diagonalLineParentPoint = {
                point: {
                    x: labelDataPoint.leaderLinePoints[0][0],
                    y: labelDataPoint.leaderLinePoints[0][1] < 0 ? labelDataPoint.leaderLinePoints[1][1] : labelDataPoint.leaderLinePoints[0][1]
                },
                radius: 0,
                validPositions: null
            }, diagonalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.DiagonalLineIndex], diagonalLineParentPoint, position, offset), horizontalLineParentPoint = {
                point: {
                    x: labelDataPoint.leaderLinePoints[1][0],
                    y: labelDataPoint.leaderLinePoints[1][1]
                },
                radius: 0,
                validPositions: null
            }, horizontalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.HorizontalLineIndex], horizontalLineParentPoint, position, offset);
            if (labelRect && diagonalLineRect && horizontalLineRect) {
                labelRect.left += center.x, labelRect.top += center.y;
                var centerForLinesWidth = center.x - labelRect.width / 2;
                return diagonalLineRect.left += centerForLinesWidth, diagonalLineRect.top += center.y, 
                horizontalLineRect.left += centerForLinesWidth, horizontalLineRect.top += center.y, 
                grid.hasConflict(labelRect) || grid.hasConflict(diagonalLineRect) || grid.hasConflict(horizontalLineRect) ? void 0 : {
                    textRect: labelRect,
                    diagonalLineRect: diagonalLineRect,
                    horizontalLineRect: horizontalLineRect
                };
            }
        }, DonutLabelLayout.prototype.getLabelPointPositions = function(labelPoint, isTruncated) {
            var parentShape = labelPoint.parentShape, position = parentShape.validPositions[0];
            return isTruncated ? parentShape.point.y < 0 ? 8 === position ? [ 64 ] : [ 128 ] : 8 === position ? [ 16 ] : [ 32 ] : 4 === position ? [ 128, 32 ] : [ 16, 64 ];
        }, DonutLabelLayout.prototype.splitDonutDataPoint = function(labelPoint) {
            var textSize = {
                width: Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width),
                height: 2 * labelPoint.dataLabelSize.height
            }, newLabelPoint = _.clone(labelPoint);
            return newLabelPoint.textSize = textSize, newLabelPoint.secondRowText = labelPoint.categoryLabel, 
            newLabelPoint;
        }, DonutLabelLayout.prototype.generateCandidateAngleForPosition = function(d, position) {
            var midAngle = d.startAngle + (d.endAngle - d.startAngle) / 2;
            switch (position) {
              case 64:
              case 32:
                return (d.startAngle + midAngle - Math.PI) / 2;

              case 128:
              case 16:
                return (midAngle + d.endAngle - Math.PI) / 2;
            }
        }, DonutLabelLayout.prototype.getPointPositionForAngle = function(angle) {
            var labelX = DonutLabelUtils.getXPositionForDonutLabel(Math.cos(angle) * this.outerRadius), labelY = Math.sin(angle) * this.outerRadius, newPosition = 0 > labelX ? 4 : 8, pointPosition = {
                point: {
                    x: labelX,
                    y: labelY
                },
                validPositions: [ newPosition ],
                radius: 0
            };
            return pointPosition;
        }, DonutLabelLayout.prototype.score = function(labelPoint, point) {
            var textWidth, spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(point.x, this.donutChartProperties.viewport);
            return this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both && null == labelPoint.secondRowText ? (textWidth = Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width + this.additionalCharsWidth), 
            spaceAvailableForLabels /= 2) : textWidth = labelPoint.textSize.width, Math.max(textWidth - spaceAvailableForLabels, 0);
        }, DonutLabelLayout;
    }();
    powerbi.DonutLabelLayout = DonutLabelLayout;
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, DefaultCentroidOffset = 5, OffsetDelta = 10, MaximumOffset = 60, stemExtension = 5, FilledMapLabelLayout = function() {
        function FilledMapLabelLayout() {}
        return FilledMapLabelLayout.prototype.layout = function(labelDataPoints, viewport, polygonInfoTransform, redrawDataLabels) {
            if (redrawDataLabels || void 0 === this.labels) {
                for (var labelDataPointsGroup = {
                    labelDataPoints: labelDataPoints,
                    maxNumberOfLabels: labelDataPoints.length
                }, _i = 0, labelDataPoints_5 = labelDataPoints; _i < labelDataPoints_5.length; _i++) {
                    var labelPoint = labelDataPoints_5[_i];
                    labelPoint.labelSize = {
                        width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                        height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding
                    };
                }
                for (var grid = new powerbi.LabelArrangeGrid([ labelDataPointsGroup ], viewport), resultingDataLabels = [], allPolygons = [], _a = 0, labelDataPoints_6 = labelDataPoints; _a < labelDataPoints_6.length; _a++) {
                    var labelPoint = labelDataPoints_6[_a], polygon = labelPoint.parentShape.polygon;
                    allPolygons.push(polygon), polygon.pixelBoundingRect = polygonInfoTransform.applyToRect(polygon.absoluteBoundingRect());
                }
                for (var shapesgrid = new LabelPolygonArrangeGrid(allPolygons, viewport), _b = 0, labelDataPoints_7 = labelDataPoints; _b < labelDataPoints_7.length; _b++) {
                    var labelPoint = labelDataPoints_7[_b], dataLabel = this.getLabelByPolygonPositions(labelPoint, polygonInfoTransform, grid, shapesgrid);
                    null != dataLabel && resultingDataLabels.push(dataLabel);
                }
                this.labels = resultingDataLabels;
            } else this.updateLabelOffsets(polygonInfoTransform);
            return this.labels;
        }, FilledMapLabelLayout.prototype.getLabelPolygon = function(mapDataPoint, position, pointPosition, offset) {
            var dataPointSize = {
                width: mapDataPoint.textSize.width,
                height: mapDataPoint.textSize.height
            };
            return this.getLabelBoundingBox(dataPointSize, position, pointPosition, offset);
        }, FilledMapLabelLayout.prototype.getLabelBoundingBox = function(dataPointSize, position, pointPosition, offset) {
            switch (position) {
              case 1:
                return powerbi.DataLabelPointPositioner.above(dataPointSize, pointPosition, offset);

              case 2:
                return powerbi.DataLabelPointPositioner.below(dataPointSize, pointPosition, offset);

              case 4:
                return powerbi.DataLabelPointPositioner.left(dataPointSize, pointPosition, offset);

              case 8:
                return powerbi.DataLabelPointPositioner.right(dataPointSize, pointPosition, offset);

              case 128:
                return powerbi.DataLabelPointPositioner.aboveLeft(dataPointSize, pointPosition, offset);

              case 64:
                return powerbi.DataLabelPointPositioner.aboveRight(dataPointSize, pointPosition, offset);

              case 32:
                return powerbi.DataLabelPointPositioner.belowLeft(dataPointSize, pointPosition, offset);

              case 16:
                return powerbi.DataLabelPointPositioner.belowRight(dataPointSize, pointPosition, offset);

              case 256:
                return powerbi.DataLabelPointPositioner.center(dataPointSize, pointPosition);
            }
            return null;
        }, FilledMapLabelLayout.prototype.getLabelByPolygonPositions = function(labelPoint, polygonInfoTransform, grid, shapesGrid) {
            for (var offset = 0, inverseTransorm = polygonInfoTransform.getInverse(), i = 0; 2 > i; i++) {
                1 === i && (offset = DefaultCentroidOffset);
                for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                    var position = _a[_i], resultingAbsoluteBoundingBox = this.tryPositionForPolygonPosition(position, labelPoint, polygonInfoTransform, offset, inverseTransorm);
                    if ((256 !== position || 0 === i) && resultingAbsoluteBoundingBox) {
                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsoluteBoundingBox), dataLabel = {
                            text: labelPoint.text,
                            secondRowText: labelPoint.secondRowText,
                            boundingBox: resultingBoundingBox,
                            isVisible: !0,
                            fill: labelPoint.insideFill,
                            identity: null,
                            selected: !1,
                            hasBackground: !0,
                            textAnchor: "middle",
                            originalPixelOffset: offset,
                            isPlacedInsidePolygon: !0,
                            absoluteBoundingBoxCenter: {
                                x: resultingAbsoluteBoundingBox.left + resultingAbsoluteBoundingBox.width / 2,
                                y: resultingAbsoluteBoundingBox.top + resultingAbsoluteBoundingBox.height / 2
                            }
                        };
                        return dataLabel;
                    }
                }
            }
            for (var currentOffset = 6; MaximumOffset >= currentOffset; ) {
                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b];
                    if (256 !== position) {
                        var polygon = labelPoint.parentShape.polygon, pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid()), resultingAbsolutBoundingBox = this.tryPlaceLabelOutsidePolygon(grid, position, labelPoint, currentOffset, pixelCentroid, shapesGrid, inverseTransorm);
                        if (resultingAbsolutBoundingBox) {
                            var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsolutBoundingBox), dataLabel = {
                                text: labelPoint.text,
                                secondRowText: labelPoint.secondRowText,
                                boundingBox: resultingBoundingBox,
                                isVisible: !0,
                                fill: labelPoint.insideFill,
                                identity: null,
                                selected: !1,
                                hasBackground: !0,
                                isPlacedInsidePolygon: !1,
                                textAnchor: "middle",
                                originalPixelOffset: currentOffset,
                                originalPosition: position,
                                originalAbsoluteCentroid: polygon.absoluteCentroid(),
                                absoluteBoundingBoxCenter: {
                                    x: resultingAbsolutBoundingBox.left + resultingAbsolutBoundingBox.width / 2,
                                    y: resultingAbsolutBoundingBox.top + resultingAbsolutBoundingBox.height / 2
                                }
                            }, pixelStemSource = this.calculateStemSource(polygonInfoTransform, inverseTransorm, polygon, resultingBoundingBox, position, pixelCentroid);
                            return dataLabel.leaderLinePoints = this.setLeaderLinePoints(pixelStemSource, this.calculateStemDestination(resultingBoundingBox, position)), 
                            dataLabel.absoluteStemSource = inverseTransorm.applyToPoint(pixelStemSource), grid.add(resultingBoundingBox), 
                            dataLabel;
                        }
                    }
                }
                currentOffset += OffsetDelta;
            }
            return null;
        }, FilledMapLabelLayout.prototype.setLeaderLinePoints = function(stemSource, stemDestination) {
            return [ [ stemSource.x, stemSource.y ], [ stemDestination.x, stemDestination.y ] ];
        }, FilledMapLabelLayout.prototype.calculateStemSource = function(polygonInfoTransform, inverseTransorm, polygon, labelBoundingBox, position, pixelCentroid) {
            var absoluteStemSource = polygon.lineIntersectionPoint(polygon.absoluteCentroid(), inverseTransorm.applyToPoint({
                x: labelBoundingBox.left + labelBoundingBox.width / 2,
                y: labelBoundingBox.top + labelBoundingBox.height / 2
            }));
            if (null == absoluteStemSource) return pixelCentroid;
            var stemSource = polygonInfoTransform.applyToPoint(absoluteStemSource);
            switch (position) {
              case 1:
                stemSource.y += stemExtension;
                break;

              case 2:
                stemSource.y -= stemExtension;
                break;

              case 4:
                stemSource.x += stemExtension;
                break;

              case 8:
                stemSource.x -= stemExtension;
                break;

              case 128:
                stemSource.x += stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y += stemExtension / powerbi.DataLabelPointPositioner.sin45;
                break;

              case 64:
                stemSource.x -= stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y += stemExtension / powerbi.DataLabelPointPositioner.sin45;
                break;

              case 32:
                stemSource.x += stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y -= stemExtension / powerbi.DataLabelPointPositioner.sin45;
                break;

              case 16:
                stemSource.x -= stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y -= stemExtension / powerbi.DataLabelPointPositioner.sin45;
                break;

              case 256:            }
            return stemSource;
        }, FilledMapLabelLayout.prototype.calculateStemDestination = function(labelBoundingBox, position) {
            var x, y;
            switch (position) {
              case 1:
                x = labelBoundingBox.left + labelBoundingBox.width / 2, y = labelBoundingBox.top + labelBoundingBox.height;
                break;

              case 2:
                x = labelBoundingBox.left + labelBoundingBox.width / 2, y = labelBoundingBox.top;
                break;

              case 4:
                x = labelBoundingBox.left + labelBoundingBox.width, y = labelBoundingBox.top + labelBoundingBox.height / 2;
                break;

              case 8:
                x = labelBoundingBox.left, y = labelBoundingBox.top + labelBoundingBox.height / 2;
                break;

              case 128:
                x = labelBoundingBox.left + labelBoundingBox.width, y = labelBoundingBox.top + labelBoundingBox.height;
                break;

              case 64:
                x = labelBoundingBox.left, y = labelBoundingBox.top + labelBoundingBox.height;
                break;

              case 32:
                x = labelBoundingBox.left + labelBoundingBox.width, y = labelBoundingBox.top;
                break;

              case 16:
                x = labelBoundingBox.left, y = labelBoundingBox.top;
                break;

              case 256:            }
            return {
                x: x,
                y: y
            };
        }, FilledMapLabelLayout.prototype.tryPositionForPolygonPosition = function(position, labelDataPoint, polygonInfoTransform, offset, inverseTransorm) {
            var polygon = labelDataPoint.parentShape.polygon, pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid()), labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offset), absoluteLabelRect = this.getAbsoluteRectangle(inverseTransorm, labelRect);
            return polygon.contains(absoluteLabelRect) ? absoluteLabelRect : null;
        }, FilledMapLabelLayout.prototype.tryPlaceLabelOutsidePolygon = function(grid, position, labelDataPoint, offset, pixelCentroid, shapesGrid, inverseTransform) {
            var offsetForPosition = offset, labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offsetForPosition), otherLabelsConflict = grid.hasConflict(labelRect);
            if (!otherLabelsConflict) {
                var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransform, labelRect);
                if (!shapesGrid.hasConflict(absoluteLabelRect, labelRect)) return absoluteLabelRect;
            }
            return null;
        }, FilledMapLabelLayout.prototype.updateLabelOffsets = function(polygonInfoTransform) {
            for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
                var label = _a[_i];
                if (label.isVisible) if (label.isPlacedInsidePolygon) {
                    var newOffset = polygonInfoTransform.applyToPoint(label.absoluteBoundingBoxCenter), xDelta = label.boundingBox.left + label.boundingBox.width / 2 - newOffset.x, yDelta = label.boundingBox.top + label.boundingBox.height / 2 - newOffset.y;
                    label.boundingBox.top -= yDelta, label.boundingBox.left -= xDelta;
                } else {
                    var stemSourcePoint = polygonInfoTransform.applyToPoint(label.absoluteStemSource), pixelCentroid = polygonInfoTransform.applyToPoint(label.originalAbsoluteCentroid);
                    label.boundingBox = this.getLabelBoundingBox({
                        width: label.boundingBox.width,
                        height: label.boundingBox.height
                    }, label.originalPosition, pixelCentroid, label.originalPixelOffset), void 0 !== label.leaderLinePoints && (label.leaderLinePoints = this.setLeaderLinePoints(stemSourcePoint, this.calculateStemDestination(label.boundingBox, label.originalPosition)));
                }
            }
        }, FilledMapLabelLayout.prototype.getAbsoluteRectangle = function(inverseTransorm, rect) {
            return inverseTransorm.applyToRect(rect);
        }, FilledMapLabelLayout;
    }();
    powerbi.FilledMapLabelLayout = FilledMapLabelLayout;
    var LabelPolygonArrangeGrid = function() {
        function LabelPolygonArrangeGrid(polygons, viewport) {
            this.viewport = viewport;
            for (var maxPolygonWidth = 0, maxPolygonHeight = 0, _i = 0, polygons_1 = polygons; _i < polygons_1.length; _i++) {
                var polygon = polygons_1[_i], polygonSize = polygon.pixelBoundingRect;
                polygonSize.width > maxPolygonWidth && (maxPolygonWidth = polygonSize.width), polygonSize.height > maxPolygonHeight && (maxPolygonHeight = polygonSize.height);
            }
            0 === maxPolygonWidth && (maxPolygonWidth = viewport.width), 0 === maxPolygonHeight && (maxPolygonHeight = viewport.height);
            var cellSize = this.cellSize = {
                width: maxPolygonWidth * LabelPolygonArrangeGrid.cellSizeMultiplier,
                height: maxPolygonHeight * LabelPolygonArrangeGrid.cellSizeMultiplier
            };
            this.columnCount = LabelPolygonArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100), 
            this.rowCount = LabelPolygonArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            for (var grid = [], i = 0, ilen = this.columnCount; ilen > i; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; jlen > j; j++) grid[i][j] = [];
            }
            this.grid = grid;
            for (var _a = 0, polygons_2 = polygons; _a < polygons_2.length; _a++) {
                var polygon = polygons_2[_a];
                this.add(polygon);
            }
        }
        return LabelPolygonArrangeGrid.prototype.hasConflict = function(absolutLabelRect, pixelLabelRect) {
            for (var containingIndexRect = this.getContainingGridSubsection(pixelLabelRect), grid = this.grid, x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                var currentPolygon = _a[_i];
                if (currentPolygon.conflicts(absolutLabelRect)) return !0;
            }
            return !1;
        }, LabelPolygonArrangeGrid.prototype.add = function(polygon) {
            for (var containingIndexRect = this.getContainingGridSubsection(polygon.pixelBoundingRect), x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) this.grid[x][y].push(polygon);
        }, LabelPolygonArrangeGrid.prototype.getContainingGridSubsection = function(rect) {
            return {
                xMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
            };
        }, LabelPolygonArrangeGrid.getCellCount = function(step, length, minCount, maxCount) {
            return LabelPolygonArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        }, LabelPolygonArrangeGrid.bound = function(value, min, max) {
            return Math.max(Math.min(value, max), min);
        }, LabelPolygonArrangeGrid.cellSizeMultiplier = 2, LabelPolygonArrangeGrid;
    }();
    powerbi.LabelPolygonArrangeGrid = LabelPolygonArrangeGrid;
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function createColorAllocatorFactory() {
            return new ColorAllocatorFactory();
        }
        visuals.createColorAllocatorFactory = createColorAllocatorFactory;
        var ColorAllocatorFactory = function() {
            function ColorAllocatorFactory() {}
            return ColorAllocatorFactory.prototype.linearGradient2 = function(options) {
                return new LinearGradient2Allocator(options);
            }, ColorAllocatorFactory.prototype.linearGradient3 = function(options, splitScales) {
                return splitScales ? new LinearGradient3AllocatorWithSplittedScales(options) : new LinearGradient3Allocator(options);
            }, ColorAllocatorFactory;
        }(), LinearGradient2Allocator = function() {
            function LinearGradient2Allocator(options) {
                this.options = options;
                var min = options.min, max = options.max;
                this.scale = d3.scale.linear().domain([ min.value, max.value ]).range([ min.color, max.color ]).clamp(!0);
            }
            return LinearGradient2Allocator.prototype.color = function(value) {
                var min = this.options.min, max = this.options.max;
                return min.value === max.value ? value >= max.value ? max.color : min.color : this.scale(value);
            }, LinearGradient2Allocator;
        }(), LinearGradient3Allocator = function() {
            function LinearGradient3Allocator(options) {
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                this.scale = d3.scale.linear().domain([ min.value, mid.value, max.value ]).range([ min.color, mid.color, max.color ]).clamp(!0);
            }
            return LinearGradient3Allocator.prototype.color = function(value) {
                var min = this.options.min, mid = this.options.mid, max = this.options.max;
                return max.value === mid.value || mid.value === min.value || max.value === mid.value && max.value === min.value ? value >= max.value ? max.color : value >= mid.value ? mid.color : min.color : this.scale(value);
            }, LinearGradient3Allocator;
        }(), LinearGradient3AllocatorWithSplittedScales = function() {
            function LinearGradient3AllocatorWithSplittedScales(options) {
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                this.scale1 = d3.scale.linear().domain([ min.value, mid.value ]).range([ min.color, mid.color ]).clamp(!0), 
                this.scale2 = d3.scale.linear().domain([ mid.value, max.value ]).range([ mid.color, max.color ]).clamp(!0);
            }
            return LinearGradient3AllocatorWithSplittedScales.prototype.color = function(value) {
                var min = this.options.min, mid = this.options.mid, max = this.options.max;
                return max.value === mid.value || mid.value === min.value || max.value === mid.value && max.value === min.value ? value >= max.value ? max.color : value >= mid.value ? mid.color : min.color : value <= mid.value ? this.scale1(value) : this.scale2(value);
            }, LinearGradient3AllocatorWithSplittedScales;
        }();
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var BeautifiedFormat = {
            "0.00 %;-0.00 %;0.00 %": "Percentage",
            "0.0 %;-0.0 %;0.0 %": "Percentage1"
        }, defaultLocalizedStrings = {
            NullValue: "(Blank)",
            BooleanTrue: "True",
            BooleanFalse: "False",
            NaNValue: "NaN",
            InfinityValue: "+Infinity",
            NegativeInfinityValue: "-Infinity",
            Restatement_Comma: "{0}, {1}",
            Restatement_CompoundAnd: "{0} and {1}",
            DisplayUnitSystem_EAuto_Title: "Auto",
            DisplayUnitSystem_E0_Title: "None",
            DisplayUnitSystem_E3_LabelFormat: "{0}K",
            DisplayUnitSystem_E3_Title: "Thousands",
            DisplayUnitSystem_E6_LabelFormat: "{0}M",
            DisplayUnitSystem_E6_Title: "Millions",
            DisplayUnitSystem_E9_LabelFormat: "{0}bn",
            DisplayUnitSystem_E9_Title: "Billions",
            DisplayUnitSystem_E12_LabelFormat: "{0}T",
            DisplayUnitSystem_E12_Title: "Trillions",
            Percentage: "#,0.##%",
            Percentage1: "#,0.#%",
            RichTextbox_Link_DefaultText: "Link",
            TableTotalLabel: "Total",
            Tooltip_HighlightedValueDisplayName: "Highlighted",
            Funnel_PercentOfFirst: "Percent of first",
            Funnel_PercentOfPrevious: "Percent of previous",
            Funnel_PercentOfFirst_Highlight: "Percent of first (highlight)",
            Funnel_PercentOfPrevious_Highlight: "Percent of previous (highlight)",
            GeotaggingString_Continent: "continent",
            GeotaggingString_Continents: "continents",
            GeotaggingString_Country: "country",
            GeotaggingString_Countries: "countries",
            GeotaggingString_State: "state",
            GeotaggingString_States: "states",
            GeotaggingString_City: "city",
            GeotaggingString_Cities: "cities",
            GeotaggingString_Town: "town",
            GeotaggingString_Towns: "towns",
            GeotaggingString_Province: "province",
            GeotaggingString_Provinces: "provinces",
            GeotaggingString_County: "county",
            GeotaggingString_Counties: "counties",
            GeotaggingString_Village: "village",
            GeotaggingString_Villages: "villages",
            GeotaggingString_Post: "post",
            GeotaggingString_Zip: "zip",
            GeotaggingString_Code: "code",
            GeotaggingString_Place: "place",
            GeotaggingString_Places: "places",
            GeotaggingString_Address: "address",
            GeotaggingString_Addresses: "addresses",
            GeotaggingString_Street: "street",
            GeotaggingString_Streets: "streets",
            GeotaggingString_Longitude: "longitude",
            GeotaggingString_Longitude_Short: "lon",
            GeotaggingString_Latitude: "latitude",
            GeotaggingString_Latitude_Short: "lat",
            GeotaggingString_PostalCode: "postal code",
            GeotaggingString_PostalCodes: "postal codes",
            GeotaggingString_ZipCode: "zip code",
            GeotaggingString_ZipCodes: "zip codes",
            GeotaggingString_Territory: "territory",
            GeotaggingString_Territories: "territories",
            Waterfall_IncreaseLabel: "Increase",
            Waterfall_DecreaseLabel: "Decrease",
            Waterfall_TotalLabel: "Total",
            Slicer_SelectAll: "Select All"
        }, DefaultVisualHostServices = function() {
            function DefaultVisualHostServices() {}
            return DefaultVisualHostServices.initialize = function() {
                visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions()), 
                visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
            }, DefaultVisualHostServices.createLocaleOptions = function() {
                return {
                    "null": defaultLocalizedStrings.NullValue,
                    "true": defaultLocalizedStrings.BooleanTrue,
                    "false": defaultLocalizedStrings.BooleanFalse,
                    NaN: defaultLocalizedStrings.NaNValue,
                    infinity: defaultLocalizedStrings.InfinityValue,
                    negativeInfinity: defaultLocalizedStrings.NegativeInfinityValue,
                    beautify: function(format) {
                        return DefaultVisualHostServices.beautify(format);
                    },
                    describe: function(exponent) {
                        return DefaultVisualHostServices.describeUnit(exponent);
                    },
                    restatementComma: defaultLocalizedStrings.Restatement_Comma,
                    restatementCompoundAnd: defaultLocalizedStrings.Restatement_CompoundAnd,
                    restatementCompoundOr: defaultLocalizedStrings.Restatement_CompoundOr
                };
            }, DefaultVisualHostServices.createTooltipLocaleOptions = function() {
                return {
                    highlightedValueDisplayName: defaultLocalizedStrings.Tooltip_HighlightedValueDisplayName
                };
            }, DefaultVisualHostServices.prototype.getLocalizedString = function(stringId) {
                return defaultLocalizedStrings[stringId];
            }, DefaultVisualHostServices.prototype.onDragStart = function() {}, DefaultVisualHostServices.prototype.canSelect = function() {
                return !1;
            }, DefaultVisualHostServices.prototype.onSelect = function() {}, DefaultVisualHostServices.prototype.onContextMenu = function() {}, 
            DefaultVisualHostServices.prototype.loadMoreData = function() {}, DefaultVisualHostServices.prototype.persistProperties = function(changes) {}, 
            DefaultVisualHostServices.prototype.onCustomSort = function(args) {}, DefaultVisualHostServices.prototype.getViewMode = function() {
                return 0;
            }, DefaultVisualHostServices.prototype.setWarnings = function(warnings) {}, DefaultVisualHostServices.prototype.setToolbar = function($toolbar) {}, 
            DefaultVisualHostServices.prototype.shouldRetainSelection = function() {
                return !1;
            }, DefaultVisualHostServices.prototype.geocoder = function() {
                return visuals.services.createGeocoder();
            }, DefaultVisualHostServices.prototype.geolocation = function() {
                return visuals.services.createGeolocation();
            }, DefaultVisualHostServices.prototype.promiseFactory = function() {
                return powerbi.createJQueryPromiseFactory();
            }, DefaultVisualHostServices.prototype.analyzeFilter = function(options) {
                return {
                    isNotFilter: !1,
                    selectedIdentities: [],
                    filter: void 0,
                    defaultValue: void 0
                };
            }, DefaultVisualHostServices.prototype.getIdentityDisplayNames = function(dentities) {}, 
            DefaultVisualHostServices.prototype.setIdentityDisplayNames = function(displayNamesIdentityPairs) {}, 
            DefaultVisualHostServices.beautify = function(format) {
                var key = BeautifiedFormat[format];
                return key ? defaultLocalizedStrings[key] || format : format;
            }, DefaultVisualHostServices.describeUnit = function(exponent) {
                var exponentLookup = -1 === exponent ? "Auto" : exponent.toString(), title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"], format = 0 >= exponent ? "{0}" : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                return title || format ? {
                    title: title,
                    format: format
                } : void 0;
            }, DefaultVisualHostServices;
        }();
        visuals.DefaultVisualHostServices = DefaultVisualHostServices, visuals.defaultVisualHostServices = new DefaultVisualHostServices();
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function createInteractivityService(hostServices) {
            return new InteractivityService(hostServices);
        }
        function appendClearCatcher(selection) {
            return selection.append("rect").classed("clearCatcher", !0).attr({
                width: "100%",
                height: "100%"
            });
        }
        function isCategoryColumnSelected(propertyId, categories, idx) {
            return null != categories.objects && categories.objects[idx] && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
        }
        function dataHasSelection(data) {
            for (var i = 0, ilen = data.length; ilen > i; i++) if (data[i].selected) return !0;
            return !1;
        }
        var ArrayExtensions = jsCommon.ArrayExtensions;
        visuals.createInteractivityService = createInteractivityService, visuals.appendClearCatcher = appendClearCatcher, 
        visuals.isCategoryColumnSelected = isCategoryColumnSelected, visuals.dataHasSelection = dataHasSelection;
        var InteractivityService = function() {
            function InteractivityService(hostServices) {
                this.renderSelectionInVisual = _.noop, this.renderSelectionInLegend = _.noop, this.renderSelectionInLabels = _.noop, 
                this.selectedIds = [], this.isInvertedSelectionMode = !1, this.hostService = hostServices;
            }
            return InteractivityService.prototype.bind = function(dataPoints, behavior, behaviorOptions, options) {
                var _this = this;
                options && options.overrideSelectionFromData && this.takeSelectionStateFromDataPoints(dataPoints), 
                options ? (options.isLegend ? (this.selectableLegendDataPoints = dataPoints, this.renderSelectionInLegend = function() {
                    return behavior.renderSelection(_this.legendHasSelection());
                }) : options.isLabels ? (this.selectableLabelsDataPoints = dataPoints, this.renderSelectionInLabels = function() {
                    return behavior.renderSelection(_this.labelsHasSelection());
                }) : (this.selectableDataPoints = dataPoints, this.renderSelectionInVisual = function() {
                    return behavior.renderSelection(_this.hasSelection());
                }), null != options.hasSelectionOverride && (this.hasSelectionOverride = options.hasSelectionOverride), 
                options.slicerDefaultValueHandler && (this.slicerDefaultValueHandler = options.slicerDefaultValueHandler)) : (this.selectableDataPoints = dataPoints, 
                this.renderSelectionInVisual = function() {
                    return behavior.renderSelection(_this.hasSelection());
                }), this.behavior = behavior, behavior.bindEvents(behaviorOptions, this), this.syncSelectionState();
            }, InteractivityService.prototype.clearSelection = function() {
                return this.slicerDefaultValueHandler && this.slicerDefaultValueHandler.getDefaultValue() && this.useDefaultValue ? void (this.isInvertedSelectionMode = !1) : (this.hasSelectionOverride = void 0, 
                ArrayExtensions.clear(this.selectedIds), this.isInvertedSelectionMode = !1, this.applyToAllSelectableDataPoints(function(dataPoint) {
                    return dataPoint.selected = !1;
                }), void this.renderAll());
            }, InteractivityService.prototype.applySelectionStateToData = function(dataPoints) {
                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var dataPoint = dataPoints_1[_i];
                    dataPoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(dataPoint, this.selectedIds);
                }
                return this.hasSelection();
            }, InteractivityService.prototype.hasSelection = function() {
                return this.selectedIds.length > 0;
            }, InteractivityService.prototype.legendHasSelection = function() {
                return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : !1;
            }, InteractivityService.prototype.labelsHasSelection = function() {
                return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : !1;
            }, InteractivityService.prototype.isSelectionModeInverted = function() {
                return this.isInvertedSelectionMode;
            }, InteractivityService.prototype.setSelectionModeInverted = function(inverted) {
                this.isInvertedSelectionMode = inverted;
            }, InteractivityService.prototype.handleSelection = function(dataPoint, multiSelect) {
                dataPoint && (this.useDefaultValue = !1, this.select(dataPoint, multiSelect), this.sendSelectionToHost(), 
                this.renderAll());
            }, InteractivityService.prototype.handleContextMenu = function(dataPoint, point) {
                this.sendContextMenuToHost(dataPoint, point);
            }, InteractivityService.prototype.handleClearSelection = function() {
                this.useDefaultValue = !0, this.clearSelection(), this.sendSelectionToHost();
            }, InteractivityService.prototype.toggleSelectionModeInversion = function() {
                return this.useDefaultValue = !1, this.isInvertedSelectionMode = !this.isInvertedSelectionMode, 
                ArrayExtensions.clear(this.selectedIds), this.applyToAllSelectableDataPoints(function(dataPoint) {
                    return dataPoint.selected = !1;
                }), this.sendSelectionToHost(), this.isInvertedSelectionMode ? this.syncSelectionStateInverted() : this.syncSelectionState(), 
                this.renderAll(), this.isInvertedSelectionMode;
            }, InteractivityService.prototype.persistSelectionFilter = function(filterPropertyIdentifier) {
                this.hostService.persistProperties(this.createChangeForFilterProperty(filterPropertyIdentifier));
            }, InteractivityService.prototype.setDefaultValueMode = function(useDefaultValue) {
                this.useDefaultValue = useDefaultValue;
            }, InteractivityService.prototype.isDefaultValueEnabled = function() {
                return this.useDefaultValue;
            }, InteractivityService.prototype.renderAll = function() {
                this.renderSelectionInVisual(), this.renderSelectionInLegend(), this.renderSelectionInLabels();
            }, InteractivityService.prototype.select = function(d, multiSelect) {
                if (this.isInvertedSelectionMode) return this.selectInverted(d, multiSelect);
                d.identity.highlight && (d = _.find(this.selectableDataPoints, function(dp) {
                    return !dp.identity.highlight && d.identity.includes(dp.identity, !0);
                }));
                var id = d.identity;
                if (id) {
                    var selected = !d.selected || !multiSelect && this.selectedIds.length > 1;
                    multiSelect && (selected ? (d.selected = !0, this.selectedIds.push(id)) : (d.selected = !1, 
                    this.removeId(id))), multiSelect && this.hostService.canSelect({
                        data: this.selectedIds.map(function(value) {
                            return value.getSelector();
                        })
                    }) || (this.clearSelection(), selected && (d.selected = !0, this.selectedIds.push(id))), 
                    this.syncSelectionState();
                }
            }, InteractivityService.prototype.selectInverted = function(d, multiSelect) {
                var wasSelected = d.selected, id = d.identity;
                d.selected = !wasSelected, wasSelected ? this.removeId(id) : this.selectedIds.push(id), 
                this.syncSelectionStateInverted();
            }, InteractivityService.prototype.removeId = function(toRemove) {
                for (var selectedIds = this.selectedIds, i = selectedIds.length - 1; i > -1; i--) {
                    var currentId = selectedIds[i];
                    toRemove.includes(currentId) && selectedIds.splice(i, 1);
                }
            }, InteractivityService.prototype.createChangeForFilterProperty = function(filterPropertyIdentifier) {
                var properties = {}, selectors = [];
                this.selectedIds.length > 0 && (selectors = _.chain(this.selectedIds).filter(function(value) {
                    return value.hasIdentity();
                }).map(function(value) {
                    return value.getSelector();
                }).value());
                var instance = {
                    objectName: filterPropertyIdentifier.objectName,
                    selector: void 0,
                    properties: properties
                }, filter = powerbi.data.Selector.filterFromSelector(selectors, this.isInvertedSelectionMode);
                return this.slicerDefaultValueHandler && this.slicerDefaultValueHandler.getDefaultValue() && (this.useDefaultValue === !0 ? filter = powerbi.data.SemanticFilter.getDefaultValueFilter(this.slicerDefaultValueHandler.getIdentityFields()) : _.isEmpty(selectors) && (filter = powerbi.data.SemanticFilter.getAnyValueFilter(this.slicerDefaultValueHandler.getIdentityFields()))), 
                null == filter ? (properties[filterPropertyIdentifier.propertyName] = {}, {
                    remove: [ instance ]
                }) : (properties[filterPropertyIdentifier.propertyName] = filter, {
                    merge: [ instance ]
                });
            }, InteractivityService.prototype.sendContextMenuToHost = function(dataPoint, position) {
                var host = this.hostService;
                if (host.onContextMenu) {
                    var selectors = this.getSelectorsByColumn([ dataPoint.identity ]);
                    if (!_.isEmpty(selectors)) {
                        var args = {
                            data: selectors,
                            position: position
                        };
                        host.onContextMenu(args);
                    }
                }
            }, InteractivityService.prototype.sendSelectionToHost = function() {
                var host = this.hostService;
                if (host.onSelect) {
                    var selectArgs = {
                        data: this.selectedIds.filter(function(value) {
                            return value.hasIdentity();
                        }).map(function(value) {
                            return value.getSelector();
                        })
                    }, data2 = this.getSelectorsByColumn(this.selectedIds);
                    _.isEmpty(data2) || (selectArgs.data2 = data2), host.onSelect(selectArgs);
                }
            }, InteractivityService.prototype.getSelectorsByColumn = function(selectionIds) {
                return _(selectionIds).filter(function(value) {
                    return value.hasIdentity;
                }).map(function(value) {
                    return value.getSelectorsByColumn();
                }).compact().value();
            }, InteractivityService.prototype.takeSelectionStateFromDataPoints = function(dataPoints) {
                var selectedIds = this.selectedIds;
                ArrayExtensions.clear(selectedIds);
                for (var _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var dataPoint = dataPoints_2[_i];
                    dataPoint.selected && selectedIds.push(dataPoint.identity);
                }
            }, InteractivityService.prototype.syncSelectionState = function() {
                if (this.isInvertedSelectionMode) return this.syncSelectionStateInverted();
                var selectedIds = this.selectedIds, selectableDataPoints = this.selectableDataPoints, selectableLegendDataPoints = this.selectableLegendDataPoints, selectableLabelsDataPoints = this.selectableLabelsDataPoints, foundMatchingId = !1;
                if (selectableDataPoints || selectableLegendDataPoints) {
                    if (selectableDataPoints && InteractivityService.updateSelectableDataPointsBySelectedIds(selectableDataPoints, selectedIds) && (foundMatchingId = !0), 
                    selectableLegendDataPoints && InteractivityService.updateSelectableDataPointsBySelectedIds(selectableLegendDataPoints, selectedIds) && (foundMatchingId = !0), 
                    selectableLabelsDataPoints) for (var labelsDataPoint_1, i = 0, ilen = selectableLabelsDataPoints.length; ilen > i; i++) labelsDataPoint_1 = selectableLabelsDataPoints[i], 
                    selectedIds.some(function(value) {
                        return value.includes(labelsDataPoint_1.identity);
                    }) ? labelsDataPoint_1.selected = !0 : labelsDataPoint_1.selected = !1;
                    !foundMatchingId && selectedIds.length > 0 && (this.clearSelection(), this.sendSelectionToHost());
                }
            }, InteractivityService.prototype.syncSelectionStateInverted = function() {
                var selectedIds = this.selectedIds, selectableDataPoints = this.selectableDataPoints;
                if (selectableDataPoints) if (0 === selectedIds.length) for (var _i = 0, selectableDataPoints_1 = selectableDataPoints; _i < selectableDataPoints_1.length; _i++) {
                    var dataPoint_1 = selectableDataPoints_1[_i];
                    dataPoint_1.selected = !1;
                } else for (var _a = 0, selectableDataPoints_2 = selectableDataPoints; _a < selectableDataPoints_2.length; _a++) {
                    var dataPoint = selectableDataPoints_2[_a];
                    selectedIds.some(function(value) {
                        return value.includes(dataPoint.identity);
                    }) ? dataPoint.selected = !0 : dataPoint.selected && (dataPoint.selected = !1);
                }
            }, InteractivityService.prototype.applyToAllSelectableDataPoints = function(action) {
                var selectableDataPoints = this.selectableDataPoints, selectableLegendDataPoints = this.selectableLegendDataPoints, selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                if (selectableDataPoints) for (var _i = 0, selectableDataPoints_3 = selectableDataPoints; _i < selectableDataPoints_3.length; _i++) {
                    var dataPoint = selectableDataPoints_3[_i];
                    action(dataPoint);
                }
                if (selectableLegendDataPoints) for (var _a = 0, selectableLegendDataPoints_1 = selectableLegendDataPoints; _a < selectableLegendDataPoints_1.length; _a++) {
                    var dataPoint = selectableLegendDataPoints_1[_a];
                    action(dataPoint);
                }
                if (selectableLabelsDataPoints) for (var _b = 0, selectableLabelsDataPoints_1 = selectableLabelsDataPoints; _b < selectableLabelsDataPoints_1.length; _b++) {
                    var dataPoint = selectableLabelsDataPoints_1[_b];
                    action(dataPoint);
                }
            }, InteractivityService.updateSelectableDataPointsBySelectedIds = function(selectableDataPoints, selectedIds) {
                for (var foundMatchingId = !1, _i = 0, selectableDataPoints_4 = selectableDataPoints; _i < selectableDataPoints_4.length; _i++) {
                    var datapoint = selectableDataPoints_4[_i];
                    datapoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(datapoint, selectedIds), 
                    datapoint.selected && (foundMatchingId = !0);
                }
                return foundMatchingId;
            }, InteractivityService.checkDatapointAgainstSelectedIds = function(datapoint, selectedIds) {
                return selectedIds.some(function(value) {
                    return value.includes(datapoint.identity);
                });
            }, InteractivityService;
        }();
        visuals.InteractivityService = InteractivityService;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var services;
        !function(services) {
            function createGeocoder() {
                return {
                    geocode: geocode,
                    geocodeBoundary: geocodeBoundary
                };
            }
            function isCategoryType(value) {
                return services.CategoryTypeArray.indexOf(value) > -1;
            }
            function mapLocalesForBing(locale) {
                switch (locale.toLowerCase()) {
                  case "fr":
                    return "fr-FR";

                  default:
                    return locale;
                }
            }
            function geocodeCore(geocodeQuery) {
                var result = geocodingCache ? geocodingCache.getCoordinates(geocodeQuery) : void 0, deferred = $.Deferred();
                return result ? deferred.resolve(result) : (geocodeQueue.push({
                    query: geocodeQuery,
                    deferred: deferred
                }), dequeue()), deferred;
            }
            function geocode(query, category) {
                return void 0 === category && (category = ""), geocodeCore(new GeocodeQuery(query, category));
            }
            function geocodeBoundary(latitude, longitude, category, levelOfDetail, maxGeoData) {
                return void 0 === category && (category = ""), void 0 === levelOfDetail && (levelOfDetail = 2), 
                void 0 === maxGeoData && (maxGeoData = 3), geocodeCore(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData));
            }
            function dequeue(decrement) {
                for (void 0 === decrement && (decrement = 0), activeRequests -= decrement; activeRequests < Settings.MaxBingRequest && 0 !== geocodeQueue.length; ) activeRequests++, 
                makeRequest(geocodeQueue.shift());
            }
            function makeRequest(item) {
                var result = geocodingCache ? geocodingCache.getCoordinates(item.query) : void 0;
                if (result) return setTimeout(function() {
                    return dequeue(1);
                }), void item.deferred.resolve(result);
                var config = {
                    type: "GET",
                    dataType: "jsonp",
                    jsonp: "jsonp"
                }, url = item.query.getUrl();
                url || completeRequest(item, new Error("Unsupported query. " + item.query.query)), 
                services.BingAjaxCall(url, config).then(function(data) {
                    try {
                        if (item.query instanceof GeocodeBoundaryQuery) {
                            var result_1 = data;
                            if (result_1 && result_1.d && Array.isArray(result_1.d.results) && result_1.d.results.length > 0) {
                                var entity = result_1.d.results[0], primitives = entity.Primitives;
                                if (primitives && primitives.length > 0) {
                                    var coordinates = {
                                        latitude: item.query.latitude,
                                        longitude: item.query.longitude,
                                        locations: []
                                    };
                                    primitives.sort(function(a, b) {
                                        return a.Shape.length < b.Shape.length ? 1 : a.Shape.length > b.Shape.length ? -1 : 0;
                                    });
                                    for (var maxGeoData = Math.min(primitives.length, item.query.maxGeoData), i = 0; maxGeoData > i; i++) for (var ringStr = primitives[i].Shape, ringArray = ringStr.split(","), j = 1; j < ringArray.length; j++) coordinates.locations.push({
                                        nativeBing: ringArray[j]
                                    });
                                    completeRequest(item, null, coordinates);
                                } else completeRequest(item, new Error("Geocode result is empty."));
                            } else completeRequest(item, new Error("Geocode result is empty."));
                        } else {
                            var resources = data.resourceSets[0].resources;
                            if (Array.isArray(resources) && resources.length > 0) {
                                var index = getBestResultIndex(resources, item.query), pointData = resources[index].point.coordinates, coordinates = {
                                    latitude: parseFloat(pointData[0]),
                                    longitude: parseFloat(pointData[1])
                                };
                                completeRequest(item, null, coordinates);
                            } else completeRequest(item, new Error("Geocode result is empty."));
                        }
                    } catch (error) {
                        completeRequest(item, error);
                    }
                }, function(error) {
                    completeRequest(item, error);
                });
            }
            function completeRequest(item, error, coordinate) {
                void 0 === coordinate && (coordinate = null), dequeueTimeoutId = setTimeout(function() {
                    return dequeue(1);
                }, Settings.UseDoubleArrayGeodataResult ? Settings.UseDoubleArrayDequeueTimeout : 0), 
                error ? item.deferred.reject(error) : (geocodingCache && geocodingCache.registerCoordinates(item.query, coordinate), 
                item.deferred.resolve(coordinate));
            }
            function getBestResultIndex(resources, query) {
                var queryString = query.query.toLowerCase();
                if (2 === queryString.length && query.category === CategoryTypes.CountryRegion) for (var index = 0; index < resources.length; index++) {
                    var iso2 = resources[index].address && resources[index].address.countryRegionIso2;
                    if (iso2 && queryString === iso2.toLowerCase()) return index;
                }
                for (var targetEntity = query.getBingEntity().toLowerCase(), index = 0; index < resources.length; index++) {
                    var resultEntity = (resources[index].entityType || "").toLowerCase();
                    if (resultEntity === targetEntity) return index;
                }
                return 0;
            }
            function reset() {
                geocodeQueue = [], activeRequests = 0, categoryToBingEntity = null, clearTimeout(dequeueTimeoutId);
            }
            var CategoryTypes = visuals.MapUtil.CategoryTypes, Settings = visuals.MapUtil.Settings;
            services.createGeocoder = createGeocoder, services.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-", 
            services.BingAjaxCall = $.ajax, services.CategoryTypeArray = [ "Address", "City", "Continent", "Country", "County", "Longitude", "Latitude", "Place", "PostalCode", "StateOrProvince" ], 
            services.isCategoryType = isCategoryType, services.BingEntities = {
                Continent: "Continent",
                Sovereign: "Sovereign",
                CountryRegion: "CountryRegion",
                AdminDivision1: "AdminDivision1",
                AdminDivision2: "AdminDivision2",
                PopulatedPlace: "PopulatedPlace",
                Postcode: "Postcode",
                Postcode1: "Postcode1",
                Neighborhood: "Neighborhood",
                Address: "Address"
            };
            var geocodeQueue, activeRequests, categoryToBingEntity, categoryToBingEntityGeodata, geocodingCache, GeocodeQuery = function() {
                function GeocodeQuery(query, category) {
                    this.query = null != query ? query : "", this.category = null != category ? category : "", 
                    this.key = (this.query + "/" + this.category).toLowerCase(), this.cacheHits = 0, 
                    geocodingCache || (geocodingCache = services.createGeocodingCache(Settings.MaxCacheSize, Settings.MaxCacheSizeOverflow));
                }
                return GeocodeQuery.prototype.incrementCacheHit = function() {
                    this.cacheHits++;
                }, GeocodeQuery.prototype.getCacheHits = function() {
                    return this.cacheHits;
                }, GeocodeQuery.prototype.getBingEntity = function() {
                    var category = this.category.toLowerCase();
                    return categoryToBingEntity || (categoryToBingEntity = {}, categoryToBingEntity[CategoryTypes.Continent.toLowerCase()] = services.BingEntities.Continent, 
                    categoryToBingEntity[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.Sovereign, 
                    categoryToBingEntity[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1, 
                    categoryToBingEntity[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2, 
                    categoryToBingEntity[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace, 
                    categoryToBingEntity[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode, 
                    categoryToBingEntity[CategoryTypes.Address.toLowerCase()] = services.BingEntities.Address), 
                    categoryToBingEntity[category] || "";
                }, GeocodeQuery.prototype.getUrl = function() {
                    var url = Settings.BingUrl + "key=" + Settings.BingKey, entityType = this.getBingEntity(), queryAdded = !1;
                    if (entityType) if (entityType === services.BingEntities.Postcode) url += "&includeEntityTypes=Postcode,Postcode1,Postcode2,Postcode3,Postcode4"; else if (-1 !== this.query.indexOf(",") || entityType !== services.BingEntities.AdminDivision1 && entityType !== services.BingEntities.AdminDivision2) url += "&includeEntityTypes=" + entityType; else {
                        queryAdded = !0;
                        try {
                            url += "&adminDistrict=" + decodeURIComponent(this.query);
                        } catch (e) {
                            return null;
                        }
                    }
                    if (!queryAdded) try {
                        url += "&q=" + decodeURIComponent(this.query);
                    } catch (e) {
                        return null;
                    }
                    var cultureName = navigator.userLanguage || navigator.language;
                    return cultureName = mapLocalesForBing(cultureName), cultureName && (url += "&c=" + cultureName), 
                    url += "&maxRes=20", 2 === this.query.length && this.category === CategoryTypes.CountryRegion && (url += "&include=ciso2"), 
                    url;
                }, GeocodeQuery;
            }();
            services.GeocodeQuery = GeocodeQuery;
            var GeocodeBoundaryQuery = function(_super) {
                function GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData) {
                    void 0 === maxGeoData && (maxGeoData = 3), _super.call(this, [ latitude, longitude, levelOfDetail, maxGeoData ].join(","), category), 
                    this.latitude = latitude, this.longitude = longitude, this.levelOfDetail = levelOfDetail, 
                    this.maxGeoData = maxGeoData;
                }
                return __extends(GeocodeBoundaryQuery, _super), GeocodeBoundaryQuery.prototype.getBingEntity = function() {
                    var category = this.category.toLowerCase();
                    return categoryToBingEntityGeodata || (categoryToBingEntityGeodata = {}, categoryToBingEntityGeodata[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.CountryRegion, 
                    categoryToBingEntityGeodata[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1, 
                    categoryToBingEntityGeodata[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2, 
                    categoryToBingEntityGeodata[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace, 
                    categoryToBingEntityGeodata[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode1), 
                    categoryToBingEntityGeodata[category] || "";
                }, GeocodeBoundaryQuery.prototype.getUrl = function() {
                    var url = Settings.BingUrlGeodata + "key=" + Settings.BingKey + "&$format=json", entityType = this.getBingEntity();
                    if (!entityType) return null;
                    var cultureName = navigator.userLanguage || navigator.language;
                    cultureName = mapLocalesForBing(cultureName);
                    var cultures = cultureName.split("-"), data = [ this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'" ];
                    return cultures.length > 1 && data.push("'" + cultures[1] + "'"), url + "&SpatialFilter=GetBoundary(" + data.join(", ") + ")";
                }, GeocodeBoundaryQuery;
            }(GeocodeQuery);
            services.GeocodeBoundaryQuery = GeocodeBoundaryQuery, services.geocodeCore = geocodeCore, 
            services.geocode = geocode, services.geocodeBoundary = geocodeBoundary;
            var dequeueTimeoutId;
            services.reset = reset, reset();
        }(services = visuals.services || (visuals.services = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var services;
        !function(services) {
            function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                return new GeocodingCache(maxCacheSize, maxCacheSizeOverflow);
            }
            services.createGeocodingCache = createGeocodingCache;
            var GeocodingCache = function() {
                function GeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                    this.geocodeCache = {}, this.maxCacheSize = maxCacheSize, this.maxCacheSizeOverflow = maxCacheSizeOverflow;
                }
                return GeocodingCache.prototype.getCoordinates = function(query) {
                    var pair = this.geocodeCache[query.key];
                    return pair ? (pair.query.incrementCacheHit(), pair.coordinate) : (pair = powerbi.localStorageService.getData(query.key), 
                    pair ? (this.registerInMemory(query, pair.coordinate), pair.coordinate) : void 0);
                }, GeocodingCache.prototype.registerCoordinates = function(query, coordinate) {
                    this.registerInMemory(query, coordinate), this.registerInStorage(query, coordinate);
                }, GeocodingCache.prototype.registerInMemory = function(query, coordinate) {
                    var geocodeCache = this.geocodeCache, keys = Object.keys(geocodeCache), cacheSize = keys.length, maxCacheSize = this.maxCacheSize;
                    if (keys.length > maxCacheSize + this.maxCacheSizeOverflow) for (var sortedKeys = keys.sort(function(a, b) {
                        var cachedA = geocodeCache[a], cachedB = geocodeCache[b], ca = cachedA ? cachedA.query.getCacheHits() : 0, cb = cachedB ? cachedB.query.getCacheHits() : 0;
                        return cb > ca ? -1 : ca > cb ? 1 : 0;
                    }), i = 0; cacheSize - maxCacheSize > i; i++) geocodeCache[sortedKeys[i]] = void 0;
                    geocodeCache[query.key] = {
                        query: query,
                        coordinate: coordinate
                    };
                }, GeocodingCache.prototype.registerInStorage = function(query, coordinate) {
                    powerbi.localStorageService.setData(query.key, {
                        query: query,
                        coordinate: coordinate
                    });
                }, GeocodingCache;
            }();
        }(services = visuals.services || (visuals.services = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var services;
        !function(services) {
            function createGeolocation() {
                return new GeolocationService();
            }
            services.createGeolocation = createGeolocation;
            var GeolocationService = function() {
                function GeolocationService() {
                    this.webGeolocation = navigator.geolocation;
                }
                return GeolocationService.prototype.watchPosition = function(successCallback, errorCallback) {
                    return this.webGeolocation.watchPosition(function(position) {
                        successCallback(position);
                    }, function(error) {
                        null != errorCallback && errorCallback(error);
                    });
                }, GeolocationService.prototype.clearWatch = function(watchId) {
                    this.webGeolocation.clearWatch(watchId);
                }, GeolocationService.prototype.getCurrentPosition = function(successCallback, errorCallback) {
                    this.webGeolocation.getCurrentPosition(function(position) {
                        successCallback(position);
                    }, function(error) {
                        null != errorCallback && errorCallback(error);
                    });
                }, GeolocationService;
            }();
        }(services = visuals.services || (visuals.services = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var visualPluginFactory, unsupportedVisuals = [ "play", "subview", "smallMultiple" ];
        !function(visualPluginFactory) {
            function createPlugin(visualPlugins, base, create, modifyPluginFn) {
                var visualPlugin = powerbi.Prototype.inherit(base);
                visualPlugin.create = create, modifyPluginFn && modifyPluginFn(visualPlugin), visualPlugins[base.name] = visualPlugin;
            }
            function createDashboardPlugins(plugins, options, featureSwitches) {
                var tooltipsOnDashboard = options.tooltipsEnabled, lineChartLabelDensityEnabled = featureSwitches && featureSwitches.lineChartLabelDensityEnabled, tablixFormattingEnabled = featureSwitches ? featureSwitches.tablixFormattingEnabled : !1;
                createPlugin(plugins, powerbi.visuals.plugins.barChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 6,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.clusteredBarChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 5,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.clusteredColumnChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 3,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.columnChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 4,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 15,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 16,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.donutChart, function() {
                    return new visuals.DonutChart({
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.funnel, function() {
                    return new visuals.FunnelChart({
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.gauge, function() {
                    return new visuals.Gauge({
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 7,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 8,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.lineChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 0,
                        tooltipsEnabled: tooltipsOnDashboard,
                        lineChartLabelDensityEnabled: lineChartLabelDensityEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.areaChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 1,
                        tooltipsEnabled: tooltipsOnDashboard,
                        lineChartLabelDensityEnabled: lineChartLabelDensityEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.stackedAreaChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 2,
                        tooltipsEnabled: tooltipsOnDashboard,
                        lineChartLabelDensityEnabled: lineChartLabelDensityEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 13,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 14,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.pieChart, function() {
                    return new visuals.DonutChart({
                        sliceWidthRatio: 0,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.scatterChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 9,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.treemap, function() {
                    return new visuals.Treemap({
                        isScrollable: !1,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.waterfallChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 12,
                        tooltipsEnabled: tooltipsOnDashboard
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.map, function() {
                    return new visuals.Map({
                        tooltipsEnabled: tooltipsOnDashboard,
                        disableZooming: !0,
                        disablePanning: !0
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.filledMap, function() {
                    return new visuals.Map({
                        filledMap: !0,
                        tooltipsEnabled: tooltipsOnDashboard,
                        disableZooming: !0,
                        disablePanning: !0
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.matrix, function() {
                    return new visuals.Matrix({
                        isFormattingPropertiesEnabled: tablixFormattingEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.table, function() {
                    return new visuals.Table({
                        isFormattingPropertiesEnabled: tablixFormattingEnabled,
                        isConditionalFormattingEnabled: !1
                    });
                });
            }
            function createMinervaPlugins(plugins, featureSwitches) {
                var scriptVisualEnabled = featureSwitches ? featureSwitches.scriptVisualEnabled : !1, scriptVisualAuthoringEnabled = featureSwitches ? featureSwitches.scriptVisualAuthoringEnabled : !1, isLabelInteractivityEnabled = featureSwitches ? featureSwitches.isLabelInteractivityEnabled : !1, tablixFormattingEnabled = featureSwitches ? featureSwitches.tablixFormattingEnabled : !1, conditionalFormattingEnabled = featureSwitches ? featureSwitches.conditionalFormattingEnabled : !1, fillMapDataLabelsEnabled = featureSwitches ? featureSwitches.filledMapDataLabelsEnabled : !1, lineChartLabelDensityEnabled = featureSwitches ? featureSwitches.lineChartLabelDensityEnabled : !1;
                createPlugin(plugins, powerbi.visuals.plugins.barChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 6,
                        isScrollable: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: !0,
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.card, function() {
                    return new visuals.Card({
                        isScrollable: !0,
                        animator: new visuals.BaseAnimator()
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.clusteredBarChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 5,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.clusteredColumnChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 3,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.columnChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 4,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 15,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior(), new visuals.DataDotChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 16,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior(), new visuals.DataDotChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.donutChart, function() {
                    return new visuals.DonutChart({
                        animator: new visuals.WebDonutChartAnimator(),
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        behavior: new visuals.DonutChartWebBehavior()
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.funnel, function() {
                    return new visuals.FunnelChart({
                        animator: new visuals.WebFunnelAnimator(),
                        behavior: new visuals.FunnelWebBehavior(),
                        tooltipsEnabled: !0
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.gauge, function() {
                    return new visuals.Gauge({
                        animator: new visuals.BaseAnimator(),
                        tooltipsEnabled: !0
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 7,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 8,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.lineChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 0,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.BaseAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.LineChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.areaChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 1,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.BaseAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.LineChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.stackedAreaChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 2,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.BaseAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.LineChartWebBehavior() ]),
                        lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 13,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior(), new visuals.LineChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 14,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior(), new visuals.LineChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.pieChart, function() {
                    return new visuals.DonutChart({
                        sliceWidthRatio: 0,
                        animator: new visuals.WebDonutChartAnimator(),
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        behavior: new visuals.DonutChartWebBehavior()
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.scatterChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 9,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        animator: new visuals.BaseAnimator(),
                        behavior: new visuals.CartesianChartBehavior([ new visuals.ScatterChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.treemap, function() {
                    return new visuals.Treemap({
                        animator: new visuals.WebTreemapAnimator(),
                        isScrollable: !0,
                        behavior: new visuals.TreemapWebBehavior(),
                        tooltipsEnabled: !0
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.waterfallChart, function() {
                    return new visuals.CartesianChart({
                        chartType: 12,
                        isScrollable: !0,
                        tooltipsEnabled: !0,
                        behavior: new visuals.CartesianChartBehavior([ new visuals.WaterfallChartWebBehavior() ]),
                        isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                        trendLinesEnabled: featureSwitches.trendLinesEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.map, function() {
                    return new visuals.Map({
                        behavior: new visuals.MapBehavior(),
                        tooltipsEnabled: !0,
                        isLegendScrollable: !0
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.filledMap, function() {
                    return new visuals.Map({
                        filledMap: !0,
                        behavior: new visuals.MapBehavior(),
                        tooltipsEnabled: !0,
                        filledMapDataLabelsEnabled: fillMapDataLabelsEnabled,
                        isLegendScrollable: !0
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.slicer, function() {
                    return new visuals.Slicer({
                        behavior: new visuals.SlicerWebBehavior()
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.matrix, function() {
                    return new visuals.Matrix({
                        isFormattingPropertiesEnabled: tablixFormattingEnabled
                    });
                }), createPlugin(plugins, powerbi.visuals.plugins.table, function() {
                    return new visuals.Table({
                        isFormattingPropertiesEnabled: tablixFormattingEnabled,
                        isConditionalFormattingEnabled: conditionalFormattingEnabled
                    });
                }), scriptVisualEnabled && scriptVisualAuthoringEnabled && createPlugin(plugins, powerbi.visuals.plugins.scriptVisual, function() {
                    return new visuals.ScriptVisual({
                        canRefresh: !0
                    });
                });
            }
            function create() {
                return new VisualPluginService(void 0);
            }
            function createVisualPluginService(featureSwitch) {
                return new VisualPluginService(featureSwitch);
            }
            function createMinerva(featureSwitches) {
                return new MinervaVisualPluginService(featureSwitches);
            }
            function createDashboard(featureSwitches, options) {
                return new DashboardPluginService(featureSwitches, options);
            }
            function createInsights(featureSwitches) {
                return new InsightsPluginService(featureSwitches);
            }
            function createMobile(smallViewPortProperties, featureSwitches) {
                return new MobileVisualPluginService(smallViewPortProperties, featureSwitches);
            }
            var VisualPluginService = function() {
                function VisualPluginService(featureSwitches) {
                    this.plugins = powerbi.visuals.plugins, this.featureSwitches = featureSwitches;
                }
                return VisualPluginService.prototype.getVisuals = function() {
                    var registry = this.plugins, names = Object.keys(registry);
                    return names.map(function(name) {
                        return registry[name];
                    });
                }, VisualPluginService.prototype.getPlugin = function(type) {
                    if (type) {
                        var plugin = this.plugins[type];
                        if (plugin) return plugin;
                    }
                }, VisualPluginService.prototype.capabilities = function(type) {
                    var plugin = this.getPlugin(type);
                    return plugin ? plugin.capabilities : void 0;
                }, VisualPluginService.prototype.requireSandbox = function(plugin) {
                    return plugin && plugin.custom;
                }, VisualPluginService.prototype.removeAnyCustomVisuals = function() {
                    var plugins = powerbi.visuals.plugins;
                    for (var key in plugins) {
                        var p = plugins[key];
                        p.custom && delete plugins[key];
                    }
                }, VisualPluginService.prototype.isCustomVisual = function(visual) {
                    return visual ? this.plugins[visual] ? this.plugins[visual].custom === !0 : !_.include(unsupportedVisuals, visual) : !1;
                }, VisualPluginService.prototype.shouldDisableVisual = function(type, mapDisabled) {
                    return (type === visuals.plugins.map.name || type === visuals.plugins.filledMap.name) && mapDisabled;
                }, VisualPluginService.prototype.isScriptVisualQueryable = function() {
                    return void 0 !== this.featureSwitches && this.featureSwitches.scriptVisualEnabled;
                }, VisualPluginService.prototype.getInteractivityOptions = function(visualType) {
                    var interactivityOptions = {
                        overflow: "hidden"
                    };
                    return interactivityOptions;
                }, VisualPluginService;
            }();
            visualPluginFactory.VisualPluginService = VisualPluginService, visualPluginFactory.createPlugin = createPlugin;
            var MinervaVisualPluginService = function(_super) {
                function MinervaVisualPluginService(featureSwitches) {
                    _super.call(this, featureSwitches), this.visualPlugins = {}, this.addCustomVisualizations([]), 
                    createMinervaPlugins(this.visualPlugins, this.featureSwitches);
                }
                return __extends(MinervaVisualPluginService, _super), MinervaVisualPluginService.prototype.getVisuals = function() {
                    var convertibleVisualTypes = [ powerbi.visuals.plugins.barChart, powerbi.visuals.plugins.columnChart, powerbi.visuals.plugins.clusteredBarChart, powerbi.visuals.plugins.clusteredColumnChart, powerbi.visuals.plugins.hundredPercentStackedBarChart, powerbi.visuals.plugins.hundredPercentStackedColumnChart, powerbi.visuals.plugins.lineChart, powerbi.visuals.plugins.areaChart, powerbi.visuals.plugins.stackedAreaChart, powerbi.visuals.plugins.lineStackedColumnComboChart, powerbi.visuals.plugins.lineClusteredColumnComboChart, powerbi.visuals.plugins.waterfallChart, powerbi.visuals.plugins.scatterChart, powerbi.visuals.plugins.pieChart, powerbi.visuals.plugins.treemap, powerbi.visuals.plugins.map, powerbi.visuals.plugins.table, powerbi.visuals.plugins.matrix, powerbi.visuals.plugins.filledMap, powerbi.visuals.plugins.funnel, powerbi.visuals.plugins.gauge, powerbi.visuals.plugins.multiRowCard, powerbi.visuals.plugins.card, powerbi.visuals.plugins.kpi, powerbi.visuals.plugins.slicer, powerbi.visuals.plugins.donutChart ];
                    this.featureSwitches.scriptVisualEnabled && this.featureSwitches.scriptVisualAuthoringEnabled && convertibleVisualTypes.push(powerbi.visuals.plugins.scriptVisual);
                    for (var p in visuals.plugins) {
                        var plugin = visuals.plugins[p];
                        plugin.custom && this.pushPluginIntoConvertibleTypes(convertibleVisualTypes, plugin);
                    }
                    return this.addCustomVisualizations(convertibleVisualTypes), this.featureSwitches.dataDotChartEnabled && (convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotClusteredColumnComboChart), 
                    convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotStackedColumnComboChart)), 
                    convertibleVisualTypes;
                }, MinervaVisualPluginService.prototype.pushPluginIntoConvertibleTypes = function(convertibleVisualTypes, plugin) {
                    convertibleVisualTypes.some(function(pl) {
                        return pl.name === plugin.name;
                    }) || convertibleVisualTypes.push(plugin);
                }, MinervaVisualPluginService.prototype.addCustomVisualizations = function(convertibleVisualTypes) {
                    var customVisualizationDict = powerbi.localStorageService.getData("customVisualMetaData");
                    for (var visualName in customVisualizationDict) {
                        var customVisualMetaData = customVisualizationDict[visualName];
                        if (customVisualMetaData) {
                            var pluginName = customVisualMetaData.pluginName;
                            if (pluginName && customVisualMetaData.sourceCode && customVisualMetaData.sourceCode.javascriptCode) {
                                var plugin = this.getPlugin(pluginName);
                                if (!plugin) {
                                    var jsCode = customVisualMetaData.sourceCode.javascriptCode, script = $("<script/>", {
                                        html: jsCode + "//# sourceURL=" + pluginName + ".js\n//# sourceMappingURL=" + pluginName + ".js.map"
                                    });
                                    script.attr("pluginName", pluginName), $("body").append(script);
                                    var style = $("<style/>", {
                                        html: customVisualMetaData.sourceCode.cssCode
                                    });
                                    if (style.attr("pluginName", pluginName), $("head").append(style), plugin = this.getPlugin(pluginName), 
                                    !plugin) continue;
                                }
                                this.pushPluginIntoConvertibleTypes(convertibleVisualTypes, plugin);
                            }
                        }
                    }
                }, MinervaVisualPluginService.prototype.getPlugin = function(type) {
                    return this.visualPlugins[type] ? this.visualPlugins[type] : _super.prototype.getPlugin.call(this, type);
                }, MinervaVisualPluginService.prototype.requireSandbox = function(plugin) {
                    return this.featureSwitches.sandboxVisualsEnabled && (!plugin || plugin && plugin.custom);
                }, MinervaVisualPluginService;
            }(VisualPluginService);
            visualPluginFactory.MinervaVisualPluginService = MinervaVisualPluginService;
            var PlaygroundVisualPluginService = function(_super) {
                function PlaygroundVisualPluginService() {
                    _super.call(this, void 0), this.visualPlugins = powerbi.visuals.plugins, createMinervaPlugins(this.visualPlugins, {});
                }
                return __extends(PlaygroundVisualPluginService, _super), PlaygroundVisualPluginService.prototype.getVisuals = function() {
                    var registry = this.visualPlugins, names = Object.keys(registry);
                    return names.map(function(name) {
                        return registry[name];
                    });
                }, PlaygroundVisualPluginService.prototype.getPlugin = function(type) {
                    if (type) {
                        var plugin = this.visualPlugins[type];
                        if (plugin) return plugin;
                    }
                }, PlaygroundVisualPluginService.prototype.capabilities = function(type) {
                    var plugin = this.getPlugin(type);
                    return plugin ? plugin.capabilities : void 0;
                }, PlaygroundVisualPluginService;
            }(VisualPluginService);
            visualPluginFactory.PlaygroundVisualPluginService = PlaygroundVisualPluginService;
            var DashboardPluginService = function(_super) {
                function DashboardPluginService(featureSwitches, options) {
                    _super.call(this, featureSwitches), this.visualPlugins = {}, createDashboardPlugins(this.visualPlugins, options, this.featureSwitches);
                }
                return __extends(DashboardPluginService, _super), DashboardPluginService.prototype.getPlugin = function(type) {
                    return this.visualPlugins[type] ? this.visualPlugins[type] : _super.prototype.getPlugin.call(this, type);
                }, DashboardPluginService.prototype.requireSandbox = function(plugin) {
                    return this.featureSwitches.sandboxVisualsEnabled && (!plugin || plugin && plugin.custom);
                }, DashboardPluginService;
            }(VisualPluginService);
            visualPluginFactory.DashboardPluginService = DashboardPluginService;
            var InsightsPluginService = function(_super) {
                function InsightsPluginService(featureSwitches) {
                    _super.call(this, featureSwitches), this.visualPlugins = {}, createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 5,
                            animator: new visuals.WebColumnChartAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 4,
                            animator: new visuals.WebColumnChartAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function() {
                        return new visuals.DonutChart({
                            animator: new visuals.WebDonutChartAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 7,
                            animator: new visuals.WebColumnChartAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 8,
                            animator: new visuals.WebColumnChartAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 0,
                            animator: new visuals.BaseAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 1,
                            animator: new visuals.BaseAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function() {
                        return new visuals.DonutChart({
                            sliceWidthRatio: 0,
                            animator: new visuals.WebDonutChartAnimator(),
                            tooltipsEnabled: !0
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 9,
                            animator: new visuals.BaseAnimator(),
                            tooltipsEnabled: !0
                        });
                    }, void 0);
                }
                return __extends(InsightsPluginService, _super), InsightsPluginService.prototype.getPlugin = function(type) {
                    return this.visualPlugins[type] ? this.visualPlugins[type] : _super.prototype.getPlugin.call(this, type);
                }, InsightsPluginService.prototype.requireSandbox = function(plugin) {
                    return this.featureSwitches.sandboxVisualsEnabled && (!plugin || plugin && plugin.custom);
                }, InsightsPluginService;
            }(VisualPluginService);
            visualPluginFactory.InsightsPluginService = InsightsPluginService;
            var MobileVisualPluginService = function(_super) {
                function MobileVisualPluginService(smallViewPortProperties, featureSwitches) {
                    var _this = this;
                    _super.call(this, featureSwitches), this.smallViewPortProperties = smallViewPortProperties || {
                        CartesianSmallViewPortProperties: {
                            hideAxesOnSmallViewPort: !0,
                            hideLegendOnSmallViewPort: !0,
                            MinHeightLegendVisible: MobileVisualPluginService.MinHeightLegendVisible,
                            MinHeightAxesVisible: MobileVisualPluginService.MinHeightAxesVisible
                        },
                        GaugeSmallViewPortProperties: {
                            hideGaugeSideNumbersOnSmallViewPort: !0,
                            smallGaugeMarginsOnSmallViewPort: !0,
                            MinHeightGaugeSideNumbersVisible: MobileVisualPluginService.MinHeightGaugeSideNumbersVisible,
                            GaugeMarginsOnSmallViewPort: MobileVisualPluginService.GaugeMarginsOnSmallViewPort
                        },
                        FunnelSmallViewPortProperties: {
                            hideFunnelCategoryLabelsOnSmallViewPort: !0,
                            minHeightFunnelCategoryLabelsVisible: MobileVisualPluginService.MinHeightFunnelCategoryLabelsVisible
                        },
                        DonutSmallViewPortProperties: {
                            maxHeightToScaleDonutLegend: MobileVisualPluginService.MaxHeightToScaleDonutLegend
                        }
                    }, visuals.TooltipManager.ShowTooltips = !1;
                    var trimOrdinalDataOnOverflow = !1, mapThrottleInterval = this.getMapThrottleInterval();
                    this.visualPlugins = {}, createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 1,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.barChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 6,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 5,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredColumnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 3,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 4,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.comboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 10,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 11,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 15,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 16,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 7,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 8,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.stackedAreaChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 2,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.waterfallChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 12,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 0,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 13,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 14,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                            trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 9,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                            behavior: new visuals.CartesianChartBehavior([ new visuals.ScatterChartMobileBehavior() ])
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.gauge, function() {
                        return new visuals.Gauge({
                            gaugeSmallViewPortProperties: _this.smallViewPortProperties.GaugeSmallViewPortProperties
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.funnel, function() {
                        return new visuals.FunnelChart({
                            animator: null,
                            funnelSmallViewPortProperties: _this.smallViewPortProperties.FunnelSmallViewPortProperties
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function() {
                        return new visuals.DonutChart({
                            disableGeometricCulling: !0,
                            smallViewPortProperties: _this.smallViewPortProperties.DonutSmallViewPortProperties
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function() {
                        return new visuals.DonutChart({
                            sliceWidthRatio: 0,
                            disableGeometricCulling: !0,
                            smallViewPortProperties: _this.smallViewPortProperties.DonutSmallViewPortProperties
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.matrix, function() {
                        return new visuals.Matrix({
                            isTouchEnabled: !0,
                            isFormattingPropertiesEnabled: featureSwitches ? featureSwitches.tablixFormattingEnabled : !1
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.table, function() {
                        return new visuals.Table({
                            isTouchEnabled: !0,
                            isFormattingPropertiesEnabled: featureSwitches ? featureSwitches.tablixFormattingEnabled : !1
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.map, function() {
                        return new visuals.Map({
                            viewChangeThrottleInterval: mapThrottleInterval,
                            enableCurrentLocation: featureSwitches ? featureSwitches.mapCurrentLocationEnabled : !1
                        });
                    }), createPlugin(this.visualPlugins, powerbi.visuals.plugins.filledMap, function() {
                        return new visuals.Map({
                            filledMap: !0,
                            viewChangeThrottleInterval: mapThrottleInterval
                        });
                    });
                }
                return __extends(MobileVisualPluginService, _super), MobileVisualPluginService.prototype.getPlugin = function(type) {
                    return this.visualPlugins[type] ? this.visualPlugins[type] : _super.prototype.getPlugin.call(this, type);
                }, MobileVisualPluginService.prototype.requireSandbox = function(plugin) {
                    return this.featureSwitches ? this.featureSwitches.sandboxVisualsEnabled && (!plugin || plugin && plugin.custom) : _super.prototype.requireSandbox.call(this, plugin);
                }, MobileVisualPluginService.prototype.getMapThrottleInterval = function() {
                    var windowsPhoneThrottleInterval = 100, userAgentLowerCase = navigator.userAgent.toLowerCase();
                    return -1 !== userAgentLowerCase.indexOf("windows phone") ? windowsPhoneThrottleInterval : void 0;
                }, MobileVisualPluginService.prototype.getInteractivityOptions = function(visualType) {
                    var mobileOptions = {
                        overflow: this.getMobileOverflowString(visualType),
                        isInteractiveLegend: this.isChartSupportInteractivity(visualType),
                        selection: !0
                    };
                    return mobileOptions;
                }, MobileVisualPluginService.prototype.getMobileOverflowString = function(visualType) {
                    switch (visualType) {
                      case "multiRowCard":
                        return "visible";

                      default:
                        return "hidden";
                    }
                }, MobileVisualPluginService.prototype.isChartSupportInteractivity = function(visualType) {
                    switch (visualType) {
                      case "areaChart":
                      case "barChart":
                      case "clusteredBarChart":
                      case "clusteredColumnChart":
                      case "columnChart":
                      case "donutChart":
                      case "hundredPercentStackedBarChart":
                      case "hundredPercentStackedColumnChart":
                      case "lineChart":
                      case "pieChart":
                      case "scatterChart":
                      case "table":
                      case "matrix":
                      case "multiRowCard":
                        return !0;

                      default:
                        return !1;
                    }
                }, MobileVisualPluginService.MinHeightLegendVisible = 125, MobileVisualPluginService.MinHeightAxesVisible = 125, 
                MobileVisualPluginService.MinHeightGaugeSideNumbersVisible = 80, MobileVisualPluginService.GaugeMarginsOnSmallViewPort = 10, 
                MobileVisualPluginService.MinHeightFunnelCategoryLabelsVisible = 80, MobileVisualPluginService.MaxHeightToScaleDonutLegend = 300, 
                MobileVisualPluginService;
            }(VisualPluginService);
            visualPluginFactory.MobileVisualPluginService = MobileVisualPluginService, visualPluginFactory.create = create, 
            visualPluginFactory.createVisualPluginService = createVisualPluginService, visualPluginFactory.createMinerva = createMinerva, 
            visualPluginFactory.createDashboard = createDashboard, visualPluginFactory.createInsights = createInsights, 
            visualPluginFactory.createMobile = createMobile;
        }(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            function fire(eventHandlers, eventArgs) {
                if (eventHandlers) for (var i = 0; i < eventHandlers.length; i++) {
                    var h = eventHandlers[i];
                    h(eventArgs);
                }
            }
            var UNSELECTABLE_CLASS_NAME = "unselectable";
            controls.fire = fire;
            var ScrollbarButton = function() {
                function ScrollbarButton(owner, direction) {
                    this._owner = owner, this._direction = direction, this._timerHandle = void 0, this.createView();
                    var that = this;
                    this._element.addEventListener("mousedown", function(e) {
                        that.onMouseDown(e);
                    }), $(this._element).addClass(UNSELECTABLE_CLASS_NAME), $(this._svg).addClass(UNSELECTABLE_CLASS_NAME), 
                    $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
                }
                return Object.defineProperty(ScrollbarButton.prototype, "element", {
                    get: function() {
                        return this._element;
                    },
                    enumerable: !0,
                    configurable: !0
                }), ScrollbarButton.prototype.createView = function() {
                    var svgns = "http://www.w3.org/2000/svg";
                    this._polygon = document.createElementNS(svgns, "polygon"), this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8"), 
                    this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR), this._svg = document.createElementNS(svgns, "svg");
                    var svgStyle = this._svg.style;
                    svgStyle.position = "absolute", svgStyle.left = "0px", svgStyle.top = "0px", this._svg.appendChild(this._polygon), 
                    this._element = document.createElement("div"), this._element.className = Scrollbar.arrowClassName, 
                    this._element.appendChild(this._svg), this._owner.element.appendChild(this._element);
                }, ScrollbarButton.prototype.onMouseDown = function(event) {
                    var that = this;
                    if (clearTimeout(this._timerHandle), !this._mouseUpWrapper) {
                        event.cancelBubble = !0;
                        var that_1 = this;
                        this._mouseUpWrapper = function(event) {
                            that_1.onMouseUp(event);
                        }, Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
                    }
                    this._owner._scrollSmallIncrement(this._direction), this._owner.refresh(), this._timerHandle = setTimeout(function() {
                        that.onMouseDown(event);
                    }, 100), event.preventDefault && event.preventDefault();
                }, ScrollbarButton.prototype.onMouseUp = function(event) {
                    clearTimeout(this._timerHandle), Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper), 
                    this._mouseUpWrapper = void 0;
                }, ScrollbarButton.prototype.arrange = function(width, height, angle) {
                    var size = Math.min(width, height), scale = size / 16, x = (width - size) / 2, y = (height - size) / 2;
                    this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)"), 
                    this._svg.setAttributeNS(null, "width", width + "px"), this._svg.setAttributeNS(null, "height", height + "px"), 
                    controls.HTMLElementUtils.setElementWidth(this._element, width), controls.HTMLElementUtils.setElementHeight(this._element, height);
                }, ScrollbarButton.MIN_WIDTH = 26, ScrollbarButton.ARROW_COLOR = "#404040", ScrollbarButton;
            }();
            controls.ScrollbarButton = ScrollbarButton;
            var Scrollbar = function() {
                function Scrollbar(parentElement, layoutKind) {
                    this.MIN_BAR_SIZE = 10, this.min = 0, this.max = 10, this.viewMin = 0, this.viewSize = 2, 
                    this.smallIncrement = 1, this._onscroll = [], this._screenToOffsetScale = 1, this.createView(parentElement, layoutKind);
                    var that = this;
                    this._element.addEventListener("mousedown", function(e) {
                        that.onBackgroundMouseDown(e);
                    }), this._middleBar.addEventListener("mousedown", function(e) {
                        that.onMiddleBarMouseDown(e);
                    }), this._timerHandle = void 0, this._visible = !0, this.element.winControl = this, 
                    $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
                }
                return Scrollbar.prototype.scrollBy = function(delta) {
                    this.scrollTo(this.viewMin + delta);
                }, Scrollbar.prototype.scrollUp = function() {
                    this.scrollBy(-this.smallIncrement);
                }, Scrollbar.prototype.scrollDown = function() {
                    this.scrollBy(this.smallIncrement);
                }, Scrollbar.prototype.scrollPageUp = function() {
                    this.scrollBy(-this.viewSize);
                }, Scrollbar.prototype.scrollPageDown = function() {
                    this.scrollBy(this.viewSize);
                }, Object.defineProperty(Scrollbar.prototype, "width", {
                    get: function() {
                        return this._width;
                    },
                    set: function(value) {
                        this._width = value, this._element.style.width = value, this.invalidateArrange();
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(Scrollbar.prototype, "height", {
                    get: function() {
                        return this._height;
                    },
                    set: function(value) {
                        this._height = value, this._element.style.height = value, this.invalidateArrange();
                    },
                    enumerable: !0,
                    configurable: !0
                }), Scrollbar.prototype.refresh = function() {}, Object.defineProperty(Scrollbar.prototype, "element", {
                    get: function() {
                        return this._element;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(Scrollbar.prototype, "maxButton", {
                    get: function() {
                        return this._maxButton;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(Scrollbar.prototype, "middleBar", {
                    get: function() {
                        return this._middleBar;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Scrollbar.prototype._scrollSmallIncrement = function(direction) {
                    this.scrollBy(this.smallIncrement * direction);
                }, Object.defineProperty(Scrollbar.prototype, "visible", {
                    get: function() {
                        return this._visible;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
                    get: function() {
                        return void 0 !== this._timerHandle;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Scrollbar.prototype.show = function(value) {
                    this._visible = value, this.element.style.visibility = value ? "visible" : "hidden", 
                    this.invalidateArrange();
                }, Scrollbar.prototype._getMouseOffset = function(event) {
                    return void 0 !== event.offsetX ? {
                        x: event.offsetX,
                        y: event.offsetY
                    } : void 0 !== event.layerX ? {
                        x: event.layerX,
                        y: event.layerY
                    } : {
                        x: event.screenX,
                        y: event.screenY
                    };
                }, Scrollbar.prototype._getOffsetXDelta = function(event) {
                    return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
                }, Scrollbar.prototype._getOffsetYDelta = function(event) {
                    return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
                }, Scrollbar.prototype._getOffsetXTouchDelta = function(event) {
                    return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
                }, Scrollbar.prototype._getOffsetYTouchDelta = function(event) {
                    return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
                }, Scrollbar.prototype.initTouch = function(panel, allowMouseDrag) {
                    var _this = this;
                    this._touchPanel = panel, this._allowMouseDrag = void 0 === allowMouseDrag ? !0 : allowMouseDrag, 
                    "ontouchmove" in panel ? (panel.addEventListener("touchstart", function(e) {
                        return _this.onTouchStart(e);
                    }), panel.addEventListener("touchmove", function(e) {
                        return _this.onTouchMove(e);
                    }), panel.addEventListener("touchend", function(e) {
                        return _this.onTouchEnd(e);
                    })) : (panel.addEventListener("mousedown", function(e) {
                        return _this.onTouchMouseDown(e);
                    }), panel.addEventListener("mousemove", function(e) {
                        return _this.onTouchMouseMove(e);
                    }), panel.addEventListener("mouseup", function(e) {
                        return _this.onTouchMouseUp(e);
                    }));
                }, Scrollbar.prototype.onTouchStart = function(e) {
                    1 === e.touches.length && this.onTouchMouseDown(e.touches[0]);
                }, Scrollbar.prototype.onTouchMove = function(e) {
                    1 === e.touches.length && (e.preventDefault && e.preventDefault(), this.onTouchMouseMove(e.touches[0]));
                }, Scrollbar.prototype.onTouchEnd = function(e) {
                    this.onTouchMouseUp(1 === e.touches.length ? e.touches[0] : e, !0);
                }, Scrollbar.prototype.onTouchMouseDown = function(e) {
                    (this._allowMouseDrag || e.pointerType !== MSPointerEvent.MSPOINTER_TYPE_MOUSE) && ("setCapture" in this._touchPanel && this._touchPanel.setCapture(!0), 
                    this._offsetTouchPrevPos = this._offsetTouchStartPos = null, this._touchStarted = !0);
                }, Scrollbar.prototype._getOffsetTouchDelta = function(e) {
                    return null;
                }, Scrollbar.prototype.onTouchMouseMove = function(e) {
                    if (this._touchStarted) {
                        this._offsetTouchStartPos || (this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e));
                        var delta = this._getOffsetTouchDelta(e);
                        0 !== delta && (this.scrollBy(-delta / this._getRunningSize(!1) * this.viewSize), 
                        this._offsetTouchPrevPos = this._getMouseOffset(e)), e.preventDefault && e.preventDefault(), 
                        e.cancelBubble = !0;
                    }
                }, Scrollbar.prototype.onTouchMouseUp = function(e, bubble) {
                    if (this._touchStarted && this._offsetTouchStartPos) {
                        var end = this._getMouseOffset(e);
                        !bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3) && (e.preventDefault && e.preventDefault(), 
                        e.cancelBubble = !0);
                    }
                    "releaseCapture" in this._touchPanel && this._touchPanel.releaseCapture(), this._touchStarted = !1;
                }, Scrollbar.prototype.registerElementForMouseWheelScrolling = function(element) {
                    var _this = this;
                    element.addEventListener("mousewheel", function(e) {
                        _this.onMouseWheel(e);
                    }), element.addEventListener("DOMMouseScroll", function(e) {
                        _this.onFireFoxMouseWheel(e);
                    });
                }, Scrollbar.prototype.createView = function(parentElement, layoutKind) {
                    this._element = document.createElement("div"), this._element.className = Scrollbar.className, 
                    this._element.setAttribute("drag-resize-disabled", "true"), 0 === layoutKind && parentElement.appendChild(this._element), 
                    this._minButton = new ScrollbarButton(this, -1), this._maxButton = new ScrollbarButton(this, 1), 
                    this._middleBar = document.createElement("div"), this._middleBar.className = Scrollbar.barClassName, 
                    this._element.appendChild(this._middleBar);
                }, Scrollbar.prototype.scrollTo = function(pos) {
                    var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
                    viewMin !== this.viewMin && (this.viewMin = viewMin, fire(this._onscroll, null));
                }, Scrollbar.prototype._scrollByPage = function(event) {}, Scrollbar.prototype._getRunningSize = function(net) {
                    return null;
                }, Scrollbar.prototype._getOffsetDelta = function(event) {
                    return null;
                }, Scrollbar.prototype.scroll = function(event) {
                    var delta = this._getOffsetDelta(event) / this._getRunningSize(!0) * (this.max - this.min);
                    if (0 > delta) {
                        if (this._getScreenMousePos(event) >= this._screenMaxMousePos) return;
                    } else if (delta > 0 && this._getScreenMousePos(event) <= this._screenMinMousePos) return;
                    this.scrollBy(delta);
                }, Object.defineProperty(Scrollbar.prototype, "actualWidth", {
                    get: function() {
                        return void 0 === this._actualWidth && this.arrange(), this._actualWidth;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(Scrollbar.prototype, "actualHeight", {
                    get: function() {
                        return void 0 === !this._actualHeight && this.arrange(), this._actualHeight;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
                    get: function() {
                        return void 0 === !this._actualButtonWidth && this.arrange(), this._actualButtonWidth;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
                    get: function() {
                        return void 0 === !this._actualButtonHeight && this.arrange(), this._actualButtonHeight;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Scrollbar.prototype.arrange = function() {
                    this._actualWidth || (this._actualWidth = this._element.offsetWidth, this._actualHeight = this._element.offsetHeight, 
                    this._actualButtonWidth = this._calculateButtonWidth(), this._actualButtonHeight = this._calculateButtonHeight(), 
                    this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle()), 
                    this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle()), 
                    this._setMaxButtonPosition());
                }, Scrollbar.prototype._calculateButtonWidth = function() {
                    return null;
                }, Scrollbar.prototype._calculateButtonHeight = function() {
                    return null;
                }, Scrollbar.prototype._getMinButtonAngle = function() {
                    return null;
                }, Scrollbar.prototype._getMaxButtonAngle = function() {
                    return null;
                }, Scrollbar.prototype._setMaxButtonPosition = function() {}, Scrollbar.prototype.invalidateArrange = function() {
                    this._actualWidth = void 0, this._actualHeight = void 0, this._actualButtonWidth = void 0, 
                    this._actualButtonHeight = void 0;
                }, Scrollbar.prototype.onHoldBackgroundMouseDown = function(event) {
                    var _this = this, holdDelay = this._timerHandle ? Scrollbar.ScrollbarBackgroundMousedownHoldDelay : Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
                    this._timerHandle = setTimeout(function() {
                        _this.onBackgroundMouseDown(event);
                    }, holdDelay);
                }, Scrollbar.prototype.onBackgroundMouseDown = function(event) {
                    var that = this;
                    clearTimeout(this._timerHandle), this._backgroundMouseUpWrapper || (event.cancelBubble = !0, 
                    this._backgroundMouseUpWrapper = function(event) {
                        that.onBackgroundMouseUp(event);
                    }, Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper)), this._scrollByPage(event), 
                    this.refresh(), this.onHoldBackgroundMouseDown(event), event.preventDefault && event.preventDefault();
                }, Scrollbar.prototype.onBackgroundMouseUp = function(event) {
                    clearTimeout(this._timerHandle), this._timerHandle = void 0, Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper), 
                    this._backgroundMouseUpWrapper = void 0;
                }, Scrollbar.prototype.getPinchZoomY = function() {
                    return document.documentElement.clientHeight / window.innerHeight;
                }, Scrollbar.prototype.onMiddleBarMouseDown = function(event) {
                    event.cancelBubble = !0, this._screenPrevMousePos = {
                        x: event.screenX,
                        y: event.screenY
                    }, this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element)), 
                    this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar)), 
                    this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
                    var that = this;
                    this._middleBarMouseMoveWrapper = function(e) {
                        that.onMiddleBarMouseMove(e);
                    }, Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper), this._middleBarMouseUpWrapper = function(e) {
                        that.onMiddleBarMouseUp(e);
                    }, Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper), event.preventDefault && event.preventDefault();
                }, Scrollbar.prototype.onMiddleBarMouseMove = function(event) {
                    this._screenPrevMousePos && (this.scroll(event), this.refresh(), this._screenPrevMousePos = {
                        x: event.screenX,
                        y: event.screenY
                    });
                }, Scrollbar.prototype.onMiddleBarMouseUp = function(event) {
                    this._screenPrevMousePos = void 0, Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper), 
                    this._middleBarMouseMoveWrapper = void 0, Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper), 
                    this._middleBarMouseUpWrapper = void 0, event.preventDefault && event.preventDefault();
                }, Scrollbar.prototype._getScreenContextualLeft = function(element) {
                    return null;
                }, Scrollbar.prototype._getScreenContextualRight = function(element) {
                    return null;
                }, Scrollbar.prototype.onMouseWheel = function(e) {
                    e.wheelDelta && this.mouseWheel(e.wheelDelta);
                }, Scrollbar.prototype.onFireFoxMouseWheel = function(e) {
                    e.detail && this.mouseWheel(-e.detail);
                }, Scrollbar.prototype.mouseWheel = function(delta) {
                    this.visible && (0 > delta ? delta = Math.min(-Scrollbar.MouseWheelRange, delta) : delta > 0 && (delta = Math.max(Scrollbar.MouseWheelRange, delta)), 
                    this.scrollBy(-delta / Scrollbar.MouseWheelRange * this.smallIncrement));
                }, Scrollbar.prototype._getScreenMousePos = function(event) {
                    return null;
                }, Scrollbar.addDocumentMouseUpEvent = function(func) {
                    document.addEventListener("mouseup", func);
                }, Scrollbar.removeDocumentMouseUpEvent = function(func) {
                    document.removeEventListener("mouseup", func);
                }, Scrollbar.addDocumentMouseMoveEvent = function(func) {
                    document.addEventListener("mousemove", func);
                }, Scrollbar.removeDocumentMouseMoveEvent = function(func) {
                    document.removeEventListener("mousemove", func);
                }, Scrollbar.DefaultScrollbarWidth = "15px", Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500, 
                Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50, Scrollbar.MouseWheelRange = 120, 
                Scrollbar.className = "scroll-bar-div", Scrollbar.barClassName = "scroll-bar-part-bar", 
                Scrollbar.arrowClassName = "scroll-bar-part-arrow", Scrollbar;
            }();
            controls.Scrollbar = Scrollbar;
            var HorizontalScrollbar = function(_super) {
                function HorizontalScrollbar(parentElement, layoutKind) {
                    _super.call(this, parentElement, layoutKind), this.height = Scrollbar.DefaultScrollbarWidth;
                }
                return __extends(HorizontalScrollbar, _super), HorizontalScrollbar.prototype._calculateButtonWidth = function() {
                    return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
                }, HorizontalScrollbar.prototype._calculateButtonHeight = function() {
                    return this.actualHeight;
                }, HorizontalScrollbar.prototype._getMinButtonAngle = function() {
                    return -180;
                }, HorizontalScrollbar.prototype._getMaxButtonAngle = function() {
                    return 0;
                }, HorizontalScrollbar.prototype._setMaxButtonPosition = function() {
                    controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
                }, HorizontalScrollbar.prototype.refresh = function() {
                    this.arrange();
                    var runningSize = this.actualWidth - 2 * this.actualButtonWidth - 2, barSize = this.viewSize / (this.max - this.min) * runningSize;
                    barSize < this.MIN_BAR_SIZE && (runningSize -= this.MIN_BAR_SIZE - barSize, barSize = this.MIN_BAR_SIZE), 
                    0 > runningSize && (runningSize = 0, barSize = 0), barSize = Math.min(barSize, runningSize);
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize), controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight), 
                    controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
                }, HorizontalScrollbar.prototype.show = function(visible) {
                    visible !== this.visible && (_super.prototype.show.call(this, visible), visible ? this.element.style.height = this.height : controls.HTMLElementUtils.setElementHeight(this.element, 0));
                }, HorizontalScrollbar.prototype._scrollByPage = function(event) {
                    var left = this.middleBar.offsetLeft, right = left + this.middleBar.offsetWidth, x = void 0 === event.offsetX ? event.layerX : event.offsetX;
                    x > right ? this.scrollPageDown() : left > x && this.scrollPageUp();
                }, HorizontalScrollbar.prototype._getRunningSize = function(net) {
                    var result = this.actualWidth;
                    if (net) {
                        var barMinPos = this.actualButtonWidth + 1;
                        result -= 2 * barMinPos;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        barSize < this.MIN_BAR_SIZE && (result -= this.MIN_BAR_SIZE - barSize);
                    }
                    return result;
                }, HorizontalScrollbar.prototype._getOffsetDelta = function(event) {
                    return this._getOffsetXDelta(event);
                }, HorizontalScrollbar.prototype._getOffsetTouchDelta = function(e) {
                    return this._getOffsetXTouchDelta(e);
                }, HorizontalScrollbar.prototype._getScreenContextualLeft = function(element) {
                    return element.getBoundingClientRect().left;
                }, HorizontalScrollbar.prototype._getScreenContextualRight = function(element) {
                    return element.getBoundingClientRect().right;
                }, HorizontalScrollbar.prototype._getScreenMousePos = function(event) {
                    return event.screenX;
                }, HorizontalScrollbar;
            }(Scrollbar);
            controls.HorizontalScrollbar = HorizontalScrollbar;
            var VerticalScrollbar = function(_super) {
                function VerticalScrollbar(parentElement, layoutKind) {
                    _super.call(this, parentElement, layoutKind), this.width = Scrollbar.DefaultScrollbarWidth;
                }
                return __extends(VerticalScrollbar, _super), VerticalScrollbar.prototype._calculateButtonWidth = function() {
                    return this.actualWidth;
                }, VerticalScrollbar.prototype._calculateButtonHeight = function() {
                    return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
                }, VerticalScrollbar.prototype._getMinButtonAngle = function() {
                    return -90;
                }, VerticalScrollbar.prototype._getMaxButtonAngle = function() {
                    return 90;
                }, VerticalScrollbar.prototype._setMaxButtonPosition = function() {
                    controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
                }, VerticalScrollbar.prototype.refresh = function() {
                    this.arrange();
                    var runningSize = this.actualHeight - 2 * this.actualButtonHeight - 2, barSize = this.viewSize / (this.max - this.min) * runningSize;
                    barSize < this.MIN_BAR_SIZE && (runningSize -= this.MIN_BAR_SIZE - barSize, barSize = this.MIN_BAR_SIZE), 
                    0 > runningSize && (runningSize = 0, barSize = 0);
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth), controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize), 
                    controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
                }, VerticalScrollbar.prototype.show = function(visible) {
                    visible !== this.visible && (_super.prototype.show.call(this, visible), visible ? this.element.style.width = this.width : controls.HTMLElementUtils.setElementWidth(this.element, 0));
                }, VerticalScrollbar.prototype._scrollByPage = function(event) {
                    var top = this.middleBar.offsetTop, bottom = top + this.middleBar.offsetHeight, y = void 0 === event.offsetY ? event.layerY : event.offsetY;
                    y > bottom ? this.scrollPageDown() : top > y && this.scrollPageUp();
                }, VerticalScrollbar.prototype._getRunningSize = function(net) {
                    var result = this.actualHeight;
                    if (net) {
                        var barMinPos = this.actualButtonHeight + 1;
                        result -= 2 * barMinPos;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        barSize < this.MIN_BAR_SIZE && (result -= this.MIN_BAR_SIZE - barSize);
                    }
                    return result;
                }, VerticalScrollbar.prototype._getOffsetDelta = function(event) {
                    return this._getOffsetYDelta(event);
                }, VerticalScrollbar.prototype._getOffsetTouchDelta = function(e) {
                    return this._getOffsetYTouchDelta(e);
                }, VerticalScrollbar.prototype._getScreenContextualLeft = function(element) {
                    return element.getBoundingClientRect().top;
                }, VerticalScrollbar.prototype._getScreenContextualRight = function(element) {
                    return element.getBoundingClientRect().bottom;
                }, VerticalScrollbar.prototype._getScreenMousePos = function(event) {
                    return event.screenY;
                }, VerticalScrollbar;
            }(Scrollbar);
            controls.VerticalScrollbar = VerticalScrollbar;
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var internal;
            !function(internal) {
                var UNSELECTABLE_CLASS_NAME = "unselectable", TablixResizer = function() {
                    function TablixResizer(element, handler) {
                        this._element = element, this._handler = handler, this._elementMouseDownWrapper = null, 
                        this._elementMouseMoveWrapper = null, this._elementMouseOutWrapper = null, this._documentMouseMoveWrapper = null, 
                        this._documentMouseUpWrapper = null, this._startMousePosition = null, this._originalCursor = null;
                    }
                    return TablixResizer.addDocumentMouseUpEvent = function(listener) {
                        document.addEventListener("mouseup", listener);
                    }, TablixResizer.removeDocumentMouseUpEvent = function(listener) {
                        document.removeEventListener("mouseup", listener);
                    }, TablixResizer.addDocumentMouseMoveEvent = function(listener) {
                        document.addEventListener("mousemove", listener);
                    }, TablixResizer.removeDocumentMouseMoveEvent = function(listener) {
                        document.removeEventListener("mousemove", listener);
                    }, TablixResizer.getMouseCoordinates = function(event) {
                        return {
                            x: event.pageX,
                            y: event.pageY
                        };
                    }, TablixResizer.getMouseCoordinateDelta = function(previous, current) {
                        return {
                            x: current.x - previous.x,
                            y: current.y - previous.y
                        };
                    }, TablixResizer.prototype.initialize = function() {
                        var _this = this;
                        this._elementMouseDownWrapper = function(e) {
                            return _this.onElementMouseDown(e);
                        }, this._element.addEventListener("mousedown", this._elementMouseDownWrapper), this._elementMouseMoveWrapper = function(e) {
                            return _this.onElementMouseMove(e);
                        }, this._element.addEventListener("mousemove", this._elementMouseMoveWrapper), this._elementMouseOutWrapper = function(e) {
                            return _this.onElementMouseOut(e);
                        }, this._element.addEventListener("mouseout", this._elementMouseOutWrapper), this._elementMouseDoubleClickOutWrapper = function(e) {
                            return _this.onElementMouseDoubleClick(e);
                        }, this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                    }, TablixResizer.prototype.uninitialize = function() {
                        this._element.removeEventListener("mousedown", this._elementMouseDownWrapper), this._elementMouseDownWrapper = null, 
                        this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper), this._elementMouseMoveWrapper = null, 
                        this._element.removeEventListener("mouseout", this._elementMouseOutWrapper), this._elementMouseOutWrapper = null, 
                        this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper), 
                        this._elementMouseDoubleClickOutWrapper = null;
                    }, Object.defineProperty(TablixResizer.prototype, "cell", {
                        get: function() {
                            return null;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixResizer.prototype, "element", {
                        get: function() {
                            return this._element;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixResizer.prototype._hotSpot = function(position) {
                        return !1;
                    }, TablixResizer.prototype.onElementMouseDown = function(event) {
                        var _this = this, position = TablixResizer.getMouseCoordinates(event);
                        this._hotSpot(position) && ("setCapture" in this._element && this._element.setCapture(), 
                        event.cancelBubble = !0, this._startMousePosition = position, this._documentMouseMoveWrapper = function(e) {
                            return _this.onDocumentMouseMove(e);
                        }, TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper), this._documentMouseUpWrapper = function(e) {
                            return _this.onDocumentMouseUp(e);
                        }, TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper), document.documentElement && (this._originalCursor = document.documentElement.style.cursor, 
                        document.documentElement.style.cursor = TablixResizer.resizeCursor), this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y));
                    }, TablixResizer.prototype.onElementMouseMove = function(event) {
                        this._startMousePosition || (this._hotSpot(TablixResizer.getMouseCoordinates(event)) ? null === this._originalCursor && (this._originalCursor = this._element.style.cursor, 
                        this._element.style.cursor = TablixResizer.resizeCursor) : null !== this._originalCursor && (this._element.style.cursor = this._originalCursor, 
                        this._originalCursor = null));
                    }, TablixResizer.prototype.onElementMouseOut = function(event) {
                        this._startMousePosition || null !== this._originalCursor && (this._element.style.cursor = this._originalCursor, 
                        this._originalCursor = null);
                    }, TablixResizer.prototype.onElementMouseDoubleClick = function(event) {
                        this._hotSpot(TablixResizer.getMouseCoordinates(event)) && this._handler.onReset(this.cell);
                    }, TablixResizer.prototype.onDocumentMouseMove = function(event) {
                        if (this._startMousePosition) {
                            var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
                            this._handler.onResize(this.cell, delta.x, delta.y), event.preventDefault();
                        }
                    }, TablixResizer.prototype.onDocumentMouseUp = function(event) {
                        this._startMousePosition = null, "releaseCapture" in this._element && this._element.releaseCapture(), 
                        TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper), this._documentMouseMoveWrapper = null, 
                        TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper), this._documentMouseUpWrapper = null, 
                        document.documentElement && (document.documentElement.style.cursor = this._originalCursor), 
                        event.preventDefault && event.preventDefault(), this._handler.onEndResize(this.cell);
                    }, TablixResizer.resizeHandleSize = 4, TablixResizer.resizeCursor = "e-resize", 
                    TablixResizer;
                }();
                internal.TablixResizer = TablixResizer;
                var TablixDomResizer = function(_super) {
                    function TablixDomResizer(cell, element, handler) {
                        _super.call(this, element, handler), this._cell = cell;
                    }
                    return __extends(TablixDomResizer, _super), Object.defineProperty(TablixDomResizer.prototype, "cell", {
                        get: function() {
                            return this._cell;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixDomResizer.prototype._hotSpot = function(position) {
                        return position.x >= this.element.getBoundingClientRect().right - TablixResizer.resizeHandleSize;
                    }, TablixDomResizer;
                }(TablixResizer);
                internal.TablixDomResizer = TablixDomResizer;
                var TablixCellPresenter = function() {
                    function TablixCellPresenter(fitProportionally, layoutKind) {
                        this._tableCell = null, this._contentElement = internal.TablixUtils.createDiv(), 
                        this._contentHost = internal.TablixUtils.createDiv(), this.layoutKind = layoutKind, 
                        this._contentElement.appendChild(this._contentHost), this._resizer = null;
                    }
                    return TablixCellPresenter.prototype.initialize = function(owner) {
                        this._owner = owner;
                    }, Object.defineProperty(TablixCellPresenter.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixCellPresenter.prototype.registerTableCell = function(tableCell) {
                        this._tableCell = tableCell, tableCell.appendChild(this._contentElement);
                    }, Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
                        get: function() {
                            return this._tableCell;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
                        get: function() {
                            return this._contentElement;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
                        get: function() {
                            return this._contentHost;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixCellPresenter.prototype.registerClickHandler = function(handler) {
                        this._contentElement.onclick = handler;
                    }, TablixCellPresenter.prototype.unregisterClickHandler = function() {
                        this._contentElement.onclick = null;
                    }, TablixCellPresenter.prototype.onContentWidthChanged = function(value) {
                        controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
                    }, TablixCellPresenter.prototype.onContentHeightChanged = function(height) {
                        controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
                    }, TablixCellPresenter.prototype.onColumnSpanChanged = function(value) {
                        this._tableCell.colSpan = value;
                    }, TablixCellPresenter.prototype.onRowSpanChanged = function(value) {
                        this._tableCell.rowSpan = value;
                    }, TablixCellPresenter.prototype.onTextAlignChanged = function(value) {
                        this._tableCell.style.textAlign = value;
                    }, TablixCellPresenter.prototype.onClear = function() {
                        this._contentHost.className = "", this._tableCell.className = "";
                    }, TablixCellPresenter.prototype.onHorizontalScroll = function(width, offset) {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, offset), controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
                    }, TablixCellPresenter.prototype.onVerticalScroll = function(height, offset) {
                        controls.HTMLElementUtils.setElementTop(this._contentHost, offset), controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
                    }, TablixCellPresenter.prototype.onInitializeScrolling = function() {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, 0), controls.HTMLElementUtils.setElementTop(this._contentHost, 0), 
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, -1), controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
                    }, TablixCellPresenter.prototype.enableHorizontalResize = function(enable, handler) {
                        enable !== (null !== this._resizer) && (enable ? (this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler), 
                        this._resizer.initialize()) : (this._resizer.uninitialize(), this._resizer = null));
                    }, TablixCellPresenter.prototype.disableDragResize = function() {
                        this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
                    }, TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled", 
                    TablixCellPresenter;
                }();
                internal.TablixCellPresenter = TablixCellPresenter;
                var TablixRowPresenter = function() {
                    function TablixRowPresenter(fitProportionally) {
                        this._tableRow = null, this._fitProportionally = fitProportionally;
                    }
                    return TablixRowPresenter.prototype.initialize = function(row) {
                        this._row = row;
                    }, TablixRowPresenter.prototype.createCellPresenter = function(layoutKind) {
                        return new TablixCellPresenter(this._fitProportionally, layoutKind);
                    }, TablixRowPresenter.prototype.registerRow = function(tableRow) {
                        this._tableRow = tableRow;
                    }, TablixRowPresenter.prototype.onAppendCell = function(cell) {
                        var presenter = cell._presenter;
                        if (null === presenter.tableCell) {
                            var tableCell = this._tableRow.insertCell(-1);
                            presenter.registerTableCell(tableCell);
                        } else this._tableRow.appendChild(presenter.tableCell);
                    }, TablixRowPresenter.prototype.onInsertCellBefore = function(cell, refCell) {
                        var presenter = cell._presenter;
                        if (null === presenter.tableCell) {
                            var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
                            presenter.registerTableCell(tableCell);
                        } else this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
                    }, TablixRowPresenter.prototype.onRemoveCell = function(cell) {
                        this._tableRow.removeChild(cell._presenter.tableCell);
                    }, TablixRowPresenter.prototype.getHeight = function() {
                        return this.getCellHeight(this._row.getTablixCell());
                    }, TablixRowPresenter.prototype.getCellHeight = function(cell) {
                        return -1;
                    }, TablixRowPresenter.prototype.getCellContentHeight = function(cell) {
                        return -1;
                    }, Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
                        get: function() {
                            return this._tableRow;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixRowPresenter;
                }();
                internal.TablixRowPresenter = TablixRowPresenter;
                var DashboardRowPresenter = function(_super) {
                    function DashboardRowPresenter(gridPresenter, fitProportionally) {
                        _super.call(this, fitProportionally), this._gridPresenter = gridPresenter;
                    }
                    return __extends(DashboardRowPresenter, _super), DashboardRowPresenter.prototype.getCellHeight = function(cell) {
                        return cell._presenter ? controls.HTMLElementUtils.getElementHeight(cell._presenter.tableCell) : 0;
                    }, DashboardRowPresenter.prototype.getCellContentHeight = function(cell) {
                        return cell._presenter ? controls.HTMLElementUtils.getElementHeight(cell._presenter.contentElement) : 0;
                    }, DashboardRowPresenter;
                }(TablixRowPresenter);
                internal.DashboardRowPresenter = DashboardRowPresenter;
                var CanvasRowPresenter = function(_super) {
                    function CanvasRowPresenter() {
                        _super.apply(this, arguments);
                    }
                    return __extends(CanvasRowPresenter, _super), CanvasRowPresenter.prototype.getCellHeight = function(cell) {
                        return cell._presenter ? controls.HTMLElementUtils.getElementHeight(cell._presenter.tableCell) : 0;
                    }, CanvasRowPresenter.prototype.getCellContentHeight = function(cell) {
                        return cell._presenter ? controls.HTMLElementUtils.getElementHeight(cell._presenter.contentElement) : 0;
                    }, CanvasRowPresenter;
                }(TablixRowPresenter);
                internal.CanvasRowPresenter = CanvasRowPresenter;
                var TablixColumnPresenter = function() {
                    function TablixColumnPresenter() {}
                    return TablixColumnPresenter.prototype.initialize = function(column) {
                        this._column = column;
                    }, TablixColumnPresenter.prototype.getWidth = function() {
                        return this.getCellWidth(this._column.getTablixCell());
                    }, TablixColumnPresenter.prototype.getCellWidth = function(cell) {
                        return -1;
                    }, TablixColumnPresenter.prototype.getCellContentWidth = function(cell) {
                        return -1;
                    }, TablixColumnPresenter;
                }();
                internal.TablixColumnPresenter = TablixColumnPresenter;
                var DashboardColumnPresenter = function(_super) {
                    function DashboardColumnPresenter(gridPresenter) {
                        _super.call(this), this._gridPresenter = gridPresenter;
                    }
                    return __extends(DashboardColumnPresenter, _super), DashboardColumnPresenter.prototype.getCellWidth = function(cell) {
                        return this._gridPresenter.sizeComputationManager.cellWidth;
                    }, DashboardColumnPresenter.prototype.getCellContentWidth = function(cell) {
                        return this._gridPresenter.sizeComputationManager.contentWidth;
                    }, DashboardColumnPresenter;
                }(TablixColumnPresenter);
                internal.DashboardColumnPresenter = DashboardColumnPresenter;
                var CanvasColumnPresenter = function(_super) {
                    function CanvasColumnPresenter(gridPresenter, index) {
                        _super.call(this), this._gridPresenter = gridPresenter, this._columnIndex = index;
                    }
                    return __extends(CanvasColumnPresenter, _super), CanvasColumnPresenter.prototype.getCellWidth = function(cell) {
                        var persistedWidth = this._gridPresenter.getPersistedCellWidth(this._columnIndex);
                        return _.isNumber(persistedWidth) ? persistedWidth : cell._presenter ? controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell) : 0;
                    }, CanvasColumnPresenter.prototype.getCellContentWidth = function(cell) {
                        var persistedWidth = this._gridPresenter.getPersistedCellWidth(this._columnIndex);
                        if (_.isNumber(persistedWidth)) return persistedWidth;
                        if (!cell._presenter) return 0;
                        var requiredWidth = controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                        return requiredWidth > 0 && 1 === cell.colSpan && (requiredWidth += 1), requiredWidth;
                    }, CanvasColumnPresenter;
                }(TablixColumnPresenter);
                internal.CanvasColumnPresenter = CanvasColumnPresenter;
                var TablixGridPresenter = function() {
                    function TablixGridPresenter(columnWidthManager) {
                        this._table = internal.TablixUtils.createTable(), this._table.className = UNSELECTABLE_CLASS_NAME, 
                        this._footerTable = internal.TablixUtils.createTable(), this._footerTable.className = UNSELECTABLE_CLASS_NAME, 
                        this._columnWidthManager = columnWidthManager;
                    }
                    return TablixGridPresenter.prototype.initialize = function(owner, gridHost, footerHost, control) {
                        this._owner = owner, gridHost.appendChild(this._table), footerHost.appendChild(this._footerTable);
                    }, TablixGridPresenter.prototype.getWidth = function() {
                        return -1;
                    }, TablixGridPresenter.prototype.getHeight = function() {
                        return -1;
                    }, TablixGridPresenter.prototype.getScreenToCssRatioX = function() {
                        return 1;
                    }, TablixGridPresenter.prototype.getScreenToCssRatioY = function() {
                        return 1;
                    }, TablixGridPresenter.prototype.createRowPresenter = function() {
                        return null;
                    }, TablixGridPresenter.prototype.createColumnPresenter = function(index) {
                        return null;
                    }, TablixGridPresenter.prototype.onAppendRow = function(row) {
                        var presenter = row.presenter;
                        if (null === presenter.tableRow) {
                            var tableRow = this._table.insertRow(-1);
                            presenter.registerRow(tableRow);
                        } else this._table.tBodies[0].appendChild(row.presenter.tableRow);
                    }, TablixGridPresenter.prototype.onInsertRowBefore = function(row, refRow) {
                        var presenter = row.presenter;
                        if (null === presenter.tableRow) {
                            var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
                            presenter.registerRow(tableRow);
                        } else this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
                    }, TablixGridPresenter.prototype.onRemoveRow = function(row) {
                        this._table.tBodies[0].removeChild(row.presenter.tableRow);
                    }, TablixGridPresenter.prototype.onAddFooterRow = function(row) {
                        var presenter = row.presenter;
                        if (null === presenter.tableRow) {
                            var tableRow = this._footerTable.insertRow(-1);
                            presenter.registerRow(tableRow);
                        } else this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
                    }, TablixGridPresenter.prototype.onClear = function() {
                        controls.HTMLElementUtils.clearChildren(this._table), controls.HTMLElementUtils.clearChildren(this._footerTable);
                    }, TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function(value) {
                        value ? (this._table.style.width = "100%", this._footerTable.style.width = "100%") : (this._table.style.width = "auto", 
                        this._footerTable.style.width = "auto");
                    }, TablixGridPresenter.prototype.invokeColumnResizeEndCallback = function(columnIndex, width) {
                        this._columnWidthManager && this._columnWidthManager.onColumnWidthChanged(columnIndex, width);
                    }, TablixGridPresenter.prototype.getPersistedCellWidth = function(columnIndex) {
                        return this._columnWidthManager ? this._columnWidthManager.getPersistedColumnWidth(columnIndex) : void 0;
                    }, TablixGridPresenter;
                }();
                internal.TablixGridPresenter = TablixGridPresenter;
                var DashboardTablixGridPresenter = function(_super) {
                    function DashboardTablixGridPresenter(sizeComputationManager) {
                        _super.call(this), this._sizeComputationManager = sizeComputationManager;
                    }
                    return __extends(DashboardTablixGridPresenter, _super), DashboardTablixGridPresenter.prototype.createRowPresenter = function() {
                        return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
                    }, DashboardTablixGridPresenter.prototype.createColumnPresenter = function(index) {
                        return new DashboardColumnPresenter(this);
                    }, Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
                        get: function() {
                            return this._sizeComputationManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DashboardTablixGridPresenter.prototype.getWidth = function() {
                        return this._sizeComputationManager.gridWidth;
                    }, DashboardTablixGridPresenter.prototype.getHeight = function() {
                        return this._sizeComputationManager.gridHeight;
                    }, DashboardTablixGridPresenter;
                }(TablixGridPresenter);
                internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
                var CanvasTablixGridPresenter = function(_super) {
                    function CanvasTablixGridPresenter(columnWidthManager) {
                        _super.call(this, columnWidthManager);
                    }
                    return __extends(CanvasTablixGridPresenter, _super), CanvasTablixGridPresenter.prototype.createRowPresenter = function() {
                        return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
                    }, CanvasTablixGridPresenter.prototype.createColumnPresenter = function(index) {
                        return new CanvasColumnPresenter(this, index);
                    }, CanvasTablixGridPresenter.prototype.getWidth = function() {
                        return controls.HTMLElementUtils.getElementWidth(this._table);
                    }, CanvasTablixGridPresenter.prototype.getHeight = function() {
                        return controls.HTMLElementUtils.getElementHeight(this._table);
                    }, CanvasTablixGridPresenter;
                }(TablixGridPresenter);
                internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
            }(internal = controls.internal || (controls.internal = {}));
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var internal;
            !function(internal) {
                var TablixDimensionRealizationManager = function() {
                    function TablixDimensionRealizationManager(binder) {
                        this._binder = binder, this._adjustmentFactor = 1;
                    }
                    return TablixDimensionRealizationManager.prototype._getOwner = function() {
                        return null;
                    }, Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
                        get: function() {
                            return this._binder;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
                        get: function() {
                            return this._adjustmentFactor;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
                        get: function() {
                            return this._itemsToRealizeCount;
                        },
                        set: function(count) {
                            this._itemsToRealizeCount = count;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
                        get: function() {
                            return this._itemsEstimatedContextualWidth;
                        },
                        set: function(contextualWidth) {
                            this._itemsEstimatedContextualWidth = contextualWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function() {
                        var owner = this._getOwner();
                        owner.measureEnabled && !owner.done && this._getEstimatedItemsToRealizeCount(), 
                        this._realizedLeavesCount = 0;
                    }, TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function(gridContextualWidth, filled) {
                        filled || this._getOwner().allItemsRealized || (this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth));
                    }, TablixDimensionRealizationManager.prototype.onEndRenderingSession = function() {
                        this._adjustmentFactor = 1;
                    }, TablixDimensionRealizationManager.prototype.onCornerCellRealized = function(item, cell) {}, 
                    TablixDimensionRealizationManager.prototype.onHeaderRealized = function(item, cell, leaf) {
                        leaf && this._realizedLeavesCount++;
                    }, Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
                        get: function() {
                            return this._realizedLeavesCount < this._itemsToRealizeCount;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {}, 
                    TablixDimensionRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                        return 1;
                    }, TablixDimensionRealizationManager;
                }();
                internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
                var RowRealizationManager = function(_super) {
                    function RowRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    return __extends(RowRealizationManager, _super), Object.defineProperty(RowRealizationManager.prototype, "owner", {
                        set: function(owner) {
                            this._owner = owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), RowRealizationManager.prototype._getOwner = function() {
                        return this._owner;
                    }, RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {
                        this.estimateRowsToRealizeCount();
                    }, RowRealizationManager.prototype.estimateRowsToRealizeCount = function() {
                        return this._owner.dimension.model ? void (this._owner.alignToEnd ? this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1 : this.itemsToRealizeCount = Math.ceil(this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1) : void (this.itemsToRealizeCount = 0);
                    }, RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function() {
                        if (!this._owner.dimension.model || 0 === this._owner.dimension.getItemsCount()) return 0;
                        var levels = new RowWidths();
                        this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
                        for (var levelsArray = levels.items, levelCount = levelsArray.length, width = 0, i = 0; levelCount > i; i++) {
                            var level = levelsArray[i];
                            width += 0 !== level.maxNonLeafWidth ? level.maxNonLeafWidth : level.maxLeafWidth;
                        }
                        return width;
                    }, RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function(items, firstVisibleIndex, levels) {
                        for (var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator, binder = this.binder, length = hierarchyNavigator.getCount(items), i = firstVisibleIndex; length > i; i++) {
                            if (levels.leafCount === this.itemsToRealizeCount) return;
                            var item = hierarchyNavigator.getAt(items, i), label = binder.getHeaderLabel(item), itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex), isLeaf = hierarchyNavigator.isLeaf(item), l = hierarchyNavigator.getLevel(item), level = levels.items[l];
                            level || (level = new RowWidth(), levels.items[l] = level), isLeaf ? (level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth), 
                            levels.leafCount = levels.leafCount + 1) : (level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth), 
                            this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels));
                        }
                    }, RowRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                        return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
                    }, RowRealizationManager;
                }(TablixDimensionRealizationManager);
                internal.RowRealizationManager = RowRealizationManager;
                var ColumnRealizationManager = function(_super) {
                    function ColumnRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    return __extends(ColumnRealizationManager, _super), Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
                        set: function(owner) {
                            this._owner = owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ColumnRealizationManager.prototype._getOwner = function() {
                        return this._owner;
                    }, ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {
                        this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
                    }, Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
                        get: function() {
                            return this._owner.otherLayoutManager.realizationManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function() {
                        return this._owner.otherLayoutManager.done ? this._owner.getOtherHierarchyContextualHeight() : this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
                    }, ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function(rowHierarchyWidth) {
                        var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
                        if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) return void (this.itemsToRealizeCount = 0);
                        var binder = this.binder, hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator, startColumnIndex = this._owner.dimension.getIntegerScrollOffset(), endColumnIndex = this._owner.dimension.getItemsCount(), columnCount = endColumnIndex - startColumnIndex, startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset(), endRowIndex = this._owner.otherLayoutManager.dimension.getItemsCount();
                        if (this.itemsEstimatedContextualWidth = 0, this._owner.alignToEnd) return void (this.itemsToRealizeCount = columnCount);
                        for (var i = startColumnIndex; endColumnIndex > i; i++) {
                            if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) return void (this.itemsToRealizeCount = i - startColumnIndex);
                            var maxWidth = 0, visibleSizeRatio = void 0;
                            visibleSizeRatio = i === startColumnIndex ? this._owner.getVisibleSizeRatio() : 1;
                            var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i), label = binder.getHeaderLabel(columnMember);
                            maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
                            for (var j = startRowIndex; endRowIndex > j; j++) {
                                var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
                                label = binder.getCellContent(intersection), maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
                            }
                            this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
                        }
                        this.itemsToRealizeCount = columnCount;
                    }, ColumnRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                        return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
                    }, ColumnRealizationManager;
                }(TablixDimensionRealizationManager);
                internal.ColumnRealizationManager = ColumnRealizationManager;
                var RowWidths = function() {
                    function RowWidths() {
                        this.items = [], this.leafCount = 0;
                    }
                    return RowWidths;
                }();
                internal.RowWidths = RowWidths;
                var RowWidth = function() {
                    function RowWidth() {
                        this.maxLeafWidth = 0, this.maxNonLeafWidth = 0;
                    }
                    return RowWidth;
                }();
                internal.RowWidth = RowWidth;
            }(internal = controls.internal || (controls.internal = {}));
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var internal;
            !function(internal) {
                var TablixCell = function() {
                    function TablixCell(presenter, extension, row) {
                        this._scrollable = !1, this._presenter = presenter, this.extension = extension, 
                        this._presenter.initialize(this), this._row = row, this.item = null, this.type = null, 
                        this._horizontalOffset = 0, this._verticalOffset = 0, this._colSpan = 1, this._rowSpan = 1, 
                        this._contentWidth = -1, this._contentHeight = -1, this.position = new internal.TablixUtils.CellPosition();
                    }
                    return Object.defineProperty(TablixCell.prototype, "colSpan", {
                        get: function() {
                            return this._colSpan;
                        },
                        set: function(value) {
                            this._colSpan !== value && (this._presenter.onColumnSpanChanged(value), this._colSpan = value);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixCell.prototype, "rowSpan", {
                        get: function() {
                            return this._rowSpan;
                        },
                        set: function(value) {
                            this._rowSpan !== value && (this._presenter.onRowSpanChanged(value), this._rowSpan = value, 
                            value > 1 && this.setContentHeight(this.getCellSpanningHeight()));
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixCell.prototype.getCellSpanningHeight = function() {
                        return this._row.getCellSpanningHeight(this);
                    }, Object.defineProperty(TablixCell.prototype, "textAlign", {
                        get: function() {
                            return this._textAlign;
                        },
                        set: function(value) {
                            value !== this._textAlign && (this._presenter.onTextAlignChanged(value), this._textAlign = value);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
                        get: function() {
                            return this._horizontalOffset;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixCell.prototype, "verticalOffset", {
                        get: function() {
                            return this._verticalOffset;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixCell.prototype.isScrollable = function() {
                        return this._scrollable;
                    }, TablixCell.prototype.clear = function() {
                        this.isScrollable() && this.initializeScrolling(), this._presenter.onClear(), this.setContentWidth(-1), 
                        this.setContentHeight(-1);
                    }, TablixCell.prototype.initializeScrolling = function() {
                        this._presenter.onInitializeScrolling(), this._horizontalOffset = 0, this._verticalOffset = 0, 
                        1 === this.colSpan && this.setContentWidth(-1), 1 === this.rowSpan && this.setContentHeight(-1);
                    }, TablixCell.prototype.prepare = function(scrollable) {
                        this.isScrollable() && this.initializeScrolling(), this._scrollable = scrollable;
                    }, TablixCell.prototype.scrollVertically = function(height, offset) {
                        var offsetInPixels = Math.ceil(-height * offset);
                        this._verticalOffset = offsetInPixels, this.isScrollable() ? (this._presenter.onVerticalScroll(height, offsetInPixels), 
                        this.setContentHeight(height + offsetInPixels)) : this.setContentHeight(this._row.getCellSpanningHeight(this) + offsetInPixels);
                    }, TablixCell.prototype.scrollHorizontally = function(width, offset) {
                        if (this.isScrollable()) {
                            var offsetInPixels = Math.ceil(-width * offset);
                            this._horizontalOffset = offsetInPixels, this._presenter.onHorizontalScroll(width, offsetInPixels), 
                            this.setContentWidth(width + offsetInPixels);
                        }
                    }, TablixCell.prototype.setContentWidth = function(value) {
                        value !== this._contentWidth && (this._contentWidth = value, this._presenter.onContentWidthChanged(value));
                    }, TablixCell.prototype.setContentHeight = function(value) {
                        value !== this._contentHeight && (this._contentHeight = value, this._presenter.onContentHeightChanged(value));
                    }, TablixCell.prototype.enableHorizontalResize = function(enable, handler) {
                        this._presenter.enableHorizontalResize(enable, handler);
                    }, TablixCell;
                }();
                internal.TablixCell = TablixCell;
                var TablixColumn = function() {
                    function TablixColumn(presenter, columnIndex) {
                        this._presenter = presenter, this._presenter.initialize(this), this._contentWidth = -1, 
                        this._width = -1, this._sizeFixed = !1, this._aligningWidth = -1, this._fixedToAligningWidth = !1, 
                        this._items = [], this._itemType = null, this._footerCell = null, this._columnIndex = columnIndex;
                    }
                    return TablixColumn.prototype.initialize = function(owner) {
                        this._owner = owner, this._realizedRowHeaders = [], this._realizedColumnHeaders = [], 
                        this._realizedCornerCells = [], this._realizedBodyCells = [];
                    }, Object.defineProperty(TablixColumn.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixColumn.prototype.getType = function() {
                        return this._realizedCornerCells.length > 0 ? 0 : 2;
                    }, TablixColumn.prototype.getColumnHeadersOrCorners = function() {
                        return this._realizedCornerCells.length > 0 ? this._realizedCornerCells : this._realizedColumnHeaders;
                    }, TablixColumn.prototype.columnHeadersOrCornersEqual = function(newType, headers, hierarchyNavigator) {
                        if (this._items.length !== headers.length) return !1;
                        for (var count = this._items.length, i = 0; count > i; i++) if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator)) return !1;
                        return !0;
                    }, Object.defineProperty(TablixColumn.prototype, "itemType", {
                        get: function() {
                            return this._itemType;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixColumn.prototype.getLeafItem = function() {
                        return 0 === this._items.length ? null : this._items[this._items.length - 1];
                    }, TablixColumn.prototype.columnHeaderOrCornerEquals = function(type1, item1, type2, item2, hierarchyNavigator) {
                        if (type1 !== type2) return !1;
                        if (0 === type1) {
                            if (!hierarchyNavigator.cornerCellItemEquals(item1, item2)) return !1;
                        } else if (!hierarchyNavigator.headerItemEquals(item1, item2)) return !1;
                        return !0;
                    }, TablixColumn.prototype.OnLeafRealized = function(hierarchyNavigator) {
                        var type = this.getType(), columnHeadersOrCorners = this.getColumnHeadersOrCorners();
                        if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) this.clearSpanningCellsWidth(this._realizedColumnHeaders); else {
                            var count = columnHeadersOrCorners.length;
                            this._items = [];
                            for (var i = 0; count > i; i++) this._items.push(columnHeadersOrCorners[i].item);
                            this._itemType = type, this.clearSize();
                        }
                    }, TablixColumn.prototype.clearSpanningCellsWidth = function(cells) {
                        for (var i = 0; i < cells.length; i++) {
                            var cell = cells[i];
                            cell.colSpan > 1 && cell.setContentWidth(-1);
                        }
                    }, TablixColumn.prototype.addCornerCell = function(cell) {
                        cell._column = this, this._realizedCornerCells.push(cell), cell.setContentWidth(this._contentWidth);
                    }, TablixColumn.prototype.addRowHeader = function(cell) {
                        cell._column = this, this._realizedRowHeaders.push(cell), cell.setContentWidth(this._contentWidth);
                    }, TablixColumn.prototype.addColumnHeader = function(cell, isLeaf) {
                        cell._column = this, this._realizedColumnHeaders.push(cell), isLeaf && cell.setContentWidth(this._contentWidth);
                    }, TablixColumn.prototype.addBodyCell = function(cell) {
                        cell._column = this, this._realizedBodyCells.push(cell), cell.setContentWidth(this._contentWidth);
                    }, Object.defineProperty(TablixColumn.prototype, "footer", {
                        get: function() {
                            return this._footerCell;
                        },
                        set: function(footerCell) {
                            this._footerCell = footerCell, footerCell._column = this, footerCell.setContentWidth(this._contentWidth);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixColumn.prototype.onResize = function(width) {
                        width !== this.getContentContextualWidth() && (this._contentWidth = width, this.setContentWidth(this._contentWidth), 
                        this._sizeFixed = !0, this._fixedToAligningWidth = !1, this._aligningWidth = -1);
                    }, TablixColumn.prototype.onResizeEnd = function(width) {
                        var gridPresenter = this.owner._presenter;
                        gridPresenter && gridPresenter.invokeColumnResizeEndCallback(this._columnIndex, width);
                    }, TablixColumn.prototype.fixSize = function() {
                        var shouldAlign = -1 !== this._aligningWidth, switched = shouldAlign !== this._fixedToAligningWidth;
                        (!this._sizeFixed || switched || shouldAlign) && (-1 === this._aligningWidth ? this.setContentWidth(this._contentWidth) : this.setContentWidth(this._aligningWidth), 
                        this._sizeFixed = !0, this._fixedToAligningWidth = -1 !== this._aligningWidth);
                    }, TablixColumn.prototype.clearSize = function() {
                        this._contentWidth = -1, this.setContentWidth(this._contentWidth), this._sizeFixed = !1;
                    }, TablixColumn.prototype.getContentContextualWidth = function() {
                        return this._contentWidth;
                    }, TablixColumn.prototype.getCellIContentContextualWidth = function(cell) {
                        return this._presenter.getCellContentWidth(cell);
                    }, TablixColumn.prototype.getCellSpanningWidthWithScrolling = function(cell, tablixGrid) {
                        var width = this.getContextualWidth() + this.getScrollingOffset();
                        if (cell.colSpan > 1) for (var index = this.getIndex(tablixGrid), columns = tablixGrid.realizedColumns, i = 1; i < cell.colSpan; i++) width += columns[i + index].getContextualWidth();
                        return width;
                    }, TablixColumn.prototype.getScrollingOffset = function() {
                        var offset = 0;
                        return this._realizedColumnHeaders.length > 0 && (offset = this._realizedColumnHeaders[this._realizedColumnHeaders.length - 1].horizontalOffset), 
                        offset;
                    }, TablixColumn.prototype.getContextualWidth = function() {
                        return -1 !== this._width && -1 !== this._contentWidth || (this._width = this._presenter.getWidth()), 
                        this._width;
                    }, TablixColumn.prototype.calculateSize = function() {
                        if (this._sizeFixed) return this._contentWidth;
                        for (var contentWidth = 0, _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            1 === cell.colSpan && (contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell)));
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            1 === cell.colSpan && (contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell)));
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        return null !== this._footerCell && 1 === this._footerCell.colSpan && (contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._footerCell))), 
                        this._contentWidth = contentWidth;
                    }, TablixColumn.prototype.setAligningContextualWidth = function(size) {
                        this._aligningWidth = size;
                    }, TablixColumn.prototype.getAligningContextualWidth = function() {
                        return this._aligningWidth;
                    }, TablixColumn.prototype.setContentWidth = function(value) {
                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            1 === cell.colSpan && cell.setContentWidth(value);
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            1 === cell.colSpan && cell.setContentWidth(value);
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            cell.setContentWidth(value);
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            cell.setContentWidth(value);
                        }
                        null !== this._footerCell && 1 === this._footerCell.colSpan && this._footerCell.setContentWidth(value), 
                        this._width = value;
                    }, TablixColumn.prototype.getTablixCell = function() {
                        var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
                        return realizedCells[realizedCells.length - 1];
                    }, TablixColumn.prototype.getIndex = function(grid) {
                        return grid.realizedColumns.indexOf(this);
                    }, TablixColumn.prototype.getHeaders = function() {
                        return this._realizedColumnHeaders;
                    }, TablixColumn.prototype.getOtherDimensionHeaders = function() {
                        return this._realizedRowHeaders;
                    }, TablixColumn.prototype.getCellContextualSpan = function(cell) {
                        return cell.colSpan;
                    }, TablixColumn.prototype.getOtherDimensionOwner = function(cell) {
                        return cell._row;
                    }, TablixColumn;
                }();
                internal.TablixColumn = TablixColumn;
                var TablixRow = function() {
                    function TablixRow(presenter) {
                        this._contentHeight = -1, this._presenter = presenter, this._presenter.initialize(this), 
                        this._allocatedCells = [], this._heightFixed = !1, this._contentHeight = -1, this._height = -1;
                    }
                    return TablixRow.prototype.initialize = function(owner) {
                        this._owner = owner, this._realizedRowHeaders = [], this._realizedBodyCells = [], 
                        this._realizedCornerCells = [], this._realizedColumnHeaders = [], this._realizedCellsCount = 0;
                    }, Object.defineProperty(TablixRow.prototype, "presenter", {
                        get: function() {
                            return this._presenter;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixRow.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixRow.prototype.releaseUnusedCells = function(owner) {
                        this.releaseCells(owner, this._realizedCellsCount);
                    }, TablixRow.prototype.releaseAllCells = function(owner) {
                        this.releaseCells(owner, 0);
                    }, TablixRow.prototype.releaseCells = function(owner, startIndex) {
                        for (var cells = this._allocatedCells, length = cells.length, i = startIndex; length > i; i++) {
                            var cell = cells[i];
                            owner._unbindCell(cell), cell.clear();
                        }
                    }, TablixRow.prototype.moveScrollableCellsToEnd = function(count) {
                        for (var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length), i = frontIndex; frontIndex + count > i; i++) {
                            var cell = this._allocatedCells[i];
                            this._presenter.onRemoveCell(cell), this._presenter.onAppendCell(cell), this._allocatedCells.push(cell);
                        }
                        this._allocatedCells.splice(frontIndex, count);
                    }, TablixRow.prototype.moveScrollableCellsToStart = function(count) {
                        for (var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length), i = frontIndex; frontIndex + count > i; i++) {
                            var cell = this._allocatedCells.pop();
                            this._presenter.onRemoveCell(cell), this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]), 
                            this._allocatedCells.splice(frontIndex, 0, cell);
                        }
                    }, TablixRow.prototype.getOrCreateCornerCell = function(column) {
                        var cell = this.getOrCreateCell();
                        return cell.prepare(!1), column.addCornerCell(cell), this._realizedCornerCells.push(cell), 
                        cell.setContentHeight(this._contentHeight), cell;
                    }, TablixRow.prototype.getOrCreateRowHeader = function(column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        return cell.prepare(scrollable), column.addRowHeader(cell), this._realizedRowHeaders.push(cell), 
                        leaf && cell.setContentHeight(this._contentHeight), cell;
                    }, TablixRow.prototype.getOrCreateColumnHeader = function(column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        return cell.prepare(scrollable), column.addColumnHeader(cell, leaf), this._realizedColumnHeaders.push(cell), 
                        cell.setContentHeight(this._contentHeight), cell;
                    }, TablixRow.prototype.getOrCreateBodyCell = function(column, scrollable) {
                        var cell = this.getOrCreateCell();
                        return cell.prepare(scrollable), column.addBodyCell(cell), this._realizedBodyCells.push(cell), 
                        cell.setContentHeight(this._contentHeight), cell;
                    }, TablixRow.prototype.getOrCreateFooterRowHeader = function(column) {
                        var cell = this.getOrCreateCell();
                        return cell.prepare(!1), column.footer = cell, this._realizedRowHeaders.push(cell), 
                        cell.setContentHeight(this._contentHeight), cell;
                    }, TablixRow.prototype.getOrCreateFooterBodyCell = function(column, scrollable) {
                        var cell = this.getOrCreateCell();
                        return cell.prepare(scrollable), column.footer = cell, this._realizedBodyCells.push(cell), 
                        cell.setContentHeight(this._contentHeight), cell;
                    }, TablixRow.prototype.getRowHeaderLeafIndex = function() {
                        for (var index = -1, count = this._allocatedCells.length, i = 0; count > i && 1 === this._allocatedCells[i].type; i++) index++;
                        return index;
                    }, TablixRow.prototype.getAllocatedCellAt = function(index) {
                        return this._allocatedCells[index];
                    }, TablixRow.prototype.moveCellsBy = function(delta) {
                        if (0 !== this._allocatedCells.length) if (delta > 0) for (var refCell = this._allocatedCells[0], i = 0; delta > i; i++) {
                            var cell = this.createCell(this);
                            this._presenter.onInsertCellBefore(cell, refCell), this._allocatedCells.unshift(cell), 
                            refCell = cell;
                        } else {
                            delta = -delta;
                            for (var i = 0; delta > i; i++) this._presenter.onRemoveCell(this._allocatedCells[i]);
                            this._allocatedCells.splice(0, delta);
                        }
                    }, TablixRow.prototype.getRealizedCellCount = function() {
                        return this._realizedCellsCount;
                    }, TablixRow.prototype.getRealizedHeadersCount = function() {
                        return this._realizedRowHeaders.length;
                    }, TablixRow.prototype.getRealizedHeaderAt = function(index) {
                        return this._realizedRowHeaders[index];
                    }, TablixRow.prototype.getTablixCell = function() {
                        var realizedCells;
                        return realizedCells = this._realizedRowHeaders.length > 0 ? this._realizedRowHeaders : this._realizedCornerCells.length > 0 ? this._realizedCornerCells : this._realizedColumnHeaders, 
                        realizedCells[realizedCells.length - 1];
                    }, TablixRow.prototype.getOrCreateEmptySpaceCell = function() {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        return void 0 === cell && (cell = this.createCell(this), this._allocatedCells[this._realizedCellsCount] = cell, 
                        this._presenter.onAppendCell(cell)), cell;
                    }, TablixRow.prototype.createCell = function(row) {
                        var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
                        return new TablixCell(presenter, presenter, this);
                    }, TablixRow.prototype.getOrCreateCell = function() {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        return void 0 === cell ? (cell = this.createCell(this), this._allocatedCells[this._realizedCellsCount] = cell, 
                        this._presenter.onAppendCell(cell)) : (cell.colSpan = 1, cell.rowSpan = 1), this._realizedCellsCount = this._realizedCellsCount + 1, 
                        cell;
                    }, TablixRow.prototype.onResize = function(height) {
                        height !== this.getContentContextualWidth() && (this._contentHeight = height, this.setContentHeight(), 
                        this._heightFixed = !0, this.setAligningContextualWidth(-1));
                    }, TablixRow.prototype.onResizeEnd = function(height) {}, TablixRow.prototype.fixSize = function() {
                        this.sizeFixed() || (this.setContentHeight(), this._heightFixed = !0);
                    }, TablixRow.prototype.getContentContextualWidth = function() {
                        return this._contentHeight;
                    }, TablixRow.prototype.getCellIContentContextualWidth = function(cell) {
                        return this.presenter.getCellContentHeight(cell);
                    }, TablixRow.prototype.getCellSpanningHeight = function(cell) {
                        var height = this.getContextualWidth();
                        if (cell.rowSpan > 1) for (var index = this.getIndex(this.owner), rows = this.owner.realizedRows, i = 1; i < cell.rowSpan; i++) height += rows[i + index].getContextualWidth();
                        return height;
                    }, TablixRow.prototype.getContextualWidth = function() {
                        return -1 !== this._height && -1 !== this._contentHeight || (this._height = this._presenter.getHeight()), 
                        this._height;
                    }, TablixRow.prototype.sizeFixed = function() {
                        return this._heightFixed;
                    }, TablixRow.prototype.calculateSize = function() {
                        if (this._heightFixed) return this._contentHeight;
                        for (var contentHeight = 0, count = this._realizedRowHeaders.length, i = 0; count > i; i++) {
                            var cell = this._realizedRowHeaders[i];
                            1 === cell.rowSpan && (contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell)));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; count > i; i++) contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; count > i; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            1 === cell.rowSpan && (contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell)));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; count > i; i++) contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
                        return this._contentHeight = contentHeight;
                    }, TablixRow.prototype.setAligningContextualWidth = function(size) {}, TablixRow.prototype.getAligningContextualWidth = function() {
                        return -1;
                    }, TablixRow.prototype.setContentHeight = function() {
                        for (var count = this._realizedRowHeaders.length, i = 0; count > i; i++) {
                            var cell = this._realizedRowHeaders[i];
                            1 === cell.rowSpan ? cell.setContentHeight(this._contentHeight) : cell.setContentHeight(this.getCellSpanningHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; count > i; i++) this._realizedCornerCells[i].setContentHeight(this._contentHeight);
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; count > i; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            1 === cell.rowSpan ? cell.setContentHeight(this._contentHeight) : cell.setContentHeight(this.getCellSpanningHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; count > i; i++) this._realizedBodyCells[i].setContentHeight(this._contentHeight);
                        this._height = -1;
                    }, TablixRow.prototype.getIndex = function(grid) {
                        return grid.realizedRows.indexOf(this);
                    }, TablixRow.prototype.getHeaders = function() {
                        return this._realizedRowHeaders;
                    }, TablixRow.prototype.getOtherDimensionHeaders = function() {
                        return this._realizedColumnHeaders;
                    }, TablixRow.prototype.getCellContextualSpan = function(cell) {
                        return cell.rowSpan;
                    }, TablixRow.prototype.getOtherDimensionOwner = function(cell) {
                        return cell._column;
                    }, TablixRow;
                }();
                internal.TablixRow = TablixRow;
                var TablixGrid = function() {
                    function TablixGrid(presenter) {
                        this._presenter = presenter, this._footerRow = null;
                    }
                    return TablixGrid.prototype.initialize = function(owner, gridHost, footerHost) {
                        this._owner = owner, this._presenter.initialize(this, gridHost, footerHost, owner), 
                        this.fillColumnsProportionally = !1, this._realizedRows = [], this._realizedColumns = [], 
                        this._emptySpaceHeaderCell = null, this._emptyFooterSpaceCell = null;
                    }, Object.defineProperty(TablixGrid.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
                        get: function() {
                            return this._fillColumnsProportionally;
                        },
                        set: function(value) {
                            this._fillColumnsProportionally !== value && (this._fillColumnsProportionally = value, 
                            this._presenter.onFillColumnsProportionallyChanged(value));
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
                        get: function() {
                            return this._realizedColumns;
                        },
                        set: function(columns) {
                            this._realizedColumns = columns;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixGrid.prototype, "realizedRows", {
                        get: function() {
                            return this._realizedRows;
                        },
                        set: function(rows) {
                            this._realizedRows = rows;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixGrid.prototype, "footerRow", {
                        get: function() {
                            return this._footerRow;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
                        get: function() {
                            return this._emptySpaceHeaderCell;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
                        get: function() {
                            return this._emptyFooterSpaceCell;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixGrid.prototype.ShowEmptySpaceCells = function(rowSpan, width) {
                        0 !== this._realizedRows.length && (0 === this._realizedRows.length || this._emptySpaceHeaderCell || (this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell(), 
                        this._emptySpaceHeaderCell.rowSpan = rowSpan, this._emptySpaceHeaderCell.colSpan = 1, 
                        this._emptySpaceHeaderCell.setContentWidth(width)), this._footerRow && null === this._emptyFooterSpaceCell && (this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell(), 
                        this._emptyFooterSpaceCell.rowSpan = 1, this._emptyFooterSpaceCell.colSpan = 1, 
                        this._emptyFooterSpaceCell.setContentWidth(width)));
                    }, TablixGrid.prototype.HideEmptySpaceCells = function() {
                        this._emptySpaceHeaderCell && (this._emptySpaceHeaderCell.clear(), this._emptySpaceHeaderCell = null), 
                        this._emptyFooterSpaceCell && (this._emptyFooterSpaceCell.clear(), this._emptyFooterSpaceCell = null);
                    }, TablixGrid.prototype.onStartRenderingSession = function(clear) {
                        clear && (this.clearRows(), this.clearColumns());
                    }, TablixGrid.prototype.onStartRenderingIteration = function() {
                        this.initializeRows(), this.initializeColumns();
                    }, TablixGrid.prototype.onEndRenderingIteration = function() {
                        var rows = this._rows;
                        if (void 0 !== rows) for (var rowCount = rows.length, i = 0; rowCount > i; i++) rows[i].releaseUnusedCells(this._owner);
                        this._footerRow && this._footerRow.releaseUnusedCells(this._owner);
                    }, TablixGrid.prototype.getOrCreateRow = function(rowIndex) {
                        var currentRow = this._rows[rowIndex];
                        return void 0 === currentRow && (currentRow = new TablixRow(this._presenter.createRowPresenter()), 
                        currentRow.initialize(this), this._presenter.onAppendRow(currentRow), this._rows[rowIndex] = currentRow), 
                        void 0 === this._realizedRows[rowIndex] && (this._realizedRows[rowIndex] = currentRow), 
                        currentRow;
                    }, TablixGrid.prototype.getOrCreateFootersRow = function() {
                        return null === this._footerRow && (this._footerRow = new TablixRow(this._presenter.createRowPresenter()), 
                        this._footerRow.initialize(this), this._presenter.onAddFooterRow(this._footerRow)), 
                        this._footerRow;
                    }, TablixGrid.prototype.moveRowsToEnd = function(moveFromIndex, count) {
                        for (var i = 0; count > i; i++) {
                            var row = this._rows[i + moveFromIndex];
                            this._presenter.onRemoveRow(row), this._presenter.onAppendRow(row), this._rows.push(row);
                        }
                        this._rows.splice(moveFromIndex, count);
                    }, TablixGrid.prototype.moveRowsToStart = function(moveToIndex, count) {
                        for (var refRow = this._rows[moveToIndex], i = 0; count > i; i++) {
                            var row = this._rows.pop();
                            this._presenter.onRemoveRow(row), this._presenter.onInsertRowBefore(row, refRow), 
                            this._rows.splice(moveToIndex + i, 0, row);
                        }
                    }, TablixGrid.prototype.moveColumnsToEnd = function(moveFromIndex, count) {
                        for (var firstCol = this._rows[0]._realizedCornerCells.length, leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0), i = leafStartDepth; i < this._rows.length; i++) this._rows[i].moveScrollableCellsToEnd(count);
                        for (var i = 0; count > i; i++) {
                            var column = this._columns[i + moveFromIndex];
                            this._columns.push(column);
                        }
                        this._columns.splice(moveFromIndex, count);
                    }, TablixGrid.prototype.moveColumnsToStart = function(moveToIndex, count) {
                        for (var firstCol = this._rows[0]._realizedCornerCells.length, leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0), i = leafStartDepth; i < this._rows.length; i++) this._rows[i].moveScrollableCellsToStart(count);
                        for (var i = 0; count > i; i++) {
                            var column = this._columns.pop();
                            this._columns.splice(moveToIndex + i, 0, column);
                        }
                    }, TablixGrid.prototype.getOrCreateColumn = function(columnIndex) {
                        var currentColumn = this._columns[columnIndex];
                        return void 0 === currentColumn && (currentColumn = new TablixColumn(this._presenter.createColumnPresenter(columnIndex), columnIndex), 
                        currentColumn.initialize(this), this._columns[columnIndex] = currentColumn), void 0 === this._realizedColumns[columnIndex] && (this._realizedColumns[columnIndex] = currentColumn), 
                        currentColumn;
                    }, TablixGrid.prototype.initializeColumns = function() {
                        this._columns || (this._columns = []);
                        for (var length = this._columns.length, i = 0; length > i; i++) this._columns[i].initialize(this);
                        this._realizedColumns = [];
                    }, TablixGrid.prototype.clearColumns = function() {
                        this._columns = null, this._realizedColumns = null;
                    }, TablixGrid.prototype.initializeRows = function() {
                        var hasFooter = this._owner.rowDimension.hasFooter() && null !== this._footerRow;
                        this._realizedRows = [], this._rows || (this._rows = []);
                        for (var rows = this._rows, length = rows.length, i = 0; length > i; i++) rows[i].initialize(this);
                        hasFooter && (this._footerRow || this.getOrCreateFootersRow(), this._footerRow.initialize(this));
                    }, TablixGrid.prototype.clearRows = function() {
                        var rows = this._rows;
                        if (rows) {
                            for (var length_1 = rows.length, i = 0; length_1 > i; i++) rows[i].releaseAllCells(this._owner);
                            this._footerRow && this._footerRow.releaseAllCells(this._owner), this._presenter.onClear(), 
                            this._footerRow = null, this._rows = null, this._realizedRows = null;
                        }
                    }, TablixGrid.prototype.getWidth = function() {
                        return this._presenter.getWidth();
                    }, TablixGrid.prototype.getHeight = function() {
                        return this._presenter.getHeight();
                    }, TablixGrid;
                }();
                internal.TablixGrid = TablixGrid;
            }(internal = controls.internal || (controls.internal = {}));
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var internal;
            !function(internal) {
                var PixelConverter = jsCommon.PixelConverter, SizeComputationManager = function() {
                    function SizeComputationManager() {}
                    return Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
                        get: function() {
                            return this._viewport ? this._viewport.width : 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
                        get: function() {
                            return this._viewport ? this._viewport.height : 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
                        get: function() {
                            return this.visibleWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
                        get: function() {
                            return this.visibleHeight;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
                        get: function() {
                            return this._cellHeight;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
                        get: function() {
                            return this._cellWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
                        get: function() {
                            return this._cellHeight;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
                        get: function() {
                            return this._cellWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
                        get: function() {
                            return this._cellHeight;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), SizeComputationManager.prototype.updateColumnCount = function(columnCount) {
                        this._columnCount = columnCount;
                    }, SizeComputationManager.prototype.updateRowHeight = function(rowHeight) {
                        this._cellHeight = rowHeight;
                    }, SizeComputationManager.prototype.updateScalingFactor = function(scalingFactor) {
                        this._scalingFactor = scalingFactor, this._cellWidth = this.computeColumnWidth(this._columnCount);
                    }, SizeComputationManager.prototype.updateViewport = function(viewport) {
                        this._viewport = viewport, this._cellWidth = this.computeColumnWidth(this._columnCount), 
                        this._cellHeight = this.computeColumnHeight();
                    }, SizeComputationManager.prototype.computeColumnWidth = function(totalColumnCount) {
                        var scalingFactor = this._scalingFactor;
                        scalingFactor || (scalingFactor = 1);
                        var minimumColumnWidth = scalingFactor * SizeComputationManager.TablixMinimumColumnWidth, maxAllowedColumns = Math.floor(this._viewport.width / minimumColumnWidth);
                        return this.fitToColumnCount(maxAllowedColumns, totalColumnCount);
                    }, SizeComputationManager.prototype.computeColumnHeight = function() {
                        if (!this.hasImageContent) return this._cellHeight;
                        var width = this._viewport.width;
                        return 250 >= width ? 20 : 510 >= width ? 51 : 770 >= width ? 52 : void 0;
                    }, SizeComputationManager.prototype.fitToColumnCount = function(maxAllowedColumnCount, totalColumnCount) {
                        var columnsToFit = Math.min(maxAllowedColumnCount, totalColumnCount);
                        return Math.floor(this._viewport.width / columnsToFit);
                    }, SizeComputationManager.TablixMinimumColumnWidth = 75, SizeComputationManager;
                }();
                internal.SizeComputationManager = SizeComputationManager;
                var DimensionLayoutManager = function() {
                    function DimensionLayoutManager(owner, grid, realizationManager) {
                        this._owner = owner, this._grid = grid, this._lastScrollOffset = null, this._isScrolling = !1, 
                        this._fixedSizeEnabled = !0, this._done = !1, this._realizationManager = realizationManager;
                    }
                    return Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        set: function(owner) {
                            this._owner = owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
                        get: function() {
                            return this._realizationManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
                        get: function() {
                            return this._fixedSizeEnabled;
                        },
                        set: function(enable) {
                            this._fixedSizeEnabled = enable;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DimensionLayoutManager.prototype.onCornerCellRealized = function(item, cell, leaf) {
                        this._realizationManager.onCornerCellRealized(item, cell);
                    }, DimensionLayoutManager.prototype.onHeaderRealized = function(item, cell, leaf) {
                        this._realizationManager.onHeaderRealized(item, cell, leaf);
                    }, Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
                        get: function() {
                            return this._realizationManager.needsToRealize;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DimensionLayoutManager.prototype.getVisibleSizeRatio = function() {
                        return 1 - this.dimension.getFractionScrollOffset();
                    }, Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
                        get: function() {
                            return this._alignToEnd;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(DimensionLayoutManager.prototype, "done", {
                        get: function() {
                            return this._done;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DimensionLayoutManager.prototype._requiresMeasure = function() {
                        return !0;
                    }, DimensionLayoutManager.prototype.startScrollingSession = function() {
                        this._isScrolling = !0;
                    }, DimensionLayoutManager.prototype.endScrollingSession = function() {
                        this._isScrolling = !1;
                    }, DimensionLayoutManager.prototype.isScrolling = function() {
                        return this._isScrolling;
                    }, DimensionLayoutManager.prototype.isResizing = function() {
                        return !1;
                    }, DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function() {
                        var otherDimension = this.dimension.otherDimension, count = otherDimension.getDepth(), contextualHeight = 0, items = this._getRealizedItems();
                        if (items.length > 0) for (var i = 0; count > i; i++) contextualHeight += items[i].getContextualWidth();
                        return contextualHeight;
                    }, DimensionLayoutManager.prototype._isAutoSized = function() {
                        return !1;
                    }, DimensionLayoutManager.prototype.onStartRenderingSession = function() {
                        this._measureEnabled = this._requiresMeasure(), this._gridOffset = this.dimension.otherDimension.getDepth();
                    }, DimensionLayoutManager.prototype.onEndRenderingSession = function() {
                        this._realizationManager.onEndRenderingSession(), this._alignToEnd = !1, this._done = !1, 
                        this._measureEnabled = !0, this._sendDimensionsToControl();
                    }, DimensionLayoutManager.prototype._sendDimensionsToControl = function() {}, Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
                        get: function() {
                            return this._measureEnabled;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DimensionLayoutManager.prototype.getFooterContextualWidth = function() {
                        return 0;
                    }, DimensionLayoutManager.prototype.onStartRenderingIteration = function(clear, contextualWidth) {
                        this._measureEnabled && !this._done && (this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth()), 
                        this._realizationManager.onStartRenderingIteration(), clear ? this._lastScrollOffset = null : null !== this._lastScrollOffset && this.swapElements();
                    }, Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
                        get: function() {
                            return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || 0 === this.dimension.getItemsCount();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DimensionLayoutManager.prototype.onEndRenderingIteration = function() {
                        if (!this._done) {
                            if (!this._measureEnabled) return this._lastScrollOffset = this.dimension.scrollOffset, 
                            void (this._done = !0);
                            var newScrollOffset, gridContextualWidth = this.getGridContextualWidth(), filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision), allRealized = this.allItemsRealized;
                            newScrollOffset = filled ? this.scrollForwardToAlignEnd(gridContextualWidth) : this.scrollBackwardToFill(gridContextualWidth), 
                            this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
                            var originalScrollbarVisible = this.dimension.scrollbar.visible;
                            this.updateScrollbar(gridContextualWidth), this._done = (filled || allRealized) && this.dimension.scrollbar.visible === originalScrollbarVisible && powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision), 
                            this.dimension.scrollOffset = newScrollOffset, this._lastScrollOffset = this.dimension.scrollOffset;
                        }
                    }, DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function() {
                        if (null !== this._lastScrollOffset) {
                            var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
                            if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) return delta;
                        }
                        return null;
                    }, DimensionLayoutManager.prototype.swapElements = function() {
                        var delta = this.getScrollDeltaWithinPage();
                        if (null !== delta) {
                            var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
                            Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth && (delta > 0 ? this._moveElementsToBottom(otherHierarchyDepth, delta) : 0 > delta && this._moveElementsToTop(otherHierarchyDepth, -delta));
                        }
                    }, DimensionLayoutManager.prototype._getRealizedItems = function() {
                        return null;
                    }, DimensionLayoutManager.prototype.getRealizedItemsCount = function() {
                        var realizedItems = this._getRealizedItems();
                        return realizedItems.length;
                    }, DimensionLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {}, 
                    DimensionLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {}, 
                    DimensionLayoutManager.prototype.isScrollingWithinPage = function() {
                        return null !== this.getScrollDeltaWithinPage();
                    }, DimensionLayoutManager.prototype.getGridContextualWidth = function() {
                        return 0;
                    }, DimensionLayoutManager.prototype.updateScrollbar = function(gridContextualWidth) {
                        var scrollbar = this.dimension.scrollbar;
                        scrollbar.viewMin = this.dimension.scrollOffset, scrollbar.min = 0, scrollbar.max = this.dimension.getItemsCount(), 
                        scrollbar.viewSize = this.getViewSize(gridContextualWidth), this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
                    }, DimensionLayoutManager.prototype.getViewSize = function(gridContextualWidth) {
                        var count = this.getRealizedItemsCount();
                        if (0 === count) return 0;
                        for (var startIndex = this._gridOffset, sizeInItems = 0, sizeInPixels = 0, widthToFill = this._contextualWidthToFill, scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight(), error = this.getMeaurementError(gridContextualWidth), i = startIndex; count > i; i++) {
                            var visibleRatio = void 0;
                            visibleRatio = i === startIndex ? this.getVisibleSizeRatio() : 1;
                            var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
                            if (sizeInPixels += itemContextualWidth, sizeInItems += visibleRatio, powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
                                sizeInItems -= (sizeInPixels - scrollableArea) / itemContextualWidth * visibleRatio;
                                break;
                            }
                        }
                        return sizeInItems;
                    }, DimensionLayoutManager.prototype.isScrollableHeader = function(item, items, index) {
                        if (0 !== index || 0 === this.dimension.getFractionScrollOffset()) return !1;
                        var hierarchyNavigator = this.dimension._hierarchyNavigator;
                        if (hierarchyNavigator.isLeaf(item)) return !0;
                        var currentItem = item, currentItems = items;
                        do {
                            if (currentItems = hierarchyNavigator.getChildren(currentItem), currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1), 
                            void 0 === currentItem) break;
                            if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) return !1;
                        } while (!hierarchyNavigator.isLeaf(currentItem));
                        return !0;
                    }, DimensionLayoutManager.prototype.reachedEnd = function() {
                        return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    }, DimensionLayoutManager.prototype.scrollBackwardToFill = function(gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this.reachedEnd()) {
                            var widthToFill = this._contextualWidthToFill - gridContextualWidth;
                            if (this.dimension.getItemsCount() > 0) {
                                var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
                                newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - widthToFill / averageColumnwidth));
                            }
                            this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                        }
                        return newScrollOffset;
                    }, DimensionLayoutManager.prototype.getItemContextualWidth = function(index) {
                        var realizedItems = this._getRealizedItems();
                        return index >= realizedItems.length ? null : realizedItems[index].getContextualWidth();
                    }, DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function(index) {
                        return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
                    }, DimensionLayoutManager.prototype.getSizeWithScrolling = function(size, index) {
                        var ratio;
                        return ratio = this._gridOffset === index ? this.getVisibleSizeRatio() : 1, size * ratio;
                    }, DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function() {
                        for (var count = this.getRealizedItemsCount(), contextualWidth = 0, i = 0; count > i; i++) contextualWidth += this.getItemContextualWidthWithScrolling(i);
                        return contextualWidth;
                    }, DimensionLayoutManager.prototype.getMeaurementError = function(gridContextualWidth) {
                        return gridContextualWidth / this.getGridContextualWidthFromItems();
                    }, DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function(gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this._alignToEnd) {
                            var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                            if (!withinThreshold) for (var count = this.getRealizedItemsCount(), startIndex = this._gridOffset, widthToScroll = gridContextualWidth - this._contextualWidthToFill, error = this.getMeaurementError(gridContextualWidth), i = startIndex; count > i; i++) {
                                var itemContextualWidth = this.getItemContextualWidth(i) * error;
                                if (!powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
                                    var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
                                    newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + widthToScroll * visibleRatio / itemContextualWidth);
                                    break;
                                }
                                widthToScroll -= itemContextualWidth;
                            }
                            this._alignToEnd = !withinThreshold;
                        }
                        return newScrollOffset;
                    }, Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
                        get: function() {
                            return null;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
                        get: function() {
                            return this.dimension.otherDimension.layoutManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
                        get: function() {
                            return this._contextualWidthToFill;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DimensionLayoutManager.prototype.getGridScale = function() {
                        return 0;
                    }, Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function() {
                            return 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), DimensionLayoutManager.prototype.getActualContextualWidth = function(gridContextualWidth) {
                        return this._isAutoSized() && !this.canScroll(gridContextualWidth) ? gridContextualWidth : this._contextualWidthToFill;
                    }, DimensionLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return !1;
                    }, DimensionLayoutManager.prototype.calculateSizes = function() {
                        this.fixedSizeEnabled && (this.calculateContextualWidths(), this.calculateSpans());
                    }, DimensionLayoutManager.prototype._calculateSize = function(item) {
                        return null;
                    }, DimensionLayoutManager.prototype.calculateContextualWidths = function() {
                        for (var items = this._getRealizedItems(), count = items.length, i = 0; count > i; i++) {
                            var item = items[i];
                            this.measureEnabled && item.setAligningContextualWidth(-1), this._calculateSize(item);
                        }
                    }, DimensionLayoutManager.prototype.calculateSpans = function() {
                        this.measureEnabled && (this.updateNonScrollableItemsSpans(), this.updateScrollableItemsSpans());
                    }, DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function() {
                        for (var otherDimensionItems = this.otherLayoutManager._getRealizedItems(), otherDimensionItemsCount = otherDimensionItems.length, startIndex = this.dimension.getDepth(), i = startIndex; otherDimensionItemsCount > i; i++) {
                            var otherDimensionItem = otherDimensionItems[i];
                            this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders());
                        }
                    }, DimensionLayoutManager.prototype.updateScrollableItemsSpans = function() {
                        for (var otherRealizedItems = this.otherLayoutManager._getRealizedItems(), otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length), i = 0; otherRealizedItemsCount > i; i++) {
                            var otherRealizedItem = otherRealizedItems[i];
                            this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders());
                        }
                    }, DimensionLayoutManager.prototype.fixSizes = function() {
                        if (this.fixedSizeEnabled) for (var items = this._getRealizedItems(), count = items.length, i = 0; count > i; i++) items[i].fixSize();
                    }, DimensionLayoutManager.prototype.updateSpans = function(otherRealizedItem, cells) {
                        for (var realizedItems = this._getRealizedItems(), cellCount = cells.length, j = 0; cellCount > j; j++) {
                            var cell = cells[j], owner = otherRealizedItem.getOtherDimensionOwner(cell), span = owner.getCellContextualSpan(cell);
                            if (span > 1) for (var totalSizeInSpan = 0, startIndex = owner.getIndex(this._grid), k = 0; span > k; k++) {
                                var item = realizedItems[k + startIndex];
                                totalSizeInSpan += item.getContentContextualWidth(), k === span - 1 && this.updateLastChildSize(cell, item, totalSizeInSpan);
                            }
                        }
                    }, DimensionLayoutManager.prototype.updateLastChildSize = function(spanningCell, item, totalSpanSize) {
                        var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
                        delta > 0 && item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
                    }, DimensionLayoutManager._pixelPrecision = 1.0001, DimensionLayoutManager._scrollOffsetPrecision = .01, 
                    DimensionLayoutManager;
                }();
                internal.DimensionLayoutManager = DimensionLayoutManager;
                var ResizeState = function() {
                    function ResizeState(column, width, scale) {
                        this.column = column, this.item = column.getLeafItem(), this.itemType = column.itemType, 
                        this.startColumnWidth = width, this.resizingDelta = 0, this.animationFrame = null, 
                        this.scale = scale;
                    }
                    return ResizeState.prototype.getNewSize = function() {
                        return this.startColumnWidth + this.resizingDelta;
                    }, ResizeState;
                }();
                internal.ResizeState = ResizeState;
                var ColumnLayoutManager = function(_super) {
                    function ColumnLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager), realizationManager.owner = this, 
                        this.fillProportionally = !1, this._resizeState = null;
                    }
                    return __extends(ColumnLayoutManager, _super), Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
                        get: function() {
                            return this.owner.owner.columnDimension;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ColumnLayoutManager.prototype.isResizing = function() {
                        return null !== this._resizeState;
                    }, Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
                        get: function() {
                            return this._grid.fillColumnsProportionally;
                        },
                        set: function(value) {
                            this._grid.fillColumnsProportionally = value;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ColumnLayoutManager.prototype.getGridScale = function() {
                        return this._grid._presenter.getScreenToCssRatioX();
                    }, Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function() {
                            return this.dimension.otherDimension.scrollbar.visible ? controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element) : 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ColumnLayoutManager.prototype._getRealizedItems = function() {
                        return this._grid.realizedColumns || (this._grid.realizedColumns = []), this._grid.realizedColumns;
                    }, ColumnLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {
                        this._grid.moveColumnsToEnd(moveFromIndex, count);
                    }, ColumnLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {
                        this._grid.moveColumnsToStart(moveToIndex, count);
                    }, ColumnLayoutManager.prototype._requiresMeasure = function() {
                        return !this.isScrolling() && !this.otherLayoutManager.isScrolling() || this.isScrolling() || this.isResizing();
                    }, ColumnLayoutManager.prototype.getGridContextualWidth = function() {
                        return this._grid.getWidth();
                    }, ColumnLayoutManager.prototype.getFirstVisibleColumn = function() {
                        return this._grid.realizedColumns[this._gridOffset];
                    }, ColumnLayoutManager.prototype._isAutoSized = function() {
                        return this.owner.owner.autoSizeWidth;
                    }, ColumnLayoutManager.prototype.applyScrolling = function() {
                        var columnOffset = this.dimension.getFractionScrollOffset(), firstVisibleColumnWidth = 0;
                        if (0 !== columnOffset) {
                            var firstVisibleColumn = this.getFirstVisibleColumn();
                            void 0 !== firstVisibleColumn && (firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth(), 
                            this.scroll(firstVisibleColumn, firstVisibleColumnWidth, columnOffset));
                        }
                    }, ColumnLayoutManager.prototype.scroll = function(firstVisibleColumn, width, offset) {
                        this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset), this.scrollBodyCells(this._grid.realizedRows, width, offset), 
                        null !== firstVisibleColumn.footer && firstVisibleColumn.footer.scrollHorizontally(width, offset);
                    }, ColumnLayoutManager.prototype.scrollCells = function(cells, width, offset) {
                        for (var length = cells.length, i = 0; length > i; i++) cells[i].scrollHorizontally(width, offset);
                    }, ColumnLayoutManager.prototype.scrollBodyCells = function(rows, width, offset) {
                        for (var cells, cell, length = rows.length, i = 0; length > i; i++) cells = rows[i]._realizedBodyCells, 
                        void 0 !== cells && (cell = cells[0], void 0 !== cell && cell.scrollHorizontally(width, offset));
                    }, ColumnLayoutManager.prototype.onStartResize = function(cell, currentX, currentY) {
                        this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
                    }, ColumnLayoutManager.prototype.onResize = function(cell, deltaX, deltaY) {
                        var _this = this;
                        this.isResizing() && (this._resizeState.resizingDelta = Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth), 
                        null === this._resizeState.animationFrame && (this._resizeState.animationFrame = requestAnimationFrame(function() {
                            return _this.performResizing();
                        })));
                    }, ColumnLayoutManager.prototype.onEndResize = function(cell) {
                        this.isResizing() && null !== this._resizeState.animationFrame && this.performResizing(), 
                        this.endResizing(), this._resizeState = null;
                    }, ColumnLayoutManager.prototype.onReset = function(cell) {
                        this._resizeState = new ResizeState(cell._column, -1, 1), cell._column.clearSize(), 
                        this.endResizing(), this.owner.owner.refresh(!1), this._resizeState = null;
                    }, ColumnLayoutManager.prototype.updateItemToResizeState = function(realizedColumns) {
                        if (null !== this._resizeState) for (var columnCount = realizedColumns.length, hierarchyNavigator = this.owner.owner.hierarchyNavigator, startIndex = this.otherLayoutManager.dimension.getDepth(), i = startIndex; columnCount > i; i++) {
                            var column = realizedColumns[i];
                            if (column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator) && column !== this._resizeState.column) {
                                this._resizeState.column = column, column.onResize(this._resizeState.getNewSize());
                                break;
                            }
                        }
                    }, ColumnLayoutManager.prototype.performResizing = function() {
                        if (null !== this._resizeState) {
                            this._resizeState.animationFrame = null;
                            var newSize = this._resizeState.getNewSize();
                            this._resizeState.column.onResize(newSize), this.owner.owner.refresh(!1);
                        }
                    }, ColumnLayoutManager.prototype.endResizing = function() {
                        if (null !== this._resizeState) {
                            var newSize = this._resizeState.getNewSize();
                            this._resizeState.column.onResizeEnd(newSize);
                        }
                    }, ColumnLayoutManager.prototype._sendDimensionsToControl = function() {
                        var gridContextualWidth = this.getGridContextualWidth(), widthToFill = this.getActualContextualWidth(gridContextualWidth), otherContextualHeight = this.getOtherHierarchyContextualHeight(), scale = this.getGridScale();
                        this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
                    }, ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return -1;
                    }, ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                        return -1;
                    }, ColumnLayoutManager.minColumnWidth = 10, ColumnLayoutManager;
                }(DimensionLayoutManager);
                internal.ColumnLayoutManager = ColumnLayoutManager;
                var DashboardColumnLayoutManager = function(_super) {
                    function DashboardColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    return __extends(DashboardColumnLayoutManager, _super), DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return this.ignoreColumn(headerIndex) ? 0 : this.owner.getCellWidth(void 0);
                    }, DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                        return this.owner.getCellWidth(void 0);
                    }, DashboardColumnLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return !1;
                    }, DashboardColumnLayoutManager.prototype._calculateSize = function(item) {
                        var headerIndex = item.getIndex(this._grid), computedSize = 0;
                        return this.ignoreColumn(headerIndex) || (computedSize = this.owner.getContentWidth(void 0)), 
                        item.onResize(computedSize), item.onResizeEnd(computedSize), computedSize;
                    }, DashboardColumnLayoutManager.prototype.ignoreColumn = function(headerIndex) {
                        return 0 === headerIndex && !this.owner.binder.hasRowGroups();
                    }, DashboardColumnLayoutManager;
                }(ColumnLayoutManager);
                internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
                var CanvasColumnLayoutManager = function(_super) {
                    function CanvasColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    return __extends(CanvasColumnLayoutManager, _super), CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return this.owner.getEstimatedTextWidth(label);
                    }, CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                        return this.owner.getEstimatedTextWidth(content);
                    }, CanvasColumnLayoutManager.prototype.calculateContextualWidths = function() {
                        for (var items = this._getRealizedItems(), columnWidths = [], _i = 0, items_1 = items; _i < items_1.length; _i++) {
                            var item = items_1[_i];
                            this.measureEnabled && item.setAligningContextualWidth(-1), columnWidths.push(this._calculateSize(item));
                        }
                        this.owner.columnWidthsToPersist = columnWidths;
                    }, CanvasColumnLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || this.getRealizedItemsCount() - this._gridOffset < this.dimension.getItemsCount() && this._contextualWidthToFill > 0 || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    }, CanvasColumnLayoutManager.prototype._calculateSize = function(item) {
                        return item.calculateSize();
                    }, CanvasColumnLayoutManager;
                }(ColumnLayoutManager);
                internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
                var RowLayoutManager = function(_super) {
                    function RowLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager), realizationManager.owner = this;
                    }
                    return __extends(RowLayoutManager, _super), Object.defineProperty(RowLayoutManager.prototype, "dimension", {
                        get: function() {
                            return this.owner.owner.rowDimension;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), RowLayoutManager.prototype.getGridScale = function() {
                        return this._grid._presenter.getScreenToCssRatioY();
                    }, Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function() {
                            return this.dimension.otherDimension.scrollbar.visible ? controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element) : 0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), RowLayoutManager.prototype.startScrollingSession = function() {
                        _super.prototype.startScrollingSession.call(this);
                    }, RowLayoutManager.prototype._getRealizedItems = function() {
                        return this._grid.realizedRows || (this._grid.realizedRows = []), this._grid.realizedRows;
                    }, RowLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {
                        this._grid.moveRowsToEnd(moveFromIndex, count);
                    }, RowLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {
                        this._grid.moveRowsToStart(moveToIndex, count);
                    }, RowLayoutManager.prototype._requiresMeasure = function() {
                        return !this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing() || this.isScrolling() && this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    }, RowLayoutManager.prototype.getGridContextualWidth = function() {
                        return this._grid.getHeight();
                    }, RowLayoutManager.prototype.getFirstVisibleRow = function() {
                        return this._grid.realizedRows[this._gridOffset];
                    }, RowLayoutManager.prototype._isAutoSized = function() {
                        return this.owner.owner.autoSizeHeight;
                    }, RowLayoutManager.prototype.applyScrolling = function() {
                        var rowOffset = this.dimension.getFractionScrollOffset(), firstVisibleRowHeight = 0;
                        if (0 !== rowOffset) {
                            var firstVisibleRow = this.getFirstVisibleRow();
                            firstVisibleRow && (firstVisibleRowHeight = firstVisibleRow.getContextualWidth(), 
                            this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset));
                        }
                    }, RowLayoutManager.prototype.scroll = function(firstVisibleRow, height, offset) {
                        this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset), this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
                    }, RowLayoutManager.prototype.scrollCells = function(cells, height, offset) {
                        for (var length = cells.length, i = 0; length > i; i++) cells[i].scrollVertically(height, offset);
                    }, RowLayoutManager.prototype.getFooterContextualWidth = function() {
                        return this.owner.owner.rowDimension.hasFooter() && this.owner.grid.footerRow ? this.owner.grid.footerRow.getContextualWidth() : 0;
                    }, RowLayoutManager.prototype.calculateContextualWidths = function() {
                        if (_super.prototype.calculateContextualWidths.call(this), this.fixedSizeEnabled) {
                            var footerRow = this._grid.footerRow;
                            footerRow && this._calculateSize(footerRow);
                        }
                    }, RowLayoutManager.prototype.fixSizes = function() {
                        _super.prototype.fixSizes.call(this), this.fixedSizeEnabled && this._grid.footerRow && this._grid.footerRow.fixSize();
                    }, RowLayoutManager.prototype._sendDimensionsToControl = function() {
                        var gridContextualWidth = this.getGridContextualWidth(), widthToFill = this.getActualContextualWidth(gridContextualWidth), otherContextualHeight = this.getOtherHierarchyContextualHeight(), scale = this.getGridScale();
                        this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0);
                    }, RowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return -1;
                    }, RowLayoutManager;
                }(DimensionLayoutManager);
                internal.RowLayoutManager = RowLayoutManager;
                var DashboardRowLayoutManager = function(_super) {
                    function DashboardRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    return __extends(DashboardRowLayoutManager, _super), DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return this.getHeaderWidth(headerIndex);
                    }, DashboardRowLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return !1;
                    }, DashboardRowLayoutManager.prototype._calculateSize = function(item) {
                        var computedSize = this.owner.getEstimatedRowHeight();
                        return item.onResize(computedSize), computedSize;
                    }, DashboardRowLayoutManager.prototype.getHeaderWidth = function(headerIndex) {
                        return 0 !== headerIndex || this.owner.binder.hasRowGroups() ? this.owner.getEstimatedTextWidth(void 0) : 0;
                    }, DashboardRowLayoutManager;
                }(RowLayoutManager);
                internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
                var CanvasRowLayoutManager = function(_super) {
                    function CanvasRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    return __extends(CanvasRowLayoutManager, _super), CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return this.owner.getEstimatedTextWidth(label);
                    }, CanvasRowLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || this.getRealizedItemsCount() - this._gridOffset < this.dimension.getItemsCount() && this._contextualWidthToFill > 0 || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    }, CanvasRowLayoutManager.prototype._calculateSize = function(item) {
                        return item.calculateSize();
                    }, CanvasRowLayoutManager;
                }(RowLayoutManager);
                internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
                var TablixLayoutManager = function() {
                    function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
                        this._allowHeaderResize = !0, this._binder = binder, this._grid = grid, this._columnLayoutManager = columnLayoutManager, 
                        this._rowLayoutManager = rowLayoutManager, this._columnWidthsToPersist = [];
                    }
                    return TablixLayoutManager.prototype.initialize = function(owner) {
                        this._owner = owner, this._container = owner.container, this._gridHost = owner.contentHost, 
                        this._footersHost = owner.footerHost, this._grid.initialize(owner, this._gridHost, this._footersHost);
                    }, Object.defineProperty(TablixLayoutManager.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixLayoutManager.prototype, "binder", {
                        get: function() {
                            return this._binder;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixLayoutManager.prototype, "columnWidthsToPersist", {
                        get: function() {
                            return this._columnWidthsToPersist;
                        },
                        set: function(columnWidths) {
                            this._columnWidthsToPersist = columnWidths;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixLayoutManager.prototype.getTablixClassName = function() {
                        return null;
                    }, TablixLayoutManager.prototype.getLayoutKind = function() {
                        return null;
                    }, TablixLayoutManager.prototype.getOrCreateColumnHeader = function(item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex), column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset), isLeaf = this.owner.hierarchyNavigator.isLeaf(item), cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf), rowIdx = this.owner.hierarchyNavigator.getLevel(item);
                        cell.position.row.index = rowIdx, cell.position.row.isFirst = 0 === rowIdx, cell.position.row.isLast = isLeaf;
                        var colIdx = this.owner.hierarchyNavigator.getIndex(item);
                        return cell.position.column.index = colIdx, cell.position.column.isFirst = this.owner.hierarchyNavigator.areAllParentsFirst(item, items), 
                        cell.position.column.isLast = this.owner.hierarchyNavigator.areAllParentsLast(item, items), 
                        this.enableCellHorizontalResize(isLeaf, cell), cell;
                    }, TablixLayoutManager.prototype.getOrCreateRowHeader = function(item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset), column = this._grid.getOrCreateColumn(columnIndex), isLeaf = this.owner.hierarchyNavigator.isLeaf(item), scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
                        0 === row.getRealizedCellCount() && this.alignRowHeaderCells(item, row);
                        var cell = row.getOrCreateRowHeader(column, scrollable, this.owner.hierarchyNavigator.isLeaf(item)), rowIdx = this.owner.hierarchyNavigator.getIndex(item);
                        cell.position.row.index = rowIdx, cell.position.row.isFirst = this.owner.hierarchyNavigator.areAllParentsFirst(item, items), 
                        cell.position.row.isLast = this.owner.hierarchyNavigator.areAllParentsLast(item, items);
                        var colIdx = this.owner.hierarchyNavigator.getLevel(item);
                        return cell.position.column.index = colIdx, cell.position.column.isFirst = 0 === colIdx, 
                        cell.position.column.isLast = isLeaf, cell.enableHorizontalResize(!1, this._columnLayoutManager), 
                        cell;
                    }, TablixLayoutManager.prototype.getOrCreateCornerCell = function(item, rowLevel, columnLevel) {
                        var row = this._grid.getOrCreateRow(columnLevel), column = this._grid.getOrCreateColumn(rowLevel), columnDepth = this._columnLayoutManager.dimension.getDepth(), isLeaf = columnLevel === columnDepth - 1, cell = row.getOrCreateCornerCell(column), rowIdx = columnLevel;
                        cell.position.row.index = rowIdx, cell.position.row.isFirst = 0 === rowIdx, cell.position.row.isLast = isLeaf;
                        var colIdx = rowLevel;
                        return cell.position.column.index = colIdx, cell.position.column.isFirst = 0 === colIdx, 
                        cell.position.column.isLast = colIdx === this._rowLayoutManager.dimension.getDepth() - 1, 
                        this.enableCellHorizontalResize(isLeaf, cell), cell;
                    }, TablixLayoutManager.prototype.getOrCreateBodyCell = function(cellItem, rowItem, rowItems, rowIndex, columnIndex) {
                        var scrollable, row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset), column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        scrollable = 0 === row._realizedBodyCells.length && 0 !== this._owner.columnDimension.getFractionScrollOffset() ? !0 : this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
                        var cell = row.getOrCreateBodyCell(column, scrollable);
                        return cell.position = cellItem.position, cell.enableHorizontalResize(!1, this._columnLayoutManager), 
                        cell;
                    }, TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function(cellItem, columnIndex) {
                        var scrollable, row = this._grid.getOrCreateFootersRow(), column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        scrollable = 0 === row._realizedBodyCells.length && 0 !== this._owner.columnDimension.getFractionScrollOffset();
                        var cell = row.getOrCreateFooterBodyCell(column, scrollable);
                        return cell.position = cellItem.position, cell.enableHorizontalResize(!1, this._columnLayoutManager), 
                        cell;
                    }, TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function(item, items) {
                        var row = this._grid.getOrCreateFootersRow(), column = this._grid.getOrCreateColumn(0), cell = row.getOrCreateFooterRowHeader(column);
                        return cell.position = void 0, cell.enableHorizontalResize(!1, this._columnLayoutManager), 
                        cell;
                    }, TablixLayoutManager.prototype.getVisibleWidth = function() {
                        return -1;
                    }, TablixLayoutManager.prototype.getVisibleHeight = function() {
                        return -1;
                    }, TablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {}, 
                    TablixLayoutManager.prototype.updateViewport = function(viewport) {}, TablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                        return -1;
                    }, TablixLayoutManager.prototype.getCellWidth = function(cell) {
                        return -1;
                    }, TablixLayoutManager.prototype.getContentWidth = function(cell) {
                        return -1;
                    }, TablixLayoutManager.prototype.adjustContentSize = function(hasImage) {}, TablixLayoutManager.prototype.alignRowHeaderCells = function(item, currentRow) {
                        var index = currentRow.getRowHeaderLeafIndex();
                        if (-1 !== index) {
                            var rowDimension = this._owner.rowDimension, leaf = rowDimension.getFirstVisibleChildLeaf(item);
                            this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item) && currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
                        }
                    }, Object.defineProperty(TablixLayoutManager.prototype, "grid", {
                        get: function() {
                            return this._grid;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
                        get: function() {
                            return this._rowLayoutManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
                        get: function() {
                            return this._columnLayoutManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                        return !1;
                    }, TablixLayoutManager.prototype.onStartRenderingSession = function(scrollingDimension, parentElement, clear) {
                        if (this.showEmptySpaceHeader()) {
                            var cell = this._grid.emptySpaceHeaderCell;
                            cell && this._binder.unbindEmptySpaceHeaderCell(cell), cell = this._grid.emptySpaceFooterCell, 
                            cell && this._binder.unbindEmptySpaceFooterCell(cell), this._grid.HideEmptySpaceCells();
                        }
                        this._scrollingDimension = scrollingDimension, this._scrollingDimension && this._scrollingDimension.layoutManager.startScrollingSession(), 
                        this._rowLayoutManager.onStartRenderingSession(), this._columnLayoutManager.onStartRenderingSession(), 
                        this._grid.onStartRenderingSession(clear);
                        var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
                        measureEnabled && this.measureSampleText(parentElement);
                    }, TablixLayoutManager.prototype.onEndRenderingSession = function() {
                        if (this._rowLayoutManager.onEndRenderingSession(), this._columnLayoutManager.onEndRenderingSession(), 
                        this._scrollingDimension && this._scrollingDimension.layoutManager.endScrollingSession(), 
                        this._scrollingDimension = null, this.showEmptySpaceHeader()) {
                            var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
                            if (emptySpace > 0) {
                                this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
                                var cell = this._grid.emptySpaceHeaderCell;
                                cell && this._binder.bindEmptySpaceHeaderCell(cell), cell = this._grid.emptySpaceFooterCell, 
                                cell && this._binder.bindEmptySpaceFooterCell(cell);
                            }
                        }
                    }, TablixLayoutManager.prototype.onStartRenderingIteration = function(clear) {
                        this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight()), 
                        this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth()), 
                        this._grid.onStartRenderingIteration();
                    }, TablixLayoutManager.prototype.onEndRenderingIteration = function() {
                        return this._grid.onEndRenderingIteration(), this._columnLayoutManager.calculateSizes(), 
                        this._rowLayoutManager.calculateSizes(), this._columnLayoutManager.fixSizes(), this._rowLayoutManager.fixSizes(), 
                        this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns), this._columnLayoutManager.applyScrolling(), 
                        this._rowLayoutManager.applyScrolling(), this._columnLayoutManager.onEndRenderingIteration(), 
                        this._rowLayoutManager.onEndRenderingIteration(), this._columnLayoutManager.done && this._rowLayoutManager.done;
                    }, TablixLayoutManager.prototype.onCornerCellRealized = function(item, cell) {
                        var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item), rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
                        columnLeaf && cell._column.OnLeafRealized(this._owner.hierarchyNavigator), this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf), 
                        this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
                    }, TablixLayoutManager.prototype.onRowHeaderRealized = function(item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator, leaf = hierarchyNavigator.isLeaf(item), tablixCell = cell;
                        tablixCell.colSpan > 1 && tablixCell.setContentWidth(-1), this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
                    }, TablixLayoutManager.prototype.onRowHeaderFooterRealized = function(item, cell) {}, 
                    TablixLayoutManager.prototype.onColumnHeaderRealized = function(item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator, leaf = hierarchyNavigator.isLeaf(item);
                        leaf && cell._column.OnLeafRealized(this._owner.hierarchyNavigator), this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
                    }, TablixLayoutManager.prototype.onBodyCellRealized = function(item, cell) {}, TablixLayoutManager.prototype.onBodyCellFooterRealized = function(item, cell) {}, 
                    TablixLayoutManager.prototype.setAllowHeaderResize = function(value) {
                        this._allowHeaderResize = value;
                    }, TablixLayoutManager.prototype.enableCellHorizontalResize = function(isLeaf, cell) {
                        var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
                        cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
                    }, TablixLayoutManager.prototype.getEstimatedTextWidth = function(label) {
                        return -1;
                    }, TablixLayoutManager.prototype.measureSampleText = function(parentElement) {}, 
                    TablixLayoutManager;
                }();
                internal.TablixLayoutManager = TablixLayoutManager;
                var DashboardTablixLayoutManager = function(_super) {
                    function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
                        var dashboardColumnLayoutManager = new DashboardColumnLayoutManager(null, grid, columnRealizationManager), dashboardRowLayoutManager = new DashboardRowLayoutManager(null, grid, rowRealizationManager);
                        _super.call(this, binder, grid, dashboardColumnLayoutManager, dashboardRowLayoutManager), 
                        dashboardColumnLayoutManager.owner = this, dashboardRowLayoutManager.owner = this, 
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    return __extends(DashboardTablixLayoutManager, _super), DashboardTablixLayoutManager.createLayoutManager = function(binder) {
                        var sizeComputationManager = new SizeComputationManager();
                        return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    }, DashboardTablixLayoutManager.prototype.getTablixClassName = function() {
                        return "tablixDashboard";
                    }, DashboardTablixLayoutManager.prototype.getLayoutKind = function() {
                        return 1;
                    }, DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                        return !1;
                    }, DashboardTablixLayoutManager.prototype.measureSampleText = function(parentElement) {
                        var textProperties = powerbi.TextMeasurementService.getSvgMeasurementProperties(parentElement);
                        this._characterHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties), 
                        this._sizeComputationManager.updateRowHeight(this._characterHeight);
                        var actualTextSize = PixelConverter.toPoint(parseFloat(textProperties.fontSize)), scalingFactor = actualTextSize / controls.TablixDefaultTextSize;
                        this._sizeComputationManager.updateScalingFactor(powerbi.Double.toIncrement(scalingFactor, .05));
                    }, DashboardTablixLayoutManager.prototype.getVisibleWidth = function() {
                        return this._sizeComputationManager.visibleWidth;
                    }, DashboardTablixLayoutManager.prototype.getVisibleHeight = function() {
                        return this._sizeComputationManager.visibleHeight;
                    }, DashboardTablixLayoutManager.prototype.getCellWidth = function(cell) {
                        return this._sizeComputationManager.cellWidth;
                    }, DashboardTablixLayoutManager.prototype.getContentWidth = function(cell) {
                        return this._sizeComputationManager.contentWidth;
                    }, DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function(label) {
                        return this._sizeComputationManager.contentWidth;
                    }, DashboardTablixLayoutManager.prototype.adjustContentSize = function(hasImage) {
                        this._sizeComputationManager.hasImageContent = hasImage;
                    }, DashboardTablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {
                        var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0, columnInstances = columnDimension ? columnDimension.getItemsCount() : 0, totalColumnCount = rowDimensionDepth + columnInstances;
                        this.binder.hasRowGroups() || totalColumnCount--, this._sizeComputationManager.updateColumnCount(totalColumnCount);
                    }, DashboardTablixLayoutManager.prototype.updateViewport = function(viewport) {
                        this._sizeComputationManager.updateViewport(viewport);
                    }, DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                        return this._characterHeight;
                    }, DashboardTablixLayoutManager;
                }(TablixLayoutManager);
                internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
                var CanvasTablixLayoutManager = function(_super) {
                    function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
                        var canvasColumnLayoutManager = new CanvasColumnLayoutManager(null, grid, columnRealizationManager), canvasRowLayoutManager = new CanvasRowLayoutManager(null, grid, rowRealizationManager);
                        _super.call(this, binder, grid, canvasColumnLayoutManager, canvasRowLayoutManager), 
                        canvasColumnLayoutManager.owner = this, canvasRowLayoutManager.owner = this;
                    }
                    return __extends(CanvasTablixLayoutManager, _super), CanvasTablixLayoutManager.createLayoutManager = function(binder, columnWidthManager) {
                        return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter(columnWidthManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    }, CanvasTablixLayoutManager.prototype.getTablixClassName = function() {
                        return "tablixCanvas";
                    }, CanvasTablixLayoutManager.prototype.getLayoutKind = function() {
                        return 0;
                    }, CanvasTablixLayoutManager.prototype.measureSampleText = function(parentElement) {
                        var textDiv = controls.internal.TablixUtils.createDiv();
                        textDiv.style.cssFloat = "left", textDiv.style.whiteSpace = "nowrap", textDiv.style.overflow = "hidden", 
                        textDiv.style.lineHeight = "normal", parentElement.appendChild(textDiv);
                        var textNode = document.createTextNode("a");
                        textDiv.appendChild(textNode), this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv), 
                        this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv), textDiv.removeChild(textNode), 
                        parentElement.removeChild(textDiv);
                    }, CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                        return !this._columnLayoutManager.fillProportionally;
                    }, CanvasTablixLayoutManager.prototype.getVisibleWidth = function() {
                        return this._columnLayoutManager.measureEnabled ? this._owner.autoSizeWidth && this._owner.maxWidth ? this._owner.maxWidth : controls.HTMLElementUtils.getElementWidth(this._container) : -1;
                    }, CanvasTablixLayoutManager.prototype.getVisibleHeight = function() {
                        return this._rowLayoutManager.measureEnabled ? this._owner.autoSizeHeight && this._owner.maxHeight ? this._owner.maxHeight : controls.HTMLElementUtils.getElementHeight(this._container) : -1;
                    }, CanvasTablixLayoutManager.prototype.getCellWidth = function(cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    }, CanvasTablixLayoutManager.prototype.getContentWidth = function(cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                    }, CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function(text) {
                        return text ? text.length * this.characterWidth : 0;
                    }, CanvasTablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {}, 
                    CanvasTablixLayoutManager.prototype.updateViewport = function(viewport) {}, CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                        return this.characterHeight;
                    }, CanvasTablixLayoutManager;
                }(TablixLayoutManager);
                internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
            }(internal = controls.internal || (controls.internal = {}));
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var HTMLElementUtils;
            !function(HTMLElementUtils) {
                function clearChildren(element) {
                    if (element) for (;element.hasChildNodes(); ) element.removeChild(element.firstChild);
                }
                function setElementTop(element, top) {
                    element.style.top = top + "px";
                }
                function setElementLeft(element, left) {
                    element.style.left = left + "px";
                }
                function setElementHeight(element, height) {
                    HTMLElementUtils.isAutoSize(height) ? element.style.height = "" : element.style.height = height + "px";
                }
                function setElementWidth(element, width) {
                    HTMLElementUtils.isAutoSize(width) ? element.style.width = "" : element.style.width = width + "px";
                }
                function getElementWidth(element) {
                    return element.offsetWidth;
                }
                function getElementHeight(element) {
                    return element.offsetHeight;
                }
                function isAutoSize(size) {
                    return -1 === size;
                }
                function getAccumulatedScale(element) {
                    for (var scale = 1; element; ) scale *= HTMLElementUtils.getScale(element), element = element.parentElement;
                    return scale;
                }
                function getScale(element) {
                    element = $(element);
                    var str = element.css("-webkit-transform") || element.css("-moz-transform") || element.css("-ms-transform") || element.css("-o-transform") || element.css("transform");
                    return str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) || str.match(/\d+/) && Number(str.match(/\d+/)[0])) || 1;
                }
                HTMLElementUtils.clearChildren = clearChildren, HTMLElementUtils.setElementTop = setElementTop, 
                HTMLElementUtils.setElementLeft = setElementLeft, HTMLElementUtils.setElementHeight = setElementHeight, 
                HTMLElementUtils.setElementWidth = setElementWidth, HTMLElementUtils.getElementWidth = getElementWidth, 
                HTMLElementUtils.getElementHeight = getElementHeight, HTMLElementUtils.isAutoSize = isAutoSize, 
                HTMLElementUtils.getAccumulatedScale = getAccumulatedScale, HTMLElementUtils.getScale = getScale;
            }(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var internal;
            !function(internal) {
                var TablixObjects, DomFactory = InJs.DomFactory, DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
                !function(TablixObjects) {
                    function getMetadadataObjects(dataview) {
                        return dataview && dataview.metadata ? dataview.metadata.objects : null;
                    }
                    function enumerateObjectInstances(options, enumeration, dataView, isFormattingPropertiesEnabled, isConditionalFormattingEnabled, tablixType) {
                        var objects = getMetadadataObjects(dataView), totalsShown = !0;
                        switch (totalsShown = tablixType === controls.TablixType.Table ? shouldShowTableTotalsOption(dataView) && shouldShowTableTotals(objects) : shouldShowColumnSubtotalsOption(dataView) && shouldShowColumnSubtotals(objects) || shouldShowRowSubtotalsOption(dataView) && shouldShowRowSubtotals(objects), 
                        options.objectName) {
                          case TablixObjects.ObjectGeneral:
                            enumerateGeneralOptions(enumeration, objects, tablixType, dataView);
                            break;

                          case TablixObjects.ObjectGrid:
                            isFormattingPropertiesEnabled && enumerateGridOptions(enumeration, objects, tablixType);
                            break;

                          case TablixObjects.ObjectColumnHeaders:
                            isFormattingPropertiesEnabled && enumerateColumnHeadersOptions(enumeration, objects);
                            break;

                          case TablixObjects.ObjectRowHeaders:
                            isFormattingPropertiesEnabled && enumerateRowHeadersOptions(enumeration, objects);
                            break;

                          case TablixObjects.ObjectValues:
                            isFormattingPropertiesEnabled && (enumerateValuesOptions(enumeration, objects, tablixType), 
                            tablixType === controls.TablixType.Table && isConditionalFormattingEnabled && enumerateValuesOptionConditionalFormat(enumeration, objects));
                            break;

                          case TablixObjects.ObjectTotal:
                            isFormattingPropertiesEnabled && totalsShown && enumerateTotalOptions(enumeration, objects);
                            break;

                          case TablixObjects.ObjectSubTotals:
                            isFormattingPropertiesEnabled && totalsShown && enumerateSubTotalsOptions(enumeration, objects);
                        }
                    }
                    function enumerateGeneralOptions(enumeration, objects, tablixType, dataView) {
                        var visualObjectinstance = {
                            selector: null,
                            objectName: TablixObjects.ObjectGeneral,
                            properties: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects)
                            }
                        }, properties = visualObjectinstance.properties;
                        switch (tablixType) {
                          case controls.TablixType.Table:
                            shouldShowTableTotalsOption(dataView) && (properties[TablixObjects.PropGeneralTableTotals.propertyName] = shouldShowTableTotals(objects));
                            break;

                          case controls.TablixType.Matrix:
                            shouldShowRowSubtotalsOption(dataView) && (properties[TablixObjects.PropGeneralMatrixRowSubtotals.propertyName] = shouldShowRowSubtotals(objects)), 
                            shouldShowColumnSubtotalsOption(dataView) && (properties[TablixObjects.PropGeneralMatrixColumnSubtotals.propertyName] = shouldShowColumnSubtotals(objects));
                        }
                        enumeration.pushInstance(visualObjectinstance);
                    }
                    function enumerateGridOptions(enumeration, objects, tablixType) {
                        var visualObjectinstance = {
                            selector: null,
                            objectName: TablixObjects.ObjectGeneral,
                            properties: {}
                        }, properties = visualObjectinstance.properties, verticalGridEnabled = TablixObjects.PropGridVertical.getValue(objects);
                        properties[TablixObjects.PropGridVertical.propertyName] = verticalGridEnabled, verticalGridEnabled && (properties[TablixObjects.PropGridVerticalColor.propertyName] = TablixObjects.PropGridVerticalColor.getValue(objects), 
                        properties[TablixObjects.PropGridVerticalWeight.propertyName] = TablixObjects.PropGridVerticalWeight.getValue(objects));
                        var horizontalGridEnabled = (tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).getValue(objects);
                        properties[(tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).propertyName] = horizontalGridEnabled, 
                        horizontalGridEnabled && (properties[TablixObjects.PropGridHorizontalColor.propertyName] = TablixObjects.PropGridHorizontalColor.getValue(objects), 
                        properties[TablixObjects.PropGridHorizontalWeight.propertyName] = TablixObjects.PropGridHorizontalWeight.getValue(objects)), 
                        properties[TablixObjects.PropGridRowPadding.propertyName] = TablixObjects.PropGridRowPadding.getValue(objects), 
                        properties[TablixObjects.PropGridOutlineColor.propertyName] = TablixObjects.PropGridOutlineColor.getValue(objects), 
                        properties[TablixObjects.PropGridOutlineWeight.propertyName] = TablixObjects.PropGridOutlineWeight.getValue(objects), 
                        enumeration.pushInstance(visualObjectinstance);
                    }
                    function enumerateColumnHeadersOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectColumnHeaders,
                            properties: {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects)
                            }
                        });
                    }
                    function enumerateRowHeadersOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectRowHeaders,
                            properties: {
                                fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                                backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                                outline: TablixObjects.PropRowsOutline.getValue(objects)
                            }
                        });
                    }
                    function enumerateValuesOptions(enumeration, objects, tablixType) {
                        var instance = {
                            selector: null,
                            objectName: TablixObjects.ObjectValues,
                            properties: {
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                                outline: TablixObjects.PropValuesOutline.getValue(objects)
                            }
                        };
                        tablixType === controls.TablixType.Table && (instance.properties[TablixObjects.PropValuesUrlIconProp.propertyName] = TablixObjects.PropValuesUrlIconProp.getValue(objects)), 
                        enumeration.pushInstance(instance);
                    }
                    function enumerateValuesOptionConditionalFormat(enumeration, objects) {
                        var instance = {
                            selector: null,
                            objectName: TablixObjects.ObjectValues,
                            properties: {
                                backgroundColorConditional: TablixObjects.PropValuesBackColorConditionalFormatting.getValue(objects)
                            }
                        };
                        enumeration.pushInstance(instance);
                    }
                    function enumerateTotalOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectTotal,
                            properties: {
                                fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                                backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                                outline: TablixObjects.PropTotalOutline.getValue(objects)
                            }
                        });
                    }
                    function enumerateSubTotalsOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectSubTotals,
                            properties: {
                                fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                                backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects)
                            }
                        });
                    }
                    function getTableObjects(dataView, isFormattingEnabled, isConditionalFormattingEnabled) {
                        var objects = getMetadadataObjects(dataView), formattingProperties = {
                            isFormattingEnabled: isFormattingEnabled,
                            isConditionalFormattingEnabled: isConditionalFormattingEnabled,
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                totals: shouldShowTableTotals(objects)
                            }
                        };
                        return isFormattingEnabled && (formattingProperties.grid = {
                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                            gridHorizontal: TablixObjects.PropGridHorizontalTable.getValue(objects),
                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects, !1)
                        }, formattingProperties.columnHeaders = {
                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects, !1),
                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects, !1),
                            outline: TablixObjects.PropColumnsOutline.getValue(objects)
                        }, formattingProperties.values = {
                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects, !1),
                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects, !1),
                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects, !1),
                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects, !1),
                            outline: TablixObjects.PropValuesOutline.getValue(objects),
                            urlIcon: TablixObjects.PropValuesUrlIconProp.getValue(objects)
                        }, isConditionalFormattingEnabled && (formattingProperties.values.conditionalFormatting = TablixObjects.PropValuesBackColorConditionalFormatting.getValue(objects)), 
                        formattingProperties.total = {
                            fontColor: TablixObjects.PropTotalFontColor.getValue(objects, !1),
                            backColor: TablixObjects.PropTotalBackColor.getValue(objects, !1),
                            outline: TablixObjects.PropTotalOutline.getValue(objects)
                        }), formattingProperties;
                    }
                    function getTableObjectConditionalFormatEnabled(dataView) {
                        return TablixObjects.PropValuesBackColorConditionalFormatting.getValue(getMetadadataObjects(dataView));
                    }
                    function getMatrixObjects(dataView, isFormattingEnabled) {
                        var objects = getMetadadataObjects(dataView), formattingProperties = {
                            isFormattingEnabled: isFormattingEnabled,
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                rowSubtotals: shouldShowRowSubtotals(objects),
                                columnSubtotals: shouldShowColumnSubtotals(objects)
                            }
                        };
                        return isFormattingEnabled && (formattingProperties.grid = {
                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                            gridHorizontal: TablixObjects.PropGridHorizontalMatrix.getValue(objects),
                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects, !1)
                        }, formattingProperties.columnHeaders = {
                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects, !1),
                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects, !1),
                            outline: TablixObjects.PropColumnsOutline.getValue(objects)
                        }, formattingProperties.rowHeaders = {
                            fontColor: TablixObjects.PropRowsFontColor.getValue(objects, !1),
                            backColor: TablixObjects.PropRowsBackColor.getValue(objects, !1),
                            outline: TablixObjects.PropRowsOutline.getValue(objects)
                        }, formattingProperties.values = {
                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects, !1),
                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects, !1),
                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects, !1),
                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects, !1),
                            outline: TablixObjects.PropValuesOutline.getValue(objects)
                        }, formattingProperties.subtotals = {
                            fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects, !1),
                            backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects, !1),
                            outline: TablixObjects.PropSubTotalsOutline.getValue(objects)
                        }), formattingProperties;
                    }
                    function generateTablixDefaultObjects(tablixType) {
                        return {
                            general: [ {
                                selector: null,
                                properties: {
                                    textSize: DataViewObjectDefinitions.encodePropertyValue(12, {
                                        numeric: !0
                                    }),
                                    totals: DataViewObjectDefinitions.encodePropertyValue(!1, {
                                        bool: !0
                                    })
                                }
                            } ]
                        };
                    }
                    function getTextSizeInPx(textSize) {
                        return jsCommon.PixelConverter.fromPoint(textSize);
                    }
                    function shouldShowTableTotals(objects) {
                        return TablixObjects.PropGeneralTableTotals.getValue(objects);
                    }
                    function shouldShowTableTotalsOption(dataView) {
                        if (dataView && dataView.table && !_.isEmpty(dataView.table.columns)) {
                            var columns = dataView.table.columns;
                            if (_.some(columns, function(column) {
                                return column.discourageAggregationAcrossGroups;
                            })) return !1;
                        }
                        return !0;
                    }
                    function shouldShowRowSubtotals(objects) {
                        return TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects);
                    }
                    function shouldShowRowSubtotalsOption(dataView) {
                        return !(dataView && dataView.matrix && dataView.matrix.rows && isDiscourageAggregationAcrossGroups(dataView.matrix.rows.levels));
                    }
                    function shouldShowColumnSubtotals(objects) {
                        return TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects);
                    }
                    function shouldShowColumnSubtotalsOption(dataView) {
                        return !(dataView && dataView.matrix && dataView.matrix.columns && isDiscourageAggregationAcrossGroups(dataView.matrix.columns.levels));
                    }
                    function isDiscourageAggregationAcrossGroups(levels) {
                        var lastLevel = _.last(levels);
                        return lastLevel && _.some(lastLevel.sources, function(source) {
                            return source.discourageAggregationAcrossGroups;
                        });
                    }
                    TablixObjects.ObjectGeneral = "general", TablixObjects.ObjectGrid = "grid", TablixObjects.ObjectColumnHeaders = "columnHeaders", 
                    TablixObjects.ObjectRowHeaders = "rowHeaders", TablixObjects.ObjectValues = "values", 
                    TablixObjects.ObjectTotal = "total", TablixObjects.ObjectSubTotals = "subTotals";
                    var TablixProperty = function() {
                        function TablixProperty(objectName, propertyName, defaultValue, getterFuntion) {
                            this.objectName = objectName, this.propertyName = propertyName, this.defaultValue = defaultValue, 
                            this.getterFuntion = getterFuntion;
                        }
                        return TablixProperty.prototype.getPropertyID = function() {
                            return {
                                objectName: this.objectName,
                                propertyName: this.propertyName
                            };
                        }, TablixProperty.prototype.getValue = function(objects, useDefault) {
                            return useDefault === !1 ? this.getterFuntion(objects, this.getPropertyID()) : this.getterFuntion(objects, this.getPropertyID(), this.defaultValue);
                        }, TablixProperty;
                    }();
                    TablixObjects.TablixProperty = TablixProperty, TablixObjects.PropColumnFormatString = new TablixProperty(TablixObjects.ObjectGeneral, "formatString", void 0, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGeneralAutoSizeColumns = new TablixProperty(TablixObjects.ObjectGeneral, "autoSizeColumnWidth", !0, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGeneralTextSize = new TablixProperty(TablixObjects.ObjectGeneral, "textSize", 8, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGeneralTableTotals = new TablixProperty(TablixObjects.ObjectGeneral, "totals", !0, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGeneralMatrixRowSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, "rowSubtotals", !0, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGeneralMatrixColumnSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, "columnSubtotals", !0, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGridVertical = new TablixProperty(TablixObjects.ObjectGrid, "gridVertical", !1, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGridVerticalColor = new TablixProperty(TablixObjects.ObjectGrid, "gridVerticalColor", "#E8E8E8", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropGridVerticalWeight = new TablixProperty(TablixObjects.ObjectGrid, "gridVerticalWeight", 1, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGridHorizontalTable = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontal", !0, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGridHorizontalMatrix = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontal", !1, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGridHorizontalColor = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontalColor", "#E8E8E8", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropGridHorizontalWeight = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontalWeight", 1, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGridRowPadding = new TablixProperty(TablixObjects.ObjectGrid, "rowPadding", 0, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropGridOutlineColor = new TablixProperty(TablixObjects.ObjectGrid, "outlineColor", "#E8E8E8", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropGridOutlineWeight = new TablixProperty(TablixObjects.ObjectGrid, "outlineWeight", 2, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropColumnsFontColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, "fontColor", "#666", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropColumnsBackColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropColumnsOutline = new TablixProperty(TablixObjects.ObjectColumnHeaders, "outline", "BottomOnly", powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropRowsFontColor = new TablixProperty(TablixObjects.ObjectRowHeaders, "fontColor", "#666", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropRowsBackColor = new TablixProperty(TablixObjects.ObjectRowHeaders, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropRowsOutline = new TablixProperty(TablixObjects.ObjectRowHeaders, "outline", "RightOnly", powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropValuesBackColorConditionalFormatting = new TablixProperty(TablixObjects.ObjectValues, "backgroundColorConditional", !1, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropValuesFontColorPrimary = new TablixProperty(TablixObjects.ObjectValues, "fontColorPrimary", "#666", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropValuesBackColorPrimary = new TablixProperty(TablixObjects.ObjectValues, "backColorPrimary", void 0, powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropValuesFontColorSecondary = new TablixProperty(TablixObjects.ObjectValues, "fontColorSecondary", "#666", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropValuesBackColorSecondary = new TablixProperty(TablixObjects.ObjectValues, "backColorSecondary", void 0, powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropValuesOutline = new TablixProperty(TablixObjects.ObjectValues, "outline", "None", powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropValuesUrlIconProp = new TablixProperty(TablixObjects.ObjectValues, "urlIcon", !1, powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropTotalFontColor = new TablixProperty(TablixObjects.ObjectTotal, "fontColor", "#666", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropTotalBackColor = new TablixProperty(TablixObjects.ObjectTotal, "backColor", "#FFF", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropTotalOutline = new TablixProperty(TablixObjects.ObjectTotal, "outline", "TopOnly", powerbi.DataViewObjects.getValue), 
                    TablixObjects.PropSubTotalsFontColor = new TablixProperty(TablixObjects.ObjectSubTotals, "fontColor", "#666", powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropSubTotalsBackColor = new TablixProperty(TablixObjects.ObjectSubTotals, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                    TablixObjects.PropSubTotalsOutline = new TablixProperty(TablixObjects.ObjectSubTotals, "outline", "TopOnly", powerbi.DataViewObjects.getValue), 
                    TablixObjects.getMetadadataObjects = getMetadadataObjects, TablixObjects.enumerateObjectInstances = enumerateObjectInstances, 
                    TablixObjects.enumerateGeneralOptions = enumerateGeneralOptions, TablixObjects.enumerateGridOptions = enumerateGridOptions, 
                    TablixObjects.enumerateColumnHeadersOptions = enumerateColumnHeadersOptions, TablixObjects.enumerateRowHeadersOptions = enumerateRowHeadersOptions, 
                    TablixObjects.enumerateValuesOptions = enumerateValuesOptions, TablixObjects.enumerateValuesOptionConditionalFormat = enumerateValuesOptionConditionalFormat, 
                    TablixObjects.enumerateTotalOptions = enumerateTotalOptions, TablixObjects.enumerateSubTotalsOptions = enumerateSubTotalsOptions, 
                    TablixObjects.getTableObjects = getTableObjects, TablixObjects.getTableObjectConditionalFormatEnabled = getTableObjectConditionalFormatEnabled, 
                    TablixObjects.getMatrixObjects = getMatrixObjects, TablixObjects.generateTablixDefaultObjects = generateTablixDefaultObjects, 
                    TablixObjects.getTextSizeInPx = getTextSizeInPx, TablixObjects.shouldShowTableTotals = shouldShowTableTotals, 
                    TablixObjects.shouldShowRowSubtotals = shouldShowRowSubtotals, TablixObjects.shouldShowColumnSubtotals = shouldShowColumnSubtotals, 
                    TablixObjects.shouldShowColumnSubtotalsOption = shouldShowColumnSubtotalsOption, 
                    TablixObjects.isDiscourageAggregationAcrossGroups = isDiscourageAggregationAcrossGroups;
                }(TablixObjects = internal.TablixObjects || (internal.TablixObjects = {}));
                var TablixUtils;
                !function(TablixUtils) {
                    function createTable() {
                        return document.createElement("table");
                    }
                    function createDiv() {
                        var div = document.createElement("div");
                        return div.className = "tablixDiv", div;
                    }
                    function resetCellCssClass(cell) {
                        cell.extension.contentElement.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentElement, 
                        cell.extension.contentHost.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentHost;
                    }
                    function addCellCssClass(cell, style) {
                        cell.extension.contentHost.className += " " + style;
                    }
                    function clearCellStyle(cell) {
                        cell.extension.contentHost.className = "", cell.extension.contentHost.style.cssText = "";
                    }
                    function clearCellTextAndTooltip(cell) {
                        cell.extension.contentHost.textContent = "", cell.extension.contentHost.removeAttribute("title"), 
                        controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
                    }
                    function setCellTextAndTooltip(cell, text) {
                        var val = visuals.TextUtil.replaceSpaceWithNBSP(text);
                        cell.extension.contentHost.textContent = val, cell.extension.contentHost.title = val;
                    }
                    function isValidSortClick(e) {
                        var colHeader = e.target, x = e.offsetX;
                        return x >= 0 && x < colHeader.offsetWidth - internal.TablixResizer.resizeHandleSize;
                    }
                    function appendATagToBodyCell(value, cell, urlIcon) {
                        var element = cell.extension.contentHost, atag = null;
                        0 === element.childElementCount ? (atag = document.createElement("a"), element.appendChild(atag)) : atag = element.children[0], 
                        atag.href = value, atag.target = "_blank", atag.title = value, urlIcon === !0 ? (atag.className = TablixUtils.CssClassValueURLIcon, 
                        element.className = TablixUtils.CssClassValueURLIconContainer) : atag.innerText = value;
                    }
                    function appendImgTagToBodyCell(value, cell) {
                        var imgTag, element = cell.extension.contentHost, contentElement = element.parentElement;
                        0 === element.childElementCount ? (imgTag = document.createElement("img"), element.appendChild(imgTag)) : imgTag = element.children[0], 
                        contentElement.style.paddingBottom = "3px", contentElement.style.paddingTop = "3px", 
                        imgTag.src = value, imgTag.style.maxHeight = "75px", imgTag.style.maxWidth = "100px", 
                        imgTag.style.height = "100%";
                    }
                    function createKpiDom(kpi, kpiValue) {
                        var className = visuals.KpiUtil.getClassForKpi(kpi, kpiValue) || "";
                        return DomFactory.div().addClass(className).css({
                            display: "inline-block",
                            "vertical-align": "bottom",
                            margin: "0 1px 1px 0"
                        });
                    }
                    function isValidStatusGraphic(kpi, kpiValue) {
                        return kpi && void 0 !== kpiValue ? !!visuals.KpiUtil.getClassForKpi(kpi, kpiValue) : !1;
                    }
                    function getCustomSortEventArgs(queryName, sortDirection) {
                        var sortDescriptors = [ {
                            queryName: queryName,
                            sortDirection: sortDirection
                        } ];
                        return {
                            sortDescriptors: sortDescriptors
                        };
                    }
                    function reverseSort(sortDirection) {
                        return 2 === sortDirection ? 1 : 2;
                    }
                    function createColumnHeaderWithSortIcon(item, cell) {
                        var colHeaderContainer = TablixUtils.createDiv();
                        if (item.sort) {
                            var itemSort = item.sort;
                            colHeaderContainer.appendChild(createSortIcon(itemSort, !0)), colHeaderContainer.appendChild(createSortIcon(reverseSort(itemSort), !1));
                        } else colHeaderContainer.appendChild(createSortIcon(2, !1));
                        var colHeaderTitle = TablixUtils.createDiv(), title = item ? visuals.TextUtil.replaceSpaceWithNBSP(item.displayName) : "";
                        colHeaderTitle.textContent = title, colHeaderContainer.appendChild(colHeaderTitle), 
                        cell.extension.contentHost.title = title, cell.extension.contentHost.appendChild(colHeaderContainer);
                    }
                    function createSortIcon(sort, isSorted) {
                        var imgSort = document.createElement("i");
                        return imgSort.className = SortIconContainerClassName + " " + (isSorted ? "sorted" : "future") + " " + (1 === sort ? "powervisuals-glyph caret-up" : "powervisuals-glyph caret-down"), 
                        imgSort;
                    }
                    function checkSortIconExists(cell) {
                        for (var i = 0, len = cell.extension.contentElement.childElementCount; len > i; i++) {
                            var element = cell.extension.contentElement.children.item(i);
                            if (element.classList.contains(SortIconContainerClassName)) return !0;
                        }
                        return !1;
                    }
                    function removeSortIcons(cell) {
                        checkSortIconExists(cell) && $(cell.extension.contentElement).find("." + SortIconContainerClassName).remove();
                    }
                    TablixUtils.CssClassTablixDiv = "tablixDiv", TablixUtils.CssClassContentElement = "tablixCellContentElement", 
                    TablixUtils.CssClassContentHost = "tablixCellContentHost", TablixUtils.CssClassTablixHeader = "tablixHeader", 
                    TablixUtils.CssClassTablixColumnHeaderLeaf = "tablixColumnHeaderLeaf", TablixUtils.CssClassTablixValueNumeric = "tablixValueNumeric", 
                    TablixUtils.CssClassTablixValueTotal = "tablixValueTotal", TablixUtils.CssClassValueURLIcon = "powervisuals-glyph url-icon tablixUrlIconGlyph", 
                    TablixUtils.CssClassValueURLIconContainer = "tablixValueUrlIcon", TablixUtils.CssClassMatrixRowHeaderLeaf = "matrixRowHeaderLeaf", 
                    TablixUtils.CssClassMatrixRowHeaderSubTotal = "matrixRowHeaderSubTotal", TablixUtils.CssClassTableFooter = "tableFooterCell", 
                    TablixUtils.CssClassTableBodyCell = "tableBodyCell", TablixUtils.CssClassTableBodyCellBottom = "tableBodyCellBottom", 
                    TablixUtils.StringNonBreakingSpace = "&nbsp;", TablixUtils.UnitOfMeasurement = "px";
                    var SortIconContainerClassName = "tablixSortIconContainer";
                    TablixUtils.CellPaddingLeft = 10, TablixUtils.CellPaddingRight = 5;
                    var EdgeSettings = function() {
                        function EdgeSettings(weight, color, style) {
                            this.applyParams(!0, weight, color, style);
                        }
                        return EdgeSettings.prototype.applyParams = function(shown, weight, color, style) {
                            shown ? (this.weight = weight, this.color = color, this.style = style ? style : "solid") : (this.weight = 0, 
                            this.color = void 0, this.style = void 0);
                        }, EdgeSettings.prototype.getCSS = function() {
                            var css = [];
                            return _.isNumber(this.weight) && (css.push(this.weight + TablixUtils.UnitOfMeasurement), 
                            this.color && css.push(this.color), this.style && css.push(this.style)), css.join(" ");
                        }, EdgeSettings;
                    }();
                    TablixUtils.EdgeSettings = EdgeSettings;
                    var CellStyle = function() {
                        function CellStyle() {
                            this.borders = {}, this.paddings = {};
                        }
                        return CellStyle.prototype.applyStyle = function(cell) {
                            var div = cell.extension.contentHost, style = div.style;
                            style.color = this.fontColor ? this.fontColor : "", style.backgroundColor = this.backColor ? this.backColor : "", 
                            style.borderTop = this.borders.top ? this.borders.top.getCSS() : "", style.borderRight = this.borders.right ? this.borders.right.getCSS() : "", 
                            style.borderBottom = this.borders.bottom ? this.borders.bottom.getCSS() : "", style.borderLeft = this.borders.left ? this.borders.left.getCSS() : "", 
                            style.paddingTop = _.isNumber(this.paddings.top) ? this.paddings.top + TablixUtils.UnitOfMeasurement : "", 
                            style.paddingRight = _.isNumber(this.paddings.right) ? this.paddings.right + TablixUtils.UnitOfMeasurement : "", 
                            style.paddingBottom = _.isNumber(this.paddings.bottom) ? this.paddings.bottom + TablixUtils.UnitOfMeasurement : "", 
                            style.paddingLeft = _.isNumber(this.paddings.left) ? this.paddings.left + TablixUtils.UnitOfMeasurement : "";
                        }, CellStyle.prototype.getExtraTop = function() {
                            var extra = 0;
                            return this.paddings.top && (extra += this.paddings.top), this.borders.top && (extra += this.borders.top.weight), 
                            extra;
                        }, CellStyle.prototype.getExtraBottom = function() {
                            var extra = 0;
                            return this.paddings.bottom && (extra += this.paddings.bottom), this.borders.bottom && (extra += this.borders.bottom.weight), 
                            extra;
                        }, CellStyle;
                    }();
                    TablixUtils.CellStyle = CellStyle;
                    var DimensionPosition = function() {
                        function DimensionPosition() {}
                        return DimensionPosition;
                    }();
                    TablixUtils.DimensionPosition = DimensionPosition;
                    var CellPosition = function() {
                        function CellPosition() {
                            this.row = new DimensionPosition(), this.column = new DimensionPosition();
                        }
                        return CellPosition.prototype.isMatch = function(position) {
                            return this.column.index === position.column.index && this.row.index === position.row.index;
                        }, CellPosition;
                    }();
                    TablixUtils.CellPosition = CellPosition;
                    var TablixVisualCell = function() {
                        function TablixVisualCell(dataPoint, isTotal, columnMetadata, formatter) {
                            this.dataPoint = dataPoint, this.columnMetadata = columnMetadata, this.formatter = formatter, 
                            this.isTotal = isTotal, this.backColorCustomFormatting = void 0, this.position = new TablixUtils.CellPosition();
                        }
                        return Object.defineProperty(TablixVisualCell.prototype, "textContent", {
                            get: function() {
                                return null == this.dataPoint ? "" : this.formatter ? this.formatter(this.dataPoint, this.columnMetadata, TablixObjects.PropColumnFormatString.getPropertyID()) : this.dataPoint;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixVisualCell.prototype, "domContent", {
                            get: function() {
                                return this.columnMetadata && isValidStatusGraphic(this.columnMetadata.kpi, this.textContent) ? createKpiDom(this.columnMetadata.kpi, this.textContent) : void 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixVisualCell.prototype, "isNumeric", {
                            get: function() {
                                return this.columnMetadata ? this.columnMetadata.type.numeric && !this.columnMetadata.kpi : void 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixVisualCell.prototype, "isValidUrl", {
                            get: function() {
                                return this.columnMetadata ? visuals.converterHelper.isWebUrlColumn(this.columnMetadata) && jsCommon.UrlUtils.isValidUrl(this.textContent) : void 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixVisualCell.prototype, "isValidImage", {
                            get: function() {
                                return this.columnMetadata ? visuals.converterHelper.isImageUrlColumn(this.columnMetadata) && jsCommon.UrlUtils.isValidImageUrl(this.textContent) : void 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixVisualCell.prototype.isMatch = function(item) {
                            return this.position.isMatch(item.position);
                        }, TablixVisualCell;
                    }();
                    TablixUtils.TablixVisualCell = TablixVisualCell, TablixUtils.createTable = createTable, 
                    TablixUtils.createDiv = createDiv, TablixUtils.resetCellCssClass = resetCellCssClass, 
                    TablixUtils.addCellCssClass = addCellCssClass, TablixUtils.clearCellStyle = clearCellStyle, 
                    TablixUtils.clearCellTextAndTooltip = clearCellTextAndTooltip, TablixUtils.setCellTextAndTooltip = setCellTextAndTooltip, 
                    TablixUtils.isValidSortClick = isValidSortClick, TablixUtils.appendATagToBodyCell = appendATagToBodyCell, 
                    TablixUtils.appendImgTagToBodyCell = appendImgTagToBodyCell, TablixUtils.createKpiDom = createKpiDom, 
                    TablixUtils.isValidStatusGraphic = isValidStatusGraphic, TablixUtils.getCustomSortEventArgs = getCustomSortEventArgs, 
                    TablixUtils.reverseSort = reverseSort, TablixUtils.createColumnHeaderWithSortIcon = createColumnHeaderWithSortIcon, 
                    TablixUtils.removeSortIcons = removeSortIcons;
                }(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
            }(internal = controls.internal || (controls.internal = {}));
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            controls.TablixDefaultTextSize = jsCommon.TextSizeDefaults.TextSizeMin;
            var TablixControl = function() {
                function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
                    var _this = this;
                    this.scrollBarElementWidth = 9, this.options = options;
                    var isInteractive = options.interactive;
                    this.isTouchEnabled = isInteractive && options.enableTouchSupport, this.mainDiv = controls.internal.TablixUtils.createDiv(), 
                    this.mainDiv.classList.add(TablixControl.TablixTableAreaClassName), this.footerDiv = controls.internal.TablixUtils.createDiv(), 
                    this.footerDiv.classList.add(TablixControl.TablixFooterClassName), this.isTouchEnabled && this.InitializeTouchSupport(), 
                    this.gridDimensions = {}, this.containerElement = controls.internal.TablixUtils.createDiv(), 
                    this.className = layoutManager.getTablixClassName(), this.autoSizeWidth = !1, this.autoSizeHeight = !1, 
                    this.fontSize = options.fontSize, parentDomElement.className = TablixControl.TablixContainerClassName, 
                    parentDomElement.appendChild(this.containerElement), this.containerElement.addEventListener("mousewheel", function(e) {
                        _this.onMouseWheel(e);
                    }), this.containerElement.addEventListener("DOMMouseScroll", function(e) {
                        _this.onFireFoxMouseWheel(e);
                    }), this.containerElement.appendChild(this.mainDiv), this.containerElement.appendChild(this.footerDiv), 
                    this.isTouchEnabled && (this.touchInterpreter.initTouch(this.mainDiv, null, !1), 
                    this.footerTouchInterpreter.initTouch(this.footerDiv, this.mainDiv, !1)), this.controlLayoutManager = layoutManager, 
                    this.controlLayoutManager.initialize(this), this.hierarchyTablixNavigator = hierarchyNavigator, 
                    this.binder = binder, this.columnDim = new controls.TablixColumnDimension(this), 
                    this.rowDim = new controls.TablixRowDimension(this), this.columnDim._otherDimension = this.rowDimension, 
                    this.rowDim._otherDimension = this.columnDimension, this.InitializeScrollbars(), 
                    isInteractive || (this.scrollbarWidth = 0), this.updateHorizontalPosition(), this.updateVerticalPosition(), 
                    this.updateFooterVisibility(), this.lastRenderingArgs = {};
                }
                return TablixControl.prototype.InitializeTouchSupport = function() {
                    this.touchManager = new controls.TouchUtils.TouchManager(), this.touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager), 
                    this.footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager), 
                    this.columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle()), 
                    this.rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle()), 
                    this.bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle()), 
                    this.footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle()), 
                    this.columnTouchDelegate.setHandler(this, this.onTouchEvent), this.rowTouchDelegate.setHandler(this, this.onTouchEvent), 
                    this.bodyTouchDelegate.setHandler(this, this.onTouchEvent), this.footerTouchDelegate.setHandler(this, this.onTouchEvent), 
                    this.touchManager.addTouchRegion(this.columnTouchDelegate.dimension, this.columnTouchDelegate, this.columnTouchDelegate), 
                    this.touchManager.addTouchRegion(this.rowTouchDelegate.dimension, this.rowTouchDelegate, this.rowTouchDelegate), 
                    this.touchManager.addTouchRegion(this.bodyTouchDelegate.dimension, this.bodyTouchDelegate, this.bodyTouchDelegate), 
                    this.touchManager.addTouchRegion(this.footerTouchDelegate.dimension, this.footerTouchDelegate, this.footerTouchDelegate);
                }, TablixControl.prototype.InitializeScrollbars = function() {
                    this.rowDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var rowDimensionScrollbarStyle = this.rowDim.scrollbar.element.style;
                    rowDimensionScrollbarStyle.position = "absolute", rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement, 
                    rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement, this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                    this.rowDim.scrollbar.show(!0), this.columnDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var columnDimensionScrollbarStyle = this.columnDim.scrollbar.element.style;
                    columnDimensionScrollbarStyle.position = "absolute", columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement, 
                    columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement, this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                    this.columnDim.scrollbar.show(!1);
                }, Object.defineProperty(TablixControl.prototype, "container", {
                    get: function() {
                        return this.containerElement;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "contentHost", {
                    get: function() {
                        return this.mainDiv;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "footerHost", {
                    get: function() {
                        return this.footerDiv;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "className", {
                    set: function(value) {
                        this.containerElement.className = value;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
                    get: function() {
                        return this.hierarchyTablixNavigator;
                    },
                    enumerable: !0,
                    configurable: !0
                }), TablixControl.prototype.getBinder = function() {
                    return this.binder;
                }, Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
                    get: function() {
                        return this._autoSizeWidth;
                    },
                    set: function(value) {
                        this._autoSizeWidth = value, value || (this.containerElement.style.minWidth = this.containerElement.style.maxWidth = "none");
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
                    get: function() {
                        return this._autoSizeHeight;
                    },
                    set: function(value) {
                        value || (this.containerElement.style.minHeight = this.containerElement.style.maxHeight = "none");
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "maxWidth", {
                    get: function() {
                        return this.maximumWidth;
                    },
                    set: function(value) {
                        this.maximumWidth = value, this.containerElement.style.maxWidth = this.maximumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "viewport", {
                    get: function() {
                        return this.viewPort;
                    },
                    set: function(value) {
                        this.viewPort = value, this.containerElement.style.width = this.viewPort.width + TablixControl.UnitOfMeasurement, 
                        this.containerElement.style.height = this.viewPort.height + TablixControl.UnitOfMeasurement, 
                        this.rowDim.scrollbar.invalidateArrange(), this.columnDim.scrollbar.invalidateArrange(), 
                        this.controlLayoutManager.updateViewport(this.viewPort);
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "maxHeight", {
                    get: function() {
                        return this.maximumHeight;
                    },
                    set: function(value) {
                        this.maximumHeight = value, this.containerElement.style.maxHeight = this.maximumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "minWidth", {
                    get: function() {
                        return this.minimumWidth;
                    },
                    set: function(value) {
                        this.minimumWidth = value, this.containerElement.style.minWidth = this.minimumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "minHeight", {
                    get: function() {
                        return this.minimumHeight;
                    },
                    set: function(value) {
                        this.minimumHeight = value, this.containerElement.style.minHeight = this.minimumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "fontSize", {
                    set: function(value) {
                        this.textFontSize = value ? value : TablixControl.DefaultFontSize, this.containerElement.style.fontSize = this.textFontSize;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
                    set: function(value) {
                        this.scrollBarElementWidth = value, this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                        this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: !0,
                    configurable: !0
                }), TablixControl.prototype.updateModels = function(resetScrollOffsets, rowModel, columnModel) {
                    this.rowDim.model = rowModel, this.rowDim.modelDepth = this.hierarchyNavigator.getRowHierarchyDepth(), 
                    this.columnDim.model = columnModel, this.columnDim.modelDepth = this.hierarchyNavigator.getColumnHierarchyDepth(), 
                    resetScrollOffsets && (this.rowDim.scrollOffset = 0, this.columnDim.scrollOffset = 0), 
                    this.layoutManager.updateColumnCount(this.rowDim, this.columnDim);
                }, TablixControl.prototype.updateColumnDimensions = function(rowHierarchyWidth, columnHierarchyWidth, count) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.columnCount = count, gridDimensions.rowHierarchyWidth = rowHierarchyWidth, 
                    gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
                }, TablixControl.prototype.updateRowDimensions = function(columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.rowCount = count, gridDimensions.rowHierarchyHeight = rowHierarchyHeight, 
                    gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight, gridDimensions.columnHierarchyHeight = columnHierarchyHeight, 
                    gridDimensions.footerHeight = footerHeight;
                }, TablixControl.prototype.updateTouchDimensions = function() {
                    var gridDimensions = this.gridDimensions;
                    this.columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight), 
                    this.columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth), 
                    this.rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight), 
                    this.rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight), 
                    this.bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight), 
                    this.bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight), 
                    this.footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight), 
                    this.footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                }, TablixControl.prototype.onMouseWheel = function(e) {
                    var dimension = this.determineDimensionToScroll();
                    dimension && dimension.scrollbar.onMouseWheel(e);
                }, TablixControl.prototype.onFireFoxMouseWheel = function(e) {
                    var dimension = this.determineDimensionToScroll();
                    dimension && dimension.scrollbar.onFireFoxMouseWheel(e);
                }, TablixControl.prototype.determineDimensionToScroll = function() {
                    return this.rowDim.scrollbar.visible ? this.rowDim : this.columnDim.scrollbar.visible ? this.columnDim : null;
                }, Object.defineProperty(TablixControl.prototype, "layoutManager", {
                    get: function() {
                        return this.controlLayoutManager;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "columnDimension", {
                    get: function() {
                        return this.columnDim;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixControl.prototype, "rowDimension", {
                    get: function() {
                        return this.rowDim;
                    },
                    enumerable: !0,
                    configurable: !0
                }), TablixControl.prototype.refresh = function(clear) {
                    this.render(clear, null);
                }, TablixControl.prototype._onScrollAsync = function(dimension) {
                    var _this = this;
                    requestAnimationFrame(function() {
                        _this.performPendingScroll(dimension);
                    });
                }, TablixControl.prototype.performPendingScroll = function(dimension) {
                    this.render(!1, dimension);
                }, TablixControl.prototype.updateHorizontalPosition = function() {
                    this.rowDim.scrollbar.visible ? (this.columnDim.scrollbar.element.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                    this.footerDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                    this.mainDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement) : (this.columnDim.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement, 
                    this.mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement, this.footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement);
                }, TablixControl.prototype.updateFooterVisibility = function() {
                    (this.rowDim.hasFooter() ? "block" !== this.footerDiv.style.display : "none" !== this.footerDiv.style.display) && (this.rowDim.hasFooter() ? this.footerDiv.style.display = "block" : this.footerDiv.style.display = "none");
                }, TablixControl.prototype.updateVerticalPosition = function() {
                    var hasVerticalScrollbar = this.rowDim.scrollbar.visible, isDashboardTile = 1 === this.controlLayoutManager.getLayoutKind(), showFooter = hasVerticalScrollbar || isDashboardTile;
                    if (showFooter) {
                        var mainBottom = this.footerDiv.offsetHeight, footerBottom = 0, verticalScrollbarBottom = 0, hasHorizontalScrollbar = this.columnDim.scrollbar.visible;
                        hasHorizontalScrollbar && (mainBottom += this.scrollBarElementWidth, footerBottom += this.scrollBarElementWidth, 
                        verticalScrollbarBottom = this.scrollBarElementWidth), this.mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement, 
                        this.rowDim.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement, 
                        this.footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement, this.footerDiv.style.removeProperty("top");
                    } else this.footerDiv.style.top = this.gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement, 
                    this.footerDiv.style.removeProperty("bottom"), this.mainDiv.style.removeProperty("bottom");
                }, TablixControl.prototype.alreadyRendered = function(scrollingDimension) {
                    return scrollingDimension === this.lastRenderingArgs.scrollingDimension && this.rowDimension.scrollOffset === this.lastRenderingArgs.rowScrollOffset && this.columnDimension.scrollOffset === this.lastRenderingArgs.columnScrollOffset;
                }, TablixControl.prototype.render = function(clear, scrollingDimension) {
                    if (this.columnDim.makeScrollOffsetValid(), this.rowDim.makeScrollOffsetValid(), 
                    clear || null === scrollingDimension) this.lastRenderingArgs = {}; else if (this.alreadyRendered(scrollingDimension)) return;
                    var done = !1;
                    this.renderIterationCount = 0, this.controlLayoutManager.onStartRenderingSession(scrollingDimension, this.mainDiv, clear);
                    var binder = this.binder;
                    binder.onStartRenderingSession();
                    for (var priorFooterHeight = this.gridDimensions.footerHeight, priorRowHierarchyHeight = this.gridDimensions.rowHierarchyHeight, priorRowHierarchyContentHeight = this.gridDimensions.rowHierarchyContentHeight; !done && this.renderIterationCount < TablixControl.MaxRenderIterationCount; ) {
                        var hScrollbarVisibility = this.columnDim.scrollbar.visible, vScrollbarVisibility = this.rowDim.scrollbar.visible;
                        this.columnDim._onStartRenderingIteration(), this.rowDim._onStartRenderingIteration(), 
                        this.controlLayoutManager.onStartRenderingIteration(clear), this.renderCorner(), 
                        this.columnDim._render(), this.rowDim._render(), done = this.controlLayoutManager.onEndRenderingIteration(), 
                        this.columnDim._onEndRenderingIteration(), this.rowDim._onEndRenderingIteration(), 
                        hScrollbarVisibility !== this.columnDim.scrollbar.visible && this.updateVerticalPosition(), 
                        vScrollbarVisibility !== this.rowDim.scrollbar.visible && this.updateHorizontalPosition(), 
                        this.renderIterationCount++;
                    }
                    this.controlLayoutManager.onEndRenderingSession(), binder.onEndRenderingSession(), 
                    this.isTouchEnabled && this.updateTouchDimensions(), this.lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset, 
                    this.lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset, this.updateContainerDimensions();
                    var lastRenderingArgs = this.lastRenderingArgs;
                    lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset, lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset, 
                    lastRenderingArgs.scrollingDimension = scrollingDimension, priorFooterHeight === this.gridDimensions.footerHeight && priorRowHierarchyHeight === this.gridDimensions.rowHierarchyHeight && priorRowHierarchyContentHeight === this.gridDimensions.rowHierarchyContentHeight || this.updateVerticalPosition(), 
                    this.options.interactive && (this.columnDim.scrollbar.refresh(), this.rowDim.scrollbar.refresh());
                }, TablixControl.prototype.updateContainerDimensions = function() {
                    var gridDimensions = this.gridDimensions;
                    if (this._autoSizeWidth) {
                        var vScrollBarWidth = this.rowDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.width = gridDimensions.rowHierarchyWidth + gridDimensions.columnHierarchyWidth + vScrollBarWidth + TablixControl.UnitOfMeasurement;
                    }
                    if (this._autoSizeHeight) {
                        var hScrollBarHeight = this.columnDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.height = gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight + gridDimensions.footerHeight + hScrollBarHeight + TablixControl.UnitOfMeasurement;
                    }
                }, TablixControl.prototype.cornerCellMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return 0 === cell.type && previousItem && this.hierarchyTablixNavigator.cornerCellItemEquals(item, previousItem);
                }, TablixControl.prototype.renderCorner = function() {
                    for (var columnDepth = this.columnDim.getDepth(), rowDepth = this.rowDim.getDepth(), i = 0; columnDepth > i; i++) for (var j = 0; rowDepth > j; j++) {
                        var item = this.hierarchyTablixNavigator.getCorner(j, i), cell = this.controlLayoutManager.getOrCreateCornerCell(item, j, i), match = this.cornerCellMatch(item, cell);
                        match || (this._unbindCell(cell), cell.type = 0, cell.item = item, this.binder.bindCornerCell(item, cell)), 
                        this.controlLayoutManager.onCornerCellRealized(item, cell);
                    }
                }, TablixControl.prototype._unbindCell = function(cell) {
                    switch (cell.type) {
                      case 3:
                        this.binder.unbindBodyCell(cell.item, cell);
                        break;

                      case 2:
                        this.binder.unbindColumnHeader(cell.item, cell);
                        break;

                      case 1:
                        this.binder.unbindRowHeader(cell.item, cell);
                        break;

                      case 0:
                        this.binder.unbindCornerCell(cell.item, cell);
                    }
                    cell.item = null, cell.type = null;
                }, TablixControl.prototype.onTouchEvent = function(args) {
                    var colShift, rowShift, that;
                    args && args.length > 0 && "columnDim" in args[0] && "rowDim" in args[0] && (that = args[0], 
                    colShift = that.columnDim.scrollbar.visible ? args[1] : 0, rowShift = that.rowDim.scrollbar.visible ? args[2] : 0, 
                    that.columnDim.scrollbar.viewMin = Math.max(0, that.columnDim.scrollbar.viewMin + colShift), 
                    that.columnDim.scrollOffset = Math.max(0, that.columnDim.scrollOffset + colShift), 
                    that.rowDim.scrollbar.viewMin = Math.max(0, that.rowDim.scrollbar.viewMin + rowShift), 
                    that.rowDim.scrollOffset = Math.max(0, that.rowDim.scrollOffset + rowShift), 0 === colShift ? that._onScrollAsync(that.rowDim) : 0 === rowShift ? that._onScrollAsync(that.columnDim) : that._onScrollAsync(null));
                }, TablixControl.UnitOfMeasurement = "px", TablixControl.TablixContainerClassName = "tablixContainer", 
                TablixControl.TablixTableAreaClassName = "tablixTableArea", TablixControl.TablixFooterClassName = "tableFooterArea", 
                TablixControl.DefaultFontSize = jsCommon.PixelConverter.fromPoint(controls.TablixDefaultTextSize), 
                TablixControl.MaxRenderIterationCount = 10, TablixControl;
            }();
            controls.TablixControl = TablixControl;
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var TablixDimension = function() {
                function TablixDimension(tablixControl) {
                    this._scrollStep = .1, this._owner = tablixControl, this._hierarchyNavigator = tablixControl.hierarchyNavigator, 
                    this._binder = tablixControl.getBinder(), this._tablixLayoutManager = tablixControl.layoutManager, 
                    this.scrollOffset = 0;
                }
                return TablixDimension.prototype._onStartRenderingIteration = function() {
                    this.updateScrollPosition();
                }, TablixDimension.prototype._onEndRenderingIteration = function() {}, TablixDimension.prototype.getValidScrollOffset = function(scrollOffset) {
                    return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
                }, TablixDimension.prototype.makeScrollOffsetValid = function() {
                    this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
                }, TablixDimension.prototype.getIntegerScrollOffset = function() {
                    return Math.floor(this.scrollOffset);
                }, TablixDimension.prototype.getFractionScrollOffset = function() {
                    return this.scrollOffset - this.getIntegerScrollOffset();
                }, Object.defineProperty(TablixDimension.prototype, "scrollbar", {
                    get: function() {
                        return this._scrollbar;
                    },
                    enumerable: !0,
                    configurable: !0
                }), TablixDimension.prototype.getFirstVisibleItem = function(level) {
                    return this._scrollItems[level];
                }, TablixDimension.prototype.getFirstVisibleChild = function(item) {
                    return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
                }, TablixDimension.prototype.getFirstVisibleChildIndex = function(item) {
                    var firstVisibleIndex, startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
                    return firstVisibleIndex = void 0 === startItem || void 0 !== startItem && this._hierarchyNavigator.getParent(startItem) !== item ? 0 : this._hierarchyNavigator.getIndex(startItem);
                }, TablixDimension.prototype._initializeScrollbar = function(parentElement, touchDiv, layoutKind) {
                    var _this = this;
                    this._scrollbar = this._createScrollbar(parentElement, layoutKind), this._scrollbar._onscroll.push(function(e) {
                        return _this.onScroll();
                    }), touchDiv && (this.scrollbar.initTouch(touchDiv, !0), touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom"));
                }, TablixDimension.prototype.getItemsCount = function() {
                    return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
                }, TablixDimension.prototype.getDepth = function() {
                    return this.modelDepth;
                }, TablixDimension.prototype.onScroll = function() {
                    this.scrollOffset = this._scrollbar.viewMin, this._owner._onScrollAsync(this);
                }, Object.defineProperty(TablixDimension.prototype, "otherDimension", {
                    get: function() {
                        return this._otherDimension;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(TablixDimension.prototype, "layoutManager", {
                    get: function() {
                        return this._layoutManager;
                    },
                    enumerable: !0,
                    configurable: !0
                }), TablixDimension.prototype._createScrollbar = function(parentElement, layoutKind) {
                    return null;
                }, TablixDimension.prototype.updateScrollPosition = function() {
                    if (this._scrollItems = [], this.model) {
                        var firstVisibleScrollIndex = this.getIntegerScrollOffset(), firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
                        if (firstVisible) {
                            this._firstVisibleScrollIndex = firstVisibleScrollIndex;
                            do this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible, 
                            firstVisible = this._hierarchyNavigator.getParent(firstVisible); while (null !== firstVisible);
                        }
                    }
                }, TablixDimension;
            }();
            controls.TablixDimension = TablixDimension;
            var TablixRowDimension = function(_super) {
                function TablixRowDimension(tablixControl) {
                    _super.call(this, tablixControl), this._layoutManager = this._tablixLayoutManager.rowLayoutManager, 
                    this._footer = null;
                }
                return __extends(TablixRowDimension, _super), TablixRowDimension.prototype.setFooter = function(footerHeader) {
                    this._footer = footerHeader, this._owner.updateFooterVisibility();
                }, TablixRowDimension.prototype.hasFooter = function() {
                    return null !== this._footer;
                }, TablixRowDimension.prototype._render = function() {
                    var firstVisibleRowItem = this.getFirstVisibleItem(0);
                    this.hasFooter() && (this.addFooterRowHeader(this._footer), this.addFooterBodyCells(this._footer)), 
                    void 0 !== firstVisibleRowItem && this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
                }, TablixRowDimension.prototype._createScrollbar = function(parentElement, layoutKind) {
                    return new controls.VerticalScrollbar(parentElement, layoutKind);
                }, TablixRowDimension.prototype.addNodes = function(items, rowIndex, depth, firstVisibleIndex) {
                    for (var count = this._hierarchyNavigator.getCount(items), i = firstVisibleIndex; count > i; i++) {
                        if (!this._layoutManager.needsToRealize) return;
                        var item = this._hierarchyNavigator.getAt(items, i), cell = this.addNode(item, items, rowIndex, depth);
                        rowIndex += cell.rowSpan;
                    }
                }, TablixRowDimension.prototype.getFirstVisibleChildLeaf = function(item) {
                    for (var leaf = item; !this._hierarchyNavigator.isLeaf(leaf); ) leaf = this.getFirstVisibleChild(leaf);
                    return leaf;
                }, TablixRowDimension.prototype.bindRowHeader = function(item, cell) {
                    this._binder.bindRowHeader(item, cell);
                }, TablixRowDimension.prototype.addNode = function(item, items, rowIndex, depth) {
                    var previousCount, rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item)), match = this.rowHeaderMatch(item, rowHeaderCell);
                    return match || (this._owner._unbindCell(rowHeaderCell), rowHeaderCell.type = 1, 
                    rowHeaderCell.item = item), this._hierarchyNavigator.isLeaf(item) ? (rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item), 
                    rowHeaderCell.rowSpan = 1, match || this.bindRowHeader(item, rowHeaderCell), this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell), 
                    this.addBodyCells(item, items, rowIndex)) : (previousCount = this._layoutManager.getRealizedItemsCount(), 
                    this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item)), 
                    rowHeaderCell.colSpan = 1, rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1, 
                    match || this.bindRowHeader(item, rowHeaderCell), this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell)), 
                    rowHeaderCell;
                }, TablixRowDimension.prototype.rowHeaderMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return 1 === cell.type && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                }, TablixRowDimension.prototype.addBodyCells = function(item, items, rowIndex) {
                    for (var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset(), columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth(), hierarchyNavigator = this._hierarchyNavigator, otherModel = this._otherDimension.model, layoutManager = this._tablixLayoutManager, i = 0; columnCount > i; i++) {
                        var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i)), cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
                        this.bindBodyCell(cellItem, cell), layoutManager.onBodyCellRealized(cellItem, cell);
                    }
                }, TablixRowDimension.prototype.bindBodyCell = function(item, cell) {
                    var match = this.bodyCelMatch(item, cell);
                    match || (this._owner._unbindCell(cell), cell.type = 3, cell.item = item, this._binder.bindBodyCell(item, cell));
                }, TablixRowDimension.prototype.addFooterRowHeader = function(item) {
                    var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
                    cell.colSpan = this.getDepth();
                    var match = this.rowHeaderMatch(item, cell);
                    match || (this._owner._unbindCell(cell), cell.type = 1, cell.item = item, this.bindRowHeader(item, cell), 
                    this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell));
                }, TablixRowDimension.prototype.addFooterBodyCells = function(rowItem) {
                    for (var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset(), columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth(), layoutManager = this._tablixLayoutManager, i = 0; columnCount > i; i++) {
                        var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i), item = this._hierarchyNavigator.getIntersection(rowItem, columnItem), cell = layoutManager.getOrCreateFooterBodyCell(item, i);
                        this.bindBodyCell(item, cell), layoutManager.onBodyCellFooterRealized(item, cell);
                    }
                }, TablixRowDimension.prototype.bodyCelMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return 3 === cell.type && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
                }, TablixRowDimension;
            }(TablixDimension);
            controls.TablixRowDimension = TablixRowDimension;
            var TablixColumnDimension = function(_super) {
                function TablixColumnDimension(tablixControl) {
                    _super.call(this, tablixControl), this._layoutManager = this._tablixLayoutManager.columnLayoutManager;
                }
                return __extends(TablixColumnDimension, _super), TablixColumnDimension.prototype._render = function() {
                    var firstVisibleColumnItem = this.getFirstVisibleItem(0);
                    void 0 !== firstVisibleColumnItem && this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
                }, TablixColumnDimension.prototype._createScrollbar = function(parentElement, layoutKind) {
                    var scrollbar = new controls.HorizontalScrollbar(parentElement, layoutKind);
                    return scrollbar.smallIncrement = .2, scrollbar;
                }, TablixColumnDimension.prototype.addNodes = function(items, columnIndex, depth, firstVisibleIndex) {
                    for (var count = this._hierarchyNavigator.getCount(items), i = firstVisibleIndex; count > i; i++) {
                        if (!this._layoutManager.needsToRealize) return;
                        var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
                        columnIndex += cell.colSpan;
                    }
                }, TablixColumnDimension.prototype.addNode = function(item, items, columnIndex, depth) {
                    var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex), match = this.columnHeaderMatch(item, cell);
                    if (match || (this._owner._unbindCell(cell), cell.type = 2, cell.item = item), this._hierarchyNavigator.isLeaf(item)) cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item); else {
                        var previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
                        var childrenLevelDifference = this._hierarchyNavigator.getChildrenLevelDifference(item);
                        childrenLevelDifference === 1 / 0 ? cell.rowSpan = 1 : cell.rowSpan = childrenLevelDifference, 
                        cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                    }
                    return match || this._binder.bindColumnHeader(item, cell), this._tablixLayoutManager.onColumnHeaderRealized(item, cell), 
                    cell;
                }, TablixColumnDimension.prototype.columnHeaderMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return 2 === cell.type && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                }, TablixColumnDimension;
            }(TablixDimension);
            controls.TablixColumnDimension = TablixColumnDimension;
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var ColumnTouchDelegate = function() {
                function ColumnTouchDelegate(region) {
                    this.dim = region, this.averageSize = 1, this.handlers = null, this.tablixControl = null;
                }
                return Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
                    get: function() {
                        return this.dim;
                    },
                    enumerable: !0,
                    configurable: !0
                }), ColumnTouchDelegate.prototype.setScrollDensity = function(xRatio) {
                    this.averageSize = xRatio;
                }, ColumnTouchDelegate.prototype.resize = function(x, y, width, height) {
                    this.dim.x = x, this.dim.y = y, this.dim.width = width, this.dim.height = height;
                }, ColumnTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSize, 0, down, -dx * this.averageSize, 0);
                }, ColumnTouchDelegate.prototype.touchEvent = function(e) {
                    var args = [];
                    args[0] = this.tablixControl, args[1] = e.dx, args[2] = e.dy, this.handlers && controls.fire([ this.handlers ], args);
                }, ColumnTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                    this.handlers = handlerCall, this.tablixControl = tablixObj;
                }, ColumnTouchDelegate;
            }();
            controls.ColumnTouchDelegate = ColumnTouchDelegate;
            var RowTouchDelegate = function() {
                function RowTouchDelegate(region) {
                    this.dim = region, this.averageSize = 30, this.handlers = null, this.tablixControl = null;
                }
                return Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
                    get: function() {
                        return this.dim;
                    },
                    enumerable: !0,
                    configurable: !0
                }), RowTouchDelegate.prototype.setScrollDensity = function(yRatio) {
                    this.averageSize = yRatio;
                }, RowTouchDelegate.prototype.resize = function(x, y, width, height) {
                    this.dim.x = x, this.dim.y = y, this.dim.width = width, this.dim.height = height;
                }, RowTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                    var event = new controls.TouchUtils.TouchEvent(0, y * this.averageSize, down, 0, -dy * this.averageSize);
                    return event;
                }, RowTouchDelegate.prototype.touchEvent = function(e) {
                    var args = [];
                    args[0] = this.tablixControl, args[1] = e.dx, args[2] = e.dy, this.handlers && controls.fire([ this.handlers ], args);
                }, RowTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                    this.handlers = handlerCall, this.tablixControl = tablixObj;
                }, RowTouchDelegate;
            }();
            controls.RowTouchDelegate = RowTouchDelegate;
            var BodyTouchDelegate = function() {
                function BodyTouchDelegate(region) {
                    this.dim = region, this.averageSizeX = BodyTouchDelegate.DefaultAverageSizeX, this.averageSizeY = BodyTouchDelegate.DefaultAverageSizeY, 
                    this.handlers = null, this.tablixControl = null;
                }
                return Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
                    get: function() {
                        return this.dim;
                    },
                    enumerable: !0,
                    configurable: !0
                }), BodyTouchDelegate.prototype.setScrollDensity = function(xRatio, yRatio) {
                    this.averageSizeX = xRatio, this.averageSizeY = yRatio;
                }, BodyTouchDelegate.prototype.resize = function(x, y, width, height) {
                    var dimension = this.dim;
                    dimension.x = x, dimension.y = y, dimension.width = width, dimension.height = height;
                }, BodyTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSizeX, y * this.averageSizeY, down, -dx * this.averageSizeX, -dy * this.averageSizeY);
                }, BodyTouchDelegate.prototype.touchEvent = function(e) {
                    var args = [ this.tablixControl, e.dx, e.dy ];
                    this.handlers && controls.fire([ this.handlers ], args);
                }, BodyTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                    this.handlers = handlerCall, this.tablixControl = tablixObj;
                }, BodyTouchDelegate.DefaultAverageSizeX = 30, BodyTouchDelegate.DefaultAverageSizeY = 30, 
                BodyTouchDelegate;
            }();
            controls.BodyTouchDelegate = BodyTouchDelegate;
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var TouchUtils;
            !function(TouchUtils) {
                var Point = function() {
                    function Point(x, y) {
                        this.x = x || 0, this.y = y || 0;
                    }
                    return Point.prototype.offset = function(offsetX, offsetY) {
                        this.x += offsetX, this.y += offsetY;
                    }, Point;
                }();
                TouchUtils.Point = Point;
                var Rectangle = function(_super) {
                    function Rectangle(x, y, width, height) {
                        _super.call(this, x, y), this.width = width || 0, this.height = height || 0;
                    }
                    return __extends(Rectangle, _super), Object.defineProperty(Rectangle.prototype, "point", {
                        get: function() {
                            return new Point(this.x, this.y);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Rectangle.prototype.contains = function(p) {
                        return Rectangle.contains(this, p);
                    }, Rectangle.contains = function(rect, p) {
                        return p && !Rectangle.isEmpty(rect) ? rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height : !1;
                    }, Rectangle.isEmpty = function(rect) {
                        return !(void 0 !== rect && rect.width >= 0 && rect.height >= 0);
                    }, Rectangle;
                }(Point);
                TouchUtils.Rectangle = Rectangle, function(MouseButton) {
                    MouseButton[MouseButton.NoClick = 0] = "NoClick", MouseButton[MouseButton.LeftClick = 1] = "LeftClick", 
                    MouseButton[MouseButton.RightClick = 2] = "RightClick", MouseButton[MouseButton.CenterClick = 3] = "CenterClick";
                }(TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
                var MouseButton = TouchUtils.MouseButton, TouchEvent = function() {
                    function TouchEvent(x, y, isMouseDown, dx, dy) {
                        this._x = x, this._y = y, this.isMouseButtonDown = isMouseDown, this._dx = dx || 0, 
                        this._dy = dy || 0;
                    }
                    return Object.defineProperty(TouchEvent.prototype, "x", {
                        get: function() {
                            return this._x;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TouchEvent.prototype, "y", {
                        get: function() {
                            return this._y;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TouchEvent.prototype, "dx", {
                        get: function() {
                            return this._dx;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TouchEvent.prototype, "dy", {
                        get: function() {
                            return this._dy;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
                        get: function() {
                            return this.isMouseButtonDown;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TouchEvent;
                }();
                TouchUtils.TouchEvent = TouchEvent;
                var TouchManager = function() {
                    function TouchManager() {
                        this.touchList = [], this.swipeDirection = 2, this.matchingDirectionCount = 0, this.lockThreshold = !0, 
                        this.scrollThreshold = !0, this.lastTouchEvent = new TouchEvent(0, 0, !1);
                    }
                    return Object.defineProperty(TouchManager.prototype, "lastEvent", {
                        get: function() {
                            return this.lastTouchEvent;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TouchManager.prototype.addTouchRegion = function(region, handler, converter) {
                        var item = {
                            lastPoint: new TouchEvent(0, 0, !1),
                            handler: handler,
                            region: region,
                            converter: converter
                        };
                        this.touchList = this.touchList.concat([ item ]);
                    }, TouchManager.prototype.upAllTouches = function() {
                        var eventPoint, length;
                        length = this.touchList.length;
                        for (var i = 0; length > i; i++) this.touchList[i].lastPoint.isMouseDown && (eventPoint = this.touchList[i].converter.getPixelToItem(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, 0, 0, !1), 
                        this.touchList[i].handler.touchEvent(eventPoint)), this.touchList[i].lastPoint = new TouchEvent(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, !1);
                        this.lastTouchEvent = new TouchEvent(0, 0, !1);
                    }, TouchManager.prototype.touchEvent = function(e) {
                        var list, length, x = 0, y = 0, dx = 0, dy = 0, angle = 0, eventPoint = null;
                        list = this._getActive(), !this.lastTouchEvent.isMouseDown && e.isMouseDown && (list = this._findRegions(e)), 
                        dx = this.lastTouchEvent.x - e.x, dy = this.lastTouchEvent.y - e.y, this.lastTouchEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy), 
                        length = list.length;
                        for (var i = 0; length > i; i++) x = e.x - list[i].region.point.x, y = e.y - list[i].region.point.y, 
                        list[i].lastPoint.isMouseDown && e.isMouseDown ? (dx = x - list[i].lastPoint.x, 
                        dy = y - list[i].lastPoint.y, angle = Math.abs(180 / Math.PI * Math.atan(dy / dx)), 
                        this.scrollThreshold && (this.lockThreshold && this.matchingDirectionCount > 5 ? 1 === this.swipeDirection ? dy = 0 : 0 === this.swipeDirection && (dx = 0) : 20 > angle ? (dy = 0, 
                        1 === this.swipeDirection ? this.matchingDirectionCount++ : (this.matchingDirectionCount = 1, 
                        this.swipeDirection = 1)) : (angle = Math.abs(180 / Math.PI * Math.atan(dx / dy)), 
                        20 > angle ? (dx = 0, 0 === this.swipeDirection ? this.matchingDirectionCount++ : (this.matchingDirectionCount = 1, 
                        this.swipeDirection = 0)) : 2 === this.swipeDirection ? this.matchingDirectionCount++ : (this.swipeDirection = 2, 
                        this.matchingDirectionCount = 1)))) : (dx = 0, dy = 0, this.swipeDirection = 2, 
                        this.matchingDirectionCount = 0), list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy), 
                        eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown), list[i].handler.touchEvent(eventPoint);
                    }, TouchManager.prototype._findRegions = function(e) {
                        var length, list = [];
                        length = this.touchList.length;
                        for (var i = 0; length > i; i++) this.touchList[i].region.contains(new Point(e.x, e.y)) && (list = list.concat([ this.touchList[i] ]));
                        return list;
                    }, TouchManager.prototype._getActive = function() {
                        var length, list = [];
                        length = this.touchList.length;
                        for (var i = 0; length > i; i++) this.touchList[i].lastPoint.isMouseDown && (list = list.concat([ this.touchList[i] ]));
                        return list;
                    }, TouchManager;
                }();
                TouchUtils.TouchManager = TouchManager;
                var MinDistanceForSwipe = 80, MaxTimeForSwipe = 600, TouchEventInterpreter = function() {
                    function TouchEventInterpreter(manager) {
                        this.manager = manager, this.allowMouseDrag = !0, this.touchPanel = null, this.scale = 1, 
                        this.documentMouseMoveWrapper = null, this.documentMouseUpWrapper = null, this.sliding = !1;
                    }
                    return TouchEventInterpreter.prototype.initTouch = function(panel, touchReferencePoint, allowMouseDrag) {
                        var _this = this;
                        panel.style.setProperty("-ms-touch-action", "pinch-zoom"), this.touchReferencePoint = touchReferencePoint, 
                        this.touchPanel = panel, this.allowMouseDrag = void 0 === allowMouseDrag ? !0 : allowMouseDrag, 
                        "ontouchmove" in panel ? (panel.addEventListener("touchstart", function(e) {
                            return _this.onTouchStart(e);
                        }), panel.addEventListener("touchend", function(e) {
                            return _this.onTouchEnd(e);
                        })) : (panel.addEventListener("mousedown", function(e) {
                            return _this.onTouchMouseDown(e);
                        }), panel.addEventListener("mouseup", function(e) {
                            return _this.onTouchMouseUp(e);
                        }));
                    }, TouchEventInterpreter.prototype.getXYByClient = function(pageX, pageY, rect) {
                        var x = rect.left, y = rect.top;
                        void 0 !== window.scrollX && (x += window.scrollX, y += window.scrollY);
                        var point = new Point(0, 0);
                        return point.offset(pageX - x, pageY - y), point;
                    }, TouchEventInterpreter.prototype.onTouchStart = function(e) {
                        if (1 === e.touches.length) {
                            e.cancelBubble = !0;
                            var mouchEvent = e.touches[0];
                            this.touchStartTime = new Date().getTime(), this.touchStartPageY = mouchEvent.pageY, 
                            this.onTouchMouseDown(mouchEvent);
                        }
                    }, TouchEventInterpreter.prototype.onTouchMove = function(e) {
                        if (1 === e.touches.length) {
                            e.preventDefault && e.preventDefault();
                            var mouchEvent = e.touches[0];
                            this.touchLastPageY = mouchEvent.pageY, this.touchLastPageX = mouchEvent.pageX, 
                            this.sliding || this.onTouchMouseMove(mouchEvent);
                        }
                    }, TouchEventInterpreter.prototype.onTouchEnd = function(e) {
                        this.clearTouchEvents();
                        var swipeInfo = this.getSwipeInfo();
                        this.didUserSwipe(swipeInfo) ? this.startSlideAffect(swipeInfo) : this.sliding || this.upAllTouches();
                    }, TouchEventInterpreter.prototype.onTouchMouseDown = function(e) {
                        var _this = this;
                        this.scale = controls.HTMLElementUtils.getAccumulatedScale(this.touchPanel), document.getSelection().removeAllRanges(), 
                        this.rect = (this.touchReferencePoint ? this.touchReferencePoint : this.touchPanel).getBoundingClientRect(), 
                        "ontouchmove" in this.touchPanel ? (this.documentMouseMoveWrapper = function(e) {
                            return _this.onTouchMove(e);
                        }, document.addEventListener("touchmove", this.documentMouseMoveWrapper), this.documentMouseUpWrapper = function(e) {
                            return _this.onTouchEnd(e);
                        }, document.addEventListener("touchend", this.documentMouseUpWrapper)) : (this.documentMouseMoveWrapper = function(e) {
                            return _this.onTouchMouseMove(e);
                        }, document.addEventListener("mousemove", this.documentMouseMoveWrapper), this.documentMouseUpWrapper = function(e) {
                            return _this.onTouchMouseUp(e);
                        }, document.addEventListener("mouseup", this.documentMouseUpWrapper)), "setCapture" in this.touchPanel && this.touchPanel.setCapture();
                    }, TouchEventInterpreter.prototype.onTouchMouseMove = function(e) {
                        var event, point, rect = this.rect, validMouseDragEvent = null !== rect && e.which !== MouseButton.NoClick;
                        validMouseDragEvent && !this.sliding && (point = this.getXYByClient(e.pageX, e.pageY, rect), 
                        event = new TouchEvent(point.x / this.scale, point.y / this.scale, validMouseDragEvent), 
                        this.manager.touchEvent(event), e.preventDefault ? e.preventDefault() : "returnValue" in e && (e.returnValue = !1));
                    }, TouchEventInterpreter.prototype.onTouchMouseUp = function(e, bubble) {
                        this.upAllTouches(), this.clearTouchEvents();
                    }, TouchEventInterpreter.prototype.getSwipeInfo = function() {
                        var touchEndTime = new Date().getTime(), touchTime = touchEndTime - this.touchStartTime, touchDist = this.touchLastPageY - this.touchStartPageY, touchDirection = 0 > touchDist ? -1 : 1;
                        return {
                            direction: touchDirection,
                            distance: touchDist,
                            endTime: touchEndTime,
                            time: touchTime
                        };
                    }, TouchEventInterpreter.prototype.didUserSwipe = function(swipeInfo) {
                        return swipeInfo.time < MaxTimeForSwipe && swipeInfo.distance * swipeInfo.direction > MinDistanceForSwipe;
                    }, TouchEventInterpreter.prototype.startSlideAffect = function(swipeInfo) {
                        var _this = this;
                        if (!this.sliding) {
                            this.sliding = !0;
                            var point = this.getXYByClient(this.touchLastPageX, this.touchLastPageY, this.rect);
                            this.slide(point, 300, swipeInfo), requestAnimationFrame(function() {
                                _this.didUserChangeDirection(swipeInfo) || _this.slide(point, 200, swipeInfo), _this.clearSlide();
                            });
                        }
                    }, TouchEventInterpreter.prototype.didUserChangeDirection = function(swipeInfo) {
                        if (this.touchStartTime <= swipeInfo.endTime) return !1;
                        var updatedDist = this.touchLastPageY - this.touchStartPageY, updatedDirection = 0 > updatedDist ? -1 : 1;
                        return updatedDirection !== swipeInfo.direction;
                    }, TouchEventInterpreter.prototype.slide = function(point, slideDist, swipeInfo) {
                        var updatedDist = this.touchStartTime > swipeInfo.endTime ? this.touchLastPageY - this.touchStartPageY : 0;
                        point.y += slideDist * swipeInfo.direction + updatedDist;
                        var event = new TouchEvent(point.x / this.scale, point.y / this.scale, !0);
                        this.manager.touchEvent(event);
                    }, TouchEventInterpreter.prototype.clearSlide = function() {
                        this.sliding = !1, this.upAllTouches();
                    }, TouchEventInterpreter.prototype.upAllTouches = function() {
                        null === this.documentMouseMoveWrapper && (this.rect = null, this.manager.upAllTouches());
                    }, TouchEventInterpreter.prototype.clearTouchEvents = function() {
                        "releaseCapture" in this.touchPanel && this.touchPanel.releaseCapture(), null !== this.documentMouseMoveWrapper && ("ontouchmove" in this.touchPanel ? (document.removeEventListener("touchmove", this.documentMouseMoveWrapper), 
                        document.removeEventListener("touchend", this.documentMouseUpWrapper)) : (document.removeEventListener("mousemove", this.documentMouseMoveWrapper), 
                        document.removeEventListener("mouseup", this.documentMouseUpWrapper)), this.documentMouseMoveWrapper = null, 
                        this.documentMouseUpWrapper = null);
                    }, TouchEventInterpreter;
                }();
                TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
            }(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            !function(TablixType) {
                TablixType[TablixType.Matrix = 0] = "Matrix", TablixType[TablixType.Table = 1] = "Table";
            }(controls.TablixType || (controls.TablixType = {}));
            controls.TablixType;
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var controls;
        !function(controls) {
            var PropAutoSizeWidth = controls.internal.TablixObjects.PropGeneralAutoSizeColumns, getMetadataObjects = controls.internal.TablixObjects.getMetadadataObjects, TablixColumnWidthManager = function() {
                function TablixColumnWidthManager(dataView, isMatrix, hostPersistCallBack, matrixLeafNodes) {
                    this.columnWidthObjects = [], this.isMatrix = isMatrix, this.updateDataView(dataView, matrixLeafNodes), 
                    this.hostPersistCallBack = hostPersistCallBack;
                }
                return TablixColumnWidthManager.prototype.updateDataView = function(dataView, matrixLeafNodes) {
                    this.previousDataView = this.currentDataView, this.previousDataView ? this.previousAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.previousDataView)) : this.previousAutoColumnSizePropertyValue = void 0, 
                    this.currentDataView = dataView, this.currentDataView ? this.currentAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.currentDataView)) : this.currentAutoColumnSizePropertyValue = void 0, 
                    this.matrixLeafNodes = matrixLeafNodes, this.updateColumnWidthObjects(), this.updateTablixColumnWidths();
                }, TablixColumnWidthManager.prototype.updateColumnWidthObjects = function() {
                    this.columnWidthObjects.length = 0, this.isMatrix ? this.updateMatrixColumnWidthObjects() : this.updateTableColumnWidthObjects();
                }, TablixColumnWidthManager.prototype.updateTableColumnWidthObjects = function() {
                    if (this.currentDataView && this.currentDataView.table) for (var columnMetaData = this.currentDataView.table.columns, i = 0, len = columnMetaData.length; len > i; i++) {
                        var query = columnMetaData[i].queryName;
                        this.columnWidthObjects.push({
                            queryName: query,
                            width: void 0
                        });
                    }
                }, TablixColumnWidthManager.prototype.updateMatrixColumnWidthObjects = function() {
                    if (this.currentDataView && this.currentDataView.matrix && this.currentDataView.matrix.rows) for (var i = 0, len = this.currentDataView.matrix.rows.levels.length; len > i; i++) {
                        var rowGroup = this.currentDataView.matrix.rows.levels[i];
                        _.isEmpty(rowGroup.sources) || this.columnWidthObjects.push({
                            queryName: rowGroup.sources[0].queryName,
                            width: void 0
                        });
                    }
                    if (this.matrixLeafNodes) for (var i = 0, len = this.matrixLeafNodes.length; len > i; i++) {
                        var query = this.matrixLeafNodes[i].queryName;
                        this.columnWidthObjects.push({
                            queryName: query,
                            width: void 0
                        });
                    }
                }, TablixColumnWidthManager.prototype.updateTablixColumnWidths = function() {
                    var columnMetaData = this.currentDataView && this.currentDataView.metadata && this.currentDataView.metadata.columns;
                    columnMetaData && (this.shouldClearAllColumnWidths() ? this.autoSizeAllColumns() : this.deserializeColumnWidths(columnMetaData));
                }, TablixColumnWidthManager.prototype.deserializeColumnWidths = function(columnMetaData) {
                    this.columnWidthObjects.forEach(function(obj) {
                        obj.width = void 0;
                    });
                    for (var _i = 0, columnMetaData_1 = columnMetaData; _i < columnMetaData_1.length; _i++) {
                        var column = columnMetaData_1[_i], columnWidthPropValue = powerbi.DataViewObjects.getValue(column.objects, TablixColumnWidthManager.columnWidthProp);
                        if (_.isNumber(columnWidthPropValue)) for (var _a = 0, _b = this.columnWidthObjects; _a < _b.length; _a++) {
                            var obj = _b[_a];
                            obj.queryName === column.queryName && (obj.width = columnWidthPropValue);
                        }
                    }
                }, TablixColumnWidthManager.prototype.shouldPersistAllColumnWidths = function() {
                    return this.previousDataView ? !this.currentAutoColumnSizePropertyValue && this.previousAutoColumnSizePropertyValue : !1;
                }, TablixColumnWidthManager.prototype.shouldClearAllColumnWidths = function() {
                    return null != this.previousDataView && this.previousAutoColumnSizePropertyValue === !1 && null != this.currentDataView && this.currentAutoColumnSizePropertyValue === !0;
                }, TablixColumnWidthManager.prototype.getColumnWidthObjects = function() {
                    return this.columnWidthObjects;
                }, TablixColumnWidthManager.prototype.getFixedColumnWidthObjects = function() {
                    return this.columnWidthObjects.filter(function(obj) {
                        return null != obj.width;
                    });
                }, TablixColumnWidthManager.prototype.getPersistedColumnWidth = function(index) {
                    var colIndex = this.isMatrix ? index : index - 1, item = this.columnWidthObjects[colIndex];
                    return item ? item.width : void 0;
                }, TablixColumnWidthManager.prototype.callHostToPersist = function(generateInstances) {
                    generateInstances && this.generateVisualObjectInstancesToPersist(), this.hostPersistCallBack && this.hostPersistCallBack(this.visualObjectInstancesToPersist);
                }, TablixColumnWidthManager.prototype.autoSizeAllColumns = function() {
                    this.visualObjectInstancesToPersist = {
                        merge: [ this.getAutoSizeColumnWidthObject() ],
                        remove: []
                    };
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var columnWidthObject = _a[_i];
                        this.visualObjectInstancesToPersist.remove.push({
                            selector: {
                                metadata: columnWidthObject.queryName
                            },
                            objectName: "general",
                            properties: {
                                columnWidth: void 0
                            }
                        });
                    }
                    this.callHostToPersist(!1);
                }, TablixColumnWidthManager.prototype.onColumnAutosized = function(queryName) {
                    for (var width = this.currentAutoColumnSizePropertyValue ? void 0 : -1, _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        obj.queryName === queryName && (obj.width = width);
                    }
                    this.currentAutoColumnSizePropertyValue && (this.visualObjectInstancesToPersist = {
                        remove: [ {
                            selector: {
                                metadata: queryName
                            },
                            objectName: "general",
                            properties: {
                                columnWidth: void 0
                            }
                        } ]
                    }, this.callHostToPersist(!1));
                }, TablixColumnWidthManager.prototype.onColumnWidthChanged = function(index, width) {
                    var colIndex = this.isMatrix ? index : index - 1;
                    if (!(_.isEmpty(this.columnWidthObjects) || 0 > colIndex || colIndex >= this.columnWidthObjects.length)) {
                        var queryName = this.columnWidthObjects[colIndex].queryName;
                        if (-1 === width) this.onColumnAutosized(queryName); else {
                            for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                                var obj = _a[_i];
                                obj.queryName === queryName && (obj.width = width);
                            }
                            this.callHostToPersist(!0);
                        }
                    }
                }, TablixColumnWidthManager.prototype.persistAllColumnWidths = function(widthsToPersist) {
                    var _this = this, widths = this.isMatrix ? widthsToPersist : widthsToPersist.slice(1, widthsToPersist.length);
                    if (this.columnWidthObjects.length === widths.length) {
                        var dictionary = new Array();
                        widths.forEach(function(w, i) {
                            var query = _this.columnWidthObjects[i].queryName;
                            null == dictionary[query] ? dictionary[query] = w : dictionary[query] = Math.max(w, dictionary[query]);
                        });
                        for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                            var obj = _a[_i], width = dictionary[obj.queryName];
                            null != width && (obj.width = width);
                        }
                        this.callHostToPersist(!0);
                    }
                }, TablixColumnWidthManager.prototype.getAutoSizeColumnWidthObject = function() {
                    return {
                        selector: null,
                        objectName: "general",
                        properties: {
                            autoSizeColumnWidth: this.currentAutoColumnSizePropertyValue
                        }
                    };
                }, TablixColumnWidthManager.prototype.generateVisualObjectInstancesToPersist = function() {
                    this.visualObjectInstancesToPersist = {
                        merge: [ this.getAutoSizeColumnWidthObject() ]
                    };
                    for (var added = new Array(), _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        obj.queryName && _.isNumber(obj.width) && !added[obj.queryName] && (this.visualObjectInstancesToPersist.merge.push({
                            selector: {
                                metadata: obj.queryName
                            },
                            objectName: "general",
                            properties: {
                                columnWidth: obj.width
                            }
                        }), added[obj.queryName] = !0);
                    }
                }, TablixColumnWidthManager.columnWidthProp = {
                    objectName: "general",
                    propertyName: "columnWidth"
                }, TablixColumnWidthManager;
            }();
            controls.TablixColumnWidthManager = TablixColumnWidthManager;
        }(controls = visuals.controls || (visuals.controls = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var AnimatedText = function() {
            function AnimatedText(name) {
                this.mainText = jsCommon.CssConstants.createClassAndSelector("mainText"), this.name = name, 
                this.visualConfiguration = {
                    maxFontSize: 60
                };
            }
            return AnimatedText.prototype.getMetaDataColumn = function(dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) for (var i = 0, ilen = dataView.metadata.columns.length; ilen > i; i++) {
                    var column = dataView.metadata.columns[i];
                    if (column.isMeasure) {
                        this.metaDataColumn = column;
                        break;
                    }
                }
            }, AnimatedText.prototype.getAdjustedFontHeight = function(availableWidth, textToMeasure, seedFontHeight) {
                var textProperties = {
                    fontFamily: null,
                    fontSize: null,
                    text: textToMeasure
                }, fontHeight = this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight, 0);
                return fontHeight;
            }, AnimatedText.prototype.getAdjustedFontHeightCore = function(textProperties, availableWidth, seedFontHeight, iteration) {
                if (iteration > 10) return seedFontHeight;
                textProperties.fontSize = jsCommon.PixelConverter.toString(seedFontHeight);
                var candidateLength = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                return availableWidth > candidateLength ? seedFontHeight : this.getAdjustedFontHeightCore(textProperties, availableWidth, .9 * seedFontHeight, iteration + 1);
            }, AnimatedText.prototype.clear = function() {
                this.svg.select(this.mainText.selector).text("");
            }, AnimatedText.prototype.doValueTransition = function(startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate, formatter) {
                if (forceUpdate || startValue !== endValue || null == endValue) {
                    startValue || (startValue = 0);
                    var svg = this.svg, viewport = this.currentViewport, height = viewport.height, width = viewport.width, endValueArr = [ endValue ], seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(seedFontHeight), metaDataColumn = this.metaDataColumn;
                    formatter || (formatter = visuals.valueFormatter.create({
                        format: this.getFormatString(metaDataColumn),
                        value: endValue,
                        displayUnitSystemType: displayUnitSystemType,
                        formatSingleValues: !0,
                        allowFormatBeautification: !0,
                        columnType: metaDataColumn ? metaDataColumn.type : void 0
                    }));
                    var startText = formatter.format(startValue), endText = formatter.format(endValue);
                    svg.attr("class", this.name);
                    var textElement = svg.selectAll("text").data(endValueArr);
                    textElement.enter().append("text").attr("class", this.mainText["class"]);
                    var fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
                    translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2);
                    var textElementUpdate = textElement.text(startText).attr({
                        "text-anchor": this.getTextAnchor(),
                        "font-size": fontHeight,
                        transform: visuals.SVGUtil.translate(translateX, translateY)
                    }).style({
                        fill: this.style.titleText.color.value
                    }).call(visuals.tooltipUtils.tooltipUpdate, [ startText ]);
                    if (null == endValue) textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [ endText ]); else if (metaDataColumn && visuals.AxisHelper.isDateTime(metaDataColumn.type)) textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [ endText ]); else {
                        var interpolatedValue_1 = startValue;
                        textElementUpdate.transition().duration(duration).tween("text", function(d) {
                            var i = d3.interpolate(interpolatedValue_1, d);
                            return function(t) {
                                var num = i(t);
                                this.textContent = formatter.format(num);
                            };
                        });
                    }
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(animationOptions);
                }
            }, AnimatedText.prototype.setTextColor = function(color) {
                this.style.titleText.color.value = color;
            }, AnimatedText.prototype.getSeedFontHeight = function(boundingWidth, boundingHeight) {
                var estimatedSize = Math.floor(.75 * Math.min(boundingWidth, boundingHeight)), maxFontSize = this.visualConfiguration.maxFontSize;
                return maxFontSize ? Math.min(maxFontSize, estimatedSize) : estimatedSize;
            }, AnimatedText.prototype.getTranslateX = function(width) {
                if (this.visualConfiguration) switch (this.visualConfiguration.align) {
                  case "left":
                    return 0;

                  case "right":
                    return width;
                }
                return width / 2;
            }, AnimatedText.prototype.getTranslateY = function(height) {
                return height;
            }, AnimatedText.prototype.getTextAnchor = function() {
                if (this.visualConfiguration) switch (this.visualConfiguration.align) {
                  case "left":
                    return "start";

                  case "right":
                    return "end";
                }
                return "middle";
            }, AnimatedText.prototype.getFormatString = function(column) {
                return visuals.valueFormatter.getFormatString(column, AnimatedText.formatStringProp);
            }, AnimatedText.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            }, AnimatedText;
        }();
        visuals.AnimatedText = AnimatedText;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var AnimatedNumber = function(_super) {
            function AnimatedNumber(svg, animator) {
                _super.call(this, "animatedNumber"), svg && (this.svg = svg), animator && (this.animator = animator);
            }
            return __extends(AnimatedNumber, _super), AnimatedNumber.prototype.init = function(options) {
                this.options = options;
                var element = options.element;
                this.svg || (this.svg = d3.select(element.get(0)).append("svg")), this.currentViewport = options.viewport, 
                this.hostServices = options.host, this.style = options.style, this.updateViewportDependantProperties();
            }, AnimatedNumber.prototype.updateViewportDependantProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            }, AnimatedNumber.prototype.update = function(options) {
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (dataViews && dataViews[0]) {
                    var dataView = dataViews[0];
                    this.updateViewportDependantProperties(), this.getMetaDataColumn(dataView);
                    var newValue = dataView && dataView.single ? dataView.single.value : 0;
                    null != newValue && this.updateInternal(newValue, options.suppressAnimations, !0, this.formatter);
                }
            }, AnimatedNumber.prototype.setFormatter = function(formatter) {
                this.formatter = formatter;
            }, AnimatedNumber.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            }, AnimatedNumber.prototype.onResizing = function(viewport) {
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: !0,
                    viewport: viewport
                });
            }, AnimatedNumber.prototype.canResizeTo = function(viewport) {
                return !0;
            }, AnimatedNumber.prototype.updateInternal = function(target, suppressAnimations, forceUpdate, formatter) {
                void 0 === forceUpdate && (forceUpdate = !1);
                var start = this.value || 0, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.doValueTransition(start, target, null, this.options.animation, duration, forceUpdate, formatter), 
                this.value = target;
            }, AnimatedNumber;
        }(visuals.AnimatedText);
        visuals.AnimatedNumber = AnimatedNumber;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var BasicShapeVisual = function() {
            function BasicShapeVisual(options) {}
            return Object.defineProperty(BasicShapeVisual.prototype, "shapeType", {
                get: function() {
                    return this.data ? this.data.shapeType : BasicShapeVisual.DefaultShape;
                },
                set: function(shapeType) {
                    this.data.shapeType = shapeType;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "lineColor", {
                get: function() {
                    return this.data ? this.data.lineColor : BasicShapeVisual.DefaultStrokeColor;
                },
                set: function(color) {
                    this.data.lineColor = color;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "lineTransparency", {
                get: function() {
                    return this.data ? this.data.lineTransparency : BasicShapeVisual.DefaultLineTransValue;
                },
                set: function(trans) {
                    this.data.lineTransparency = trans;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "lineWeight", {
                get: function() {
                    return this.data ? this.data.lineWeight : BasicShapeVisual.DefaultWeightValue;
                },
                set: function(weight) {
                    this.data.lineWeight = weight;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "roundEdge", {
                get: function() {
                    return this.data ? this.data.roundEdge : BasicShapeVisual.DefaultRoundEdgeValue;
                },
                set: function(roundEdge) {
                    this.data.roundEdge = roundEdge;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "showFill", {
                get: function() {
                    return this.data ? this.data.showFill : BasicShapeVisual.DefaultFillShowValue;
                },
                set: function(show) {
                    this.data.showFill = show;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "fillColor", {
                get: function() {
                    return this.data ? this.data.fillColor : BasicShapeVisual.DefaultFillColor;
                },
                set: function(color) {
                    this.data.fillColor = color;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "shapeTransparency", {
                get: function() {
                    return this.data ? this.data.shapeTransparency : BasicShapeVisual.DefaultFillTransValue;
                },
                set: function(trans) {
                    this.data.shapeTransparency = trans;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(BasicShapeVisual.prototype, "angle", {
                get: function() {
                    return this.data ? this.data.angle : BasicShapeVisual.DefaultAngle;
                },
                set: function(angle) {
                    this.data.angle = this.scaleTo360Deg(angle);
                },
                enumerable: !0,
                configurable: !0
            }), BasicShapeVisual.prototype.init = function(options) {
                this.element = options.element, this.selection = d3.select(this.element.context), 
                this.currentViewport = options.viewport;
            }, BasicShapeVisual.prototype.update = function(options) {
                this.currentViewport = options.viewport;
                var dataViews = options.dataViews;
                if (!_.isEmpty(dataViews)) {
                    var dataView = options.dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var dataViewObject = options.dataViews[0].metadata.objects;
                        this.data = this.getDataFromDataView(dataViewObject);
                    }
                }
                this.render();
            }, BasicShapeVisual.prototype.getDataFromDataView = function(dataViewObject) {
                return dataViewObject ? {
                    shapeType: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.general.shapeType, BasicShapeVisual.DefaultShape),
                    lineColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.lineColor, BasicShapeVisual.DefaultStrokeColor)),
                    lineTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.transparency, BasicShapeVisual.DefaultLineTransValue),
                    lineWeight: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.weight, BasicShapeVisual.DefaultWeightValue),
                    roundEdge: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.roundEdge, BasicShapeVisual.DefaultRoundEdgeValue),
                    shapeTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.transparency, BasicShapeVisual.DefaultFillTransValue),
                    fillColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.fillColor, BasicShapeVisual.DefaultFillColor)),
                    showFill: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.show, BasicShapeVisual.DefaultFillShowValue),
                    angle: this.scaleTo360Deg(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.rotation.angle, BasicShapeVisual.DefaultAngle))
                } : null;
            }, BasicShapeVisual.prototype.scaleTo360Deg = function(angle) {
                return 0 !== angle && Math.abs(angle) % 360 === 0 ? angle : (angle %= 360, angle = (angle + 360) % 360);
            }, BasicShapeVisual.prototype.getValueFromColor = function(color) {
                return color.solid ? color.solid.color : color;
            }, BasicShapeVisual.prototype.enumerateObjectInstances = function(options) {
                var objectInstances = [];
                switch (options.objectName) {
                  case "line":
                    var instance = {
                        selector: null,
                        properties: {
                            lineColor: this.lineColor,
                            transparency: this.lineTransparency,
                            weight: this.lineWeight
                        },
                        objectName: options.objectName
                    };
                    return this.data.shapeType === visuals.basicShapeType.rectangle && (instance.properties.roundEdge = this.roundEdge), 
                    objectInstances.push(instance), objectInstances;

                  case "fill":
                    return this.shapeType !== visuals.basicShapeType.line && objectInstances.push({
                        selector: null,
                        properties: {
                            show: this.showFill,
                            fillColor: this.fillColor,
                            transparency: this.shapeTransparency
                        },
                        objectName: options.objectName
                    }), objectInstances;

                  case "rotation":
                    return objectInstances.push({
                        selector: null,
                        properties: {
                            angle: this.angle
                        },
                        objectName: options.objectName
                    }), objectInstances;
                }
                return null;
            }, BasicShapeVisual.prototype.render = function() {
                switch (this.selection.html(""), this.shapeType) {
                  case visuals.basicShapeType.rectangle:
                    visuals.ShapeFactory.createRectangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                    break;

                  case visuals.basicShapeType.oval:
                    visuals.ShapeFactory.createOval(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                    break;

                  case visuals.basicShapeType.line:
                    visuals.ShapeFactory.createLine(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                    break;

                  case visuals.basicShapeType.arrow:
                    visuals.ShapeFactory.createUpArrow(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                    break;

                  case visuals.basicShapeType.triangle:
                    visuals.ShapeFactory.createTriangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                }
            }, BasicShapeVisual.DefaultShape = visuals.basicShapeType.rectangle, BasicShapeVisual.DefaultStrokeColor = "#00B8AA", 
            BasicShapeVisual.DefaultFillColor = "#E6E6E6", BasicShapeVisual.DefaultFillShowValue = !0, 
            BasicShapeVisual.DefaultFillTransValue = 0, BasicShapeVisual.DefaultWeightValue = 3, 
            BasicShapeVisual.DefaultLineTransValue = 0, BasicShapeVisual.DefaultRoundEdgeValue = 0, 
            BasicShapeVisual.DefaultAngle = 0, BasicShapeVisual;
        }();
        visuals.BasicShapeVisual = BasicShapeVisual;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function getLayerData(dataViews, currentIdx, totalLayers) {
            return totalLayers > 1 ? dataViews && dataViews.length > currentIdx ? [ dataViews[currentIdx] ] : [] : dataViews;
        }
        function hasMultipleYAxes(layers) {
            return layers.length > 1;
        }
        function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
            return 0 === layerNumber && !!valueAxisProperties && !!valueAxisProperties.showAxisTitle || 1 === layerNumber && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties.secShowAxisTitle;
        }
        function tryMergeYDomains(layers, visualOptions) {
            var noMerge = {
                domain: void 0,
                merged: !1,
                tickCount: void 0
            };
            if (layers.length < 2) return noMerge;
            var min, max, minOfMax, maxOfMin, y1props = layers[0].calculateAxesProperties(visualOptions)[1], y2props = layers[1].calculateAxesProperties(visualOptions)[1], firstYDomain = y1props.scale.domain(), secondYDomain = y2props.scale.domain();
            if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0 && (noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length)), 
            min = Math.min(firstYDomain[0], secondYDomain[0]), max = Math.max(firstYDomain[1], secondYDomain[1]), 
            visualOptions.forceMerge) return {
                domain: [ min, max ],
                merged: !0,
                tickCount: noMerge.tickCount
            };
            if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0]) return noMerge;
            maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]), minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
            var range = max - min;
            if (0 === range) return noMerge;
            var intersection = Math.abs((minOfMax - maxOfMin) / range);
            return COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE > intersection ? noMerge : {
                domain: [ min, max ],
                merged: !0,
                tickCount: noMerge.tickCount
            };
        }
        function calculateAxes(layers, viewport, margin, playAxisControlLayout, categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible, existingAxisProperties, trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain) {
            var mergeResult, visualOptions = {
                viewport: viewport,
                margin: margin,
                forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                showCategoryAxisLabel: !1,
                showValueAxisLabel: !1,
                trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow,
                categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : DEFAULT_AXIS_SCALE_TYPE,
                valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : DEFAULT_AXIS_SCALE_TYPE,
                categoryAxisDisplayUnits: categoryAxisProperties && null != categoryAxisProperties.labelDisplayUnits ? categoryAxisProperties.labelDisplayUnits : 0,
                valueAxisDisplayUnits: valueAxisProperties && null != valueAxisProperties.labelDisplayUnits ? valueAxisProperties.labelDisplayUnits : 0,
                categoryAxisPrecision: categoryAxisProperties ? visuals.CartesianHelper.getPrecision(categoryAxisProperties.labelPrecision) : null,
                valueAxisPrecision: valueAxisProperties ? visuals.CartesianHelper.getPrecision(valueAxisProperties.labelPrecision) : null,
                playAxisControlLayout: playAxisControlLayout,
                ensureXDomain: ensureXDomain,
                ensureYDomain: ensureYDomain
            }, skipMerge = valueAxisProperties && valueAxisProperties.secShow === !0, yAxisWillMerge = !1;
            hasMultipleYAxes(layers) && !skipMerge && (mergeResult = tryMergeYDomains(layers, visualOptions), 
            yAxisWillMerge = mergeResult.merged, yAxisWillMerge ? visualOptions.forcedYDomain = mergeResult.domain : visualOptions.forcedTickCount = mergeResult.tickCount), 
            valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain));
            for (var result, layerNumber = 0, len = layers.length; len > layerNumber; layerNumber++) {
                var currentlayer = layers[layerNumber];
                1 !== layerNumber || yAxisWillMerge || (visualOptions.forcedYDomain = valueAxisProperties ? [ valueAxisProperties.secStart, valueAxisProperties.secEnd ] : null, 
                visualOptions.valueAxisScaleType = valueAxisProperties && null != valueAxisProperties.secAxisScale ? valueAxisProperties.secAxisScale : DEFAULT_AXIS_SCALE_TYPE, 
                visualOptions.valueAxisDisplayUnits = valueAxisProperties && null != valueAxisProperties.secLabelDisplayUnits ? valueAxisProperties.secLabelDisplayUnits : 0, 
                visualOptions.valueAxisPrecision = valueAxisProperties ? visuals.CartesianHelper.getPrecision(valueAxisProperties.secLabelPrecision) : null), 
                visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                var axes = currentlayer.calculateAxesProperties(visualOptions);
                if (0 === layerNumber) result = {
                    x: axes[0],
                    y1: axes[1]
                }; else if (axes && !result.y2) if (result.x.usingDefaultDomain || _.isEmpty(result.x.dataDomain)) {
                    visualOptions.showValueAxisLabel = !!valueAxisProperties && !!valueAxisProperties.showAxisTitle;
                    var axes_1 = currentlayer.calculateAxesProperties(visualOptions);
                    result.x = axes_1[0], result.y1 = axes_1[1];
                } else currentlayer.overrideXScale(result.x), yAxisWillMerge || axes[1].usingDefaultDomain || (result.y2 = axes[1]);
                if (existingAxisProperties && existingAxisProperties.x) result.x.willLabelsFit = existingAxisProperties.x.willLabelsFit, 
                result.x.willLabelsWordBreak = existingAxisProperties.x.willLabelsWordBreak; else {
                    var width = viewport.width - (margin.left + margin.right);
                    result.x.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(result.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                    result.x.willLabelsWordBreak = !result.x.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(result.x, margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                }
            }
            return result;
        }
        var EnumExtensions = jsCommon.EnumExtensions, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, DEFAULT_AXIS_SCALE_TYPE = visuals.axisScale.linear, COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = .1, INTERACTIVITY_RIGHT_MARGIN = 6;
        visuals.DEFAULT_AXIS_COLOR = "#777";
        var CartesianChart = function() {
            function CartesianChart(options) {
                this.xRefLine = createClassAndSelector("x-ref-line"), this.y1RefLine = createClassAndSelector("y1-ref-line");
                var isScrollable = !1;
                this.trimOrdinalDataOnOverflow = !0, options && (this.tooltipsEnabled = options.tooltipsEnabled, 
                this.type = options.chartType, this.isLabelInteractivityEnabled = options.isLabelInteractivityEnabled, 
                this.lineChartLabelDensityEnabled = options.lineChartLabelDensityEnabled, void 0 !== options.trimOrdinalDataOnOverflow && (this.trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow), 
                options.isScrollable && (isScrollable = options.isScrollable), this.animator = options.animator, 
                options.cartesianSmallViewPortProperties && (this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties), 
                options.behavior && (this.behavior = options.behavior), this.trendLinesEnabled = !!options.trendLinesEnabled), 
                this.axes = new CartesianAxes(isScrollable, ScrollableAxes.ScrollbarWidth, this.trimOrdinalDataOnOverflow), 
                this.svgAxes = new SvgCartesianAxes(this.axes), this.svgBrush = new SvgBrush(ScrollableAxes.ScrollbarWidth), 
                this.scrollableAxes = new ScrollableAxes(this.axes, this.svgBrush);
            }
            return CartesianChart.getAxisVisibility = function(type) {
                switch (type) {
                  case 6:
                  case 5:
                  case 7:
                    return 1;

                  case 9:
                    return 3;

                  default:
                    return 2;
                }
            }, CartesianChart.prototype.init = function(options) {
                this.visualInitOptions = options, this.layers = [];
                var element = this.element = options.element;
                this.currentViewport = options.viewport, this.hostServices = options.host;
                var chartAreaSvg = this.chartAreaSvg = d3.select(element.get(0)).append("svg");
                chartAreaSvg.classed(CartesianChart.ClassName, !0), chartAreaSvg.style("position", "absolute"), 
                this.behavior && (this.clearCatcher = visuals.appendClearCatcher(chartAreaSvg), 
                this.interactivityService = visuals.createInteractivityService(this.hostServices)), 
                null != options.style.maxMarginFactor && this.axes.setMaxMarginFactor(options.style.maxMarginFactor);
                var axisLinesVisibility = CartesianChart.getAxisVisibility(this.type);
                this.axes.setAxisLinesVisibility(axisLinesVisibility), this.svgAxes.init(chartAreaSvg), 
                this.svgBrush.init(chartAreaSvg), this.sharedColorPalette = new SharedColorPalette(options.style.colorPalette.dataColors), 
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, 12 !== this.type ? this.interactivityService : void 0, this.axes.isScrollable), 
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
            }, CartesianChart.prototype.isPlayAxis = function() {
                if (!this.dataViews || !this.dataViews[0]) return !1;
                var dataView = this.dataViews[0], categoryRoleIsPlay = dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.categories[0].source.roles && dataView.categorical.categories[0].source.roles.Play;
                return 9 === this.type && (this.animator || this.isMobileChart) && null != dataView.matrix && (!dataView.categorical || categoryRoleIsPlay);
            }, CartesianChart.getIsScalar = function(objects, propertyId, type) {
                var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                return objects && void 0 !== axisTypeValue ? axisTypeValue === visuals.axisType.scalar && !visuals.AxisHelper.isOrdinal(type) : !visuals.AxisHelper.isOrdinal(type);
            }, CartesianChart.getAdditionalTelemetry = function(dataView) {
                var telemetry = {}, categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
                return categoryColumn && (telemetry.axisType = visuals.CartesianChart.getIsScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type) ? "scalar" : "categorical"), 
                telemetry;
            }, CartesianChart.detectScalarMapping = function(dataViewMapping) {
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return !1;
                var dataViewCategories = dataViewMapping.categorical.categories, categoryItems = dataViewCategories["for"]["in"].items;
                if (_.isEmpty(categoryItems)) return !1;
                var categoryType = categoryItems[0].type;
                if (!dataViewMapping.metadata) return !1;
                var objects = dataViewMapping.metadata.objects;
                return CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType);
            }, CartesianChart.prototype.populateObjectProperties = function(dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    dataViewMetadata ? (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}), 
                    this.xAxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, "xAxisReferenceLine"), 
                    this.y1AxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, "y1AxisReferenceLine")) : this.legendObjectProperties = {}, 
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), 
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                }
            }, CartesianChart.prototype.updateInternal = function(options, dataChanged) {
                var dataViews = this.dataViews = options.dataViews;
                if (this.currentViewport = options.viewport, dataViews) {
                    0 === this.layers.length && (this.layers = this.createAndInitLayers(dataViews));
                    var layers = this.layers;
                    if (dataChanged) {
                        if (!_.isEmpty(dataViews)) {
                            this.populateObjectProperties(dataViews), this.axes.update(dataViews), this.svgAxes.update(this.categoryAxisProperties, this.valueAxisProperties);
                            var dataView = dataViews[0];
                            dataView.metadata && (this.background = {
                                image: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.image),
                                transparency: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.transparency, visuals.visualBackgroundHelper.getDefaultTransparency())
                            });
                        }
                        this.sharedColorPalette.clearPreferredScale();
                        for (var i = 0, len = layers.length; len > i; i++) layers[i].setData(getLayerData(dataViews, i, len)), 
                        len > 1 && this.sharedColorPalette.rotateScale();
                        var shouldAddTrendLayer = this.isTrendPropertySet(dataViews) && dataViews.length > 1;
                        this.trendLine = shouldAddTrendLayer ? visuals.TrendLineHelper.readDataView(dataViews[1]) : void 0;
                    }
                    if (this.render(!this.hasSetData || options.suppressAnimations, options.resizeMode), 
                    this.hasSetData = this.hasSetData || dataViews && dataViews.length > 0, dataViews && dataViews.length > 0) {
                        var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                        this.axes.addWarnings(warnings), warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings);
                    }
                }
            }, CartesianChart.prototype.isTrendPropertySet = function(dataViews) {
                var objects = this.extractMetadataObjects(dataViews);
                return CartesianLayerFactory.shouldAddTrendLayer(objects);
            }, CartesianChart.prototype.onDataChanged = function(options) {
                this.updateInternal({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                }, !0);
            }, CartesianChart.prototype.onResizing = function(viewport, resizeMode) {
                this.updateInternal({
                    dataViews: this.dataViews,
                    suppressAnimations: !0,
                    viewport: viewport,
                    resizeMode: resizeMode
                }, !1);
            }, CartesianChart.prototype.scrollTo = function(position) {
                this.scrollableAxes.scrollTo(position);
            }, CartesianChart.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder(), layersLength = this.layers ? this.layers.length : 0;
                if ("legend" === options.objectName) {
                    if (!this.shouldShowLegendCard()) return;
                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : ""), labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor), fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: fontSize
                        },
                        objectName: options.objectName
                    });
                } else if ("categoryAxis" === options.objectName && this.axes.hasCategoryAxis()) this.getCategoryAxisValues(enumeration); else if ("valueAxis" === options.objectName) this.getValueAxisValues(enumeration); else if ("y1AxisReferenceLine" === options.objectName) {
                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.y1AxisReferenceLines, refLinedefaultColor, options.objectName);
                } else if ("xAxisReferenceLine" === options.objectName) {
                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.xAxisReferenceLines, refLinedefaultColor, options.objectName);
                } else "trend" === options.objectName ? this.trendLinesEnabled && !_.isEmpty(this.layers) && _.all(this.layers, function(layer) {
                    return layer.supportsTrendLine();
                }) && visuals.TrendLineHelper.enumerateObjectInstances(enumeration, this.trendLine) : "plotArea" === options.objectName && visuals.visualBackgroundHelper.enumeratePlot(enumeration, this.background);
                if ("dataPoint" === options.objectName && visuals.ComboChart.isComboChart(this.type)) visuals.ComboChart.enumerateDataPoints(enumeration, options, this.layers); else for (var i = 0, len = layersLength; len > i; i++) {
                    var layer = this.layers[i];
                    layer.enumerateObjectInstances && layer.enumerateObjectInstances(enumeration, options);
                }
                return enumeration.complete();
            }, CartesianChart.prototype.shouldShowLegendCard = function() {
                var layers = this.layers, dataViews = this.dataViews;
                if (layers && dataViews) for (var layersLength = layers.length, layersWithValuesCtr = 0, i = 0; layersLength > i; i++) {
                    if (layers[i].hasLegend()) return !0;
                    var dataView = dataViews[i];
                    if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0 && (layersWithValuesCtr++, 
                    layersWithValuesCtr > 1)) return !0;
                }
                return !1;
            }, CartesianChart.prototype.getAxisScaleOptions = function(axisType) {
                var scaleOptions = [ DEFAULT_AXIS_SCALE_TYPE ];
                return this.axes.isLogScaleAllowed(axisType) && scaleOptions.push(visuals.axisScale.log), 
                scaleOptions;
            }, CartesianChart.prototype.getCategoryAxisValues = function(enumeration) {
                if (this.categoryAxisProperties) {
                    var supportedType = visuals.axisType.both, isScalar = !1, scaleOptions = this.getAxisScaleOptions(0);
                    this.layers && this.layers[0].getSupportedCategoryAxisType && (supportedType = this.layers[0].getSupportedCategoryAxisType(), 
                    isScalar = supportedType === visuals.axisType.scalar ? !0 : visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties)), 
                    isScalar || (this.categoryAxisProperties.start = null, this.categoryAxisProperties.end = null);
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: "categoryAxis",
                        validValues: {
                            axisScale: scaleOptions,
                            axisStyle: this.axes.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                        }
                    };
                    if (instance.properties.show = null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                    this.axes.isYAxisCategorical() && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                    supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                    isScalar && (instance.properties.axisScale = this.categoryAxisProperties.axisScale || DEFAULT_AXIS_SCALE_TYPE, 
                    instance.properties.start = this.categoryAxisProperties.start, instance.properties.end = this.categoryAxisProperties.end), 
                    instance.properties.showAxisTitle = null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !1, 
                    instance.properties.axisStyle = this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly, 
                    instance.properties.labelColor = this.categoryAxisProperties.labelColor || visuals.DEFAULT_AXIS_COLOR, 
                    isScalar) {
                        instance.properties.labelDisplayUnits = this.categoryAxisProperties.labelDisplayUnits ? this.categoryAxisProperties.labelDisplayUnits : 0;
                        var labelPrecision = this.categoryAxisProperties.labelPrecision;
                        instance.properties.labelPrecision = void 0 === labelPrecision || 0 > labelPrecision ? visuals.dataLabelUtils.defaultLabelPrecision : labelPrecision;
                    }
                    enumeration.pushInstance(instance);
                }
            }, CartesianChart.prototype.getValueAxisValues = function(enumeration) {
                if (this.valueAxisProperties) {
                    var scaleOptions = this.getAxisScaleOptions(1), secScaleOption = this.getAxisScaleOptions(2), instance = {
                        selector: null,
                        properties: {},
                        objectName: "valueAxis",
                        validValues: {
                            axisScale: scaleOptions,
                            secAxisScale: secScaleOption,
                            axisStyle: this.axes.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                        }
                    };
                    if (instance.properties.show = null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                    this.axes.isYAxisCategorical() || (instance.properties.position = null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                    instance.properties.axisScale = this.valueAxisProperties.axisScale || DEFAULT_AXIS_SCALE_TYPE, 
                    instance.properties.start = this.valueAxisProperties.start, instance.properties.end = this.valueAxisProperties.end, 
                    instance.properties.showAxisTitle = null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !1, 
                    instance.properties.axisStyle = null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly, 
                    instance.properties.labelColor = this.valueAxisProperties.labelColor || visuals.DEFAULT_AXIS_COLOR, 
                    7 !== this.type && 8 !== this.type) {
                        instance.properties.labelDisplayUnits = this.valueAxisProperties.labelDisplayUnits ? this.valueAxisProperties.labelDisplayUnits : 0;
                        var labelPrecision = this.valueAxisProperties.labelPrecision;
                        instance.properties.labelPrecision = void 0 === labelPrecision || 0 > labelPrecision ? visuals.dataLabelUtils.defaultLabelPrecision : labelPrecision;
                    }
                    if (enumeration.pushInstance(instance), 2 === this.layers.length && (instance.properties.secShow = null != this.valueAxisProperties.secShow ? this.valueAxisProperties.secShow : this.axes.hasY2Axis(), 
                    instance.properties.secShow && (instance.properties.axisLabel = "")), this.axes.hasY2Axis() && instance.properties.secShow) {
                        enumeration.pushContainer({
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_ShowSecondary")
                        });
                        var secInstance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis"
                        };
                        secInstance.properties.secAxisLabel = "", secInstance.properties.secPosition = null != this.valueAxisProperties.secPosition ? this.valueAxisProperties.secPosition : visuals.yAxisPosition.right, 
                        secInstance.properties.secAxisScale = this.valueAxisProperties.secAxisScale || DEFAULT_AXIS_SCALE_TYPE, 
                        secInstance.properties.secStart = this.valueAxisProperties.secStart, secInstance.properties.secEnd = this.valueAxisProperties.secEnd, 
                        secInstance.properties.secShowAxisTitle = null != this.valueAxisProperties.secShowAxisTitle ? this.valueAxisProperties.secShowAxisTitle : !1, 
                        enumeration.pushInstance(secInstance).pushInstance({
                            selector: null,
                            properties: {
                                secAxisStyle: this.valueAxisProperties.secAxisStyle ? this.valueAxisProperties.secAxisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.valueAxisProperties.secLabelColor,
                                secLabelDisplayUnits: this.valueAxisProperties.secLabelDisplayUnits ? this.valueAxisProperties.secLabelDisplayUnits : 0,
                                secLabelPrecision: this.valueAxisProperties.secLabelPrecision < 0 ? 0 : this.valueAxisProperties.secLabelPrecision
                            },
                            objectName: "valueAxis",
                            validValues: {
                                secAxisStyle: this.axes.secondaryValueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ],
                                axisScale: scaleOptions
                            }
                        }), enumeration.popContainer();
                    }
                }
            }, CartesianChart.prototype.onClearSelection = function() {
                if (this.hasSetData) for (var i = 0, len = this.layers.length; len > i; i++) {
                    var layer = this.layers[i];
                    layer.onClearSelection(), layer.render(!0);
                }
            }, CartesianChart.prototype.extractMetadataObjects = function(dataViews) {
                var objects;
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    dataViewMetadata && (objects = dataViewMetadata.objects);
                }
                return objects;
            }, CartesianChart.prototype.createAndInitLayers = function(dataViews) {
                var _this = this, objects = this.extractMetadataObjects(dataViews), layers = CartesianLayerFactory.createLayers(this.type, objects, this.interactivityService, this.animator, this.axes.isScrollable, this.tooltipsEnabled, this.lineChartLabelDensityEnabled), cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                cartesianOptions.svg = this.svgAxes.getScrollableRegion(), cartesianOptions.labelsContext = this.svgAxes.getLabelsRegion(), 
                cartesianOptions.cartesianHost = {
                    updateLegend: function(data) {
                        return _this.legend.drawLegend(data, _this.currentViewport);
                    },
                    getSharedColors: function() {
                        return _this.sharedColorPalette;
                    },
                    triggerRender: function(suppressAnimations) {
                        return _this.render(suppressAnimations);
                    }
                }, cartesianOptions.chartType = this.type;
                for (var i = 0, len = layers.length; len > i; i++) layers[i].init(cartesianOptions);
                return layers;
            }, CartesianChart.prototype.renderLegend = function() {
                for (var layers = this.layers, legendData = {
                    title: "",
                    dataPoints: []
                }, i = 0, len = layers.length; len > i; i++) this.layerLegendData = layers[i].calculateLegend(), 
                this.layerLegendData && (legendData.title = 0 === i ? this.layerLegendData.title || "" : legendData.title, 
                legendData.labelColor = this.layerLegendData.labelColor, legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                legendData.fontSize = this.layerLegendData.fontSize || visuals.SVGLegend.DefaultFontSizeInPt, 
                this.layerLegendData.grouped && (legendData.grouped = !0));
                var legendProperties = this.legendObjectProperties;
                if (legendProperties) {
                    visuals.LegendData.update(legendData, legendProperties);
                    var position = legendProperties[visuals.legendProps.position];
                    position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []), 
                this.legend.drawLegend(legendData, this.currentViewport);
            }, CartesianChart.prototype.hideLegends = function() {
                return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
            }, CartesianChart.prototype.render = function(suppressAnimations, resizeMode) {
                var _this = this;
                this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend || this.renderLegend();
                var playAxisControlLayout, legendMargins = this.legendMargins = this.legend.getMargins(), legendOrientation = this.legend.getOrientation(), hideAxisLabels = this.hideAxisLabels(legendMargins), plotAreaViewport = {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                }, padding = powerbi.Prototype.inherit(SvgCartesianAxes.AxisPadding);
                this.isPlayAxis() && (plotAreaViewport.height -= CartesianChart.PlayAxisBottomMargin, 
                playAxisControlLayout = {
                    left: visuals.Legend.isLeft(legendOrientation) ? legendMargins.width : 0,
                    top: visuals.Legend.isTop(legendOrientation) ? legendMargins.height + plotAreaViewport.height : plotAreaViewport.height,
                    height: CartesianChart.PlayAxisBottomMargin,
                    width: plotAreaViewport.width
                }), this.chartAreaSvg.attr({
                    width: plotAreaViewport.width,
                    height: plotAreaViewport.height
                }), visuals.Legend.positionChartArea(this.chartAreaSvg, this.legend);
                var interactivityRightMargin = this.calculateInteractivityRightMargin(), _a = this.getMinimumDomainExtents(), ensureXDomain = _a[0], ensureYDomain = _a[1], axesLayout = this.axes.negotiateAxes(this.layers, plotAreaViewport, padding, playAxisControlLayout, hideAxisLabels, CartesianChart.TextProperties, interactivityRightMargin, ensureXDomain, ensureYDomain), plotAreaHasChanged = !this.renderedPlotArea || this.renderedPlotArea.height !== axesLayout.plotArea.height || this.renderedPlotArea.width !== axesLayout.plotArea.width;
                suppressAnimations = suppressAnimations || plotAreaHasChanged, this.scrollableAxes.render(axesLayout, this.layers, suppressAnimations, function(layers, axesLayout, suppressAnimations) {
                    return _this.renderPlotArea(layers, axesLayout, suppressAnimations, legendMargins, resizeMode);
                }), this.renderedPlotArea = axesLayout.plotArea;
            }, CartesianChart.prototype.getMinimumDomainExtents = function() {
                var xs = [], ys = [];
                if (!_.isEmpty(this.xAxisReferenceLines)) {
                    var xAxisReferenceLineProperties = this.xAxisReferenceLines[0].object, value = visuals.ReferenceLineHelper.extractReferenceLineValue(xAxisReferenceLineProperties);
                    xs.push(value);
                }
                if (!_.isEmpty(this.y1AxisReferenceLines)) {
                    var y1AxisReferenceLineProperties = this.y1AxisReferenceLines[0].object, value = visuals.ReferenceLineHelper.extractReferenceLineValue(y1AxisReferenceLineProperties);
                    ys.push(value);
                }
                this.trendLine && !_.isEmpty(this.trendLine.points) && (xs = xs.concat(_.map(this.trendLine.points, function(p) {
                    return p.x;
                })), ys = ys.concat(_.map(this.trendLine.points, function(p) {
                    return p.y;
                })));
                var ensureXDomain = {
                    min: d3.min(xs),
                    max: d3.max(xs)
                }, ensureYDomain = {
                    min: d3.min(ys),
                    max: d3.max(ys)
                };
                return [ ensureXDomain, ensureYDomain ];
            }, CartesianChart.prototype.getPlotAreaRect = function(axesLayout, legendMargins) {
                var rect = {
                    left: axesLayout.margin.left,
                    top: axesLayout.margin.top,
                    width: axesLayout.plotArea.width,
                    height: axesLayout.plotArea.height
                };
                if (this.legend) {
                    var legendPosition_1 = this.legend.getOrientation();
                    visuals.Legend.isTop(legendPosition_1) ? rect.top += legendMargins.height : visuals.Legend.isLeft(legendPosition_1) && (rect.left += legendMargins.width);
                }
                return rect;
            }, CartesianChart.prototype.renderBackgroundImage = function(layout) {
                visuals.visualBackgroundHelper.renderBackgroundImage(this.background, this.element, layout);
            }, CartesianChart.prototype.hideAxisLabels = function(legendMargins) {
                return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.visualInitOptions.interactivity.isInteractiveLegend);
            }, CartesianChart.prototype.calculateInteractivityRightMargin = function() {
                return this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend && !this.trimOrdinalDataOnOverflow ? INTERACTIVITY_RIGHT_MARGIN : 0;
            }, CartesianChart.prototype.renderPlotArea = function(layers, axesLayout, suppressAnimations, legendMargins, resizeMode) {
                var axes = axesLayout.axes, plotArea = axesLayout.plotArea, plotAreaRect = this.getPlotAreaRect(axesLayout, legendMargins), duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.renderBackgroundImage(plotAreaRect), this.svgAxes.renderAxes(axesLayout, duration), 
                this.renderReferenceLines(axesLayout), this.renderLayers(layers, plotArea, axes, suppressAnimations, resizeMode), 
                this.renderTrendLine(axesLayout);
            }, CartesianChart.prototype.renderTrendLine = function(axesLayout) {
                var scrollableRegion = this.svgAxes.getScrollableRegion();
                visuals.TrendLineHelper.render(this.trendLine, scrollableRegion, axesLayout.axes, axesLayout.plotArea);
            }, CartesianChart.prototype.renderReferenceLines = function(axesLayout) {
                var axes = axesLayout.axes, plotArea = axesLayout.plotArea, scrollableRegion = this.svgAxes.getScrollableRegion(), refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value, showY1ReferenceLines = !1;
                if (this.y1AxisReferenceLines) for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                    var referenceLineProperties = _a[_i], object = referenceLineProperties.object;
                    if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                        var isHorizontal = !axes.y1.isCategoryAxis, y1RefLineOptions = {
                            graphicContext: scrollableRegion,
                            referenceLineProperties: object,
                            axes: axes,
                            viewport: plotArea,
                            classAndSelector: this.y1RefLine,
                            defaultColor: refLineDefaultColor,
                            isHorizontal: isHorizontal
                        };
                        visuals.ReferenceLineHelper.render(y1RefLineOptions), showY1ReferenceLines = !0;
                    }
                }
                showY1ReferenceLines || scrollableRegion.selectAll(this.y1RefLine.selector).remove();
                var showXReferenceLines = !1;
                if (this.xAxisReferenceLines) for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                    var referenceLineProperties = _c[_b], object = referenceLineProperties.object;
                    if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                        var isHorizontal = !1, xRefLineOptions = {
                            graphicContext: scrollableRegion,
                            referenceLineProperties: object,
                            axes: axes,
                            viewport: plotArea,
                            classAndSelector: this.xRefLine,
                            defaultColor: refLineDefaultColor,
                            isHorizontal: isHorizontal
                        };
                        visuals.ReferenceLineHelper.render(xRefLineOptions), showXReferenceLines = !0;
                    }
                }
                showXReferenceLines || scrollableRegion.selectAll(this.xRefLine.selector).remove();
            }, CartesianChart.prototype.getReferenceLineLabels = function(axes, plotArea) {
                var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value, referenceLineLabels = [];
                if (this.y1AxisReferenceLines) for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                    var referenceLineProperties = _a[_i], object = referenceLineProperties.object;
                    if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                        var isHorizontal = !axes.y1.isCategoryAxis, y1RefLineLabelOptions = {
                            referenceLineProperties: object,
                            axes: axes,
                            viewport: plotArea,
                            defaultColor: refLineDefaultColor,
                            isHorizontal: isHorizontal,
                            key: JSON.stringify({
                                type: "y1AxisReferenceLine",
                                id: referenceLineProperties.id
                            })
                        };
                        referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(y1RefLineLabelOptions));
                    }
                }
                if (this.xAxisReferenceLines) for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                    var referenceLineProperties = _c[_b], object = referenceLineProperties.object;
                    if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                        var isHorizontal = !1, xRefLineLabelOptions = {
                            referenceLineProperties: object,
                            axes: axes,
                            viewport: plotArea,
                            defaultColor: refLineDefaultColor,
                            isHorizontal: isHorizontal,
                            key: JSON.stringify({
                                type: "xAxisReferenceLine",
                                id: referenceLineProperties.id
                            })
                        };
                        referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(xRefLineLabelOptions));
                    }
                }
                return referenceLineLabels;
            }, CartesianChart.prototype.renderDataLabels = function(labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, isCombo) {
                var labelBackgroundRegion = this.svgAxes.getLabelBackground(), labelRegion = this.svgAxes.getLabelsRegion();
                if (this.behavior) {
                    var labelLayoutOptions = visuals.NewDataLabelUtils.getDataLabelLayoutOptions(this.type), labelLayout = new powerbi.LabelLayout(labelLayoutOptions), dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                    isCombo && visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", .7);
                    var svgLabels = void 0;
                    if (this.animator && !suppressAnimations) {
                        var isPlayAxis = this.isPlayAxis(), duration = isPlayAxis ? visuals.PlayChart.FrameAnimationDuration : this.animator.getDuration();
                        svgLabels = visuals.NewDataLabelUtils.animateDefaultLabels(labelRegion, dataLabels, duration, labelsAreNumeric, isPlayAxis ? "linear" : void 0);
                    } else svgLabels = visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                    if (labelLayoutOptions.allowLeaderLines) {
                        var filteredLabels = _.filter(dataLabels, function(d) {
                            return null != d.leaderLinePoints && !_.isEmpty(d.leaderLinePoints) && null != d.identity;
                        });
                        visuals.NewDataLabelUtils.drawLabelLeaderLines(labelRegion, filteredLabels, function(d) {
                            return d.identity.getKey();
                        });
                    }
                    if (this.interactivityService && this.isLabelInteractivityEnabled) {
                        var labelsBehaviorOptions = {
                            labelItems: svgLabels
                        };
                        this.interactivityService.bind(dataLabels, new visuals.LabelsBehavior(), labelsBehaviorOptions, {
                            isLabels: !0
                        });
                    }
                } else {
                    var labelLayout = new powerbi.LabelLayout({
                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset,
                        attemptToMoveLabelsIntoViewport: !0
                    }), dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                    isCombo && visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", .7), 
                    visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                }
            }, CartesianChart.prototype.renderLayers = function(layers, plotArea, axes, suppressAnimations, resizeMode) {
                for (var labelDataPointGroups = [], dataPoints = [], layerBehaviorOptions = [], labelsAreNumeric = !0, i = 0, len = layers.length; len > i; i++) {
                    var result = layers[i].render(suppressAnimations, resizeMode);
                    if (result) {
                        if (this.behavior && (dataPoints = dataPoints.concat(result.dataPoints), layerBehaviorOptions.push(result.behaviorOptions)), 
                        result.labelDataPointGroups) for (var resultLabelDataPointsGroups = result.labelDataPointGroups, _i = 0, resultLabelDataPointsGroups_1 = resultLabelDataPointsGroups; _i < resultLabelDataPointsGroups_1.length; _i++) {
                            var resultLabelDataPointsGroup = resultLabelDataPointsGroups_1[_i];
                            resultLabelDataPointsGroup && labelDataPointGroups.push({
                                labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultLabelDataPointsGroup.labelDataPoints || []),
                                maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels
                            });
                        } else {
                            var resultsLabelDataPoints = result.labelDataPoints || [];
                            labelDataPointGroups.push({
                                labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultsLabelDataPoints),
                                maxNumberOfLabels: resultsLabelDataPoints.length
                            });
                        }
                        labelsAreNumeric = labelsAreNumeric && result.labelsAreNumeric;
                    }
                }
                var referenceLineLabels = this.getReferenceLineLabels(axes, plotArea);
                if (_.isEmpty(referenceLineLabels) || labelDataPointGroups.unshift({
                    labelDataPoints: referenceLineLabels,
                    maxNumberOfLabels: referenceLineLabels.length
                }), this.renderDataLabels(labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, visuals.ComboChart.isComboChart(this.type)), 
                this.interactivityService) {
                    var behaviorOptions = {
                        layerOptions: layerBehaviorOptions,
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                }
            }, CartesianChart.getPreferredPlotArea = function(categoryCount, categoryThickness, viewport, isScrollable, isScalar, margin, noOuterPadding) {
                margin || (margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                });
                var plotArea = {
                    height: viewport.height - margin.top - margin.bottom,
                    width: viewport.width - margin.left - margin.right
                };
                if (!isScalar && isScrollable) {
                    var preferredCategorySpan = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness, noOuterPadding);
                    plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                }
                return plotArea;
            }, CartesianChart.getPreferredCategorySpan = function(categoryCount, categoryThickness, noOuterPadding) {
                var span = categoryThickness * categoryCount;
                return noOuterPadding ? span : span + categoryThickness * CartesianChart.OuterPaddingRatio * 2;
            }, CartesianChart.getLayout = function(data, options) {
                var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable, categoryThickness = CartesianChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar, trimOrdinalDataOnOverflow), totalOuterPadding = categoryThickness * CartesianChart.OuterPaddingRatio * 2, calculatedBarCount = powerbi.Double.floorWithPrecision((availableWidth - totalOuterPadding) / categoryThickness), visibleCategoryCount = Math.min(calculatedBarCount, categoryCount), willScroll = categoryCount > visibleCategoryCount && isScrollable, outerPaddingRatio = CartesianChart.OuterPaddingRatio;
                if (!isScalar && !willScroll) {
                    var oneOuterPadding = (availableWidth - categoryThickness * visibleCategoryCount) / 2;
                    outerPaddingRatio = oneOuterPadding / categoryThickness;
                }
                return !isScalar && isScrollable && (visibleCategoryCount = categoryCount), {
                    categoryCount: visibleCategoryCount,
                    categoryThickness: categoryThickness,
                    outerPaddingRatio: outerPaddingRatio,
                    isScalar: isScalar
                };
            }, CartesianChart.getCategoryThickness = function(seriesList, numCategories, plotLength, domain, isScalar, trimOrdinalDataOnOverflow) {
                var thickness;
                if (2 > numCategories) thickness = plotLength * (1 - CartesianChart.OuterPaddingRatio); else if (isScalar && domain && domain.length > 1) {
                    var minInterval = CartesianChart.getMinInterval(seriesList), domainSpan = domain[domain.length - 1] - domain[0], ratio = minInterval / (domainSpan + minInterval * CartesianChart.OuterPaddingRatio * 2);
                    thickness = plotLength * ratio, thickness = Math.max(thickness, CartesianChart.MinScalarRectThickness);
                } else thickness = plotLength / (numCategories + 2 * CartesianChart.OuterPaddingRatio), 
                trimOrdinalDataOnOverflow && (thickness = Math.max(thickness, CartesianChart.MinOrdinalRectThickness));
                var maxRectThickness = plotLength / (3 + 2 * CartesianChart.OuterPaddingRatio);
                return thickness = Math.min(thickness, maxRectThickness), !isScalar && numCategories >= 3 && trimOrdinalDataOnOverflow ? Math.max(thickness, CartesianChart.MinOrdinalRectThickness) : thickness;
            }, CartesianChart.getMinInterval = function(seriesList) {
                var minInterval = Number.MAX_VALUE;
                if (seriesList.length > 0) for (var series0data = seriesList[0].data.filter(function(d) {
                    return !d.highlight;
                }), i = 0, ilen = series0data.length - 1; ilen > i; i++) minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
                return minInterval;
            }, CartesianChart.MinOrdinalRectThickness = 20, CartesianChart.MinScalarRectThickness = 2, 
            CartesianChart.OuterPaddingRatio = .4, CartesianChart.InnerPaddingRatio = .2, CartesianChart.TickLabelPadding = 2, 
            CartesianChart.ClassName = "cartesianChart", CartesianChart.PlayAxisBottomMargin = 80, 
            CartesianChart.FontSize = 11, CartesianChart.FontSizeString = jsCommon.PixelConverter.toString(CartesianChart.FontSize), 
            CartesianChart.TextProperties = {
                fontFamily: "wf_segoe-ui_normal",
                fontSize: CartesianChart.FontSizeString
            }, CartesianChart;
        }();
        visuals.CartesianChart = CartesianChart;
        var SvgBrush = function() {
            function SvgBrush(brushWidth) {
                this.brush = d3.svg.brush(), this.brushWidth = brushWidth;
            }
            return SvgBrush.prototype.init = function(element) {
                this.element = element;
            }, SvgBrush.prototype.remove = function() {
                this.element.selectAll(SvgBrush.Brush.selector).remove(), this.brushGraphicsContext = void 0;
            }, SvgBrush.prototype.getExtent = function() {
                return this.brush.extent();
            }, SvgBrush.prototype.setExtent = function(extent) {
                this.brush.extent(extent);
            }, SvgBrush.prototype.setScale = function(scale) {
                this.isHorizontal ? this.brush.x(scale) : this.brush.y(scale);
            }, SvgBrush.prototype.setOrientation = function(isHorizontal) {
                this.isHorizontal = isHorizontal;
            }, SvgBrush.prototype.renderBrush = function(extentLength, brushX, brushY, scrollCallback) {
                var _this = this;
                this.brushGraphicsContext || (this.brushGraphicsContext = this.element.append("g").classed(SvgBrush.Brush["class"], !0)), 
                this.scrollCallback = scrollCallback, this.brush.on("brush", function() {
                    return window.requestAnimationFrame(scrollCallback);
                }).on("brushend", function() {
                    return _this.resizeExtent(extentLength, _this.isHorizontal);
                });
                var brushContext = this.brushContext = this.brushGraphicsContext.attr({
                    transform: visuals.SVGUtil.translate(brushX, brushY),
                    "drag-resize-disabled": "true"
                }).call(this.brush);
                brushContext.selectAll(".resize rect").remove(), brushContext.select(".background").style("cursor", "default"), 
                brushContext.selectAll(".extent").style({
                    "fill-opacity": SvgBrush.FillOpacity,
                    cursor: "default"
                }), this.isHorizontal ? brushContext.selectAll("rect").attr("height", this.brushWidth) : brushContext.selectAll("rect").attr("width", this.brushWidth);
            }, SvgBrush.prototype.scroll = function() {
                this.scrollCallback();
            }, SvgBrush.prototype.resizeExtent = function(extentLength, isHorizontal) {
                var brushContext = this.brushContext;
                isHorizontal ? brushContext.select(".extent").attr("width", extentLength) : brushContext.select(".extent").attr("height", extentLength);
            }, SvgBrush.Brush = createClassAndSelector("brush"), SvgBrush.FillOpacity = .125, 
            SvgBrush;
        }(), ScrollableAxes = function() {
            function ScrollableAxes(axes, svgBrush) {
                this.axes = axes, this.brush = svgBrush;
            }
            return ScrollableAxes.prototype.filterDataToViewport = function(mainAxisScale, layers, axes, scrollScale, extent, visibleCategoryCount) {
                if (scrollScale) {
                    var selected = void 0, data_1 = [], startIndex = visuals.AxisHelper.lookupOrdinalIndex(scrollScale, extent[0]), endIndex = startIndex + visibleCategoryCount, domain = scrollScale.domain();
                    if (selected = domain.slice(startIndex, endIndex), selected && selected.length > 0) {
                        for (var i = 0; i < layers.length; i++) data_1[i] = layers[i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
                        mainAxisScale.domain(selected);
                        var axisPropsToUpdate = void 0;
                        axisPropsToUpdate = this.axes.isXScrollBarVisible ? axes.x : axes.y1, axisPropsToUpdate.axis.scale(mainAxisScale), 
                        axisPropsToUpdate.scale(mainAxisScale), axisPropsToUpdate.axis.ticks(selected.length), 
                        axisPropsToUpdate.axis.tickValues(selected);
                        var tickFormat_1 = axisPropsToUpdate.axis.tickFormat();
                        axisPropsToUpdate.values = _.map(selected, function(d) {
                            return tickFormat_1(d);
                        });
                    }
                }
            }, ScrollableAxes.prototype.render = function(axesLayout, layers, suppressAnimations, renderDelegate) {
                var _this = this, plotArea = axesLayout.plotArea;
                if (!(plotArea.width < 1 || plotArea.height < 1)) {
                    var axisScale, brushX, brushY, scrollbarLength, numVisibleCategories, categoryThickness, newAxisLength;
                    if (this.axes.isXScrollBarVisible) {
                        axisScale = axesLayout.axes.x.scale, brushX = axesLayout.margin.left, brushY = axesLayout.viewport.height, 
                        categoryThickness = axesLayout.axes.x.categoryThickness;
                        var outerPadding = axesLayout.axes.x.outerPadding;
                        numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.width - 2 * outerPadding) / categoryThickness), 
                        scrollbarLength = (numVisibleCategories + 1) * categoryThickness, newAxisLength = plotArea.width;
                    } else {
                        if (!this.axes.isYScrollBarVisible) return this.brush.remove(), void renderDelegate(layers, axesLayout, suppressAnimations);
                        axisScale = axesLayout.axes.y1.scale, brushX = axesLayout.viewport.width, brushY = axesLayout.margin.top, 
                        categoryThickness = axesLayout.axes.y1.categoryThickness;
                        var outerPadding = axesLayout.axes.y1.outerPadding;
                        numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.height - 2 * outerPadding) / categoryThickness), 
                        scrollbarLength = (numVisibleCategories + 1) * categoryThickness, newAxisLength = plotArea.height;
                    }
                    if (!(1 > numVisibleCategories)) {
                        this.scrollScale = axisScale.copy(), this.scrollScale.rangeBands([ 0, scrollbarLength ]), 
                        this.brushMinExtent = this.scrollScale(numVisibleCategories - 1), axisScale.rangeBands([ 0, newAxisLength ], CartesianChart.InnerPaddingRatio, CartesianChart.OuterPaddingRatio), 
                        this.brush.setOrientation(this.axes.isXScrollBarVisible), this.brush.setScale(this.scrollScale), 
                        this.brush.setExtent([ 0, this.brushMinExtent ]);
                        var renderOnScroll = function(extent, suppressAnimations) {
                            _this.filterDataToViewport(axisScale, layers, axesLayout.axes, _this.scrollScale, extent, numVisibleCategories), 
                            renderDelegate(layers, axesLayout, suppressAnimations);
                        }, scrollCallback = function() {
                            return _this.onBrushed(scrollbarLength, renderOnScroll);
                        };
                        this.brush.renderBrush(this.brushMinExtent, brushX, brushY, scrollCallback), renderOnScroll(this.brush.getExtent(), suppressAnimations);
                    }
                }
            }, ScrollableAxes.prototype.scrollTo = function(position) {
                var extent = this.brush.getExtent(), extentLength = extent[1] - extent[0], halfCategoryThickness = (this.scrollScale(1) - this.scrollScale(0)) / 2;
                extent[0] = this.scrollScale(position) + halfCategoryThickness, extent[1] = extent[0] + extentLength + halfCategoryThickness, 
                this.brush.setExtent(extent);
                var scrollbarLength = this.scrollScale.rangeExtent()[1];
                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent), 
                this.brush.scroll();
            }, ScrollableAxes.prototype.onBrushed = function(scrollbarLength, render) {
                var brush = this.brush;
                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
                var extent = brush.getExtent();
                render(extent, !0);
            }, ScrollableAxes.clampBrushExtent = function(brush, scrollbarLength, minExtent) {
                var extent = brush.getExtent(), width = extent[1] - extent[0];
                if (!(width === minExtent && extent[1] <= scrollbarLength && extent[0] >= 0)) {
                    if (width > minExtent) {
                        var padding = (width - minExtent) / 2;
                        extent[0] += padding, extent[1] -= padding;
                    } else if (minExtent > width) {
                        var padding = (minExtent - width) / 2;
                        extent[0] -= padding, extent[1] += padding;
                    }
                    extent[0] < 0 ? (extent[0] = 0, extent[1] = minExtent) : extent[0] > scrollbarLength - minExtent && (extent[0] = scrollbarLength - minExtent, 
                    extent[1] = scrollbarLength), brush.setExtent(extent);
                }
            }, ScrollableAxes.ScrollbarWidth = 10, ScrollableAxes;
        }(), SvgCartesianAxes = function() {
            function SvgCartesianAxes(axes) {
                this.axes = axes;
            }
            return SvgCartesianAxes.prototype.getScrollableRegion = function() {
                return this.axisGraphicsContextScrollable;
            }, SvgCartesianAxes.prototype.getLabelsRegion = function() {
                return this.labelRegion;
            }, SvgCartesianAxes.prototype.getLabelBackground = function() {
                return this.labelBackgroundRegion;
            }, SvgCartesianAxes.prototype.getXAxis = function() {
                return this.xAxisGraphicsContext;
            }, SvgCartesianAxes.prototype.getY1Axis = function() {
                return this.y1AxisGraphicsContext;
            }, SvgCartesianAxes.prototype.getY2Axis = function() {
                return this.y2AxisGraphicsContext;
            }, SvgCartesianAxes.prototype.update = function(categoryAxisProperties, valueAxisProperties) {
                this.categoryAxisProperties = categoryAxisProperties, this.valueAxisProperties = valueAxisProperties;
            }, SvgCartesianAxes.prototype.init = function(svg) {
                var axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(SvgCartesianAxes.AxisGraphicsContext["class"], !0);
                this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(SvgCartesianAxes.AxisGraphicsContext["class"], !0);
                this.labelBackgroundRegion = this.svgScrollable.append("g").classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass["class"], !0), 
                this.labelRegion = this.svgScrollable.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0);
                var showLinesOnX = this.axes.showLinesOnX, showLinesOnY = this.axes.showLinesOnY, scrollX = showLinesOnY, scrollY = !scrollX;
                scrollY ? (this.y1AxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "y axis"), 
                this.y2AxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "y axis")) : (this.y1AxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "y axis"), 
                this.y2AxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "y axis")), 
                scrollX ? this.xAxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "x axis") : this.xAxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "x axis"), 
                this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), 
                this.y2AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.y2AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY);
            }, SvgCartesianAxes.updateAnimatedTickTooltips = function(axisSelection, values) {
                axisSelection.each("end", function() {
                    d3.select(this).selectAll("text").append("title").text(function(d, i) {
                        return values[i];
                    });
                });
            }, SvgCartesianAxes.updateTickTooltips = function(axisSelection, values) {
                axisSelection.selectAll("text").append("title").text(function(d, i) {
                    return values[i];
                });
            }, SvgCartesianAxes.prototype.renderAxes = function(axesLayout, duration) {
                var xLabelColor, yLabelColor, y2LabelColor, marginLimits = axesLayout.marginLimits, plotArea = axesLayout.plotArea, viewport = axesLayout.viewport, margin = axesLayout.margin, axes = axesLayout.axes, tickLabelMargins = axesLayout.tickLabelMargins, bottomMarginLimit = marginLimits.bottom, leftRightMarginLimit = marginLimits.left;
                if (this.axes.shouldRenderAxis(axes.x)) {
                    xLabelColor = axes.x.isCategoryAxis ? this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null : this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                    axes.x.axis.orient("bottom"), !axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale) && axes.x.axis.tickPadding(SvgCartesianAxes.TickPaddingRotatedX);
                    var xAxisGraphicsElement = this.xAxisGraphicsContext;
                    duration ? xAxisGraphicsElement.transition().duration(duration).call(axes.x.axis).call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.x.values) : xAxisGraphicsElement.call(axes.x.axis), 
                    xAxisGraphicsElement.call(SvgCartesianAxes.darkenZeroLine).call(SvgCartesianAxes.setAxisLabelColor, xLabelColor);
                    var xAxisTextNodes = xAxisGraphicsElement.selectAll("text");
                    axes.x.willLabelsWordBreak ? xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, axes.x, bottomMarginLimit) : xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.svgEllipsis, !axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale), bottomMarginLimit === tickLabelMargins.xMax, axes.x, margin, this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible), 
                    duration || SvgCartesianAxes.updateTickTooltips(xAxisGraphicsElement, axes.x.values);
                } else this.xAxisGraphicsContext.selectAll("*").remove();
                if (this.axes.shouldRenderAxis(axes.y1)) {
                    yLabelColor = axes.y1.isCategoryAxis ? this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null : this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null;
                    var showY1OnRight = this.axes.shouldShowY1OnRight(), y1TickPadding = showY1OnRight ? axesLayout.tickPadding.right : axesLayout.tickPadding.left;
                    axes.y1.axis.tickSize(-plotArea.width).tickPadding(y1TickPadding).orient(this.axes.getYAxisOrientation().toLowerCase());
                    var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                    if (duration ? y1AxisGraphicsElement.transition().duration(duration).call(axes.y1.axis).call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y1.values) : y1AxisGraphicsElement.call(axes.y1.axis), 
                    y1AxisGraphicsElement.call(SvgCartesianAxes.darkenZeroLine).call(SvgCartesianAxes.setAxisLabelColor, yLabelColor), 
                    tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - y1TickPadding, powerbi.TextMeasurementService.svgEllipsis), 
                    duration || SvgCartesianAxes.updateTickTooltips(y1AxisGraphicsElement, axes.y1.values), 
                    !axes.y2 || this.valueAxisProperties && null != this.valueAxisProperties.secShow && !this.valueAxisProperties.secShow) this.y2AxisGraphicsContext.selectAll("*").remove(); else {
                        y2LabelColor = this.valueAxisProperties && this.valueAxisProperties.secLabelColor ? this.valueAxisProperties.secLabelColor : null;
                        var y2TickPadding = showY1OnRight ? axesLayout.tickPadding.left : axesLayout.tickPadding.right;
                        axes.y2.axis.tickSize(SvgCartesianAxes.Y2TickSize).tickPadding(y2TickPadding).orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
                        var y2AxisGraphicsElement = this.y2AxisGraphicsContext;
                        duration ? y2AxisGraphicsElement.transition().duration(duration).call(axes.y2.axis).call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y2.values) : y2AxisGraphicsElement.call(axes.y2.axis), 
                        y2AxisGraphicsElement.call(SvgCartesianAxes.darkenZeroLine).call(SvgCartesianAxes.setAxisLabelColor, y2LabelColor), 
                        tickLabelMargins.yRight >= leftRightMarginLimit && y2AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - y2TickPadding, powerbi.TextMeasurementService.svgEllipsis), 
                        duration || SvgCartesianAxes.updateTickTooltips(y2AxisGraphicsElement, axes.y2.values);
                    }
                } else this.y1AxisGraphicsContext.selectAll("*").remove(), this.y2AxisGraphicsContext.selectAll("*").remove();
                var axisLabels = axesLayout.axisLabels, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2;
                if (chartHasAxisLabels) {
                    var hideXAxisTitle = !this.axes.shouldRenderAxisTitle(axes.x, !0, !1), hideYAxisTitle = !this.axes.shouldRenderAxisTitle(axes.y1, !0, !1), hideY2AxisTitle = !this.axes.shouldRenderAxisTitle(axes.y2, !1, !0), renderAxisOptions = {
                        axisLabels: axisLabels,
                        viewport: viewport,
                        margin: margin,
                        hideXAxisTitle: hideXAxisTitle,
                        hideYAxisTitle: hideYAxisTitle,
                        hideY2AxisTitle: hideY2AxisTitle,
                        xLabelColor: xLabelColor,
                        yLabelColor: yLabelColor,
                        y2LabelColor: y2LabelColor,
                        fontSize: SvgCartesianAxes.AxisLabelFontSize
                    };
                    this.renderAxesLabels(renderAxisOptions);
                } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                this.translateAxes(viewport, margin);
            }, SvgCartesianAxes.prototype.renderAxesLabels = function(options) {
                this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                var margin = options.margin, width = options.viewport.width - (margin.left + margin.right), height = options.viewport.height, fontSize = options.fontSize, heightOffset = fontSize, showOnRight = this.axes.shouldShowY1OnRight();
                if (!options.hideXAxisTitle) {
                    var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.x).call(function(text) {
                        text.each(function() {
                            var text = d3.select(this);
                            text.attr({
                                "class": "xAxisLabel",
                                transform: visuals.SVGUtil.translate(width / 2, height - heightOffset)
                            });
                        });
                    });
                    xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null), 
                    xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis).call(visuals.tooltipUtils.tooltipUpdate, [ options.axisLabels.x ]);
                }
                if (!options.hideYAxisTitle) {
                    var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y).call(function(text) {
                        text.each(function() {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                transform: "rotate(-90)",
                                y: showOnRight ? width + margin.right - fontSize : -margin.left,
                                x: -((height - margin.top - margin.bottom) / 2),
                                dy: "1em"
                            });
                        });
                    });
                    yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null), 
                    yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis).call(visuals.tooltipUtils.tooltipUpdate, [ options.axisLabels.y ]);
                }
                if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                    var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y2).call(function(text) {
                        text.each(function() {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                transform: "rotate(-90)",
                                y: showOnRight ? -margin.left : width + margin.right - fontSize,
                                x: -((height - margin.top - margin.bottom) / 2),
                                dy: "1em"
                            });
                        });
                    });
                    y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null), 
                    y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis).call(visuals.tooltipUtils.tooltipUpdate, [ options.axisLabels.y2 ]);
                }
            }, SvgCartesianAxes.prototype.translateAxes = function(viewport, margin) {
                var width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), showY1OnRight = this.axes.shouldShowY1OnRight();
                this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, height)), 
                this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0)), 
                this.y2AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0)), 
                this.svgScrollable.attr({
                    x: 0,
                    width: viewport.width,
                    height: viewport.height
                }), this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                this.labelRegion.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                this.labelBackgroundRegion.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                this.axes.isXScrollBarVisible ? (this.svgScrollable.attr({
                    x: margin.left
                }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                this.labelRegion.attr("transform", visuals.SVGUtil.translate(0, margin.top)), this.labelBackgroundRegion.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                this.svgScrollable.attr("width", width)) : this.axes.isYScrollBarVisible && this.svgScrollable.attr("height", height + margin.top);
            }, SvgCartesianAxes.darkenZeroLine = function(g) {
                g.selectAll("g.tick line").classed("zero-line", !1);
                var zeroTick = g.selectAll("g.tick").filter(function(data) {
                    return 0 === data;
                }).node();
                zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
            }, SvgCartesianAxes.setAxisLabelColor = function(g, fill) {
                g.selectAll("g.tick text").style("fill", fill ? fill.solid.color : null);
            }, SvgCartesianAxes.AxisPadding = {
                left: 10,
                right: 10,
                top: 0,
                bottom: 13
            }, SvgCartesianAxes.AxisGraphicsContext = createClassAndSelector("axisGraphicsContext"), 
            SvgCartesianAxes.TickPaddingRotatedX = 5, SvgCartesianAxes.AxisLabelFontSize = 11, 
            SvgCartesianAxes.Y2TickSize = -6, SvgCartesianAxes;
        }();
        visuals.SvgCartesianAxes = SvgCartesianAxes;
        var CartesianAxes = function() {
            function CartesianAxes(isScrollable, scrollbarWidth, trimOrdinalDataOnOverflow) {
                this.scrollbarWidth = scrollbarWidth, this.isScrollable = isScrollable, this.maxMarginFactor = CartesianAxes.MaxMarginFactor, 
                this.yAxisOrientation = visuals.yAxisPosition.left, this.trimOrdinalDataOnOverflow = trimOrdinalDataOnOverflow;
            }
            return CartesianAxes.prototype.shouldShowY1OnRight = function() {
                return this.yAxisOrientation === visuals.yAxisPosition.right;
            }, CartesianAxes.prototype.isYAxisCategorical = function() {
                return this.layout && this.layout.axes.y1.isCategoryAxis;
            }, CartesianAxes.prototype.hasCategoryAxis = function() {
                var axes = this.layout && this.layout.axes;
                return axes ? this.isYAxisCategorical() ? axes.y1 && null != axes.y1.axis : axes.x && null != axes.x.axis : !1;
            }, CartesianAxes.prototype.hasY2Axis = function() {
                return this.layout && null != this.layout.axes.y2;
            }, CartesianAxes.prototype.getYAxisOrientation = function() {
                return this.yAxisOrientation;
            }, CartesianAxes.prototype.setAxisLinesVisibility = function(axisLinesVisibility) {
                this.showLinesOnX = EnumExtensions.hasFlag(axisLinesVisibility, 3) || EnumExtensions.hasFlag(axisLinesVisibility, 1), 
                this.showLinesOnY = EnumExtensions.hasFlag(axisLinesVisibility, 3) || EnumExtensions.hasFlag(axisLinesVisibility, 2);
            }, CartesianAxes.prototype.setMaxMarginFactor = function(factor) {
                this.maxMarginFactor = factor;
            }, CartesianAxes.prototype.update = function(dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), 
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                }
                var axisPosition = this.valueAxisProperties.position;
                this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
            }, CartesianAxes.prototype.addWarnings = function(warnings) {
                var axes = this.layout && this.layout.axes;
                (axes && axes.x && axes.x.hasDisallowedZeroInDomain || axes.y1 && axes.y1.hasDisallowedZeroInDomain || axes.y2 && axes.y2.hasDisallowedZeroInDomain) && warnings.unshift(new visuals.ZeroValueWarning());
            }, CartesianAxes.prototype.negotiateAxes = function(layers, parentViewport, padding, playAxisControlLayout, hideAxisLabels, textProperties, interactivityRightMargin, ensureXDomain, ensureYDomain) {
                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin), viewport = powerbi.Prototype.inherit(parentViewport), leftRightMarginLimit = viewport.width * this.maxMarginFactor, bottomMarginLimit = Math.max(CartesianAxes.MinimumMargin.bottom, Math.ceil(viewport.height * this.maxMarginFactor)), marginLimits = {
                    left: leftRightMarginLimit,
                    right: leftRightMarginLimit,
                    top: 0,
                    bottom: bottomMarginLimit
                }, axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, !1, null, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain), renderXAxis = this.shouldRenderAxis(axes.x), renderY1Axis = this.shouldRenderAxis(axes.y1), renderY2Axis = this.shouldRenderAxis(axes.y2, !0), showY1OnRight = this.shouldShowY1OnRight(), plotArea = {
                    width: viewport.width - (margin.left + margin.right),
                    height: viewport.height - (margin.top + margin.bottom)
                }, isScalar = !1;
                _.isEmpty(layers) || layers[0].getVisualCategoryAxisIsScalar && (isScalar = layers[0].getVisualCategoryAxisIsScalar());
                var tickLabelMargins = void 0;
                tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, !1, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis), 
                margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisLabels, isScalar ? 0 : interactivityRightMargin);
                var previousTickCountY1 = axes.y1 && axes.y1.values.length, previousTickCountY2 = axes.y2 && axes.y2.values.length, previousWillFitX = axes.x && axes.x.willLabelsFit, previousWillBreakX = axes.x && axes.x.willLabelsWordBreak;
                axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, !1, null, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain), 
                plotArea.width = viewport.width - (margin.left + margin.right), plotArea.height = viewport.height - (margin.top + margin.bottom);
                var preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar), rotateXTickLabels90 = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea), allDone = !(axes.y1 && axes.y1.values.length !== previousTickCountY1 || axes.y2 && axes.y2.values.length !== previousTickCountY2 || axes.x && axes.x.willLabelsFit !== previousWillFitX || axes.x && axes.x.willLabelsWordBreak !== previousWillBreakX || rotateXTickLabels90);
                if (this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1, !allDone) {
                    tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, rotateXTickLabels90, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis), 
                    margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisLabels, isScalar ? 0 : interactivityRightMargin), 
                    axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, rotateXTickLabels90, axes, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain), 
                    plotArea.width = viewport.width - (margin.left + margin.right), plotArea.height = viewport.height - (margin.top + margin.bottom), 
                    preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                    var willScroll = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                    willScroll && (this.showLinesOnY && (this.isXScrollBarVisible = !0, plotArea.height -= this.scrollbarWidth, 
                    viewport.height -= this.scrollbarWidth), this.showLinesOnX && (this.isYScrollBarVisible = !0, 
                    plotArea.width -= this.scrollbarWidth, viewport.width -= this.scrollbarWidth), axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, !0, axes, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain));
                }
                var axisLabels = hideAxisLabels ? {
                    x: null,
                    y: null,
                    y2: null
                } : {
                    x: axes.x.axisLabel,
                    y: axes.y1.axisLabel,
                    y2: axes.y2 ? axes.y2.axisLabel : null
                };
                return this.layout = {
                    axes: axes,
                    axisLabels: axisLabels,
                    margin: margin,
                    marginLimits: marginLimits,
                    viewport: viewport,
                    plotArea: plotArea,
                    preferredPlotArea: preferredPlotArea,
                    tickLabelMargins: tickLabelMargins,
                    tickPadding: padding,
                    rotateXTickLabels90: rotateXTickLabels90
                }, this.layout;
            }, CartesianAxes.prototype.getPreferredPlotArea = function(axes, layers, isScalar) {
                var preferredPlotArea;
                if (!isScalar && this.isScrollable && !_.isEmpty(layers) && layers[0].getPreferredPlotArea) {
                    var categoryThickness = this.showLinesOnY ? axes.x.categoryThickness : axes.y1.categoryThickness, categoryCount = this.showLinesOnY ? axes.x.dataDomain.length : axes.y1.dataDomain.length;
                    preferredPlotArea = layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                }
                return preferredPlotArea;
            }, CartesianAxes.prototype.willAllCategoriesFitInPlotArea = function(plotArea, preferredPlotArea) {
                return this.showLinesOnY && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.width, plotArea.width) ? !1 : !(this.showLinesOnX && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.height, plotArea.height));
            }, CartesianAxes.prototype.updateAxisMargins = function(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisTitles, interactivityRightMargin) {
                var maxY1Padding = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxY2Padding = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, maxXAxisBottom = tickLabelMargins.xMax;
                maxY1Padding += padding.left, (renderY2Axis && !showY1OnRight || showY1OnRight && renderY1Axis) && (maxY2Padding += padding.right), 
                maxXAxisBottom += padding.bottom, hideAxisTitles && (axes.x.axisLabel = null, axes.y1.axisLabel = null, 
                axes.y2 && (axes.y2.axisLabel = null)), this.addUnitTypeToAxisLabels(axes);
                var axisLabels = {
                    x: axes.x.axisLabel,
                    y: axes.y1.axisLabel,
                    y2: axes.y2 ? axes.y2.axisLabel : null
                };
                null != axisLabels.x && (maxXAxisBottom += CartesianAxes.XAxisLabelPadding), null != axisLabels.y && (maxY1Padding += CartesianAxes.YAxisLabelPadding), 
                null != axisLabels.y2 && (maxY2Padding += CartesianAxes.YAxisLabelPadding);
                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
                return margin.left = showY1OnRight ? maxY2Padding : maxY1Padding, margin.right = showY1OnRight ? maxY1Padding : maxY2Padding, 
                margin.right += interactivityRightMargin, margin.bottom = maxXAxisBottom, margin;
            }, CartesianAxes.prototype.isLogScaleAllowed = function(axisType) {
                var axes = this.layout && this.layout.axes;
                if (!axes) return !1;
                switch (axisType) {
                  case 0:
                    return axes.x.isLogScaleAllowed;

                  case 1:
                    return axes.y1.isLogScaleAllowed;

                  case 2:
                    return axes.y2 && axes.y2.isLogScaleAllowed;
                }
            }, CartesianAxes.prototype.axesHaveTicks = function(viewport) {
                if (!this.layout) return !1;
                var margin = this.layout.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom);
                return 0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) || 0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height);
            }, CartesianAxes.prototype.shouldRenderAxisTitle = function(axisProperties, defaultValue, secondary) {
                var propertyName = secondary ? "secShowAxisTitle" : "showAxisTitle";
                return !!this.getAxisProperty(axisProperties, propertyName, defaultValue);
            }, CartesianAxes.prototype.shouldRenderAxis = function(axisProperties, secondary) {
                if (void 0 === secondary && (secondary = !1), !axisProperties) return !1;
                var propertyName = secondary ? "secShow" : "show";
                return this.getAxisProperty(axisProperties, propertyName, !0) && axisProperties.values && axisProperties.values.length > 0;
            }, CartesianAxes.prototype.getAxisProperty = function(axisProperties, propertyName, defaultValue) {
                if (!axisProperties) return defaultValue;
                var properties = axisProperties.isCategoryAxis ? this.categoryAxisProperties : this.valueAxisProperties;
                return properties && null != properties[propertyName] ? properties[propertyName] : defaultValue;
            }, CartesianAxes.prototype.addUnitTypeToAxisLabels = function(axes) {
                var unitType = CartesianAxes.getUnitType(axes.x.formatter);
                if (axes.x.isCategoryAxis ? this.categoryAxisHasUnitType = null != unitType : this.valueAxisHasUnitType = null != unitType, 
                axes.x.axisLabel && unitType && (axes.x.isCategoryAxis ? axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType) : axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType)), 
                unitType = CartesianAxes.getUnitType(axes.y1.formatter), axes.y1.isCategoryAxis ? this.categoryAxisHasUnitType = null != unitType : this.valueAxisHasUnitType = null != unitType, 
                axes.y1.axisLabel && unitType && (axes.y1.isCategoryAxis ? axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType) : axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType)), 
                axes.y2) {
                    var unitType_1 = CartesianAxes.getUnitType(axes.y2.formatter);
                    this.secondaryValueAxisHasUnitType = null != unitType_1, axes.y2.axisLabel && unitType_1 && (axes.y2.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y2.axisLabel, unitType_1, !0));
                }
            }, CartesianAxes.getUnitType = function(formatter) {
                return formatter && formatter.displayUnit && formatter.displayUnit.value > 1 ? formatter.displayUnit.title : void 0;
            }, CartesianAxes.YAxisLabelPadding = 20, CartesianAxes.XAxisLabelPadding = 18, CartesianAxes.MaxMarginFactor = .25, 
            CartesianAxes.MinimumMargin = {
                left: 1,
                right: 1,
                top: 8,
                bottom: 25
            }, CartesianAxes;
        }();
        visuals.CartesianAxes = CartesianAxes;
        var CartesianLayerFactory;
        !function(CartesianLayerFactory) {
            function createLayers(type, objects, interactivityService, animator, isScrollable, tooltipsEnabled, lineChartLabelDensityEnabled) {
                void 0 === isScrollable && (isScrollable = !1);
                var layers = [], cartesianOptions = {
                    isScrollable: isScrollable,
                    animator: animator,
                    interactivityService: interactivityService,
                    tooltipsEnabled: tooltipsEnabled,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled
                };
                switch (type) {
                  case 1:
                    layers.push(createLineChartLayer(2, !1, cartesianOptions));
                    break;

                  case 0:
                    layers.push(createLineChartLayer(1, !1, cartesianOptions));
                    break;

                  case 2:
                    layers.push(createLineChartLayer(16, !1, cartesianOptions));
                    break;

                  case 9:
                    layers.push(createScatterChartLayer(cartesianOptions));
                    break;

                  case 12:
                    layers.push(createWaterfallChartLayer(cartesianOptions));
                    break;

                  case 11:
                    layers.push(createDataDotChartLayer(cartesianOptions));
                    break;

                  case 4:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                    break;

                  case 3:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                    break;

                  case 8:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));
                    break;

                  case 6:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedBar, cartesianOptions));
                    break;

                  case 5:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredBar, cartesianOptions));
                    break;

                  case 7:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedBar, cartesianOptions));
                    break;

                  case 10:
                    var columnType = getComboColumnType();
                    layers.push(createColumnChartLayer(columnType, cartesianOptions)), layers.push(createLineChartLayer(1, !0, cartesianOptions));
                    break;

                  case 13:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions)), 
                    layers.push(createLineChartLayer(1, !0, cartesianOptions));
                    break;

                  case 14:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions)), 
                    layers.push(createLineChartLayer(1, !0, cartesianOptions));
                    break;

                  case 15:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions)), 
                    layers.push(createDataDotChartLayer(cartesianOptions));
                    break;

                  case 16:
                    layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions)), 
                    layers.push(createDataDotChartLayer(cartesianOptions));
                }
                return layers;
            }
            function shouldAddTrendLayer(objects) {
                var trendObject = powerbi.DataViewObjects.getObject(objects, "trend", null);
                return trendObject ? powerbi.DataViewObject.getValue(trendObject, "show", !1) : void 0;
            }
            function createLineChartLayer(type, inComboChart, defaultOptions, isTrendLayer) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    tooltipsEnabled: !isTrendLayer && defaultOptions.tooltipsEnabled,
                    chartType: type,
                    lineChartLabelDensityEnabled: defaultOptions.lineChartLabelDensityEnabled,
                    isTrendLayer: isTrendLayer
                };
                return inComboChart && (options.chartType = 8 | options.chartType), new visuals.LineChart(options);
            }
            function createScatterChartLayer(defaultOptions) {
                return defaultOptions.isScrollable = !1, new visuals.ScatterChart(defaultOptions);
            }
            function createWaterfallChartLayer(defaultOptions) {
                return new visuals.WaterfallChart(defaultOptions);
            }
            function createDataDotChartLayer(defaultOptions) {
                return new visuals.DataDotChart(defaultOptions);
            }
            function createColumnChartLayer(type, defaultOptions) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    tooltipsEnabled: defaultOptions.tooltipsEnabled,
                    chartType: type
                };
                return new visuals.ColumnChart(options);
            }
            function getComboColumnType(objects) {
                var columnType = visuals.ColumnChartType.clusteredColumn;
                if (objects) {
                    var comboChartTypes = objects.general;
                    if (comboChartTypes) {
                        switch (comboChartTypes.visualType1) {
                          case "Column":
                            columnType = visuals.ColumnChartType.clusteredColumn;
                            break;

                          case "ColumnStacked":
                            columnType = visuals.ColumnChartType.stackedColumn;
                        }
                        comboChartTypes.visualType2;
                    }
                }
                return columnType;
            }
            CartesianLayerFactory.createLayers = createLayers, CartesianLayerFactory.shouldAddTrendLayer = shouldAddTrendLayer;
        }(CartesianLayerFactory || (CartesianLayerFactory = {}));
        var SharedColorPalette = function() {
            function SharedColorPalette(palette) {
                this.palette = palette, this.clearPreferredScale();
            }
            return SharedColorPalette.prototype.getColorScaleByKey = function(scaleKey) {
                return this.setPreferredScale(scaleKey), this.preferredScale;
            }, SharedColorPalette.prototype.getNewColorScale = function() {
                return this.preferredScale;
            }, SharedColorPalette.prototype.getColorByIndex = function(index) {
                return this.palette.getColorByIndex(index);
            }, SharedColorPalette.prototype.getSentimentColors = function() {
                return this.palette.getSentimentColors();
            }, SharedColorPalette.prototype.getBasePickerColors = function() {
                return this.palette.getBasePickerColors();
            }, SharedColorPalette.prototype.clearPreferredScale = function() {
                this.preferredScale = this.palette.getNewColorScale(), this.rotated = !1;
            }, SharedColorPalette.prototype.rotateScale = function() {
                this.preferredScale = this.preferredScale.clone(), this.preferredScale.clearAndRotateScale(), 
                this.rotated = !0;
            }, SharedColorPalette.prototype.setPreferredScale = function(scaleKey) {
                this.rotated || (this.preferredScale = this.palette.getColorScaleByKey(scaleKey));
            }, SharedColorPalette;
        }();
        visuals.SharedColorPalette = SharedColorPalette;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var EnumExtensions = jsCommon.EnumExtensions, DataRoleHelper = powerbi.data.DataRoleHelper, flagBar = 2, flagColumn = 4, flagClustered = 8, flagStacked = 16, flagStacked100 = 32 | flagStacked;
        !function(ColumnChartType) {
            ColumnChartType[ColumnChartType.clusteredBar = flagBar | flagClustered] = "clusteredBar", 
            ColumnChartType[ColumnChartType.clusteredColumn = flagColumn | flagClustered] = "clusteredColumn", 
            ColumnChartType[ColumnChartType.hundredPercentStackedBar = flagBar | flagStacked100] = "hundredPercentStackedBar", 
            ColumnChartType[ColumnChartType.hundredPercentStackedColumn = flagColumn | flagStacked100] = "hundredPercentStackedColumn", 
            ColumnChartType[ColumnChartType.stackedBar = flagBar | flagStacked] = "stackedBar", 
            ColumnChartType[ColumnChartType.stackedColumn = flagColumn | flagStacked] = "stackedColumn";
        }(visuals.ColumnChartType || (visuals.ColumnChartType = {}));
        var ColumnChartType = visuals.ColumnChartType, RoleNames = {
            category: "Category",
            series: "Series",
            y: "Y"
        }, ColumnChart = function() {
            function ColumnChart(options) {
                var chartType = options.chartType;
                this.chartType = chartType, this.categoryAxisType = null, this.animator = options.animator, 
                this.isScrollable = options.isScrollable, this.tooltipsEnabled = options.tooltipsEnabled, 
                this.interactivityService = options.interactivityService;
            }
            return ColumnChart.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (dataViewMapping && dataViewMapping.categorical && dataViewMapping.categorical.categories && (dataViewMapping.categorical.dataVolume = 4, 
                visuals.CartesianChart.detectScalarMapping(dataViewMapping))) {
                    var dataViewCategories = dataViewMapping.categorical.categories;
                    dataViewCategories.dataReductionAlgorithm = {
                        sample: {}
                    };
                }
            }, ColumnChart.getSortableRoles = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return null;
                var dataViewCategories = dataViewMapping.categorical.categories, categoryItems = dataViewCategories["for"]["in"].items;
                if (!_.isEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type, objects = void 0;
                    if (dataViewMapping.metadata && (objects = dataViewMapping.metadata.objects), !visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) return [ "Category", "Y" ];
                }
                return null;
            }, ColumnChart.prototype.updateVisualMetadata = function(x, y, margin) {
                this.xAxisProperties = x, this.yAxisProperties = y, this.margin = margin;
            }, ColumnChart.prototype.init = function(options) {
                this.svg = options.svg, this.svg.classed(ColumnChart.ColumnChartClassName, !0), 
                this.mainGraphicsContext = this.svg.append("svg").classed("columnChartMainGraphicsContext", !0), 
                this.style = options.style, this.currentViewport = options.viewport, this.hostService = options.host, 
                this.interactivity = options.interactivity, this.colors = this.style.colorPalette.dataColors, 
                this.cartesianVisualHost = options.cartesianHost, this.options = options, this.isComboChart = visuals.ComboChart.isComboChart(options.chartType), 
                this.element = options.element;
            }, ColumnChart.prototype.getCategoryLayout = function(numCategoryValues, options) {
                var availableWidth;
                availableWidth = EnumExtensions.hasFlag(this.chartType, flagBar) ? this.currentViewport.height - (this.margin.top + this.margin.bottom) : this.currentViewport.width - (this.margin.left + this.margin.right);
                var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isScalar = this.data ? this.data.scalarCategoryAxis : !1, domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain, options.ensureXDomain);
                return visuals.CartesianChart.getLayout(this.data, {
                    availableWidth: availableWidth,
                    categoryCount: numCategoryValues,
                    domain: domain,
                    isScalar: isScalar,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
            }, ColumnChart.converter = function(dataView, colors, is100PercentStacked, isScalar, dataViewMetadata, chartType, interactivityService, tooltipsEnabled) {
                void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                void 0 === dataViewMetadata && (dataViewMetadata = null), void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties), dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                var converterStrategy = new ColumnChartConverterHelper(dataView), categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString), categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : void 0, labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PercentStacked || EnumExtensions.hasFlag(chartType, flagStacked)), defaultLegendLabelColor = visuals.LegendData.DefaultLegendLabelFillColor, defaultDataPointColor = void 0, showAllDataPoints = void 0;
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                    showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints), 
                    defaultLegendLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.legend.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                    var labelsObj = objects.labels;
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                }
                for (var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultLegendLabelColor, defaultDataPointColor), legend = legendAndSeriesInfo.legend.dataPoints, seriesSources = legendAndSeriesInfo.seriesSources, result = ColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled), columnSeries = result.series, valuesMetadata = [], j = 0, jlen = legend.length; jlen > j; j++) valuesMetadata.push(seriesSources[j]);
                var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                if (!EnumExtensions.hasFlag(chartType, flagColumn)) {
                    var temp = labels.xAxisLabel;
                    labels.xAxisLabel = labels.yAxisLabel, labels.yAxisLabel = temp;
                }
                if (interactivityService) {
                    for (var _i = 0, columnSeries_1 = columnSeries; _i < columnSeries_1.length; _i++) {
                        var series = columnSeries_1[_i];
                        interactivityService.applySelectionStateToData(series.data);
                    }
                    interactivityService.applySelectionStateToData(legendAndSeriesInfo.legend.dataPoints);
                }
                return {
                    categories: categories,
                    categoryFormatter: categoryFormatter,
                    series: columnSeries,
                    valuesMetadata: valuesMetadata,
                    legendData: legendAndSeriesInfo.legend,
                    hasHighlights: result.hasHighlights,
                    categoryMetadata: categoryMetadata,
                    scalarCategoryAxis: isScalar,
                    labelSettings: labelSettings,
                    axesLabels: {
                        x: labels.xAxisLabel,
                        y: labels.yAxisLabel
                    },
                    hasDynamicSeries: result.hasDynamicSeries,
                    isMultiMeasure: result.isMultiMeasure,
                    defaultDataPointColor: defaultDataPointColor,
                    showAllDataPoints: showAllDataPoints
                };
            }, ColumnChart.canSupportOverflow = function(chartType, seriesCount) {
                return !EnumExtensions.hasFlag(chartType, flagStacked) || 1 === seriesCount;
            }, ColumnChart.createDataPoints = function(dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled) {
                void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1);
                var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : void 0, categoryCount = categories.length, seriesCount = legend.length, columnSeries = [];
                if (1 > seriesCount || 1 > categoryCount) return {
                    series: columnSeries,
                    hasHighlights: !1,
                    hasDynamicSeries: !1,
                    isMultiMeasure: !1
                };
                var dvCategories = dataViewCat.categories;
                categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null;
                for (var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata), isDateTime = visuals.AxisHelper.isDateTime(categoryType), baseValuesPos = [], baseValuesNeg = [], rawValues = [], rawHighlightValues = [], hasDynamicSeries = !(!dataViewCat.values || !dataViewCat.values.source), isMultiMeasure = !hasDynamicSeries && seriesCount > 1, highlightsOverflow = !1, hasHighlights = converterStrategy.hasHighlightValues(0), seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                    for (var seriesValues = [], seriesHighlightValues = [], categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                        var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                        if (seriesValues[categoryIndex] = value, hasHighlights) {
                            var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesHighlightValues[categoryIndex] = highlightValue, value >= 0 && highlightValue >= 0 && value >= highlightValue || 0 >= value && 0 >= highlightValue && highlightValue >= value || (highlightsOverflow = !0);
                        }
                    }
                    rawValues.push(seriesValues), hasHighlights && rawHighlightValues.push(seriesHighlightValues);
                }
                highlightsOverflow && !ColumnChart.canSupportOverflow(chartType, seriesCount) && (highlightsOverflow = !1, 
                hasHighlights = !1, rawValues = rawHighlightValues);
                for (var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString, seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                    var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings = void 0;
                    if (!hasDynamicSeries) {
                        var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                        labelObjects && (seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings), 
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                    }
                    columnSeries.push({
                        displayName: legendItem.label,
                        key: "series" + seriesIndex,
                        index: seriesIndex,
                        data: seriesDataPoints,
                        identity: legendItem.identity,
                        color: legendItem.color,
                        labelSettings: seriesLabelSettings
                    }), seriesCount > 1 && (dataPointObjects = seriesObjectsList[seriesIndex]);
                    for (var metadata = dataViewCat.values[seriesIndex].source, gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(dataViewCat), gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCat), categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                        0 === seriesIndex && (baseValuesPos.push(0), baseValuesNeg.push(0));
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                        if (!(null == value && seriesIndex > 0)) {
                            var originalValue = value, categoryValue = categories[categoryIndex];
                            if ((!isDateTime || null == categoryValue || categoryValue instanceof Date) && (isDateTime && categoryValue && (categoryValue = categoryValue.getTime()), 
                            !isScalar || null != categoryValue && !isNaN(categoryValue))) {
                                var multipliers = void 0;
                                is100PercentStacked && (multipliers = visuals.StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy));
                                var unadjustedValue = value, isNegative = 0 > value;
                                multipliers && (value *= isNegative ? multipliers.neg : multipliers.pos);
                                var valueAbsolute = Math.abs(value), position = void 0;
                                isNegative ? (position = baseValuesNeg[categoryIndex], isNaN(valueAbsolute) || (baseValuesNeg[categoryIndex] -= valueAbsolute)) : (isNaN(valueAbsolute) || (baseValuesPos[categoryIndex] += valueAbsolute), 
                                position = baseValuesPos[categoryIndex]);
                                var seriesGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex].values[0] : null, category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIndex).withSeries(dataViewCat.values, seriesGroup).withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex)).createSelectionId(), rawCategoryValue = categories[categoryIndex], color = ColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects), gradientColumnForTooltip = 0 === gradientMeasureIndex ? null : gradientValueColumn, tooltipInfo = void 0;
                                tooltipsEnabled && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, null, gradientColumnForTooltip));
                                var series = columnSeries[seriesIndex], dataPointLabelSettings = series.labelSettings ? series.labelSettings : defaultLabelSettings, labelColor = dataPointLabelSettings.labelColor, lastValue = void 0;
                                EnumExtensions.hasFlag(chartType, flagStacked) && (lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues), 
                                labelColor = lastValue || seriesIndex === seriesCount - 1 && !isNegative ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor);
                                var dataPoint = {
                                    categoryValue: categoryValue,
                                    value: value,
                                    position: position,
                                    valueAbsolute: valueAbsolute,
                                    valueOriginal: unadjustedValue,
                                    seriesIndex: seriesIndex,
                                    labelSettings: dataPointLabelSettings,
                                    categoryIndex: categoryIndex,
                                    color: color,
                                    selected: !1,
                                    originalValue: value,
                                    originalPosition: position,
                                    originalValueAbsolute: valueAbsolute,
                                    identity: identity,
                                    key: identity.getKey(),
                                    tooltipInfo: tooltipInfo,
                                    labelFill: labelColor,
                                    labelFormatString: metadata.format,
                                    lastSeries: lastValue,
                                    chartType: chartType
                                };
                                if (seriesDataPoints.push(dataPoint), hasHighlights) {
                                    var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex], unadjustedValueHighlight = valueHighlight, highlightedTooltip = !0;
                                    null === valueHighlight && (valueHighlight = 0, highlightedTooltip = !1), is100PercentStacked && (valueHighlight *= multipliers.pos);
                                    var absoluteValueHighlight = Math.abs(valueHighlight), highlightPosition = position;
                                    valueHighlight > 0 ? highlightPosition -= valueAbsolute - absoluteValueHighlight : 0 === valueHighlight && value > 0 && (highlightPosition -= valueAbsolute);
                                    var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), rawCategoryValue_1 = categories[categoryIndex], highlightedValue = highlightedTooltip ? valueHighlight : void 0, tooltipInfo_1 = void 0;
                                    tooltipsEnabled && (tooltipInfo_1 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue_1, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue, gradientColumnForTooltip)), 
                                    highlightedTooltip && (dataPoint.tooltipInfo = tooltipInfo_1);
                                    var highlightDataPoint = {
                                        categoryValue: categoryValue,
                                        value: valueHighlight,
                                        position: highlightPosition,
                                        valueAbsolute: absoluteValueHighlight,
                                        valueOriginal: unadjustedValueHighlight,
                                        seriesIndex: seriesIndex,
                                        labelSettings: dataPointLabelSettings,
                                        categoryIndex: categoryIndex,
                                        color: color,
                                        selected: !1,
                                        highlight: !0,
                                        originalValue: value,
                                        originalPosition: position,
                                        originalValueAbsolute: valueAbsolute,
                                        drawThinner: highlightsOverflow,
                                        identity: highlightIdentity,
                                        key: highlightIdentity.getKey(),
                                        tooltipInfo: tooltipInfo_1,
                                        labelFormatString: metadata.format,
                                        labelFill: labelColor,
                                        lastSeries: lastValue,
                                        chartType: chartType
                                    };
                                    seriesDataPoints.push(highlightDataPoint);
                                }
                            }
                        }
                    }
                }
                return {
                    series: columnSeries,
                    hasHighlights: hasHighlights,
                    hasDynamicSeries: hasDynamicSeries,
                    isMultiMeasure: isMultiMeasure
                };
            }, ColumnChart.getDataPointColor = function(legendItem, categoryIndex, dataPointObjects) {
                if (dataPointObjects) {
                    var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                    if (colorOverride) return colorOverride;
                }
                return legendItem.color;
            }, ColumnChart.getStackedLabelColor = function(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                for (var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && 1 !== seriesCount), i = seriesIndex + 1; seriesCount > i; i++) {
                    var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                    if (null !== nextValues && ((!isNegative || isNegative && 0 === seriesIndex) && nextValues > 0 || isNegative && 0 !== seriesIndex)) {
                        lastValue = !1;
                        break;
                    }
                }
                return lastValue;
            }, ColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                void 0 === startIndex && (startIndex = 0);
                var newSeries = [];
                if (series && series.length > 0) for (var i = 0, len = series.length; len > i; i++) {
                    var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                    iNewSeries.data = series[i].data.filter(function(d) {
                        return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                    });
                }
                return newSeries;
            }, ColumnChart.getInteractiveColumnChartDomElement = function(element) {
                return element.children("svg").get(0);
            }, ColumnChart.prototype.setData = function(dataViews) {
                var is100PctStacked = EnumExtensions.hasFlag(this.chartType, flagStacked100);
                if (this.data = {
                    categories: [],
                    categoryFormatter: null,
                    series: [],
                    valuesMetadata: [],
                    legendData: null,
                    hasHighlights: !1,
                    categoryMetadata: null,
                    scalarCategoryAxis: !1,
                    labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked || EnumExtensions.hasFlag(this.chartType, flagStacked)),
                    axesLabels: {
                        x: null,
                        y: null
                    },
                    hasDynamicSeries: !1,
                    defaultDataPointColor: null,
                    isMultiMeasure: !1
                }, dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCat = this.dataViewCat = dataView.categorical, dvCategories = dataViewCat.categories, categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null, categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                        this.data = ColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), is100PctStacked, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.columnChartProps.categoryAxis.axisType, categoryType), dataView.metadata, this.chartType, this.interactivityService, this.tooltipsEnabled);
                    }
                }
                this.setChartStrategy();
            }, ColumnChart.prototype.setChartStrategy = function() {
                switch (this.chartType) {
                  case ColumnChartType.clusteredBar:
                    this.columnChart = new visuals.ClusteredBarChartStrategy();
                    break;

                  case ColumnChartType.clusteredColumn:
                    this.columnChart = new visuals.ClusteredColumnChartStrategy();
                    break;

                  case ColumnChartType.stackedBar:
                  case ColumnChartType.hundredPercentStackedBar:
                    this.columnChart = new visuals.StackedBarChartStrategy();
                    break;

                  case ColumnChartType.stackedColumn:
                  case ColumnChartType.hundredPercentStackedColumn:
                  default:
                    this.columnChart = new visuals.StackedColumnChartStrategy();
                }
                if (EnumExtensions.hasFlag(this.chartType, flagStacked) && 1 === this.data.series.length) switch (this.chartType) {
                  case ColumnChartType.stackedBar:
                    this.columnChart = new visuals.ClusteredBarChartStrategy();
                    break;

                  case ColumnChartType.stackedColumn:
                    this.columnChart = new visuals.ClusteredColumnChartStrategy();
                }
            }, ColumnChart.prototype.calculateLegend = function() {
                if (this.interactivity && this.interactivity.isInteractiveLegend) return this.createInteractiveLegendDataPoints(0);
                var legendData = this.data ? this.data.legendData : null, legendDataPoints = legendData ? legendData.dataPoints : [];
                return _.isEmpty(legendDataPoints) ? null : legendData;
            }, ColumnChart.prototype.hasLegend = function() {
                return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
            }, ColumnChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                switch (options.objectName) {
                  case "dataPoint":
                    visuals.GradientUtils.hasGradientRole(this.dataViewCat) || this.enumerateDataPoints(enumeration);
                    break;

                  case "labels":
                    this.enumerateDataLabels(enumeration);
                }
            }, ColumnChart.prototype.enumerateDataLabels = function(enumeration) {
                var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length, showLabelPerSeries = !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata);
                if (visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries)), 
                0 !== seriesCount && showLabelPerSeries && labelSettings.showLabelPerSeries) for (var i = 0; seriesCount > i; i++) {
                    var series = data.series[i], labelSettings_1 = series.labelSettings ? series.labelSettings : this.data.labelSettings;
                    enumeration.pushContainer({
                        displayName: series.displayName
                    }), visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_1, series)), 
                    enumeration.popContainer();
                }
            }, ColumnChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, series, showAll) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: !0,
                    displayUnits: !EnumExtensions.hasFlag(this.chartType, flagStacked100),
                    precision: !0,
                    selector: series && series.identity ? series.identity.getSelector() : null,
                    showAll: showAll,
                    fontSize: !0
                };
            }, ColumnChart.prototype.enumerateDataPoints = function(enumeration) {
                var data = this.data;
                if (data) {
                    var seriesCount = data.series.length;
                    if (0 !== seriesCount) if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) for (var i = 0; seriesCount > i; i++) {
                        var series = data.series[i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: series.displayName,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: series.color
                                    }
                                }
                            }
                        });
                    } else {
                        var singleSeriesData = data.series[0].data, categoryFormatter = data.categoryFormatter;
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            selector: null,
                            properties: {
                                defaultColor: {
                                    solid: {
                                        color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                    }
                                }
                            }
                        }).pushInstance({
                            objectName: "dataPoint",
                            selector: null,
                            properties: {
                                showAllDataPoints: !!data.showAllDataPoints
                            }
                        });
                        for (var i = 0; i < singleSeriesData.length; i++) {
                            var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), !0),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: singleSeriesDataPoints.color
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }, ColumnChart.prototype.calculateAxesProperties = function(options) {
                var data = this.data;
                this.currentViewport = options.viewport;
                var margin = this.margin = options.margin, origCatgSize = data && data.categories ? data.categories.length : 0, chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                    categoryCount: 0,
                    categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                    outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                    isScalar: !1
                };
                if (this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null, 
                data && !chartLayout.isScalar && !this.isScrollable && options.trimOrdinalDataOnOverflow) {
                    var catgSize = Math.min(origCatgSize, chartLayout.categoryCount);
                    catgSize !== origCatgSize && (data = powerbi.Prototype.inherit(data), data.series = ColumnChart.sliceSeries(data.series, catgSize), 
                    data.categories = data.categories.slice(0, catgSize));
                }
                this.columnChart.setData(data);
                var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness), is100Pct = EnumExtensions.hasFlag(this.chartType, flagStacked100), chartContext = {
                    height: preferredPlotArea.height,
                    width: preferredPlotArea.width,
                    duration: 0,
                    hostService: this.hostService,
                    mainGraphicsContext: this.mainGraphicsContext,
                    margin: this.margin,
                    layout: chartLayout,
                    animator: this.animator,
                    interactivityService: this.interactivityService,
                    viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                    viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                    is100Pct: is100Pct,
                    isComboChart: this.isComboChart
                };
                this.ApplyInteractivity(chartContext), this.columnChart.setupVisualProps(chartContext);
                var ensureXDomain, ensureYDomain, isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                if (isBarChart) {
                    var temp = options.forcedXDomain;
                    options.forcedXDomain = options.forcedYDomain, options.forcedYDomain = temp, ensureXDomain = options.ensureYDomain;
                } else ensureYDomain = options.ensureYDomain;
                return this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType, isBarChart ? options.valueAxisDisplayUnits : options.categoryAxisDisplayUnits, isBarChart ? options.valueAxisPrecision : options.categoryAxisPrecision, ensureXDomain), 
                this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType, isBarChart ? options.categoryAxisDisplayUnits : options.valueAxisDisplayUnits, isBarChart ? options.categoryAxisPrecision : options.valueAxisPrecision, ensureYDomain), 
                options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis ? this.xAxisProperties.axisLabel = data.axesLabels.x : this.xAxisProperties.axisLabel = null, 
                options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis ? this.yAxisProperties.axisLabel = data.axesLabels.y : this.yAxisProperties.axisLabel = null, 
                [ this.xAxisProperties, this.yAxisProperties ];
            }, ColumnChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                var plotArea = {
                    height: this.currentViewport.height - this.margin.top - this.margin.bottom,
                    width: this.currentViewport.width - this.margin.left - this.margin.right
                };
                if (this.isScrollable && !isScalar) {
                    var preferredCategorySpan = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                    EnumExtensions.hasFlag(this.chartType, flagBar) ? plotArea.height = Math.max(preferredCategorySpan, plotArea.height) : plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                }
                return plotArea;
            }, ColumnChart.prototype.ApplyInteractivity = function(chartContext) {
                var _this = this, interactivity = this.interactivity;
                if (interactivity && (interactivity.dragDataPoint && (chartContext.onDragStart = function(datum) {
                    datum.identity && _this.hostService.onDragStart({
                        event: d3.event,
                        data: {
                            data: datum.identity.getSelector()
                        }
                    });
                }), interactivity.isInteractiveLegend)) {
                    var dragMove = function() {
                        var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]), x = mousePoint[0], y = mousePoint[1], index = _this.columnChart.getClosestColumnIndex(x, y);
                        _this.selectColumn(index);
                    }, ColumnChartSvg = ColumnChart.getInteractiveColumnChartDomElement(this.element);
                    this.svg.on("click", dragMove), d3.select(ColumnChartSvg).on("click", dragMove).style("touch-action", "none");
                    var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                    this.svg.call(drag), d3.select(ColumnChartSvg).call(drag);
                }
            }, ColumnChart.prototype.selectColumn = function(indexOfColumnSelected, force) {
                if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== indexOfColumnSelected) {
                    var legendData = this.createInteractiveLegendDataPoints(indexOfColumnSelected), legendDataPoints = legendData.dataPoints;
                    this.cartesianVisualHost.updateLegend(legendData), legendDataPoints.length > 0 && this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex), 
                    this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                }
            }, ColumnChart.prototype.createInteractiveLegendDataPoints = function(columnIndex) {
                var data = this.data;
                if (!data || _.isEmpty(data.series)) return {
                    dataPoints: []
                };
                for (var formatStringProp = visuals.columnChartProps.general.formatString, legendDataPoints = [], category = data.categories && data.categories[columnIndex], allSeries = data.series, dataPoints = data.legendData && data.legendData.dataPoints, converterStrategy = new ColumnChartConverterHelper(this.dataViewCat), i = 0, len = allSeries.length; len > i; i++) {
                    var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex), valueMetadata = data.valuesMetadata[i], formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp), dataPointColor = void 0;
                    if (1 === allSeries.length) {
                        var series = allSeries[0];
                        dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                    } else dataPointColor = dataPoints.length > i && dataPoints[i].color;
                    legendDataPoints.push({
                        color: dataPointColor,
                        icon: visuals.LegendIcon.Box,
                        label: formattedLabel,
                        category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                        identity: visuals.SelectionId.createNull(),
                        selected: !1
                    });
                }
                return {
                    dataPoints: legendDataPoints
                };
            }, ColumnChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            }, ColumnChart.prototype.render = function(suppressAnimations) {
                var columnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations), data = this.data, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right);
                this.mainGraphicsContext.attr("height", height).attr("width", width), this.tooltipsEnabled && visuals.TooltipManager.addTooltip(columnChartDrawInfo.eventGroup, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                var allDataPoints = [], behaviorOptions = void 0;
                if (this.interactivityService) {
                    for (var i = 0, ilen = data.series.length; ilen > i; i++) allDataPoints = allDataPoints.concat(data.series[i].data);
                    behaviorOptions = {
                        datapoints: allDataPoints,
                        eventGroup: columnChartDrawInfo.eventGroup,
                        bars: columnChartDrawInfo.shapesSelection,
                        hasHighlights: data.hasHighlights,
                        mainGraphicsContext: this.mainGraphicsContext,
                        viewport: columnChartDrawInfo.viewport,
                        axisOptions: columnChartDrawInfo.axisOptions,
                        showLabel: data.labelSettings.show
                    };
                }
                return this.interactivity && this.interactivity.isInteractiveLegend && this.data.series.length > 0 && this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(this.data.series), !0), 
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                    dataPoints: allDataPoints,
                    behaviorOptions: behaviorOptions,
                    labelDataPoints: columnChartDrawInfo.labelDataPoints,
                    labelsAreNumeric: !0
                };
            }, ColumnChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, ColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return this.data ? this.data.scalarCategoryAxis : !1;
            }, ColumnChart.prototype.getSupportedCategoryAxisType = function() {
                var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
            }, ColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = powerbi.Prototype.inherit(this.data);
                return data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex), 
                data.categories = data.categories.slice(startIndex, endIndex), this.columnChart.setData(data), 
                data;
            }, ColumnChart.getLabelFill = function(labelColor, isInside, isCombo) {
                return labelColor ? labelColor : isInside && !isCombo ? visuals.NewDataLabelUtils.defaultInsideLabelColor : visuals.NewDataLabelUtils.defaultLabelColor;
            }, ColumnChart.ColumnChartClassName = "columnChart", ColumnChart.clusteredValidLabelPositions = [ 16, 4, 1, 2 ], 
            ColumnChart.stackedValidLabelPositions = [ 1, 4, 2 ], ColumnChart.SeriesClasses = jsCommon.CssConstants.createClassAndSelector("series"), 
            ColumnChart;
        }();
        visuals.ColumnChart = ColumnChart;
        var ColumnChartConverterHelper = function() {
            function ColumnChartConverterHelper(dataView) {
                this.dataView = dataView;
            }
            return ColumnChartConverterHelper.prototype.getLegend = function(colors, defaultLegendLabelColor, defaultColor) {
                var legend = [], seriesSources = [], seriesObjects = [], grouped = !1, colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor), legendTitle = void 0;
                if (this.dataView && this.dataView.values) {
                    for (var allValues = this.dataView.values, valueGroups = allValues.grouped(), hasDynamicSeries = !(!allValues || !allValues.source), formatStringProp = visuals.columnChartProps.general.formatString, valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsLen > valueGroupsIndex; valueGroupsIndex++) for (var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values, valueIndex = 0, valuesLen = values.length; valuesLen > valueIndex; valueIndex++) {
                        var series = values[valueIndex], source = series.source;
                        if (!DataRoleHelper.hasRole(source, "Gradient") || DataRoleHelper.hasRole(source, "Y")) {
                            seriesSources.push(source), seriesObjects.push(series.objects);
                            var selectionId = series.identity ? visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) : visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex)), label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                            legend.push({
                                icon: visuals.LegendIcon.Box,
                                color: color,
                                label: label,
                                identity: selectionId,
                                selected: !1
                            }), series.identity && void 0 !== source.groupName && (grouped = !0);
                        }
                    }
                    var dvValues = this.dataView.values;
                    legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                }
                var legendData = {
                    title: legendTitle,
                    dataPoints: legend,
                    grouped: grouped,
                    labelColor: defaultLegendLabelColor
                };
                return {
                    legend: legendData,
                    seriesSources: seriesSources,
                    seriesObjects: seriesObjects
                };
            }, ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function(series, category) {
                return this.dataView.values[series].values[category];
            }, ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function(index) {
                return this.dataView.values[index].source.queryName;
            }, ColumnChartConverterHelper.prototype.hasHighlightValues = function(series) {
                var column = this.dataView && this.dataView.values ? this.dataView.values[series] : void 0;
                return column && !!column.highlights;
            }, ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                return this.dataView.values[series].highlights[category];
            }, ColumnChartConverterHelper;
        }();
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var PixelConverter = jsCommon.PixelConverter, ClusteredColumnChartStrategy = function() {
            function ClusteredColumnChartStrategy() {}
            return ClusteredColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                this.viewportWidth = columnChartProps.viewportWidth, this.isComboChart = columnChartProps.isComboChart;
            }, ClusteredColumnChartStrategy.prototype.setData = function(data) {
                this.data = data;
            }, ClusteredColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var forcedXMin, forcedXMax, width = this.width;
                forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain), seriesLength = this.data.series.length, columnWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio) / seriesLength;
                return this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function(s) {
                    return s.index;
                })).rangeBands([ 0, seriesLength * columnWidth ]), props;
            }, ClusteredColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                var height = this.viewportHeight, valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, !0) || visuals.emptyDomain, combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomain, ensureYDomain), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                return this.yProps = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: this.data.valuesMetadata[0],
                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !0,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    shouldClamp: shouldClamp
                }), this.yProps;
            }, ClusteredColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                this.columnsCenters = null;
                var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), columnWidth = categoryWidth / data.series.length, axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                }, clusteredColumnLayout = this.layout = ClusteredColumnChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                return this.animator && useAnimation && (result = this.animator.animate({
                    viewModel: data,
                    series: series,
                    layout: clusteredColumnLayout,
                    itemCS: ClusteredColumnChartStrategy.classes.item,
                    interactivityService: this.interactivityService,
                    mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                    viewPort: {
                        height: this.height,
                        width: this.width
                    }
                }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredColumnLayout, ClusteredColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: {
                        height: this.height,
                        width: this.width
                    },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints
                };
            }, ClusteredColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                this.moveHandle(selectedColumnIndex);
            }, ClusteredColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            }, ClusteredColumnChartStrategy.prototype.getColumnsCenters = function() {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var xScaleOffset_1 = 0;
                        this.categoryLayout.isScalar || (xScaleOffset_1 = categoryWidth / 2);
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function(d) {
                            return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_1;
                        });
                    }
                }
                return this.columnsCenters;
            }, ClusteredColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex];
                if (this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        x1: x,
                        x2: x
                    }), handle.select("circle").attr({
                        cx: x
                    });
                } else {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", !0).attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height
                    }), handle.append("circle").attr({
                        cx: x,
                        cy: this.height,
                        r: "6px"
                    }).classed("drag-handle", !0);
                }
            }, ClusteredColumnChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth, halfColumnWidth = .5 * columnWidth, quarterColumnWidth = halfColumnWidth / 2, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, seriesOffsetScale = axisOptions.seriesOffsetScale, scaledY0 = yScale(0), xScaleOffset = 0;
                return isScalar && (xScaleOffset = axisOptions.categoryWidth / 2), {
                    shapeLayout: {
                        width: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        y: function(d) {
                            return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0);
                        },
                        height: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value));
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset;
                        },
                        y: function(d) {
                            return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.originalValue), 0);
                        },
                        height: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.originalValue));
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        y: function(d) {
                            return scaledY0;
                        },
                        height: function(d) {
                            return 0;
                        }
                    }
                };
            }, ClusteredColumnChartStrategy.prototype.createLabelDataPoints = function() {
                for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_2 = series; _i < series_2.length; _i++) {
                    var currentSeries = series_2[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                            var parentRect = {
                                left: shapeLayout.x(dataPoint),
                                top: shapeLayout.y(dataPoint),
                                width: shapeLayout.width(dataPoint),
                                height: shapeLayout.height(dataPoint)
                            }, formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                            labelDataPoints.push({
                                isPreferred: !0,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight
                                },
                                outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                parentType: 1,
                                parentShape: {
                                    rect: parentRect,
                                    orientation: dataPoint.value >= 0 ? 1 : 2,
                                    validPositions: visuals.ColumnChart.clusteredValidLabelPositions
                                },
                                identity: dataPoint.identity,
                                fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                            });
                        }
                    }
                }
                return labelDataPoints;
            }, ClusteredColumnChartStrategy.classes = {
                item: {
                    "class": "column",
                    selector: ".column"
                }
            }, ClusteredColumnChartStrategy;
        }();
        visuals.ClusteredColumnChartStrategy = ClusteredColumnChartStrategy;
        var ClusteredBarChartStrategy = function() {
            function ClusteredBarChartStrategy() {}
            return ClusteredBarChartStrategy.prototype.setupVisualProps = function(barChartProps) {
                this.graphicsContext = barChartProps, this.margin = barChartProps.margin, this.width = this.graphicsContext.width, 
                this.height = this.graphicsContext.height, this.categoryLayout = barChartProps.layout, 
                this.animator = barChartProps.animator, this.interactivityService = barChartProps.interactivityService, 
                this.viewportHeight = barChartProps.viewportHeight, this.viewportWidth = barChartProps.viewportWidth, 
                this.isComboChart = barChartProps.isComboChart;
            }, ClusteredBarChartStrategy.prototype.setData = function(data) {
                this.data = data;
            }, ClusteredBarChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                var forcedYMin, forcedYMax, height = this.height;
                forcedYDomain && 2 === forcedYDomain.length && (forcedYMin = forcedYDomain[0], forcedYMax = forcedYDomain[1]);
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, !0, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain), seriesLength = this.data.series.length, columnWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio) / seriesLength;
                return this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function(s) {
                    return s.index;
                })).rangeBands([ 0, seriesLength * columnWidth ]), props;
            }, ClusteredBarChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var width = this.width, valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, !0) || visuals.emptyDomain, combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomain, ensureXDomain), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                return this.xProps = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedDomain,
                    metaDataColumn: this.data.valuesMetadata[0],
                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !1,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    shouldClamp: shouldClamp
                }), this.xProps.axis.tickSize(-this.viewportHeight, 0), this.xProps;
            }, ClusteredBarChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                this.barsCenters = null;
                var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), columnWidth = categoryWidth / data.series.length, axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                }, clusteredBarLayout = this.layout = ClusteredBarChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                return this.animator && useAnimation && (result = this.animator.animate({
                    viewModel: data,
                    series: series,
                    layout: clusteredBarLayout,
                    itemCS: ClusteredBarChartStrategy.classes.item,
                    interactivityService: this.interactivityService,
                    mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                    viewPort: {
                        height: this.height,
                        width: this.width
                    }
                }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredBarLayout, ClusteredBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: {
                        height: this.height,
                        width: this.width
                    },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints
                };
            }, ClusteredBarChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredBarChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                this.moveHandle(selectedColumnIndex);
            }, ClusteredBarChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            }, ClusteredBarChartStrategy.prototype.getBarsCenters = function() {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var yScaleOffset_1 = 0;
                        this.categoryLayout.isScalar || (yScaleOffset_1 = barWidth / 2);
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function(d) {
                            return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_1;
                        });
                    }
                }
                return this.barsCenters;
            }, ClusteredBarChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var barCenters = this.getBarsCenters(), y = barCenters[selectedColumnIndex];
                if (this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        y1: y,
                        y2: y
                    }), handle.select("circle").attr({
                        cy: y
                    });
                } else {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", !0).attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y
                    }), handle.append("circle").attr({
                        cx: 0,
                        cy: y,
                        r: "6px"
                    }).classed("drag-handle", !0);
                }
            }, ClusteredBarChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth, halfColumnWidth = .5 * columnWidth, quarterColumnWidth = halfColumnWidth / 2, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, seriesOffsetScale = axisOptions.seriesOffsetScale, scaledX0 = xScale(0), yScaleOffset = 0;
                return isScalar && (yScaleOffset = axisOptions.categoryWidth / 2), {
                    shapeLayout: {
                        width: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value));
                        },
                        x: function(d) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        height: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue));
                        },
                        x: function(d) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.originalValue), 0);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset;
                        },
                        height: function(d) {
                            return columnWidth;
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return 0;
                        },
                        x: function(d) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        height: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        }
                    }
                };
            }, ClusteredBarChartStrategy.prototype.createLabelDataPoints = function() {
                for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_3 = series; _i < series_3.length; _i++) {
                    var currentSeries = series_3[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if (!(this.interactivityService && this.interactivityService.hasSelection() && !dataPoint.selected || data.hasHighlights && !dataPoint.highlight || null == dataPoint.value)) {
                            var formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0), parentRect = {
                                left: shapeLayout.x(dataPoint),
                                top: shapeLayout.y(dataPoint),
                                width: shapeLayout.width(dataPoint),
                                height: shapeLayout.height(dataPoint)
                            };
                            labelDataPoints.push({
                                isPreferred: !0,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight
                                },
                                outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                parentType: 1,
                                parentShape: {
                                    rect: parentRect,
                                    orientation: dataPoint.value >= 0 ? 3 : 4,
                                    validPositions: visuals.ColumnChart.clusteredValidLabelPositions
                                },
                                identity: dataPoint.identity,
                                fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                            });
                        }
                    }
                }
                return labelDataPoints;
            }, ClusteredBarChartStrategy.classes = {
                item: {
                    "class": "bar",
                    selector: ".bar"
                }
            }, ClusteredBarChartStrategy;
        }();
        visuals.ClusteredBarChartStrategy = ClusteredBarChartStrategy;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var PixelConverter = jsCommon.PixelConverter, StackedColumnChartStrategy = function() {
            function StackedColumnChartStrategy() {}
            return StackedColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                this.viewportWidth = columnChartProps.viewportWidth, this.isComboChart = columnChartProps.isComboChart;
            }, StackedColumnChartStrategy.prototype.setData = function(data) {
                this.data = data;
            }, StackedColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue) {
                var forcedXMin, forcedXMax, width = this.width;
                forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue);
                return props;
            }, StackedColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, y1ReferenceLineValue) {
                var height = this.viewportHeight, valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr, y1ReferenceLineValue), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                return this.yProps = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: metadataColumn,
                    formatString: formatString,
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !0,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    is100Pct: is100Pct,
                    shouldClamp: shouldClamp
                }), this.yProps;
            }, StackedColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                this.columnsCenters = null;
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                }, stackedColumnLayout = this.layout = StackedColumnChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                return this.animator && useAnimation && (result = this.animator.animate({
                    viewModel: data,
                    series: series,
                    layout: stackedColumnLayout,
                    itemCS: StackedColumnChartStrategy.classes.item,
                    interactivityService: this.interactivityService,
                    mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                    viewPort: {
                        height: this.height,
                        width: this.width
                    }
                }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedColumnLayout, StackedColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: {
                        height: this.height,
                        width: this.width
                    },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints
                };
            }, StackedColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                this.moveHandle(selectedColumnIndex);
            }, StackedColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            }, StackedColumnChartStrategy.prototype.getColumnsCenters = function() {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var xScaleOffset_2 = 0;
                        this.categoryLayout.isScalar || (xScaleOffset_2 = categoryWidth / 2);
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function(d) {
                            return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_2;
                        });
                    }
                }
                return this.columnsCenters;
            }, StackedColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex];
                if (this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        x1: x,
                        x2: x
                    }), handle.select("circle").attr({
                        cx: x
                    });
                } else {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", !0).attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height
                    }), handle.append("circle").attr({
                        cx: x,
                        cy: this.height,
                        r: "6px"
                    }).classed("drag-handle", !0);
                }
            }, StackedColumnChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, xScaleOffset = 0;
                return isScalar && (xScaleOffset = columnWidth / 2), {
                    shapeLayout: {
                        width: function(d) {
                            return columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        y: function(d) {
                            return yScale(d.position);
                        },
                        height: function(d) {
                            return yScale(d.position - d.valueAbsolute) - yScale(d.position);
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        y: function(d) {
                            return yScale(d.originalPosition);
                        },
                        height: function(d) {
                            return yScale(d.originalPosition - d.originalValueAbsolute) - yScale(d.originalPosition);
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        y: function(d) {
                            return yScale(d.value >= 0 ? d.position - d.valueAbsolute : d.position);
                        },
                        height: function(d) {
                            return 0;
                        }
                    }
                };
            }, StackedColumnChartStrategy.prototype.createLabelDataPoints = function() {
                for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_4 = series; _i < series_4.length; _i++) {
                    var currentSeries = series_4[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                            var parentRect = {
                                left: shapeLayout.x(dataPoint),
                                top: shapeLayout.y(dataPoint),
                                width: shapeLayout.width(dataPoint),
                                height: shapeLayout.height(dataPoint)
                            }, formatString = "";
                            formatString = this.graphicsContext.is100Pct ? visuals.NewDataLabelUtils.hundredPercentFormat : dataPoint.labelFormatString;
                            var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                            labelDataPoints.push({
                                isPreferred: !0,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight
                                },
                                outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                parentType: 1,
                                parentShape: {
                                    rect: parentRect,
                                    orientation: dataPoint.value >= 0 ? 1 : 2,
                                    validPositions: visuals.ColumnChart.stackedValidLabelPositions
                                },
                                identity: dataPoint.identity,
                                fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                            });
                        }
                    }
                }
                return labelDataPoints;
            }, StackedColumnChartStrategy.classes = {
                item: {
                    "class": "column",
                    selector: ".column"
                },
                highlightItem: {
                    "class": "highlightColumn",
                    selector: ".highlightColumn"
                }
            }, StackedColumnChartStrategy;
        }();
        visuals.StackedColumnChartStrategy = StackedColumnChartStrategy;
        var StackedBarChartStrategy = function() {
            function StackedBarChartStrategy() {}
            return StackedBarChartStrategy.prototype.setupVisualProps = function(barChartProps) {
                this.graphicsContext = barChartProps, this.margin = barChartProps.margin, this.width = this.graphicsContext.width, 
                this.height = this.graphicsContext.height, this.categoryLayout = barChartProps.layout, 
                this.animator = barChartProps.animator, this.interactivityService = barChartProps.interactivityService, 
                this.viewportHeight = barChartProps.viewportHeight, this.viewportWidth = barChartProps.viewportWidth, 
                this.isComboChart = barChartProps.isComboChart;
            }, StackedBarChartStrategy.prototype.setData = function(data) {
                this.data = data;
            }, StackedBarChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                var forcedYMin, forcedYMax, height = this.height;
                forcedYDomain && 2 === forcedYDomain.length && (forcedYMin = forcedYDomain[0], forcedYMax = forcedYDomain[1]);
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, !0, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
                return props;
            }, StackedBarChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var width = this.width, valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomainArr, ensureXDomain), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                return this.xProps = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedDomain,
                    metaDataColumn: metadataColumn,
                    formatString: formatString,
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !1,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    is100Pct: is100Pct,
                    shouldClamp: shouldClamp
                }), this.xProps.axis.tickSize(-this.viewportHeight, 0), this.xProps;
            }, StackedBarChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                this.barsCenters = null;
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                }, stackedBarLayout = this.layout = StackedBarChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                return this.animator && useAnimation && (result = this.animator.animate({
                    viewModel: data,
                    series: series,
                    layout: stackedBarLayout,
                    itemCS: StackedBarChartStrategy.classes.item,
                    interactivityService: this.interactivityService,
                    mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                    viewPort: {
                        height: this.height,
                        width: this.width
                    }
                }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedBarLayout, StackedBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: {
                        height: this.height,
                        width: this.width
                    },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints
                };
            }, StackedBarChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastInteractiveSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedBarChartStrategy.classes.item.selector, selectedColumnIndex, lastInteractiveSelectedColumnIndex), 
                this.moveHandle(selectedColumnIndex);
            }, StackedBarChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            }, StackedBarChartStrategy.prototype.getBarsCenters = function() {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var yScaleOffset_2 = 0;
                        this.categoryLayout.isScalar || (yScaleOffset_2 = barWidth / 2);
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function(d) {
                            return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_2;
                        });
                    }
                }
                return this.barsCenters;
            }, StackedBarChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var barCenters = this.getBarsCenters(), y = barCenters[selectedColumnIndex];
                if (this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        y1: y,
                        y2: y
                    }), handle.select("circle").attr({
                        cy: y
                    });
                } else {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", !0).attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y
                    }), handle.append("circle").classed("drag-handle", !0).attr({
                        cx: 0,
                        cy: y,
                        r: "6px"
                    });
                }
            }, StackedBarChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, yScaleOffset = 0;
                return isScalar && (yScaleOffset = columnWidth / 2), {
                    shapeLayout: {
                        width: function(d) {
                            return xScale(d.position) - xScale(d.position - d.valueAbsolute);
                        },
                        x: function(d) {
                            return xScale(d.position - d.valueAbsolute);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset;
                        },
                        height: function(d) {
                            return columnWidth;
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return xScale(d.originalPosition) - xScale(d.originalPosition - d.originalValueAbsolute);
                        },
                        x: function(d) {
                            return xScale(d.originalPosition - d.originalValueAbsolute);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset;
                        },
                        height: function(d) {
                            return columnWidth;
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return 0;
                        },
                        x: function(d) {
                            return xScale(d.value >= 0 ? d.position - d.valueAbsolute : d.position);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset;
                        },
                        height: function(d) {
                            return columnWidth;
                        }
                    }
                };
            }, StackedBarChartStrategy.prototype.createLabelDataPoints = function() {
                for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_5 = series; _i < series_5.length; _i++) {
                    var currentSeries = series_5[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if (!(this.interactivityService && this.interactivityService.hasSelection() && !dataPoint.selected || data.hasHighlights && !dataPoint.highlight || null == dataPoint.value)) {
                            var formatString = void 0;
                            formatString = this.graphicsContext.is100Pct ? visuals.NewDataLabelUtils.hundredPercentFormat : dataPoint.labelFormatString;
                            var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0), parentRect = {
                                left: shapeLayout.x(dataPoint),
                                top: shapeLayout.y(dataPoint),
                                width: shapeLayout.width(dataPoint),
                                height: shapeLayout.height(dataPoint)
                            };
                            labelDataPoints.push({
                                isPreferred: !0,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight
                                },
                                outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                parentType: 1,
                                parentShape: {
                                    rect: parentRect,
                                    orientation: dataPoint.value >= 0 ? 3 : 4,
                                    validPositions: visuals.ColumnChart.stackedValidLabelPositions
                                },
                                identity: dataPoint.identity,
                                fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                            });
                        }
                    }
                }
                return labelDataPoints;
            }, StackedBarChartStrategy.classes = {
                item: {
                    "class": "bar",
                    selector: ".bar"
                },
                highlightItem: {
                    "class": "highlightBar",
                    selector: ".highlightBar"
                }
            }, StackedBarChartStrategy;
        }();
        visuals.StackedBarChartStrategy = StackedBarChartStrategy;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var ComboChart;
        !function(ComboChart) {
            function enumerateDataPoints(enumeration, options, layers) {
                if (layers) {
                    for (var columnChartLayerIndex, layersLength = layers.length, layerIndex = 0; layersLength > layerIndex; layerIndex++) {
                        var layer = layers[layerIndex];
                        if (layer.enumerateObjectInstances) {
                            if (layer instanceof visuals.ColumnChart) {
                                columnChartLayerIndex = layerIndex;
                                continue;
                            }
                            layer.enumerateObjectInstances(enumeration, options);
                        }
                    }
                    void 0 !== columnChartLayerIndex && layers[columnChartLayerIndex].enumerateObjectInstances(enumeration, options);
                }
            }
            function customizeQuery(options) {
                var columnMapping = !_.isEmpty(options.dataViewMappings) && options.dataViewMappings[0];
                if (columnMapping) {
                    var columnValuesMapping = columnMapping.categorical && columnMapping.categorical.values, seriesSelect = columnValuesMapping.group && !_.isEmpty(columnValuesMapping.group.select) && columnValuesMapping.group.select[0];
                    _.isEmpty(seriesSelect["for"]["in"].items) && (columnValuesMapping.group.by.items = void 0);
                }
                columnMapping && columnMapping.categorical && (columnMapping.categorical.dataVolume = 4);
                var lineMapping = options.dataViewMappings.length > 1 && options.dataViewMappings[1];
                lineMapping && lineMapping.categorical && (lineMapping.categorical.dataVolume = 4);
            }
            function getSortableRoles(options) {
                if (options && options.dataViewMappings.length > 0) {
                    var dataViewMapping = options.dataViewMappings[0];
                    if (!visuals.CartesianChart.detectScalarMapping(dataViewMapping)) return [ "Category", "Y", "Y2" ];
                }
                return null;
            }
            function isComboChart(chartType) {
                return 10 === chartType || 13 === chartType || 14 === chartType || 15 === chartType || 16 === chartType;
            }
            ComboChart.capabilities = visuals.comboChartCapabilities, ComboChart.enumerateDataPoints = enumerateDataPoints, 
            ComboChart.customizeQuery = customizeQuery, ComboChart.getSortableRoles = getSortableRoles, 
            ComboChart.isComboChart = isComboChart;
        }(ComboChart = visuals.ComboChart || (visuals.ComboChart = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions, DataColorPalette = function() {
            function DataColorPalette(colors, sentimentcolors) {
                this.basePickerColors = [ {
                    value: "#FFFFFF"
                }, {
                    value: "#000000"
                }, {
                    value: "#00B8AA"
                }, {
                    value: "#374649"
                }, {
                    value: "#FD625E"
                }, {
                    value: "#F2C811"
                }, {
                    value: "#5F6B6D"
                }, {
                    value: "#8AD4EB"
                }, {
                    value: "#FE9666"
                }, {
                    value: "#A66999"
                } ], this.colors = colors || ThemeManager.getDefaultTheme(), this.sentimentColors = sentimentcolors || ThemeManager.defaultSentimentColors, 
                this.scales = {};
            }
            return DataColorPalette.prototype.getColorScaleByKey = function(key) {
                var scale = this.scales[key];
                return void 0 === scale && (scale = this.createScale(), this.scales[key] = scale), 
                scale;
            }, DataColorPalette.prototype.getNewColorScale = function() {
                return this.createScale();
            }, DataColorPalette.prototype.getColorByIndex = function(index) {
                return this.colors[index];
            }, DataColorPalette.prototype.getSentimentColors = function() {
                return this.sentimentColors;
            }, DataColorPalette.prototype.getBasePickerColors = function() {
                return this.basePickerColors;
            }, DataColorPalette.prototype.getAllColors = function() {
                return this.colors;
            }, DataColorPalette.prototype.createScale = function() {
                return D3ColorScale.createFromColors(this.colors);
            }, DataColorPalette;
        }();
        visuals.DataColorPalette = DataColorPalette;
        var D3ColorScale = function() {
            function D3ColorScale(scale) {
                this.scale = scale;
            }
            return D3ColorScale.prototype.getColor = function(key) {
                return this.scale(key);
            }, D3ColorScale.prototype.clearAndRotateScale = function() {
                var offset = this.scale.domain().length, rotatedColors = ArrayExtensions.rotate(this.scale.range(), offset);
                this.scale = d3.scale.ordinal().range(rotatedColors);
            }, D3ColorScale.prototype.clone = function() {
                return new D3ColorScale(this.scale.copy());
            }, D3ColorScale.prototype.getDomain = function() {
                return this.scale.domain();
            }, D3ColorScale.createFromColors = function(colors) {
                return new D3ColorScale(d3.scale.ordinal().range(colors));
            }, D3ColorScale;
        }();
        visuals.D3ColorScale = D3ColorScale;
        var ThemeManager = function() {
            function ThemeManager() {}
            return ThemeManager.getDefaultTheme = function() {
                if (!ThemeManager.defaultTheme) {
                    ThemeManager.defaultTheme = [];
                    for (var baseColors = ThemeManager.defaultBaseColors, i = 0; i < ThemeManager.colorSectorCount; ++i) for (var j = 0, jlen = baseColors.length; jlen > j; ++j) ThemeManager.defaultTheme.push({
                        value: jsCommon.Color.rotate(baseColors[j].value, i / ThemeManager.colorSectorCount)
                    });
                }
                return ThemeManager.defaultTheme;
            }, ThemeManager.colorSectorCount = 12, ThemeManager.defaultBaseColors = [ {
                value: "#01B8AA"
            }, {
                value: "#374649"
            }, {
                value: "#FD625E"
            }, {
                value: "#F2C80F"
            }, {
                value: "#5F6B6D"
            }, {
                value: "#8AD4EB"
            }, {
                value: "#FE9666"
            }, {
                value: "#A66999"
            }, {
                value: "#3599B8"
            }, {
                value: "#DFBFBF"
            }, {
                value: "#4AC5BB"
            }, {
                value: "#5F6B6D"
            }, {
                value: "#FB8281"
            }, {
                value: "#F4D25A"
            }, {
                value: "#7F898A"
            }, {
                value: "#A4DDEE"
            }, {
                value: "#FDAB89"
            }, {
                value: "#B687AC"
            }, {
                value: "#28738A"
            }, {
                value: "#A78F8F"
            }, {
                value: "#168980"
            }, {
                value: "#293537"
            }, {
                value: "#BB4A4A"
            }, {
                value: "#B59525"
            }, {
                value: "#475052"
            }, {
                value: "#6A9FB0"
            }, {
                value: "#BD7150"
            }, {
                value: "#7B4F71"
            }, {
                value: "#1B4D5C"
            }, {
                value: "#706060"
            }, {
                value: "#0F5C55"
            }, {
                value: "#1C2325"
            }, {
                value: "#7D3231"
            }, {
                value: "#796419"
            }, {
                value: "#303637"
            }, {
                value: "#476A75"
            }, {
                value: "#7E4B36"
            }, {
                value: "#52354C"
            }, {
                value: "#0D262E"
            }, {
                value: "#544848"
            } ], ThemeManager.defaultSentimentColors = [ {
                value: "#C0433A"
            }, {
                value: "#E8D62E"
            }, {
                value: "#79C75B"
            } ], ThemeManager;
        }();
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var DataDotChart = function() {
            function DataDotChart(options) {
                this.isScrollable = options.isScrollable, this.interactivityService = options.interactivityService;
            }
            return DataDotChart.prototype.init = function(options) {
                this.options = options, this.svg = options.svg, this.svg.classed(DataDotChart.ClassName, !0), 
                this.mainGraphicsG = this.svg.append("g").classed("dataDotChartMainGraphicsContext", !0), 
                this.mainGraphicsContext = this.mainGraphicsG.append("svg"), this.currentViewport = options.viewport, 
                this.hostService = options.host, this.cartesianVisualHost = options.cartesianHost, 
                this.style = options.style, this.colors = this.style.colorPalette.dataColors, this.interactivity = options.interactivity, 
                this.element = options.element;
            }, DataDotChart.prototype.setData = function(dataViews) {
                if (this.data = {
                    series: {
                        data: []
                    },
                    hasHighlights: !1,
                    hasDynamicSeries: !1
                }, dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCategorical = this.dataViewCategorical = dataView.categorical, dvCategories = dataViewCategorical.categories, categoryType = powerbi.ValueType.fromDescriptor({
                            text: !0
                        });
                        dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type), 
                        this.data = DataDotChart.converter(dataView, visuals.valueFormatter.format(null), this.interactivityService);
                    }
                }
            }, DataDotChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                return data && data.series && data.series.data && (data.series = {
                    data: data.series.data.slice(startIndex, endIndex),
                    xCol: data.series.xCol,
                    yCol: data.series.yCol
                }), data;
            }, DataDotChart.prototype.calculateAxesProperties = function(options) {
                var _this = this;
                this.currentViewport = options.viewport, this.margin = options.margin;
                var data = this.clippedData = this.data, viewport = this.currentViewport, margin = this.margin, series = data ? data.series : null, seriesArray = series && series.data && series.data.length > 0 ? [ series ] : [], categoryCount = series && series.data ? series.data.length : 0;
                data.hasHighlights && (categoryCount /= 2);
                var xMetaDataColumn, yMetaDataColumn, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom);
                DataDotChart.hasDataPoint(series) && (xMetaDataColumn = series.xCol, yMetaDataColumn = series.yCol);
                var layout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: !1,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                }), outerPadding = layout.categoryThickness * visuals.CartesianChart.OuterPaddingRatio;
                this.isScrollable || (this.clippedData = DataDotChart.createClippedDataIfOverflowed(data, layout.categoryCount));
                var yDomain = visuals.AxisHelper.createValueDomain(seriesArray, !0) || visuals.emptyDomain, combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, yDomain, options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, DataDotChart.formatStringProp),
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1
                });
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({
                    text: !0
                }), xDomain = visuals.AxisHelper.createDomain(seriesArray, axisType, !1, options.forcedXDomain, options.ensureXDomain);
                return this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, DataDotChart.formatStringProp),
                    outerPadding: outerPadding,
                    isScalar: !1,
                    isVertical: !1,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    categoryThickness: layout.categoryThickness,
                    getValueFn: function(index, type) {
                        return _this.lookupXValue(index, type);
                    },
                    isCategoryAxis: !0
                }), [ this.xAxisProperties, this.yAxisProperties ];
            }, DataDotChart.createClippedDataIfOverflowed = function(data, categoryCount) {
                var requiredLength = data.hasHighlights ? Math.min(data.series.data.length, 2 * categoryCount) : Math.min(data.series.data.length, categoryCount);
                if (requiredLength >= data.series.data.length) return data;
                var clipped = powerbi.Prototype.inherit(data);
                return clipped.series = powerbi.Prototype.inherit(data.series), clipped.series.data = clipped.series.data.slice(0, requiredLength), 
                clipped;
            }, DataDotChart.hasDataPoint = function(series) {
                return series && series.data && series.data.length > 0;
            }, DataDotChart.prototype.lookupXValue = function(index, type) {
                var data = this.data, isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime) return new Date(index);
                if (data && data.series) {
                    var seriesData = data.series.data;
                    if (seriesData) {
                        var dataAtIndex = seriesData[index];
                        if (dataAtIndex) return dataAtIndex.categoryValue;
                    }
                }
                return index;
            }, DataDotChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            }, DataDotChart.prototype.render = function(suppressAnimations) {
                var _this = this;
                if (this.clippedData) {
                    var data = this.clippedData, dataPoints = data.series.data, hasHighlights = data.hasHighlights, margin = this.margin, viewport = this.currentViewport, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, dotWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), dotRadius = dotWidth / 2, dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey), hasSelection = this.interactivityService ? this.interactivityService.hasSelection() : !1;
                    this.mainGraphicsContext.attr("width", width).attr("height", height);
                    var dots = this.mainGraphicsContext.selectAll(DataDotChart.DotClassSelector).data(dataPoints, function(d) {
                        return d.identity.getKey();
                    });
                    dots.enter().append("circle").classed(DataDotChart.DotClassName, !0), dots.style({
                        fill: dotColor.value
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                    }).classed("null-value", function(d) {
                        return null === d.value;
                    }).attr({
                        r: function(d) {
                            return dotRadius;
                        },
                        cx: function(d) {
                            return xScale(d.categoryIndex) + dotRadius;
                        },
                        cy: function(d) {
                            return yScale(d.value);
                        }
                    }), dots.exit().remove();
                    var dotLabels = this.mainGraphicsContext.selectAll(DataDotChart.DotLabelClassSelector).data(dataPoints, function(d) {
                        return d.identity.getKey();
                    });
                    dotLabels.enter().append("text").classed(DataDotChart.DotLabelClassName, !0).attr({
                        "text-anchor": DataDotChart.DotLabelTextAnchor,
                        dy: DataDotChart.DotLabelVerticalOffset
                    }), dotLabels.classed("null-value", function(d) {
                        return null === d.value;
                    }).classed("overflowed", !1).attr({
                        x: function(d) {
                            return xScale(d.categoryIndex) + dotRadius;
                        },
                        y: function(d) {
                            return yScale(d.value);
                        }
                    }).text(function(d) {
                        return _this.yAxisProperties.formatter.format(d.value);
                    });
                    var overflowed = !1;
                    dotLabels.each(function() {
                        if (!overflowed && !$("<div>").addClass($(this).attr("class")).hasClass("null-value")) {
                            var width_1 = powerbi.TextMeasurementService.measureSvgTextElementWidth(this);
                            width_1 > dotWidth && (dotLabels.classed("overflowed", !0), overflowed = !0);
                        }
                    }), dotLabels.exit().remove();
                    var behaviorOptions = void 0;
                    return this.interactivityService && (behaviorOptions = {
                        dots: dots,
                        dotLabels: dotLabels,
                        datapoints: dataPoints
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                        dataPoints: dataPoints,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: [],
                        labelsAreNumeric: !0
                    };
                }
            }, DataDotChart.prototype.calculateLegend = function() {
                return this.createLegendDataPoints(0);
            }, DataDotChart.prototype.hasLegend = function() {
                return this.data && this.data.hasDynamicSeries;
            }, DataDotChart.prototype.createLegendDataPoints = function(columnIndex) {
                var data = this.data;
                if (!data) return null;
                var category, series = data.series, seriesData = series.data, legendDataPoints = [], axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({
                    text: !0
                });
                if (data.series && data.series.data) {
                    var firstDataPoint = data.series.data[0];
                    category = firstDataPoint && this.lookupXValue(firstDataPoint.categoryValue, axisType);
                }
                if (series.yCol) {
                    var formatStringProp = DataDotChart.formatStringProp, lineDataPoint = seriesData[columnIndex], measure = lineDataPoint && lineDataPoint.value, label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCategorical.values, formatStringProp), dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey), dataViewCategoricalValues = this.dataViewCategorical.values, identity = dataViewCategoricalValues && dataViewCategoricalValues.length > columnIndex ? visuals.SelectionId.createWithIdAndMeasure(dataViewCategoricalValues[columnIndex].identity, dataViewCategoricalValues[columnIndex].source.queryName) : visuals.SelectionId.createWithMeasure(dataViewCategoricalValues.source.queryName);
                    legendDataPoints.push({
                        color: dotColor.value,
                        icon: visuals.LegendIcon.Line,
                        label: label,
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: identity,
                        selected: !1
                    });
                }
                return {
                    dataPoints: legendDataPoints
                };
            }, DataDotChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, DataDotChart.converter = function(dataView, blankCategoryValue, interactivityService) {
                var categorical = dataView.categorical, category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                    source: void 0,
                    values: [ blankCategoryValue ],
                    identity: void 0
                }, categoryType = visuals.AxisHelper.getCategoryValueType(category.source), isDateTime = visuals.AxisHelper.isDateTime(categoryType), categoryValues = category.values;
                if (!_.isEmpty(categorical.values)) {
                    for (var measure = categorical.values[0], hasHighlights = !!measure.highlights, dataPoints = [], categoryIndex = 0, len = measure.values.length; len > categoryIndex; categoryIndex++) {
                        var identity = category.identity ? visuals.SelectionId.createWithIdAndMeasure(category.identity[categoryIndex], measure.source.queryName) : visuals.SelectionId.createWithMeasure(measure.source.queryName), categoryValue = categoryValues[categoryIndex];
                        if ((!isDateTime || null == categoryValue || categoryValue instanceof Date) && (dataPoints.push({
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: measure.values[categoryIndex],
                            categoryIndex: categoryIndex,
                            seriesIndex: 0,
                            selected: !1,
                            identity: identity,
                            highlight: !1
                        }), hasHighlights)) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlightValue = measure.highlights[categoryIndex];
                            dataPoints.push({
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: highlightValue,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: !1,
                                identity: highlightIdentity,
                                highlight: !0
                            });
                        }
                    }
                    return interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                    {
                        series: {
                            xCol: category.source,
                            yCol: measure.source,
                            data: dataPoints
                        },
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: !0
                    };
                }
                return {
                    series: {
                        data: []
                    },
                    hasHighlights: !1,
                    hasDynamicSeries: !1
                };
            }, DataDotChart.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            }, DataDotChart.ClassName = "dataDotChart", DataDotChart.DotClassName = "dot", DataDotChart.DotClassSelector = ".dot", 
            DataDotChart.DotColorKey = "dataDot", DataDotChart.DotLabelClassName = "label", 
            DataDotChart.DotLabelClassSelector = ".label", DataDotChart.DotLabelVerticalOffset = "0.4em", 
            DataDotChart.DotLabelTextAnchor = "middle", DataDotChart;
        }();
        visuals.DataDotChart = DataDotChart;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, DataRoleHelper = powerbi.data.DataRoleHelper, FunnelChart = function() {
            function FunnelChart(options) {
                this.labelPositionObjects = [ visuals.labelPosition.outsideEnd, visuals.labelPosition.insideCenter ], 
                options && (this.tooltipsEnabled = options.tooltipsEnabled, options.funnelSmallViewPortProperties && (this.funnelSmallViewPortProperties = options.funnelSmallViewPortProperties), 
                options.animator && (this.animator = options.animator), options.behavior && (this.behavior = options.behavior));
            }
            return FunnelChart.isValidValueColumn = function(valueColumn) {
                return DataRoleHelper.hasRole(valueColumn.source, "Y");
            }, FunnelChart.getFirstValidValueColumn = function(values) {
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var valueColumn = values_1[_i];
                    if (FunnelChart.isValidValueColumn(valueColumn)) return valueColumn;
                }
            }, FunnelChart.converter = function(dataView, colors, hostServices, defaultDataPointColor, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var slices = [], formatStringProp = visuals.funnelChartProps.general.formatString, categorical = dataView.categorical, categories = categorical.categories || [], values = categorical.values, valueMetaData = [];
                values && (valueMetaData = _.map(values, function(v) {
                    return v.source;
                }));
                var firstValue, firstHighlight, previousValue, previousHighlight, hasHighlights = values && values.length > 0 && values[0] && !!values[0].highlights, highlightsOverflow = !1, hasNegativeValues = !1, allValuesAreNegative = !1, categoryLabels = [], dataLabelsSettings = visuals.dataLabelUtils.getDefaultFunnelLabelSettings(), percentBarLabelSettings = visuals.dataLabelUtils.getDefaultLabelSettings(!0), colorHelper = new visuals.ColorHelper(colors, visuals.funnelChartProps.dataPoint.fill, defaultDataPointColor), gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(categorical), gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(categorical), defaultSeriesIndex = 0, seriesIndexGradientAddedFirst = 1;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects.labels;
                    labelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    var percentLabelsObj = dataView.metadata.objects.percentBarLabel;
                    percentLabelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(percentLabelsObj, percentBarLabelSettings);
                }
                var firstValueColumn = !_.isEmpty(values) && FunnelChart.getFirstValidValueColumn(values);
                if (!firstValueColumn) return {
                    slices: slices,
                    categoryLabels: categoryLabels,
                    valuesMetadata: valueMetaData,
                    hasHighlights: hasHighlights,
                    highlightsOverflow: highlightsOverflow,
                    canShowDataLabels: !0,
                    dataLabelsSettings: dataLabelsSettings,
                    hasNegativeValues: hasNegativeValues,
                    allValuesAreNegative: allValuesAreNegative,
                    percentBarLabelSettings: percentBarLabelSettings
                };
                var seriesIndex = gradientMeasureIndex === defaultSeriesIndex ? seriesIndexGradientAddedFirst : defaultSeriesIndex;
                if (firstValue = firstValueColumn.values[0], hasHighlights && (firstHighlight = firstValueColumn.highlights[0]), 
                1 === categories.length) for (var category = categories[0], categoryValues = category.values, categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp), i = 0, ilen = categoryValues.length; ilen > i; i++) {
                    var measureName = firstValueColumn.source.queryName, identity = visuals.SelectionIdBuilder.builder().withCategory(category, i).withMeasure(measureName).createSelectionId(), value = firstValueColumn.values[i], formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString), tooltipInfo = void 0;
                    if (tooltipsEnabled) {
                        if (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null, gradientValueColumn), 
                        hasHighlights) {
                            var highlight = firstValueColumn.highlights[i];
                            0 !== highlight && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlight, gradientValueColumn));
                        }
                        FunnelChart.addFunnelPercentsToTooltip(tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
                    }
                    var color = colorHelper.getColorForMeasure(category.objects && category.objects[i], "");
                    if (slices.push({
                        label: formattedCategoryValue,
                        value: value,
                        originalValue: value,
                        categoryOrMeasureIndex: i,
                        identity: identity,
                        selected: !1,
                        key: identity.getKey(),
                        tooltipInfo: tooltipInfo,
                        color: color,
                        labelFill: dataLabelsSettings.labelColor
                    }), hasHighlights) {
                        var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlight = firstValueColumn.highlights[i], highlightedValue = 0 !== highlight ? highlight : void 0, tooltipInfo_2 = void 0;
                        tooltipsEnabled && (tooltipInfo_2 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue, gradientValueColumn), 
                        FunnelChart.addFunnelPercentsToTooltip(tooltipInfo_2, hostServices, firstHighlight ? highlight / firstHighlight : null, previousHighlight ? highlight / previousHighlight : null, !0)), 
                        slices.push({
                            label: formattedCategoryValue,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: i,
                            identity: highlightIdentity,
                            selected: !1,
                            key: highlightIdentity.getKey(),
                            highlight: !0,
                            highlightValue: highlight,
                            originalHighlightValue: highlight,
                            tooltipInfo: tooltipInfo_2,
                            color: color
                        }), previousHighlight = highlight;
                    }
                    previousValue = value;
                } else if (valueMetaData.length > 0 && values && values.length > 0) for (var i = 0, len = values.length; len > i; i++) {
                    var valueColumn = values[i];
                    if (FunnelChart.isValidValueColumn(valueColumn)) {
                        var value = valueColumn.values[0], identity = visuals.SelectionId.createWithMeasure(valueColumn.source.queryName), categoryValue = valueMetaData[i].displayName, valueIndex = categorical.categories ? null : i, tooltipInfo = void 0, color = colorHelper.getColorForMeasure(valueColumn.source.objects, "");
                        if (tooltipsEnabled) {
                            if (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, valueIndex, i), 
                            hasHighlights) {
                                var highlight = valueColumn.highlights[0];
                                0 !== highlight && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, 0, i, highlight));
                            }
                            FunnelChart.addFunnelPercentsToTooltip(tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
                        }
                        if (slices.push({
                            label: valueMetaData[i].displayName,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: !1,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.labelColor
                        }), hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlight = valueColumn.highlights[0];
                            highlight > value && (highlightsOverflow = !0);
                            var highlightedValue = 0 !== highlight ? highlight : void 0, tooltipInfo_3 = void 0;
                            tooltipsEnabled && (tooltipInfo_3 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, 0, i, highlightedValue), 
                            FunnelChart.addFunnelPercentsToTooltip(tooltipInfo_3, hostServices, firstHighlight ? highlight / firstHighlight : null, previousHighlight ? highlight / previousHighlight : null, !0)), 
                            slices.push({
                                label: valueMetaData[i].displayName,
                                value: value,
                                originalValue: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                selected: !1,
                                highlight: !0,
                                originalHighlightValue: highlight,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo_3,
                                color: color
                            }), previousHighlight = highlight;
                        }
                        previousValue = value;
                    }
                }
                for (var i = 0; i < slices.length; i += hasHighlights ? 2 : 1) {
                    var slice = slices[i];
                    categoryLabels.push(slice.label);
                }
                allValuesAreNegative = slices.length > 0 && _.every(slices, function(slice) {
                    return (slice.highlight ? slice.highlightValue <= 0 : !0) && slice.value < 0;
                });
                for (var _i = 0, slices_1 = slices; _i < slices_1.length; _i++) {
                    var slice = slices_1[_i];
                    if (allValuesAreNegative) slice.value = Math.abs(slice.value), slice.highlight && (slice.highlightValue = Math.abs(slice.highlightValue)); else {
                        var value = slice.value, isValueNegative = 0 > value;
                        isValueNegative && (slice.value = 0);
                        var isHighlightValueNegative = !1;
                        if (slice.highlight) {
                            var highlightValue = slice.highlightValue;
                            isHighlightValueNegative = 0 > highlightValue, slice.highlightValue = isHighlightValueNegative ? 0 : highlightValue;
                        }
                        hasNegativeValues || (hasNegativeValues = isValueNegative || isHighlightValueNegative);
                    }
                    slice.highlightValue > slice.value && (highlightsOverflow = !0);
                }
                return {
                    slices: slices,
                    categoryLabels: categoryLabels,
                    valuesMetadata: valueMetaData,
                    hasHighlights: hasHighlights,
                    highlightsOverflow: highlightsOverflow,
                    canShowDataLabels: !0,
                    dataLabelsSettings: dataLabelsSettings,
                    hasNegativeValues: hasNegativeValues,
                    allValuesAreNegative: allValuesAreNegative,
                    percentBarLabelSettings: percentBarLabelSettings
                };
            }, FunnelChart.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                  case "dataPoint":
                    var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical, hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                    hasGradientRole || this.enumerateDataPoints(enumeration);
                    break;

                  case "labels":
                    var labelSettingsOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.dataLabelsSettings, !0, this.labelPositionObjects);
                    visuals.dataLabelUtils.enumerateDataLabels(labelSettingsOptions);
                    break;

                  case "percentBarLabel":
                    var percentLabelSettingOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.percentBarLabelSettings, !1);
                    visuals.dataLabelUtils.enumerateDataLabels(percentLabelSettingOptions);
                }
                return enumeration.complete();
            }, FunnelChart.getLabelSettingsOptions = function(enumeration, labelSettings, isDataLabels, positionObject) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: !0,
                    displayUnits: isDataLabels,
                    precision: isDataLabels,
                    position: isDataLabels,
                    positionObject: positionObject,
                    fontSize: !0
                };
            }, FunnelChart.prototype.enumerateDataPoints = function(enumeration) {
                var data = this.data;
                if (data) {
                    var slices = data.slices;
                    enumeration.pushInstance({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            defaultColor: {
                                solid: {
                                    color: this.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                }
                            }
                        }
                    });
                    for (var i = 0; i < slices.length; i++) {
                        var slice = slices[i];
                        if (!slice.highlight) {
                            var color = slice.color, selector = slice.identity.getSelector(), isSingleSeries = !!selector.data;
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: slice.label,
                                selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: color
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }, FunnelChart.prototype.init = function(options) {
                this.options = options;
                var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(FunnelChart.VisualClassName, !0);
                this.behavior && (this.clearCatcher = visuals.appendClearCatcher(this.svg)), this.currentViewport = options.viewport, 
                this.margin = {
                    left: 5,
                    right: 5,
                    top: 0,
                    bottom: 0
                };
                var style = options.style;
                this.colors = style.colorPalette.dataColors, this.hostServices = options.host, this.behavior && (this.interactivityService = visuals.createInteractivityService(this.hostServices)), 
                this.percentGraphicsContext = svg.append("g").classed(FunnelChart.Selectors.percentBar.root["class"], !0), 
                this.funnelGraphicsContext = svg.append("g"), this.axisGraphicsContext = svg.append("g"), 
                this.updateViewportProperties();
            }, FunnelChart.prototype.updateViewportProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            }, FunnelChart.prototype.update = function(options) {
                this.data = {
                    slices: [],
                    categoryLabels: [],
                    valuesMetadata: [],
                    hasHighlights: !1,
                    highlightsOverflow: !1,
                    canShowDataLabels: !0,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
                    hasNegativeValues: !1,
                    allValuesAreNegative: !1,
                    percentBarLabelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0)
                };
                var dataViews = this.dataViews = options.dataViews;
                if (this.currentViewport = options.viewport, dataViews && dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var defaultColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, visuals.funnelChartProps.dataPoint.defaultColor);
                        defaultColor && (this.defaultDataPointColor = defaultColor);
                    }
                    dataView.categorical && (this.data = FunnelChart.converter(dataView, this.colors, this.hostServices, this.defaultDataPointColor, this.tooltipsEnabled), 
                    this.interactivityService && this.interactivityService.applySelectionStateToData(this.data.slices));
                    var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                    this.data.allValuesAreNegative ? warnings.unshift(new visuals.AllNegativeValuesWarning()) : this.data.hasNegativeValues && warnings.unshift(new visuals.NegativeValuesNotSupportedWarning()), 
                    this.hostServices.setWarnings(warnings);
                }
                this.updateViewportProperties(), this.updateInternal(options.suppressAnimations);
            }, FunnelChart.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            }, FunnelChart.prototype.onResizing = function(viewport) {
                this.currentViewport = viewport, this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: !0,
                    viewport: this.currentViewport
                });
            }, FunnelChart.prototype.getMaxLabelLength = function(labels, properties) {
                for (var max = 0, textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth, i = 0, len = labels.length; len > i; i++) properties.text = labels[i], 
                max = Math.max(max, textMeasurer(properties));
                return max + FunnelChart.LabelFunnelPadding;
            }, FunnelChart.prototype.updateInternal = function(suppressAnimations) {
                if (null != this.data) {
                    var data = this.data, slices = data.slices, slicesWithoutHighlights = slices.filter(function(d) {
                        return !d.highlight;
                    }), isHidingPercentBars = this.isHidingPercentBars(), axisOptions = this.setUpAxis(), margin = axisOptions.margin, verticalRange = axisOptions.verticalRange, funnelContext = this.funnelGraphicsContext.attr("transform", visuals.SVGUtil.translateAndRotate(margin.left, margin.top, verticalRange / 2, verticalRange / 2, 90));
                    this.percentGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.svg.style("font-family", visuals.dataLabelUtils.StandardFontFamily);
                    var result, shapes, dataLabels, layout = FunnelChart.getLayout(data, axisOptions), labelLayout = visuals.dataLabelUtils.getFunnelChartLabelLayout(data, axisOptions, FunnelChart.InnerTextMinimumPadding, data.dataLabelsSettings, this.currentViewport);
                    if (this.animator && !suppressAnimations) {
                        var animationOptions = {
                            viewModel: data,
                            interactivityService: this.interactivityService,
                            layout: layout,
                            axisGraphicsContext: this.axisGraphicsContext,
                            shapeGraphicsContext: funnelContext,
                            percentGraphicsContext: this.percentGraphicsContext,
                            labelGraphicsContext: this.svg,
                            axisOptions: axisOptions,
                            slicesWithoutHighlights: slicesWithoutHighlights,
                            labelLayout: labelLayout,
                            isHidingPercentBars: isHidingPercentBars,
                            visualInitOptions: this.options
                        };
                        result = this.animator.animate(animationOptions), shapes = result.shapes, dataLabels = result.dataLabels;
                    }
                    if ((!this.animator || suppressAnimations || result.failed) && (FunnelChart.drawDefaultAxis(this.axisGraphicsContext, axisOptions, isHidingPercentBars), 
                    shapes = FunnelChart.drawDefaultShapes(data, slices, funnelContext, layout, this.interactivityService && this.interactivityService.hasSelection()), 
                    FunnelChart.drawPercentBars(data, this.percentGraphicsContext, layout, isHidingPercentBars), 
                    data.dataLabelsSettings.show && data.canShowDataLabels ? dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(data.slices, this.svg, labelLayout) : visuals.dataLabelUtils.cleanDataLabels(this.svg)), 
                    this.interactivityService) {
                        var interactors = FunnelChart.drawInteractorShapes(slices, funnelContext, layout), behaviorOptions = {
                            bars: shapes,
                            interactors: interactors,
                            clearCatcher: this.clearCatcher,
                            hasHighlights: data.hasHighlights
                        };
                        this.interactivityService.bind(slices, this.behavior, behaviorOptions), this.tooltipsEnabled && visuals.TooltipManager.addTooltip(interactors, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }
                    this.tooltipsEnabled && visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                }
            }, FunnelChart.prototype.getUsableVerticalSpace = function() {
                var categoryLabels = this.data.categoryLabels, margin = this.margin, verticalSpace = this.currentViewport.height - (margin.top + margin.bottom);
                return verticalSpace - FunnelChart.MinBarThickness * categoryLabels.length;
            }, FunnelChart.prototype.isHidingPercentBars = function() {
                var data = this.data;
                if (data.percentBarLabelSettings.show) {
                    var percentBarTextHeight = this.getPercentBarTextHeight(), verticalSpace = this.getUsableVerticalSpace() - 2 * FunnelChart.MinBarThickness * FunnelChart.PercentBarToBarRatio - 2 * percentBarTextHeight;
                    return 0 >= verticalSpace;
                }
                return !0;
            }, FunnelChart.prototype.isSparklines = function() {
                return this.getUsableVerticalSpace() <= 0;
            }, FunnelChart.prototype.setUpAxis = function() {
                var data = this.data, slices = data.slices, categoryLabels = data.categoryLabels, viewport = this.currentViewport, margin = this.margin, isSparklines = this.isSparklines(), isHidingPercentBars = this.isHidingPercentBars(), percentBarTextHeight = isHidingPercentBars ? 0 : this.getPercentBarTextHeight(), horizontalRange = viewport.height - (margin.top + margin.bottom) - 2 * percentBarTextHeight, maxMarginFactor = FunnelChart.MaxMarginFactor;
                if (categoryLabels.length > 0 && isSparklines) categoryLabels = [], data.canShowDataLabels = !1; else if (this.showCategoryLabels()) {
                    var textProperties = FunnelChart.getTextProperties(), longestLabelLength = this.getMaxLabelLength(categoryLabels, textProperties), maxLabelLength = viewport.width * maxMarginFactor, labelLength = Math.min(longestLabelLength, maxLabelLength);
                    margin.left = labelLength + FunnelChart.YAxisPadding;
                } else categoryLabels = [];
                var delta, verticalRange = viewport.width - (margin.left + margin.right), barToSpaceRatio = FunnelChart.BarToSpaceRatio, maxScore = d3.max(slices.map(function(d) {
                    return d.value;
                })), minScore = 0, rangeStart = 0, rangeEnd = horizontalRange;
                delta = isHidingPercentBars ? horizontalRange - categoryLabels.length * FunnelChart.MaxBarWidth : horizontalRange - categoryLabels.length * FunnelChart.MaxBarWidth - 2 * FunnelChart.MaxBarWidth * FunnelChart.PercentBarToBarRatio, 
                categoryLabels.length > 0 && delta > 0 && (rangeStart = Math.ceil(delta / 2), rangeEnd = Math.ceil(horizontalRange - delta / 2)), 
                isHidingPercentBars || (rangeStart += percentBarTextHeight, rangeEnd += percentBarTextHeight);
                var yScale = d3.scale.linear().domain([ minScore, maxScore ]).range([ verticalRange, 0 ]), xScale = d3.scale.ordinal().domain(d3.range(0, data.categoryLabels.length)).rangeBands([ rangeStart, rangeEnd ], barToSpaceRatio, isHidingPercentBars ? barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
                return {
                    margin: margin,
                    xScale: xScale,
                    yScale: yScale,
                    maxScore: maxScore,
                    verticalRange: verticalRange,
                    rangeStart: rangeStart,
                    rangeEnd: rangeEnd,
                    barToSpaceRatio: barToSpaceRatio,
                    categoryLabels: categoryLabels
                };
            }, FunnelChart.prototype.getPercentBarTextHeight = function() {
                var percentBarTextProperties = FunnelChart.getTextProperties(this.data.percentBarLabelSettings.fontSize);
                return powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties);
            }, FunnelChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, FunnelChart.getLayout = function(data, axisOptions) {
                var highlightsOverflow = data.highlightsOverflow, yScale = axisOptions.yScale, xScale = axisOptions.xScale, maxScore = axisOptions.maxScore, columnWidth = xScale.rangeBand(), halfColumnWidth = Math.ceil(columnWidth / 2), percentBarTickHeight = halfColumnWidth, overFlowHighlightColumnWidth = columnWidth * FunnelChart.OverflowingHighlightWidthRatio, overFlowHighlightOffset = overFlowHighlightColumnWidth / 2, lastCategoryIndex = axisOptions.categoryLabels.length - 1, horizontalDistance = Math.abs(yScale(maxScore) - yScale(0)), emptyHorizontalSpace = function(value) {
                    return (horizontalDistance - Math.abs(yScale(value) - yScale(0))) / 2;
                }, getMinimumShapeSize = function(value) {
                    return Math.max(FunnelChart.MinimumInteractorSize, Math.abs(yScale(value) - yScale(0)));
                }, percentBarFontSize = PixelConverter.fromPoint(data.percentBarLabelSettings.fontSize), percentBarTextProperties = FunnelChart.getTextProperties(data.percentBarLabelSettings.fontSize), baselineDelta = powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(percentBarTextProperties), percentBarYOffset = powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties) - baselineDelta;
                return {
                    percentBarLayout: {
                        mainLine: {
                            x2: function(d) {
                                return Math.abs(yScale(d.value) - yScale(0));
                            },
                            transform: function(d) {
                                var xOffset = yScale(d.value) - emptyHorizontalSpace(d.value), yOffset = d.isTop ? xScale(0) - halfColumnWidth : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth;
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            }
                        },
                        leftTick: {
                            y2: function(d) {
                                return percentBarTickHeight;
                            },
                            transform: function(d) {
                                var xOffset = yScale(d.value) - emptyHorizontalSpace(d.value), yOffset = d.isTop ? xScale(0) - halfColumnWidth - percentBarTickHeight / 2 : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth - percentBarTickHeight / 2;
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            }
                        },
                        rightTick: {
                            y2: function(d) {
                                return percentBarTickHeight;
                            },
                            transform: function(d) {
                                var columnOffset = yScale(d.value) - emptyHorizontalSpace(d.value), columnHeight = Math.abs(yScale(d.value) - yScale(0)), xOffset = columnOffset + columnHeight, yOffset = d.isTop ? xScale(0) - halfColumnWidth - percentBarTickHeight / 2 : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth - percentBarTickHeight / 2;
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            }
                        },
                        text: {
                            x: function(d) {
                                return Math.ceil(Math.abs(yScale(maxScore) - yScale(0)) / 2);
                            },
                            y: function(d) {
                                return d.isTop ? -percentBarTickHeight / 2 - baselineDelta : percentBarYOffset + percentBarTickHeight / 2;
                            },
                            style: function() {
                                return "font-size: " + percentBarFontSize + ";";
                            },
                            transform: function(d) {
                                var yOffset = d.isTop ? xScale(0) - halfColumnWidth : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth;
                                return visuals.SVGUtil.translate(0, yOffset);
                            },
                            fill: data.percentBarLabelSettings.labelColor,
                            maxWidth: horizontalDistance
                        }
                    },
                    shapeLayout: {
                        width: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth;
                        },
                        height: function(d) {
                            return Math.abs(yScale(FunnelChart.getFunnelSliceValue(d)) - yScale(0));
                        },
                        x: function(d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function(d) {
                            var value = FunnelChart.getFunnelSliceValue(d);
                            return yScale(value) - emptyHorizontalSpace(value);
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return columnWidth;
                        },
                        height: function(d) {
                            return Math.abs(yScale(d.value) - yScale(0));
                        },
                        x: function(d) {
                            return xScale(d.categoryOrMeasureIndex) + 0;
                        },
                        y: function(d) {
                            return yScale(d.value) - emptyHorizontalSpace(d.value);
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth;
                        },
                        height: function(d) {
                            return 0;
                        },
                        x: function(d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function(d) {
                            return yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);
                        }
                    },
                    interactorLayout: {
                        width: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth;
                        },
                        height: function(d) {
                            return getMinimumShapeSize(FunnelChart.getFunnelSliceValue(d));
                        },
                        x: function(d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function(d) {
                            var size = getMinimumShapeSize(FunnelChart.getFunnelSliceValue(d));
                            return (horizontalDistance - size) / 2;
                        }
                    }
                };
            }, FunnelChart.drawDefaultAxis = function(graphicsContext, axisOptions, isHidingPercentBars) {
                var indices = d3.range(0, axisOptions.categoryLabels.length), xScaleForAxis = d3.scale.ordinal().domain(indices).rangeBands([ axisOptions.rangeStart, axisOptions.rangeEnd ], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : FunnelChart.PercentBarToBarRatio), xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right").tickPadding(FunnelChart.TickPadding).innerTickSize(FunnelChart.InnerTickSize).ticks(indices.length).tickValues(indices).tickFormat(function(i) {
                    return axisOptions.categoryLabels[i];
                });
                graphicsContext.attr("class", "axis hideLinesOnAxis").attr("transform", visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis), 
                graphicsContext.selectAll(".tick").call(visuals.tooltipUtils.tooltipUpdate, axisOptions.categoryLabels);
                var leftRightMarginLimit = axisOptions.margin.left - FunnelChart.LabelFunnelPadding;
                graphicsContext.selectAll(".tick text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit, powerbi.TextMeasurementService.svgEllipsis);
            }, FunnelChart.drawDefaultShapes = function(data, slices, graphicsContext, layout, hasSelection) {
                var hasHighlights = data.hasHighlights, columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.bars.selector).data(slices, function(d) {
                    return d.key;
                });
                return columns.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? FunnelChart.FunnelBarHighlightClass : FunnelChart.Selectors.funnel.bars["class"];
                }), columns.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                    };
                }).attr(layout.shapeLayout), columns.exit().remove(), columns;
            }, FunnelChart.getFunnelSliceValue = function(slice, asOriginal) {
                return void 0 === asOriginal && (asOriginal = !1), asOriginal ? slice.highlight ? slice.originalHighlightValue : slice.originalValue : slice.highlight ? slice.highlightValue : slice.value;
            }, FunnelChart.drawInteractorShapes = function(slices, graphicsContext, layout) {
                var needInteractors = slices.filter(function(d) {
                    return !d.highlight && layout.interactorLayout.height(d) === FunnelChart.MinimumInteractorSize;
                }), columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.interactors.selector).data(needInteractors, function(d) {
                    return d.key;
                });
                return columns.enter().append("rect").attr("class", FunnelChart.Selectors.funnel.interactors["class"]), 
                columns.style("fill-opacity", 0).attr(layout.interactorLayout), columns.exit().remove(), 
                columns;
            }, FunnelChart.drawPercentBarComponents = function(graphicsContext, data, layout, percentLabelSettings) {
                var mainLine = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                mainLine.exit().remove(), mainLine.enter().append("line").classed(FunnelChart.Selectors.percentBar.mainLine["class"], !0), 
                mainLine.attr(layout.percentBarLayout.mainLine);
                var leftTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                leftTick.exit().remove(), leftTick.enter().append("line").classed(FunnelChart.Selectors.percentBar.leftTick["class"], !0), 
                leftTick.attr(layout.percentBarLayout.leftTick);
                var rightTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                rightTick.exit().remove(), rightTick.enter().append("line").classed(FunnelChart.Selectors.percentBar.rightTick["class"], !0), 
                rightTick.attr(layout.percentBarLayout.rightTick);
                var text = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.text.selector).data(data), localizedString = visuals.valueFormatter.getLocalizedString("Percentage1");
                text.exit().remove(), text.enter().append("text").classed(FunnelChart.Selectors.percentBar.text["class"], !0), 
                text.attr(layout.percentBarLayout.text).text(function(fp) {
                    return visuals.dataLabelUtils.getLabelFormattedText({
                        label: fp.percent,
                        format: localizedString,
                        fontSize: percentLabelSettings.fontSize,
                        maxWidth: layout.percentBarLayout.text.maxWidth
                    });
                }).append("title").text(function(d) {
                    return powerbi.formattingService.formatValue(d.percent, localizedString);
                });
            }, FunnelChart.drawPercentBars = function(data, graphicsContext, layout, isHidingPercentBars) {
                if (isHidingPercentBars || !data.slices || (data.hasHighlights ? data.slices.length / 2 : data.slices.length) < 2) return void FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                var slices = [ data.slices[data.hasHighlights ? 1 : 0], data.slices[data.slices.length - 1] ], baseline = FunnelChart.getFunnelSliceValue(slices[0]);
                if (0 >= baseline) return void FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                var percentData = [ {
                    value: FunnelChart.getFunnelSliceValue(slices[0]),
                    percent: 1,
                    isTop: !0
                }, {
                    value: FunnelChart.getFunnelSliceValue(slices[1]),
                    percent: FunnelChart.getFunnelSliceValue(slices[1]) / baseline,
                    isTop: !1
                } ];
                FunnelChart.drawPercentBarComponents(graphicsContext, percentData, layout, data.percentBarLabelSettings);
            }, FunnelChart.prototype.showCategoryLabels = function() {
                return !(this.funnelSmallViewPortProperties && this.funnelSmallViewPortProperties.hideFunnelCategoryLabelsOnSmallViewPort && this.currentViewport.height < this.funnelSmallViewPortProperties.minHeightFunnelCategoryLabelsVisible);
            }, FunnelChart.addFunnelPercentsToTooltip = function(tooltipInfo, hostServices, percentOfFirst, percentOfPrevious, highlight) {
                null != percentOfFirst && tooltipInfo.push({
                    displayName: hostServices.getLocalizedString("Funnel_PercentOfFirst" + (highlight ? "_Highlight" : "")),
                    value: visuals.valueFormatter.format(percentOfFirst, "0.00 %;-0.00 %;0.00 %")
                }), null != percentOfPrevious && tooltipInfo.push({
                    displayName: hostServices.getLocalizedString("Funnel_PercentOfPrevious" + (highlight ? "_Highlight" : "")),
                    value: visuals.valueFormatter.format(percentOfPrevious, "0.00 %;-0.00 %;0.00 %")
                });
            }, FunnelChart.getTextProperties = function(fontSize) {
                return {
                    fontSize: PixelConverter.fromPoint(fontSize || visuals.dataLabelUtils.DefaultFontSizeInPt),
                    fontFamily: FunnelChart.DefaultFontFamily
                };
            }, FunnelChart.DefaultBarOpacity = 1, FunnelChart.DimmedBarOpacity = .4, FunnelChart.PercentBarToBarRatio = .75, 
            FunnelChart.TickPadding = 0, FunnelChart.InnerTickSize = 0, FunnelChart.MinimumInteractorSize = 15, 
            FunnelChart.InnerTextClassName = "labelSeries", FunnelChart.Selectors = {
                funnel: {
                    bars: createClassAndSelector("funnelBar"),
                    highlights: createClassAndSelector("highlight"),
                    interactors: createClassAndSelector("funnelBarInteractor")
                },
                percentBar: {
                    root: createClassAndSelector("percentBars"),
                    mainLine: createClassAndSelector("mainLine"),
                    leftTick: createClassAndSelector("leftTick"),
                    rightTick: createClassAndSelector("rightTick"),
                    text: createClassAndSelector("value")
                }
            }, FunnelChart.FunnelBarHighlightClass = [ FunnelChart.Selectors.funnel.bars["class"], FunnelChart.Selectors.funnel.highlights["class"] ].join(" "), 
            FunnelChart.YAxisPadding = 10, FunnelChart.VisualClassName = "funnelChart", FunnelChart.DefaultFontFamily = "wf_standard-font", 
            FunnelChart.BarToSpaceRatio = .1, FunnelChart.MaxBarWidth = 40, FunnelChart.MinBarThickness = 12, 
            FunnelChart.LabelFunnelPadding = 6, FunnelChart.InnerTextMinimumPadding = 10, FunnelChart.OverflowingHighlightWidthRatio = .5, 
            FunnelChart.MaxMarginFactor = .25, FunnelChart;
        }();
        visuals.FunnelChart = FunnelChart;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, DataRoleHelper = powerbi.data.DataRoleHelper, Gauge = function() {
            function Gauge(options) {
                this.lastAngle = -Math.PI / 2, options && (options.gaugeSmallViewPortProperties && (this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties), 
                this.animator = options.animator, this.tooltipsEnabled = options.tooltipsEnabled);
            }
            return Gauge.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                  case "axis":
                    this.enumerateAxis(enumeration);
                    break;

                  case "labels":
                    var labelSettings = this.data ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                    visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                    break;

                  case "calloutValue":
                    var labelSettings = this.data ? this.data.calloutValueLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                    visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                    break;

                  case "dataPoint":
                    this.enumerateDataPoint(enumeration);
                }
                return enumeration.complete();
            }, Gauge.prototype.getDataLabelSettingsOptions = function(enumeration, labelSettings) {
                return {
                    dataLabelsSettings: labelSettings,
                    show: !0,
                    precision: !0,
                    displayUnits: !0,
                    fontSize: !0,
                    enumeration: enumeration
                };
            }, Gauge.prototype.enumerateAxis = function(enumeration) {
                var dataView = this.dataViews[0];
                if (dataView && dataView.metadata) {
                    var properties = Gauge.getGaugeObjectsProperties(dataView);
                    enumeration.pushInstance({
                        selector: null,
                        objectName: "axis",
                        properties: properties
                    });
                }
            }, Gauge.prototype.enumerateDataPoint = function(enumeration) {
                var dataPointSettings = this.data ? this.data.dataPointSettings : Gauge.DefaultDataPointSettings, properties = {};
                properties.fill = {
                    solid: {
                        color: dataPointSettings.fillColor
                    }
                }, null != dataPointSettings.targetColor && (properties.target = {
                    solid: {
                        color: dataPointSettings.targetColor
                    }
                }), enumeration.pushInstance({
                    selector: null,
                    objectName: visuals.gaugeProps.dataPoint.target.objectName,
                    properties: properties
                });
            }, Gauge.getGaugeObjectsProperties = function(dataView) {
                var properties = {}, objects = dataView.metadata.objects, hasAxisObject = !!objects && !!objects.axis;
                return DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.minValue) || (properties.min = hasAxisObject ? objects.axis.min : void 0), 
                DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.maxValue) || (properties.max = hasAxisObject ? objects.axis.max : void 0), 
                DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.targetValue) || (properties.target = hasAxisObject ? objects.axis.target : void 0), 
                properties;
            }, Gauge.prototype.init = function(options) {
                this.element = options.element, this.currentViewport = options.viewport, this.style = options.style, 
                this.options = options, this.settings = Gauge.DefaultStyleProperties, this.targetSettings = Gauge.DefaultTargetSettings, 
                this.setMargins(), this.color = d3.scale.ordinal().range(this.style.colorPalette.dataColors.getSentimentColors().map(function(color) {
                    return color.value;
                })), this.hostService = options.host;
                var svg = this.svg = d3.select(this.element.get(0)).append("svg");
                svg.classed(Gauge.VisualClassName, !0);
                var mainGraphicsContext = this.mainGraphicsContext = svg.append("g");
                mainGraphicsContext.attr("class", Gauge.MainGaugeGroupClassName), this.initKpiBands();
                var backgroundArc = this.backgroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2).endAngle(Math.PI / 2), foregroundArc = this.foregroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2);
                this.backgroundArcPath = mainGraphicsContext.append("path").classed("backgroundArc", !0).attr("d", backgroundArc), 
                this.foregroundArcPath = mainGraphicsContext.append("path").datum({
                    endAngle: -Math.PI / 2
                }).classed("foregroundArc", !0).attr("d", foregroundArc);
                var g = this.animatedNumberGrapicsContext = svg.append("g");
                this.animatedNumber = new visuals.AnimatedNumber(g), this.animatedNumber.init(options);
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties(), animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.animatedNumberGrapicsContext.attr("transform", animatedNumberProperties.transformString), 
                this.animatedNumber.onResizing(animatedNumberProperties.viewport);
            }, Gauge.prototype.update = function(options) {
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (dataViews && dataViews[0]) {
                    this.data = Gauge.converter(dataViews[0], this.tooltipsEnabled), this.targetSettings = this.data.targetSettings, 
                    dataViews[0] && (dataViews[0].single = {
                        value: this.data.total
                    }), this.showTargetLabel = null != this.targetSettings.target && (this.currentViewport.width > Gauge.MinWidthForTargetLabel || !this.showMinMaxLabelsOnBottom()) && this.showSideNumbersLabelText() && this.data.dataLabelsSettings.show, 
                    this.setMargins(), this.gaugeVisualProperties = this.getGaugeVisualProperties(), 
                    this.drawViewPort(this.gaugeVisualProperties), this.updateInternal(options.suppressAnimations), 
                    this.updateCalloutValue(options.suppressAnimations);
                    var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                    this.hostService.setWarnings(warnings);
                }
            }, Gauge.prototype.updateCalloutValue = function(suppressAnimations) {
                if (this.data.calloutValueLabelsSettings.show) {
                    var animatedNumberProperties = this.getAnimatedNumberProperties(this.gaugeVisualProperties.radius, this.gaugeVisualProperties.innerRadiusFactor, this.gaugeVisualProperties.top, this.gaugeVisualProperties.left);
                    this.animatedNumberGrapicsContext.attr("transform", animatedNumberProperties.transformString), 
                    this.animatedNumber.setTextColor(this.data.calloutValueLabelsSettings.labelColor);
                    var calloutValue = this.data ? this.data.total : null, formatter = this.getFormatter(this.data.calloutValueLabelsSettings, calloutValue);
                    this.animatedNumber.setFormatter(formatter), this.animatedNumber.update({
                        viewport: animatedNumberProperties.viewport,
                        dataViews: this.dataViews,
                        suppressAnimations: suppressAnimations
                    }), this.animatedNumberGrapicsContext.selectAll("title").remove(), this.animatedNumberGrapicsContext.append("title").text([ formatter.format(calloutValue) ]);
                } else this.animatedNumber.clear(), this.animatedNumberGrapicsContext.selectAll("title").remove();
            }, Gauge.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            }, Gauge.prototype.onResizing = function(viewport) {
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: !0,
                    viewMode: 0,
                    viewport: viewport
                });
            }, Gauge.getValidSettings = function(targetData) {
                var maxVal = targetData.max === Gauge.MAX_VALUE ? Gauge.DEFAULT_MAX : targetData.max, minVal = targetData.min === Gauge.MIN_VALUE ? Gauge.DEFAULT_MIN : targetData.min, targetVal = targetData.target;
                return {
                    min: minVal,
                    max: maxVal,
                    target: targetVal
                };
            }, Gauge.getGaugeData = function(dataView) {
                var settings = {
                    max: Gauge.MAX_VALUE,
                    min: Gauge.MIN_VALUE,
                    target: void 0,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
                    for (var values = dataView.categorical.values, metadataColumns = dataView.metadata.columns, i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        col && col.roles && (col.roles[visuals.gaugeRoleNames.y] ? (settings.total = value, 
                        value && settings.tooltipItems.push({
                            value: value,
                            metadata: values[i]
                        })) : col.roles[visuals.gaugeRoleNames.minValue] ? settings.min = value : col.roles[visuals.gaugeRoleNames.maxValue] ? settings.max = value : col.roles[visuals.gaugeRoleNames.targetValue] && (settings.target = value, 
                        value && settings.tooltipItems.push({
                            value: value,
                            metadata: values[i]
                        })));
                    }
                    var gaugeObjectsSettings = Gauge.getGaugeObjectsProperties(dataView);
                    gaugeObjectsSettings && !$.isEmptyObject(gaugeObjectsSettings) && Gauge.overrideGaugeSettings(settings, gaugeObjectsSettings);
                }
                return settings;
            }, Gauge.overrideGaugeSettings = function(settings, gaugeObjectsSettings) {
                $.isNumeric(gaugeObjectsSettings.min) && (settings.min = gaugeObjectsSettings.min), 
                $.isNumeric(gaugeObjectsSettings.max) && (settings.max = gaugeObjectsSettings.max), 
                $.isNumeric(gaugeObjectsSettings.target) && (settings.target = gaugeObjectsSettings.target);
            }, Gauge.converter = function(dataView, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var gaugeData = Gauge.getGaugeData(dataView), total = gaugeData.total, formatString = null, hasPercent = !1;
                dataView.metadata && !_.isEmpty(dataView.metadata.columns) && (formatString = visuals.valueFormatter.getFormatString(dataView.metadata.columns[0], Gauge.formatStringProp, !0), 
                null != formatString && (hasPercent = visuals.valueFormatter.getFormatMetadata(formatString).hasPercent)), 
                total > 0 && gaugeData.max === Gauge.MAX_VALUE && (gaugeData.max = hasPercent ? Gauge.DEFAULT_MAX : 2 * total);
                var settings = Gauge.getValidSettings(gaugeData), adjustedTotal = Math.max(total, settings.min);
                adjustedTotal = Math.min(adjustedTotal, settings.max);
                var tooltipInfo, percent = settings.min !== settings.max ? (adjustedTotal - settings.min) / (settings.max - settings.min) : 0;
                if (tooltipsEnabled && dataView) if (gaugeData.tooltipItems.length > 0) tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, null, null, null, null, gaugeData.tooltipItems); else {
                    var dataViewCat = dataView.categorical;
                    if (dataViewCat && dataViewCat.values && dataViewCat.values.length > 0) {
                        var categoryValue = dataViewCat.values[0], value = categoryValue.values[0];
                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, dataViewCat, null, value);
                    }
                }
                return {
                    percent: percent,
                    adjustedTotal: adjustedTotal,
                    total: total,
                    metadataColumn: Gauge.getMetaDataColumn(dataView),
                    targetSettings: settings,
                    tooltipInfo: tooltipInfo,
                    dataLabelsSettings: Gauge.convertDataLabelSettings(dataView, "labels"),
                    calloutValueLabelsSettings: Gauge.convertDataLabelSettings(dataView, "calloutValue"),
                    dataPointSettings: Gauge.convertDataPointSettings(dataView, settings)
                };
            }, Gauge.convertDataLabelSettings = function(dataview, objectName) {
                var dataViewMetadata = dataview.metadata, dataLabelsSettings = visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                if (dataViewMetadata) {
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var labelsObj = objects[objectName];
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    }
                }
                return dataLabelsSettings;
            }, Gauge.convertDataPointSettings = function(dataView, targetSettings) {
                var targetColor, fillColor = Gauge.DefaultDataPointSettings.fillColor;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    fillColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.fill, Gauge.DefaultDataPointSettings.fillColor), 
                    targetSettings && null != targetSettings.target && (targetColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.target, Gauge.DefaultDataPointSettings.targetColor));
                } else targetSettings && null != targetSettings.target && (targetColor = Gauge.DefaultDataPointSettings.targetColor);
                return {
                    fillColor: fillColor,
                    targetColor: targetColor
                };
            }, Gauge.getMetaDataColumn = function(dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) for (var i = 0, ilen = dataView.metadata.columns.length; ilen > i; i++) {
                    var column = dataView.metadata.columns[i];
                    if (column.isMeasure) return column;
                }
                return null;
            }, Gauge.prototype.initKpiBands = function() {
                if (this.settings.kpiBands.show) for (var kpiArcs = this.kpiArcs = [], kpiArcPaths = this.kpiArcPaths = [], mainGraphicsContext = this.mainGraphicsContext, i = 0; 3 > i; i++) {
                    var arc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(0).endAngle(0);
                    kpiArcs.push(arc);
                    var arcPath = mainGraphicsContext.append("path").attr("d", arc);
                    kpiArcPaths.push(arcPath);
                }
            }, Gauge.prototype.updateKpiBands = function(radius, innerRadiusFactor, tString, kpiAngleAttr) {
                if (this.settings.kpiBands.show) for (var i = 0; i < kpiAngleAttr.length; i++) this.kpiArcs[i].innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)).outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc).startAngle(kpiAngleAttr[i].start).endAngle(kpiAngleAttr[i].end), 
                this.kpiArcPaths[i].attr("fill", kpiAngleAttr[i].fill).attr("d", this.kpiArcs[i]).attr("transform", tString);
            }, Gauge.prototype.removeTargetElements = function() {
                this.targetLine && (this.targetLine.remove(), this.targetText.remove(), this.targetConnector.remove(), 
                this.targetLine = this.targetConnector = this.targetText = null);
            }, Gauge.prototype.getTargetRatio = function() {
                var targetSettings = this.targetSettings, range = targetSettings.max - targetSettings.min;
                return 0 !== range ? (targetSettings.target - targetSettings.min) / range : 0;
            }, Gauge.prototype.updateTargetLine = function(radius, innerRadius, left, top) {
                this.targetLine || (this.targetLine = this.mainGraphicsContext.append("line"));
                var angle = this.getTargetRatio() * Math.PI, outY = top - radius * Math.sin(angle), outX = left - radius * Math.cos(angle), inY = top - innerRadius * Math.sin(angle), inX = left - innerRadius * Math.cos(angle);
                this.targetLine.attr({
                    x1: inX,
                    y1: inY,
                    x2: outX,
                    y2: outY
                });
            }, Gauge.prototype.getAnimatedNumberProperties = function(radius, innerRadiusFactor, top, left) {
                var boxAngle = Math.PI / 4, scale = 1, innerRadiusOfArc = radius * innerRadiusFactor, innerRadiusForTextBoundingBox = innerRadiusOfArc - (this.settings.kpiBands.show ? Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness : 0), innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle), innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle), innerY = top - innerRSin, innerX = left - innerRCos;
                innerY *= scale, innerX *= scale;
                var animatedNumberWidth = 2 * innerRCos, properties = {
                    transformString: visuals.SVGUtil.translate(innerX, innerY),
                    viewport: {
                        height: innerRSin,
                        width: animatedNumberWidth
                    }
                };
                return properties;
            }, Gauge.prototype.getGaugeVisualProperties = function() {
                var viewport = this.currentViewport, margin = this.margin, width = viewport.width - margin.right - margin.left, halfWidth = width / 2, height = viewport.height - margin.top - margin.bottom, radius = Math.min(halfWidth, height), innerRadiusFactor = Gauge.InnerRadiusFactor, left = margin.left + halfWidth, top = radius + (height - radius) / 2 + margin.top, tString = visuals.SVGUtil.translate(left, top), innerRadiusOfArc = radius * innerRadiusFactor, gaugeData = {
                    radius: radius,
                    innerRadiusOfArc: innerRadiusOfArc,
                    left: left,
                    top: top,
                    height: height,
                    width: width,
                    margin: margin,
                    transformString: tString,
                    innerRadiusFactor: innerRadiusFactor
                };
                return gaugeData;
            }, Gauge.prototype.drawViewPort = function(drawOptions) {
                var separation = this.settings.kpiBands.separationRadians, innerRadiusFactor = Gauge.InnerRadiusFactor, backgroudArc = this.backgroundArc, color = this.color, attrs = [ {
                    fill: color(0),
                    start: -Math.PI / 2,
                    end: -Math.PI / 2 + Math.PI / 4 - separation
                }, {
                    fill: color(1),
                    start: -Math.PI / 2 + 1 * Math.PI / 4 + separation,
                    end: -Math.PI / 2 + 3 * Math.PI / 4 - separation
                }, {
                    fill: color(2),
                    start: -Math.PI / 2 + 3 * Math.PI / 4 + separation,
                    end: Math.PI / 2
                } ], radius = drawOptions.radius, transformString = drawOptions.transformString;
                this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs), backgroudArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2).endAngle(Math.PI / 2), 
                this.backgroundArcPath.attr("d", backgroudArc).attr("transform", transformString);
                var foregroundArc = this.foregroundArc;
                foregroundArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2), 
                this.foregroundArcPath.datum({
                    endAngle: this.lastAngle
                }).attr("transform", transformString).attr("d", foregroundArc);
                var innerRadiusOfArc = drawOptions.innerRadiusOfArc, left = drawOptions.left, top = drawOptions.top, margin = drawOptions.margin, height = drawOptions.height, targetSettings = this.targetSettings;
                this.settings.targetLine.show && null != targetSettings.target ? targetSettings.min > targetSettings.target || targetSettings.max < targetSettings.target ? this.removeTargetElements() : (this.updateTargetLine(radius, innerRadiusOfArc, left, top), 
                this.appendTargetTextAlongArc(radius, height, drawOptions.width, margin)) : this.removeTargetElements(), 
                this.svg.attr("height", this.currentViewport.height).attr("width", this.currentViewport.width);
            }, Gauge.prototype.createTicks = function() {
                for (var settings = this.settings, targetSettings = this.targetSettings, total = targetSettings.max - targetSettings.min, numberOfLabels = settings.labels.count, step = total / numberOfLabels, arr = [], formatter = this.getFormatter(this.data.dataLabelsSettings, targetSettings.max), i = 0; numberOfLabels + 1 > i; i++) arr.push(formatter.format(targetSettings.min + i * step));
                return arr;
            }, Gauge.prototype.updateInternal = function(suppressAnimations) {
                var height = this.gaugeVisualProperties.height, width = this.gaugeVisualProperties.width, radius = this.gaugeVisualProperties.radius, margin = this.margin, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), data = this.data, lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * data.percent, ticks = this.createTicks();
                this.foregroundArcPath.transition().ease(this.settings.transition.ease).duration(duration).call(this.arcTween, [ lastAngle, this.foregroundArc ]), 
                this.appendTextAlongArc(ticks, radius, height, width, margin), this.updateVisualConfigurations(), 
                this.updateVisualStyles(), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(this.foregroundArcPath, function(tooltipEvent) {
                    return data.tooltipInfo;
                }), visuals.TooltipManager.addTooltip(this.backgroundArcPath, function(tooltipEvent) {
                    return data.tooltipInfo;
                }));
            }, Gauge.prototype.updateVisualStyles = function() {
                var fillColor = this.data.dataLabelsSettings.labelColor || this.style.labelText.color.value;
                this.mainGraphicsContext.selectAll("text").style({
                    fill: fillColor
                });
            }, Gauge.prototype.updateVisualConfigurations = function() {
                var configOptions = this.settings, dataPointSettings = this.data.dataPointSettings;
                this.mainGraphicsContext.select("line").attr({
                    stroke: dataPointSettings.targetColor,
                    "stroke-width": configOptions.targetLine.thickness
                }), this.backgroundArcPath.style("fill", configOptions.arcColors.background), this.foregroundArcPath.style("fill", dataPointSettings.fillColor);
            }, Gauge.prototype.appendTextAlongArc = function(ticks, radius, height, width, margin) {
                if (this.svg.selectAll(Gauge.LabelText.selector).remove(), this.data.dataLabelsSettings.show) for (var total = ticks.length, divisor = total - 1, top = radius + (height - radius) / 2 + margin.top, showMinMaxLabelsOnBottom = this.showMinMaxLabelsOnBottom(), fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt), padding = this.settings.labels.padding, count = 0; total > count; count++) if (Math.floor(total / 2) !== count && this.showSideNumbersLabelText()) {
                    var x = margin.left + width / 2 - radius * Math.cos(Math.PI * count / divisor), y = top - radius * Math.sin(Math.PI * count / divisor), anchor = void 0, onRight = 2 * count > total, onBottom = !1;
                    !showMinMaxLabelsOnBottom || 0 !== count && count !== total - 1 ? (anchor = onRight ? "start" : "end", 
                    x += padding * (onRight ? 1 : -1)) : (onBottom = !0, y += padding / 2, anchor = onRight ? "end" : "start");
                    var text = this.mainGraphicsContext.append("text").attr({
                        x: x,
                        y: y,
                        dy: onBottom ? fontSize : 0,
                        "class": Gauge.LabelText["class"]
                    }).style({
                        "text-anchor": anchor,
                        "font-size": fontSize
                    }).text(ticks[count]).append("title").text(ticks[count]);
                    onBottom || this.truncateTextIfNeeded(text, x, onRight);
                }
            }, Gauge.prototype.truncateTextIfNeeded = function(text, positionX, onRight) {
                var availableSpace = onRight ? this.currentViewport.width - positionX : positionX;
                text.call(visuals.AxisHelper.LabelLayoutStrategy.clip, availableSpace, powerbi.TextMeasurementService.svgEllipsis);
            }, Gauge.prototype.getFormatter = function(dataLabelSettings, value2) {
                var realValue2 = 0 === dataLabelSettings.displayUnits ? value2 : null, formatString = visuals.valueFormatter.getFormatString(this.data.metadataColumn, Gauge.formatStringProp), precision = visuals.dataLabelUtils.getLabelPrecision(dataLabelSettings.precision, formatString), valueFormatterOptions = visuals.dataLabelUtils.getOptionsForLabelFormatter(dataLabelSettings, formatString, realValue2, precision);
                return valueFormatterOptions.formatSingleValues = !(dataLabelSettings.displayUnits > 0), 
                visuals.valueFormatter.create(valueFormatterOptions);
            }, Gauge.prototype.appendTargetTextAlongArc = function(radius, height, width, margin) {
                var targetSettings = this.targetSettings, target = targetSettings.target, tRatio = this.getTargetRatio(), top = radius + (height - radius) / 2 + margin.top, flag = tRatio > .5, padding = this.settings.labels.padding, anchor = flag ? "start" : "end", formatter = this.getFormatter(this.data.dataLabelsSettings, targetSettings.max), maxRatio = Math.asin(Gauge.MinDistanceFromBottom / radius) / Math.PI, finalRatio = maxRatio > tRatio || tRatio > 1 - maxRatio ? flag ? 1 - maxRatio : maxRatio : tRatio, targetX = margin.left + width / 2 - (radius + padding) * Math.cos(Math.PI * finalRatio), targetY = top - (radius + padding) * Math.sin(Math.PI * finalRatio);
                this.targetText || (this.targetText = this.mainGraphicsContext.append("text").classed(Gauge.TargetText["class"], !0)), 
                this.targetText.attr({
                    x: targetX,
                    y: targetY
                }).style({
                    "text-anchor": anchor,
                    display: this.showTargetLabel ? "" : "none",
                    "font-size": this.style.labelText.fontSize
                }).text(formatter.format(target)), this.truncateTextIfNeeded(this.targetText, targetX, flag), 
                this.targetText.call(visuals.tooltipUtils.tooltipUpdate, [ formatter.format(target) ]), 
                this.targetConnector || (this.targetConnector = this.mainGraphicsContext.append("line").classed(Gauge.TargetConnector["class"], !0)), 
                tRatio === finalRatio ? this.targetConnector.style("display", "none") : this.targetConnector.attr({
                    x1: margin.left + width / 2 - radius * Math.cos(Math.PI * tRatio),
                    y1: top - radius * Math.sin(Math.PI * tRatio),
                    x2: targetX,
                    y2: targetY
                }).style({
                    "stroke-width": this.settings.targetLine.thickness,
                    stroke: this.settings.targetLine.color,
                    display: ""
                });
            }, Gauge.prototype.arcTween = function(transition, arr) {
                transition.attrTween("d", function(d) {
                    var interpolate = d3.interpolate(d.endAngle, arr[0]);
                    return function(t) {
                        return d.endAngle = interpolate(t), arr[1](d);
                    };
                });
            }, Gauge.prototype.showMinMaxLabelsOnBottom = function() {
                if (this.currentViewport.height > this.currentViewport.width) return !0;
                if (this.data && this.gaugeVisualProperties) {
                    var ticks = this.createTicks(), visualWhitespace = (this.currentViewport.width - 2 * this.gaugeVisualProperties.radius) / 2, maxLabelWidth = visualWhitespace - this.settings.labels.padding, textProperties = powerbi.TextMeasurementService.getMeasurementProperties($(this.svg.node()));
                    textProperties.fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                    for (var width = void 0, _i = 0, _a = [ ticks[0], ticks[ticks.length - 1] ]; _i < _a.length; _i++) {
                        var tickValue = _a[_i];
                        if (textProperties.text = tickValue, width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), 
                        width > maxLabelWidth) return !0;
                    }
                }
                return !1;
            }, Gauge.prototype.setMargins = function() {
                if (this.gaugeSmallViewPortProperties && this.gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                    var margins = this.gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
                    return void (this.margin = {
                        top: margins,
                        bottom: margins,
                        left: margins,
                        right: margins
                    });
                }
                if (this.margin = {
                    top: Gauge.DefaultTopBottomMargin,
                    bottom: Gauge.DefaultTopBottomMargin,
                    left: Gauge.DefaultLeftRightMargin,
                    right: Gauge.DefaultLeftRightMargin
                }, !this.showSideNumbersLabelText() || this.showMinMaxLabelsOnBottom()) {
                    var targetSettings = this.targetSettings;
                    if (this.showTargetLabel) {
                        var tRatio = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                        tRatio > .5 ? this.margin.left = Gauge.ReducedLeftRightMargin : this.margin.right = Gauge.ReducedLeftRightMargin;
                    } else this.margin.left = this.margin.right = Gauge.ReducedLeftRightMargin;
                }
                var fontSize = 0;
                this.data && this.data.dataLabelsSettings && this.data.dataLabelsSettings.fontSize && this.data.dataLabelsSettings.fontSize >= visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt && (fontSize = PixelConverter.fromPointToPixel(this.data.dataLabelsSettings.fontSize - visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt)), 
                0 !== fontSize && (this.margin.bottom += fontSize, this.margin.left += fontSize, 
                this.margin.right += fontSize);
            }, Gauge.prototype.showSideNumbersLabelText = function() {
                return !(this.gaugeSmallViewPortProperties && this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort && this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible);
            }, Gauge.MIN_VALUE = -(1 / 0), Gauge.MAX_VALUE = +(1 / 0), Gauge.MinDistanceFromBottom = 10, 
            Gauge.MinWidthForTargetLabel = 150, Gauge.DefaultTopBottomMargin = 20, Gauge.DefaultLeftRightMargin = 45, 
            Gauge.ReducedLeftRightMargin = 15, Gauge.DEFAULT_MAX = 1, Gauge.DEFAULT_MIN = 0, 
            Gauge.VisualClassName = "gauge", Gauge.DefaultStyleProperties = {
                transition: {
                    ease: "bounce"
                },
                arcColors: {
                    background: "#e9e9e9",
                    foreground: "#00B8AA"
                },
                targetLine: {
                    show: !0,
                    color: "#666666",
                    thickness: 2
                },
                labels: {
                    count: 2,
                    padding: 5,
                    fontSize: visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                },
                kpiBands: {
                    show: !1,
                    separationRadians: Math.PI / 128,
                    thickness: 5
                }
            }, Gauge.DefaultTargetSettings = {
                min: 0,
                max: 1,
                target: void 0
            }, Gauge.DefaultDataPointSettings = {
                fillColor: Gauge.DefaultStyleProperties.arcColors.foreground,
                targetColor: Gauge.DefaultStyleProperties.targetLine.color
            }, Gauge.InnerRadiusFactor = .7, Gauge.KpiBandDistanceFromMainArc = 2, Gauge.MainGaugeGroupClassName = "mainGroup", 
            Gauge.LabelText = createClassAndSelector("labelText"), Gauge.TargetConnector = createClassAndSelector("targetConnector"), 
            Gauge.TargetText = createClassAndSelector("targetText"), Gauge.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            }, Gauge;
        }();
        visuals.Gauge = Gauge;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var Utility = jsCommon.Utility, ImageVisual = function() {
            function ImageVisual() {
                this.scalingType = visuals.imageScalingType.normal;
            }
            return ImageVisual.prototype.init = function(options) {
                this.element = options.element;
            }, ImageVisual.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "imageScaling":
                    return this.enumerateImageScaling();
                }
                return null;
            }, ImageVisual.prototype.enumerateImageScaling = function() {
                return [ {
                    selector: null,
                    objectName: "imageScaling",
                    properties: {
                        imageScalingType: this.scalingType
                    }
                } ];
            }, ImageVisual.prototype.update = function(options) {
                var dataViews = options.dataViews;
                if (dataViews && 0 !== dataViews.length) {
                    var objects = dataViews[0].metadata.objects;
                    if (objects && objects.general) {
                        var div = this.imageBackgroundElement;
                        div || (div = $("<div class='imageBackground' />"), this.imageBackgroundElement = div, 
                        this.imageBackgroundElement.appendTo(this.element));
                        var viewport = options.viewport;
                        div.css("height", viewport.height), objects.imageScaling ? this.scalingType = objects.imageScaling.imageScalingType.toString() : this.scalingType = visuals.imageScalingType.normal;
                        var imageUrl = objects.general.imageUrl;
                        Utility.isValidImageDataUrl(imageUrl) && div.css("backgroundImage", "url(" + imageUrl + ")"), 
                        this.scalingType === visuals.imageScalingType.fit ? div.css("background-size", "100% 100%") : this.scalingType === visuals.imageScalingType.fill ? div.css("background-size", "cover") : div.css("background-size", "contain");
                    }
                }
            }, ImageVisual;
        }();
        visuals.ImageVisual = ImageVisual;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function GetStatus(actual, goals, directionType) {
            if (!goals || 0 === goals.length) return KPIStatusWithHistory.status.NOGOAL;
            var maxGoal, minGoal;
            if (2 === goals.length) {
                if (maxGoal = Math.max.apply(Math, goals), minGoal = Math.min.apply(Math, goals), 
                actual >= minGoal && maxGoal >= actual) return KPIStatusWithHistory.status.IN_BETWEEN;
            } else maxGoal = goals[0], minGoal = goals[0];
            switch (directionType) {
              case visuals.kpiDirection.positive:
                if (minGoal > actual) return KPIStatusWithHistory.status.DROP;
                break;

              case visuals.kpiDirection.negative:
                if (actual > maxGoal) return KPIStatusWithHistory.status.DROP;
            }
            return KPIStatusWithHistory.status.INCREASE;
        }
        function getDistanceFromGoalInPercentageString(actual, goals, directionType) {
            if (!goals || 1 !== goals.length || 0 === goals[0]) return "";
            var distance, sign = "+", goal = goals[0];
            switch (distance = Math.abs(actual - goal), directionType) {
              case visuals.kpiDirection.positive:
                goal > actual && (sign = "-");
                break;

              case visuals.kpiDirection.negative:
                actual > goal && (sign = "-");
            }
            var percent = Number((100 * distance / goal).toFixed(2));
            return "(" + sign + percent + "%)";
        }
        function GetTextColorClassByStatus(status) {
            switch (status) {
              case KPIStatusWithHistory.status.NOGOAL:
                return KPIStatusWithHistory.kpiTextGreyClass;

              case KPIStatusWithHistory.status.INCREASE:
                return KPIStatusWithHistory.kpiGreenClass;

              case KPIStatusWithHistory.status.IN_BETWEEN:
                return KPIStatusWithHistory.kpiYellowClass;

              case KPIStatusWithHistory.status.DROP:
                return KPIStatusWithHistory.kpiRedClass;
            }
        }
        function GetGraphColorClassByStatus(status) {
            switch (status) {
              case KPIStatusWithHistory.status.NOGOAL:
                return KPIStatusWithHistory.kpiGraphGreyClass;

              case KPIStatusWithHistory.status.INCREASE:
                return KPIStatusWithHistory.kpiGreenClass;

              case KPIStatusWithHistory.status.IN_BETWEEN:
                return KPIStatusWithHistory.kpiYellowClass;

              case KPIStatusWithHistory.status.DROP:
                return KPIStatusWithHistory.kpiRedClass;
            }
        }
        var DataRoleHelper = powerbi.data.DataRoleHelper, KPIStatusWithHistory = function() {
            function KPIStatusWithHistory() {}
            return KPIStatusWithHistory.prototype.init = function(options) {
                KPIStatusWithHistory.getLocalizedString = options.host.getLocalizedString, this.rootElement = d3.select(options.element.get(0)).append("div").attr("text-align", "center").classed("kpiVisual", !0), 
                this.svg = this.rootElement.append("svg");
                var mainGroupElement = this.mainGroupElement = this.svg.append("g");
                this.areaFill = mainGroupElement.append("path"), this.textContainer = this.rootElement.append("div").classed("textContainer", !0), 
                this.indicatorTextContainer = this.textContainer.append("div").classed("indicatorText", !0), 
                this.absoluteGoalDistanceText = this.textContainer.append("div").classed("goalText", !0), 
                this.kpiActualText = this.indicatorTextContainer.append("div").attr("id", "indicatorText"), 
                this.initIcons(), this.host = options.host;
            }, KPIStatusWithHistory.prototype.update = function(options) {
                if (options.dataViews && options.dataViews[0]) {
                    var dataView = this.dataView = options.dataViews[0], viewport = options.viewport;
                    if ((!dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1) && (!dataView.categorical || !dataView.categorical.categories || dataView.categorical.categories.length < 1)) return this.svg.attr("visibility", "hidden"), 
                    void this.textContainer.attr("style", "display:none");
                    this.svg.attr("visibility", "visible");
                    var kpiViewModel = KPIStatusWithHistory.converter(dataView, viewport, KPIStatusWithHistory.getProp_KPIDirection(dataView));
                    this.render(kpiViewModel, viewport);
                }
            }, KPIStatusWithHistory.prototype.initIcons = function() {
                this.successMarkIcon = this.indicatorTextContainer.append("div").classed("powervisuals-glyph checkmark kpi-visual-green", !0), 
                this.betweenIcon = this.indicatorTextContainer.append("div").classed("powervisuals-glyph circle-small kpi-visual-yellow", !0), 
                this.exclamationMarkIcon = this.indicatorTextContainer.append("div").classed("powervisuals-glyph exclamation kpi-visual-red", !0), 
                this.successMarkIcon.attr("style", "display:none"), this.betweenIcon.attr("style", "display:none"), 
                this.exclamationMarkIcon.attr("style", "display:none");
            }, KPIStatusWithHistory.prototype.render = function(kpiViewModel, viewport) {
                if (this.setShowDataMissingWarning(!(kpiViewModel.indicatorExists && kpiViewModel.trendExists)), 
                0 === kpiViewModel.dataPoints.length || !kpiViewModel.historyExists || !kpiViewModel.indicatorExists || !kpiViewModel.trendExists) return this.areaFill.attr("visibility", "hidden"), 
                this.svg.attr("visibility", "hidden"), void this.textContainer.attr("style", "display:none");
                this.svg.attr({
                    height: viewport.height,
                    width: viewport.width
                });
                var status = KPIStatusWithHistory.status.NOGOAL;
                kpiViewModel.targetExists && kpiViewModel.indicatorExists && kpiViewModel.trendExists && (status = GetStatus(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType));
                var actualText = kpiViewModel.formattedValue, calculatedHeight = KPIStatusWithHistory.indicatorTextSizeInPx;
                this.textContainer.attr("style", "width:" + viewport.width + "px;top:" + (viewport.height - calculatedHeight) / 2 + "px"), 
                this.kpiActualText.classed(KPIStatusWithHistory.allColorClasses, !1).classed(GetTextColorClassByStatus(status), !0).attr("text-anchor", "middle").text(actualText);
                var icon = null;
                switch (status) {
                  case KPIStatusWithHistory.status.INCREASE:
                    icon = this.successMarkIcon, this.exclamationMarkIcon.attr("style", "display:none"), 
                    this.betweenIcon.attr("style", "display:none");
                    break;

                  case KPIStatusWithHistory.status.IN_BETWEEN:
                    icon = this.betweenIcon, this.exclamationMarkIcon.attr("style", "display:none"), 
                    this.successMarkIcon.attr("style", "display:none");
                    break;

                  case KPIStatusWithHistory.status.DROP:
                    icon = this.exclamationMarkIcon, this.successMarkIcon.attr("style", "display:none"), 
                    this.betweenIcon.attr("style", "display:none");
                    break;

                  default:
                    this.exclamationMarkIcon.attr("style", "display:none"), this.successMarkIcon.attr("style", "display:none"), 
                    this.betweenIcon.attr("style", "display:none");
                }
                icon && icon.attr("style", "font-size:12px");
                var shownGoalString = kpiViewModel.showGoal ? kpiViewModel.formattedGoalString + " " : "", shownDistanceFromGoalString = kpiViewModel.showDistanceFromGoal ? getDistanceFromGoalInPercentageString(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType) : "";
                if (this.absoluteGoalDistanceText.attr("text-anchor", "middle").text(shownGoalString + shownDistanceFromGoalString), 
                kpiViewModel.showTrendLine) {
                    var area = d3.svg.area().x(function(d) {
                        return d.x;
                    }).y0(viewport.height).y1(function(d) {
                        return d.y;
                    });
                    this.areaFill.classed(KPIStatusWithHistory.allColorClasses, !1).classed(GetGraphColorClassByStatus(status), !0).attr("d", area(kpiViewModel.dataPoints)).attr("stroke", "none").attr("visibility", "visible").attr("fill-opacity", .2);
                } else this.areaFill.attr("visibility", "hidden");
            }, KPIStatusWithHistory.prototype.setShowDataMissingWarning = function(show) {
                this.host.setWarnings(show ? [ new visuals.VisualKPIDataMissingWarning() ] : []);
            }, KPIStatusWithHistory.getDefaultFormatSettings = function() {
                return {
                    labelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, visuals.Card.DefaultStyle.value.color),
                    textSize: 27,
                    wordWrap: !1
                };
            }, KPIStatusWithHistory.getMetaDataColumn = function(dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                    var column = _a[_i];
                    if (column.isMeasure) return column;
                }
            }, KPIStatusWithHistory.getFormatString = function(column) {
                return visuals.valueFormatter.getFormatString(column, visuals.AnimatedText.formatStringProp);
            }, KPIStatusWithHistory.getProp_Show_KPIGoal = function(dataView) {
                return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIGoal, !0) : !0;
            }, KPIStatusWithHistory.getProp_Show_KPITrendLine = function(dataView) {
                return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPITrendLine, !0) : !0;
            }, KPIStatusWithHistory.getProp_Show_KPIDistance = function(dataView) {
                return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIDistance, !0) : !0;
            }, KPIStatusWithHistory.getProp_KPIDirection = function(dataView) {
                return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.directionTypeStringProp, visuals.kpiDirection.positive) : visuals.kpiDirection.positive;
            }, KPIStatusWithHistory.getProp_Indicator_DisplayUnits = function(dataView) {
                return KPIStatusWithHistory.initDefaultLabelSettings(), dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorDisplayUnitsProp, KPIStatusWithHistory.defaultLabelSettings.displayUnits) : KPIStatusWithHistory.defaultLabelSettings.displayUnits;
            }, KPIStatusWithHistory.getProp_Indicator_Precision = function(dataView) {
                return KPIStatusWithHistory.initDefaultLabelSettings(), dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorPrecisionProp, KPIStatusWithHistory.defaultLabelSettings.precision) : KPIStatusWithHistory.defaultLabelSettings.precision;
            }, KPIStatusWithHistory.initDefaultLabelSettings = function() {
                KPIStatusWithHistory.defaultCardFormatSetting || (KPIStatusWithHistory.defaultCardFormatSetting = KPIStatusWithHistory.getDefaultFormatSettings(), 
                KPIStatusWithHistory.defaultLabelSettings = KPIStatusWithHistory.defaultCardFormatSetting.labelSettings);
            }, KPIStatusWithHistory.getFormattedValue = function(metaDataColumn, theValue, precision, displayUnits) {
                var isDefaultDisplayUnit = 0 === displayUnits, formatter = visuals.valueFormatter.create({
                    format: KPIStatusWithHistory.getFormatString(metaDataColumn),
                    value: displayUnits,
                    precision: precision,
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.WholeUnits,
                    formatSingleValues: !!isDefaultDisplayUnit,
                    allowFormatBeautification: !0,
                    columnType: metaDataColumn ? metaDataColumn.type : void 0
                });
                return formatter.format(theValue);
            }, KPIStatusWithHistory.getFormattedGoalString = function(metaDataColumn, goals, precision, displayUnits) {
                if (!goals || 0 === goals.length) return "";
                var goalsString = KPIStatusWithHistory.getLocalizedString("Visual_KPI_Goal_Title") + ": " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[0], precision, displayUnits);
                return 2 === goals.length && (goalsString += ", " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[1], precision, displayUnits)), 
                goalsString;
            }, KPIStatusWithHistory.converter = function(dataView, viewPort, directionType) {
                var dataPoints = [], catDv = dataView.categorical, metaDataColumn = KPIStatusWithHistory.getMetaDataColumn(dataView), formattedGoalString = "", formattedValue = "", targetExists = !1, indicatorExists = !1, trendExists = !1, historyExists = !0;
                dataView.categorical.categories || (historyExists = !1);
                for (var values = catDv.values, columns = dataView.metadata.columns, _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var column = columns_1[_i];
                    DataRoleHelper.hasRole(column, "Indicator") && (indicatorExists = !0), DataRoleHelper.hasRole(column, "TrendLine") && (trendExists = !0);
                }
                if (!(indicatorExists && trendExists && values && 0 !== values.length && values[0].values && dataView.categorical.values)) return {
                    dataPoints: dataPoints,
                    directionType: directionType,
                    actual: 0,
                    goals: [],
                    formattedGoalString: formattedGoalString,
                    targetExists: targetExists,
                    historyExists: historyExists,
                    indicatorExists: indicatorExists,
                    trendExists: trendExists,
                    formattedValue: formattedValue,
                    showGoal: !1,
                    showDistanceFromGoal: !1,
                    showTrendLine: !1
                };
                var category, categoryValues;
                historyExists && (category = catDv.categories[0], categoryValues = category.values);
                var historyActualData = [], historyGoalData = [], indicatorColumns = KPIStatusWithHistory.getColumnsByRole(values, "Indicator"), goalColumns = KPIStatusWithHistory.getColumnsByRole(values, "Goal");
                goalColumns.length > 0 && (targetExists = !0);
                for (var actualValue, i = 0, len = values[0].values.length; len > i; i++) {
                    actualValue = indicatorColumns[0].values[i];
                    for (var goals_1 = [], goalCnt = 0; goalCnt < goalColumns.length; goalCnt++) goals_1.push(goalColumns[goalCnt].values[i]);
                    historyGoalData.push(goals_1), historyActualData.push(actualValue);
                }
                for (var maxActualData = Math.max.apply(Math, historyActualData), minActualData = Math.min.apply(Math, historyActualData), areaMaxHight = viewPort.height * KPIStatusWithHistory.trendAreaFilePercentage, precision = KPIStatusWithHistory.getProp_Indicator_Precision(dataView), displayUnits = KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView), i = 0; i < historyActualData.length; i++) {
                    var yPos = areaMaxHight * (historyActualData[i] - minActualData) / (maxActualData - minActualData), selectorId = null;
                    historyExists && (selectorId = visuals.SelectionId.createWithId(category.identity[i]).getSelector()), 
                    dataPoints.push({
                        x: i * viewPort.width / (historyActualData.length - 1),
                        y: viewPort.height - yPos,
                        actual: historyActualData[i],
                        goals: historyGoalData[i]
                    });
                }
                var actual, goals;
                dataPoints.length > 0 && (actual = dataPoints[dataPoints.length - 1].actual, goals = dataPoints[dataPoints.length - 1].goals), 
                1 === dataPoints.length && (historyExists = !1), formattedValue = KPIStatusWithHistory.getFormattedValue(metaDataColumn, actual, precision, displayUnits), 
                formattedGoalString = KPIStatusWithHistory.getFormattedGoalString(metaDataColumn, goals, precision, displayUnits);
                var showGoal = KPIStatusWithHistory.getProp_Show_KPIGoal(dataView), showDistanceFromGoal = KPIStatusWithHistory.getProp_Show_KPIDistance(dataView), showTrendLine = KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView);
                return {
                    dataPoints: dataPoints,
                    directionType: directionType,
                    actual: actual,
                    goals: goals,
                    formattedGoalString: formattedGoalString,
                    targetExists: targetExists,
                    historyExists: historyExists,
                    indicatorExists: indicatorExists,
                    trendExists: trendExists,
                    formattedValue: formattedValue,
                    showGoal: showGoal,
                    showDistanceFromGoal: showDistanceFromGoal,
                    showTrendLine: showTrendLine
                };
            }, KPIStatusWithHistory.getColumnsByRole = function(values, roleString) {
                for (var retval = [], i = 0; i < values.length; i++) DataRoleHelper.hasRole(values[i].source, roleString) && retval.push(values[i]);
                return retval;
            }, KPIStatusWithHistory.prototype.enumerateObjectInstances = function(options) {
                var instances = [], dataView = this.dataView;
                switch (options.objectName) {
                  case "indicator":
                    instances.push({
                        selector: null,
                        objectName: "indicator",
                        properties: {
                            indicatorDisplayUnits: KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView),
                            indicatorPrecision: KPIStatusWithHistory.getProp_Indicator_Precision(dataView)
                        }
                    });

                  case "trendline":
                    instances.push({
                        selector: null,
                        objectName: "trendline",
                        properties: {
                            show: KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView)
                        }
                    });

                  case "goals":
                    instances.push({
                        selector: null,
                        objectName: "goals",
                        properties: {
                            showGoal: KPIStatusWithHistory.getProp_Show_KPIGoal(dataView),
                            showDistance: KPIStatusWithHistory.getProp_Show_KPIDistance(dataView)
                        }
                    });

                  case "status":
                    instances.push({
                        selector: null,
                        objectName: "status",
                        properties: {
                            direction: KPIStatusWithHistory.getProp_KPIDirection(dataView)
                        }
                    });
                }
                return instances;
            }, KPIStatusWithHistory.prototype.destroy = function() {
                this.svg = null;
            }, KPIStatusWithHistory.directionTypeStringProp = {
                objectName: "status",
                propertyName: "direction"
            }, KPIStatusWithHistory.showKPIGoal = {
                objectName: "goals",
                propertyName: "showGoal"
            }, KPIStatusWithHistory.showKPIDistance = {
                objectName: "goals",
                propertyName: "showDistance"
            }, KPIStatusWithHistory.showKPITrendLine = {
                objectName: "trendline",
                propertyName: "show"
            }, KPIStatusWithHistory.indicatorDisplayUnitsProp = {
                objectName: "indicator",
                propertyName: "indicatorDisplayUnits"
            }, KPIStatusWithHistory.indicatorPrecisionProp = {
                objectName: "indicator",
                propertyName: "indicatorPrecision"
            }, KPIStatusWithHistory.status = {
                INCREASE: "increase",
                DROP: "drop",
                IN_BETWEEN: "in-between",
                NOGOAL: "no-goal"
            }, KPIStatusWithHistory.statusBandingType = {
                Below: "BELOW",
                Above: "ABOVE"
            }, KPIStatusWithHistory.actualTextConsts = {
                VERTICAL_OFFSET_FROM_HALF_HEIGHT: 20,
                FONT_WIDTH_FACTOR: 14,
                RIGHT_MARGIN: 10
            }, KPIStatusWithHistory.kpiRedClass = "kpi-visual-red", KPIStatusWithHistory.kpiYellowClass = "kpi-visual-yellow", 
            KPIStatusWithHistory.kpiGreenClass = "kpi-visual-green", KPIStatusWithHistory.kpiTextGreyClass = "kpi-visual-text-grey", 
            KPIStatusWithHistory.kpiGraphGreyClass = "kpi-visual-graph-grey", KPIStatusWithHistory.allColorClasses = KPIStatusWithHistory.kpiRedClass + " " + KPIStatusWithHistory.kpiYellowClass + " " + KPIStatusWithHistory.kpiGreenClass + " " + KPIStatusWithHistory.kpiTextGreyClass + " " + KPIStatusWithHistory.kpiGraphGreyClass, 
            KPIStatusWithHistory.trendAreaFilePercentage = 1, KPIStatusWithHistory.estimatedIconHeightInPx = 9, 
            KPIStatusWithHistory.indicatorTextSizeInPx = 60, KPIStatusWithHistory;
        }();
        visuals.KPIStatusWithHistory = KPIStatusWithHistory;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var EnumExtensions = jsCommon.EnumExtensions, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, LineChart = function() {
            function LineChart(options) {
                var _this = this;
                this.deferDragMoveOperation = jsCommon.DeferUtility.deferUntilNextFrame(function() {
                    if (_this.lastDragMoveXPosition) {
                        var index = _this.findIndex(_this.lastDragMoveXPosition - _this.margin.left);
                        _this.selectColumn(index), _this.lastDragMoveXPosition = void 0;
                    }
                }), this.isScrollable = options.isScrollable ? options.isScrollable : !1, this.tooltipsEnabled = options.tooltipsEnabled, 
                this.lineType = options.chartType ? options.chartType : 1, this.interactivityService = options.interactivityService, 
                this.animator = options.animator, this.lineChartLabelDensityEnabled = options.lineChartLabelDensityEnabled, 
                this.lineClassAndSelector = LineChart.LineClassSelector;
            }
            return LineChart.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (dataViewMapping && dataViewMapping.categorical && dataViewMapping.categorical.categories && (dataViewMapping.categorical.dataVolume = 4, 
                visuals.CartesianChart.detectScalarMapping(dataViewMapping))) {
                    var dataViewCategories = dataViewMapping.categorical.categories;
                    dataViewCategories.dataReductionAlgorithm = {
                        sample: {}
                    };
                }
            }, LineChart.getSortableRoles = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return null;
                var dataViewCategories = dataViewMapping.categorical.categories, categoryItems = dataViewCategories["for"]["in"].items;
                if (!_.isEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type, objects = void 0;
                    if (dataViewMapping.metadata && (objects = dataViewMapping.metadata.objects), !visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType)) return [ "Category", "Y" ];
                }
                return null;
            }, LineChart.converter = function(dataView, blankCategoryValue, colors, isScalar, interactivityService, shouldCalculateStacked, isComboChart, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var categorical = dataView.categorical, category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                    source: void 0,
                    values: [ blankCategoryValue ],
                    identity: void 0
                }, xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties), categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
                var defaultSeriesColor, formatStringProp = visuals.lineChartProps.general.formatString, categoryType = visuals.AxisHelper.getCategoryValueType(category.source, isScalar), isDateTime = visuals.AxisHelper.isDateTime(categoryType), categoryValues = category.values, categoryData = [], series = [], seriesLen = categorical.values ? categorical.values.length : 0, hasDynamicSeries = !(!categorical.values || !categorical.values.source), values = categorical.values, defaultLabelSettings = visuals.dataLabelUtils.getDefaultLineChartLabelSettings(isComboChart);
                if (dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    defaultSeriesColor = isComboChart ? void 0 : powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.dataPoint.defaultColor);
                    var labelsObj = objects.labels;
                    visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelsObj, defaultLabelSettings);
                }
                var grouped, colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultSeriesColor);
                dataView.categorical.values && (grouped = dataView.categorical.values.grouped());
                var stackedValues;
                shouldCalculateStacked && (stackedValues = categorical.values && categorical.values.length > 0 ? _.times(categorical.values[0].values.length, function() {
                    return 0;
                }) : []);
                for (var seriesIndex = 0; seriesLen > seriesIndex; seriesIndex++) {
                    var column = categorical.values[seriesIndex], valuesMetadata = column.source, dataPoints = [], groupedIdentity = grouped[seriesIndex], identity = hasDynamicSeries && groupedIdentity ? visuals.SelectionId.createWithIdAndMeasure(groupedIdentity.identity, column.source.queryName) : visuals.SelectionId.createWithMeasure(column.source.queryName), key = identity.getKey(), color = this.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity), seriesLabelSettings = void 0;
                    if (!hasDynamicSeries) {
                        var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                        labelObjects && (seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings), 
                        visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                    }
                    for (var dataPointLabelSettings = seriesLabelSettings ? seriesLabelSettings : defaultLabelSettings, useHighlightValues = column.highlights && column.highlights.length > 0, valuesArray = useHighlightValues ? column.highlights : column.values, categoryIndex = 0, len = valuesArray.length; len > categoryIndex; categoryIndex++) {
                        var categoryValue = categoryValues[categoryIndex], value = visuals.AxisHelper.normalizeNonFiniteNumber(valuesArray[categoryIndex]);
                        if ((!isScalar || null != categoryValue && null != value) && (!isDateTime || null == categoryValue || categoryValue instanceof Date)) {
                            var categorical_1 = dataView.categorical, tooltipInfo = void 0;
                            tooltipsEnabled && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical_1, categoryValue, value, null, null, seriesIndex));
                            var categoryKey = category && !_.isEmpty(category.identity) && category.identity[categoryIndex] ? category.identity[categoryIndex].key : categoryIndex, dataPoint = {
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: value,
                                categoryIndex: categoryIndex,
                                seriesIndex: seriesIndex,
                                tooltipInfo: tooltipInfo,
                                selected: !1,
                                identity: identity,
                                key: JSON.stringify({
                                    series: key,
                                    category: categoryKey
                                }),
                                labelFill: dataPointLabelSettings.labelColor,
                                labelFormatString: valuesMetadata.format,
                                labelSettings: dataPointLabelSettings
                            };
                            shouldCalculateStacked && (stackedValues[categoryIndex] += value, dataPoint.stackedValue = stackedValues[categoryIndex]), 
                            category.objects && category.objects[categoryIndex] && (dataPoint.pointColor = powerbi.DataViewObjects.getFillColor(category.objects[categoryIndex], visuals.lineChartProps.dataPoint.fill)), 
                            dataPoints.push(dataPoint), categoryData[categoryIndex] || (categoryData[categoryIndex] = dataPoint);
                        }
                    }
                    interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                    dataPoints.length > 0 && series.push({
                        displayName: valuesMetadata.displayName,
                        key: key,
                        lineIndex: seriesIndex,
                        color: color,
                        xCol: category.source,
                        yCol: column.source,
                        data: dataPoints,
                        identity: identity,
                        selected: !1,
                        labelSettings: seriesLabelSettings
                    });
                }
                xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata), valuesMetadataArray = [];
                if (values) for (var i = 0; i < values.length; i++) values[i] && values[i].source && values[i].source.displayName && valuesMetadataArray.push({
                    displayName: values[i].source.displayName
                });
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
                return interactivityService && interactivityService.applySelectionStateToData(series), 
                {
                    series: series,
                    isScalar: isScalar,
                    dataLabelsSettings: defaultLabelSettings,
                    axesLabels: {
                        x: axesLabels.xAxisLabel,
                        y: axesLabels.yAxisLabel
                    },
                    hasDynamicSeries: hasDynamicSeries,
                    categoryMetadata: category.source,
                    categories: categoryValues,
                    categoryData: categoryData
                };
            }, LineChart.getInteractiveLineChartDomElement = function(element) {
                return element.children("svg").get(0);
            }, LineChart.getColor = function(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
                var objects;
                return hasDynamicSeries ? grouped && grouped[seriesIndex] && (objects = grouped[seriesIndex].objects) : values[seriesIndex] && (objects = values[seriesIndex].source.objects), 
                hasDynamicSeries && groupedIdentity ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name) : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
            }, LineChart.createStackedValueDomain = function(data) {
                if (0 === data.length) return null;
                var minY = d3.min(data, function(kv) {
                    return d3.min(kv.data, function(d) {
                        return d.stackedValue;
                    });
                }), maxY = d3.max(data, function(kv) {
                    return d3.max(kv.data, function(d) {
                        return d.stackedValue;
                    });
                });
                return [ minY, maxY ];
            }, LineChart.prototype.init = function(options) {
                var _this = this;
                this.options = options, this.element = options.element, this.cartesainSVG = options.svg, 
                this.host = options.host, this.currentViewport = options.viewport, this.colors = options.style.colorPalette.dataColors, 
                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                this.cartesianVisualHost = options.cartesianHost;
                var chartType = options.chartType;
                this.isComboChart = 10 === chartType || 13 === chartType || 14 === chartType;
                var svg = options.svg;
                svg.classed(LineChart.ClassName, !0);
                var graphicsContextParent = this.mainGraphicsSVG = svg.append("svg").classed("lineChartSVG", !0);
                this.isComboChart || this.isInteractiveChart || (this.overlayRect = graphicsContextParent.append(LineChart.RectOverlayName).style("opacity", visuals.SVGUtil.AlmostZero)), 
                this.mainGraphicsContext = graphicsContextParent.append("g").classed(LineChart.MainGraphicsContextClassName, !0), 
                this.hoverLineContext = svg.append("g").classed("hover-line", !0), this.hoverLineContext.append(LineChart.LineElementName).attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0);
                var hoverLine = this.hoverLine = this.hoverLineContext.select(LineChart.LineElementName);
                if (this.isInteractiveChart && hoverLine.classed("interactive", !0), hoverLine.style("opacity", visuals.SVGUtil.AlmostZero), 
                this.selectionCircles = [], this.xAxisProperties = {
                    axis: null,
                    scale: null,
                    axisType: null,
                    formatter: null,
                    graphicsContext: null,
                    values: null,
                    axisLabel: null,
                    isCategoryAxis: !0
                }, this.isInteractiveChart) {
                    var rootSvg_1 = LineChart.getInteractiveLineChartDomElement(this.element), dragMove = function() {
                        _this.lastDragMoveXPosition = d3.mouse(rootSvg_1)[0], _this.deferDragMoveOperation();
                    }, drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                    d3.select(rootSvg_1).style("touch-action", "none").call(drag).on("click", dragMove);
                }
                this.shouldAdjustMouseCoordsOnPathsForStroke = !jsCommon.BrowserUtils.isChrome();
            }, LineChart.prototype.setData = function(dataViews) {
                if (this.data = {
                    series: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLineChartLabelSettings(this.isComboChart),
                    axesLabels: {
                        x: null,
                        y: null
                    },
                    hasDynamicSeries: !1,
                    categories: [],
                    categoryMetadata: void 0,
                    categoryData: []
                }, dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCat = this.dataViewCat = dataView.categorical, dvCategories = dataViewCat.categories, categoryType = powerbi.ValueType.fromDescriptor({
                            text: !0
                        });
                        dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type);
                        var convertedData = LineChart.converter(dataView, visuals.valueFormatter.format(null), this.cartesianVisualHost.getSharedColors(), visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.lineChartProps.categoryAxis.axisType, categoryType), this.interactivityService, EnumExtensions.hasFlag(this.lineType, 16), this.isComboChart);
                        this.data = convertedData;
                    }
                }
            }, LineChart.prototype.calculateLegend = function() {
                return this.createLegendDataPoints(0);
            }, LineChart.prototype.hasLegend = function() {
                return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
            }, LineChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var catgSize = endIndex - startIndex, data = this.clippedData = powerbi.Prototype.inherit(this.data);
                return data.series = LineChart.sliceSeries(data.series, catgSize, startIndex), data.categories = data.categories.slice(startIndex, endIndex), 
                data;
            }, LineChart.prototype.calculateAxesProperties = function(options) {
                var _this = this, data = this.data, viewport = options.viewport, margin = options.margin;
                this.currentViewport = viewport, this.margin = margin;
                var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0, categoryWidth = visuals.CartesianChart.MinOrdinalRectThickness, isScalar = this.data.isScalar, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, preferredPlotArea = this.getPreferredPlotArea(isScalar, origCatgSize, categoryWidth);
                if (this.clippedData = void 0, data && !isScalar && !this.isScrollable && trimOrdinalDataOnOverflow) {
                    var categoryCount = this.getCategoryCount(origCatgSize), catgSize = Math.min(origCatgSize, categoryCount);
                    catgSize !== origCatgSize && (data = this.clippedData = powerbi.Prototype.inherit(data), 
                    this.clippedData.series = LineChart.sliceSeries(data.series, catgSize));
                }
                var xMetaDataColumn, yMetaDataColumn;
                data.series && data.series.length > 0 && (xMetaDataColumn = data.series[0].xCol, 
                yMetaDataColumn = data.series[0].yCol);
                var valueDomain = EnumExtensions.hasFlag(this.lineType, 16) ? LineChart.createStackedValueDomain(data.series) : visuals.AxisHelper.createValueDomain(data.series, !1), hasZeroValueInYDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(valueDomain), combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, valueDomain, options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, visuals.lineChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    scaleType: options.valueAxisScaleType,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision,
                    shouldClamp: !1
                });
                var xDomain = visuals.AxisHelper.createDomain(data.series, this.xAxisProperties.axisType, this.data.isScalar, options.forcedXDomain, options.ensureXDomain), hasZeroValueInXDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(xDomain);
                return this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, visuals.lineChartProps.general.formatString),
                    outerPadding: this.data.isScalar ? LineChart.ScalarOuterPadding : 0,
                    isScalar: this.data.isScalar,
                    isVertical: !1,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    getValueFn: function(index, type) {
                        return visuals.CartesianHelper.lookupXValue(_this.data, index, type, _this.data.isScalar);
                    },
                    categoryThickness: visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.getAvailableWidth(), xDomain, isScalar, trimOrdinalDataOnOverflow),
                    isCategoryAxis: !0,
                    scaleType: options.categoryAxisScaleType,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                }), this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null, 
                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null, 
                this.xAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInXDomain, this.yAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInYDomain, 
                [ this.xAxisProperties, this.yAxisProperties ];
            }, LineChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                switch (options.objectName) {
                  case "dataPoint":
                    this.enumerateDataPoints(enumeration);
                    break;

                  case "labels":
                    this.enumerateDataLabels(enumeration);
                }
            }, LineChart.prototype.enumerateDataPoints = function(enumeration) {
                var data = this.data;
                if (data && data.series && 0 !== data.series.length) for (var formatStringProp = visuals.lineChartProps.general.formatString, singleSeriesData = data.series, seriesLength = singleSeriesData.length, i = 0; seriesLength > i; i++) {
                    var selector = visuals.ColorHelper.normalizeSelector(singleSeriesData[i].identity.getSelector()), label = visuals.converterHelper.getFormattedLegendLabel(singleSeriesData[i].yCol, this.dataViewCat.values, formatStringProp);
                    enumeration.pushInstance({
                        objectName: "dataPoint",
                        displayName: label,
                        selector: selector,
                        properties: {
                            fill: {
                                solid: {
                                    color: data.defaultSeriesColor || singleSeriesData[i].color
                                }
                            }
                        }
                    });
                }
            }, LineChart.prototype.enumerateDataLabels = function(enumeration) {
                var data = this.data, labelSettings = this.data.dataLabelsSettings, seriesCount = data.series.length, showLabelPerSeries = this.showLabelPerSeries();
                if (visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries)), 
                0 !== seriesCount && showLabelPerSeries && labelSettings.showLabelPerSeries) for (var i = 0; seriesCount > i; i++) {
                    var series = data.series[i], labelSettings_2 = series.labelSettings ? series.labelSettings : this.data.dataLabelsSettings;
                    enumeration.pushContainer({
                        displayName: series.displayName
                    }), visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_2, series)), 
                    enumeration.popContainer();
                }
            }, LineChart.prototype.supportsTrendLine = function() {
                var data = this.data;
                return data ? data.isScalar && 1 === data.series.length : !1;
            }, LineChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, series, showAll) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: !0,
                    displayUnits: !0,
                    precision: !0,
                    selector: series && series.identity ? series.identity.getSelector() : null,
                    showAll: showAll,
                    fontSize: !0,
                    labelDensity: this.lineChartLabelDensityEnabled
                };
            }, LineChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            }, LineChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, LineChart.prototype.render = function(suppressAnimations) {
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.data.categoryData.length !== this.previousCategoryCount && (duration = 0), 
                this.previousCategoryCount = this.data.categoryData.length;
                var result;
                return result = this.isInteractiveChart ? this.renderOld(duration) : this.renderNew(duration), 
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), result;
            }, LineChart.prototype.renderNew = function(duration) {
                var _this = this, data = this.clippedData ? this.clippedData : this.data;
                if (data) {
                    var dataPointCount = data.categories.length * data.series.length;
                    dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate && (duration = 0);
                    var y0Position, yPosition, isStackedArea = EnumExtensions.hasFlag(this.lineType, 16), margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, horizontalOffset = this.getXOfFirstCategory(), hasSelection = this.interactivityService && this.interactivityService.hasSelection(), renderAreas = EnumExtensions.hasFlag(this.lineType, 2) || EnumExtensions.hasFlag(this.lineType, 16), xPosition = function(d) {
                        return xScale(_this.getXValue(d)) + horizontalOffset;
                    };
                    isStackedArea ? (y0Position = function(d) {
                        return yScale(d.stackedValue - d.value);
                    }, yPosition = function(d) {
                        return yScale(d.stackedValue);
                    }) : (y0Position = yScale(0), yPosition = function(d) {
                        return yScale(d.value);
                    });
                    var area;
                    renderAreas && (area = d3.svg.area().x(xPosition).y0(y0Position).y1(yPosition).defined(function(d) {
                        return null !== d.value;
                    }));
                    var line = d3.svg.line().x(xPosition).y(yPosition).defined(function(d) {
                        return null !== d.value;
                    });
                    EnumExtensions.hasFlag(this.lineType, 4) && (line.interpolate("basis"), area && area.interpolate("basis")), 
                    this.mainGraphicsSVG.attr("height", height).attr("width", width);
                    var areas = void 0;
                    renderAreas && (areas = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector).data(data.series, function(d) {
                        return d.identity.getKey();
                    }), areas.enter().append(LineChart.PathElementName).classed(LineChart.CategoryAreaSelector["class"], !0), 
                    areas.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return hasSelection && !d.selected ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity;
                    }).transition().ease("linear").duration(duration).attr("d", function(d) {
                        return area(d.data);
                    }), areas.exit().remove());
                    var lines = this.mainGraphicsContext.selectAll(this.lineClassAndSelector.selector).data(data.series, function(d) {
                        return d.identity.getKey();
                    });
                    lines.enter().append(LineChart.PathElementName).classed(this.lineClassAndSelector["class"], !0), 
                    lines.style("stroke", function(d) {
                        return d.color;
                    }).style("stroke-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }).transition().ease("linear").duration(duration).attr("d", function(d) {
                        return line(d.data);
                    }), lines.exit().remove();
                    var interactivityLines;
                    this.interactivityService && (interactivityLines = this.mainGraphicsContext.selectAll(".interactivity-line").data(data.series, function(d) {
                        return d.identity.getKey();
                    }), interactivityLines.enter().append(LineChart.PathElementName).classed("interactivity-line", !0).style("stroke-width", LineChart.interactivityStrokeWidth), 
                    interactivityLines.attr("d", function(d) {
                        return line(d.data);
                    }), interactivityLines.exit().remove());
                    var dotGroups = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector).data(data.series, function(d) {
                        return d.identity.getKey();
                    });
                    dotGroups.enter().append("g").classed(LineChart.CategorySelector["class"], !0), 
                    dotGroups.exit().remove();
                    var dots = dotGroups.selectAll(LineChart.CategoryValuePoint.selector).data(function(series) {
                        return series.data.filter(function(value, i) {
                            return _this.shouldDrawCircle(series, i);
                        });
                    }, function(d) {
                        return d.key;
                    });
                    dots.enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint["class"], !0), 
                    dots.style("fill", function() {
                        var lineSeries = d3.select(this.parentNode).datum();
                        return lineSeries.color;
                    }).style("fill-opacity", function() {
                        var lineSeries = d3.select(this.parentNode).datum();
                        return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, !1, hasSelection, !1);
                    }).transition().duration(duration).attr({
                        cx: function(d, i) {
                            return xScale(_this.getXValue(d)) + horizontalOffset;
                        },
                        cy: function(d, i) {
                            return yScale(isStackedArea ? d.stackedValue : d.value);
                        },
                        r: LineChart.CircleRadius
                    }), dots.exit().remove();
                    var explicitDots;
                    this.isComboChart || (explicitDots = dotGroups.selectAll(LineChart.CategoryPointSelector.selector).data(function(series) {
                        return _.filter(series.data, function(value) {
                            return null != value.pointColor;
                        });
                    }, function(d) {
                        return d.key;
                    }), explicitDots.enter().append(LineChart.CircleElementName).classed(LineChart.CategoryPointSelector["class"], !0), 
                    explicitDots.style("fill", function(d) {
                        return d.pointColor;
                    }).transition().duration(duration).attr({
                        cx: function(d) {
                            return xScale(_this.getXValue(d));
                        },
                        cy: function(d) {
                            return yScale(isStackedArea ? d.stackedValue : d.value);
                        },
                        r: LineChart.PointRadius
                    }), explicitDots.exit().remove());
                    var labelDataPointsGroups;
                    if (data.dataLabelsSettings.show && (labelDataPointsGroups = this.createLabelDataPoints()), 
                    this.tooltipsEnabled) if (this.isComboChart) {
                        var seriesTooltipApplier = function(tooltipEvent) {
                            var pointX = tooltipEvent.elementCoordinates[0];
                            return _this.getTooltipInfoForCombo(tooltipEvent, pointX);
                        };
                        interactivityLines && visuals.TooltipManager.addTooltip(interactivityLines, seriesTooltipApplier, !0), 
                        visuals.TooltipManager.addTooltip(dots, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), explicitDots && visuals.TooltipManager.addTooltip(explicitDots, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0);
                    } else {
                        this.overlayRect.attr({
                            x: 0,
                            width: width,
                            height: height
                        });
                        var seriesTooltipApplier = function(tooltipEvent) {
                            var pointX = tooltipEvent.elementCoordinates[0], index = _this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX), categoryData = _this.selectColumnForTooltip(index);
                            return _this.getSeriesTooltipInfo(categoryData);
                        }, clearHoverLine = function() {
                            _this.hoverLine.style("opacity", visuals.SVGUtil.AlmostZero), _this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).remove();
                        };
                        visuals.TooltipManager.addTooltip(this.mainGraphicsSVG, seriesTooltipApplier, !0, clearHoverLine);
                    }
                    var dataPointsToBind = void 0, behaviorOptions = void 0;
                    if (this.interactivityService) {
                        dataPointsToBind = data.series.slice();
                        for (var i = 0, ilen = data.series.length; ilen > i; i++) dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                        behaviorOptions = {
                            lines: lines,
                            interactivityLines: interactivityLines,
                            dots: dots,
                            areas: areas,
                            tooltipOverlay: this.overlayRect
                        };
                    }
                    return {
                        dataPoints: dataPointsToBind,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: [],
                        labelsAreNumeric: !0,
                        labelDataPointGroups: labelDataPointsGroups
                    };
                }
            }, LineChart.prototype.renderOld = function(duration) {
                var _this = this, data = this.clippedData ? this.clippedData : this.data;
                if (data) {
                    var area, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    EnumExtensions.hasFlag(this.lineType, 2) && (area = d3.svg.area().x(function(d) {
                        return xScale(_this.getXValue(d));
                    }).y0(height).y1(function(d) {
                        return yScale(d.value);
                    }).defined(function(d) {
                        return null !== d.value;
                    }));
                    var line = d3.svg.line().x(function(d) {
                        return xScale(_this.getXValue(d));
                    }).y(function(d) {
                        return yScale(d.value);
                    }).defined(function(d) {
                        return null !== d.value;
                    });
                    EnumExtensions.hasFlag(this.lineType, 4) && (line.interpolate("basis"), area && area.interpolate("basis"));
                    var firstCategoryOffset = this.getXOfFirstCategory();
                    if (this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(firstCategoryOffset, 0)), 
                    this.mainGraphicsSVG.attr("height", this.getAvailableHeight()).attr("width", this.getAvailableWidth()), 
                    this.hoverLineContext.attr("transform", visuals.SVGUtil.translate(firstCategoryOffset, 0)), 
                    EnumExtensions.hasFlag(this.lineType, 2)) {
                        var catAreaSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector).data(data.series, function(d) {
                            return d.identity.getKey();
                        }), catAreaEnter = catAreaSelect.enter().append("g").classed(LineChart.CategoryAreaSelector["class"], !0);
                        catAreaEnter.append(LineChart.PathElementName);
                        var catAreaUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector);
                        catAreaUpdate.select(LineChart.PathElementName).transition().ease("linear").duration(duration).attr("d", function(d) {
                            return area(d.data);
                        }).style("fill", function(d) {
                            return d.color;
                        }).style("fill-opacity", function(d) {
                            return hasSelection && !d.selected ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity;
                        }), catAreaSelect.exit().remove();
                    }
                    var catSelect = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector).data(data.series, function(d) {
                        return d.identity.getKey();
                    }), catEnter = catSelect.enter().append("g").classed(LineChart.CategorySelector["class"], !0);
                    if (catEnter.append(LineChart.PathElementName), catEnter.selectAll(LineChart.CategoryValuePoint.selector).data(function(d) {
                        return d.data;
                    }).enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint["class"], !0), 
                    catSelect.exit().remove(), this.isInteractiveChart && !this.dragHandle) {
                        var handleTop = this.getAvailableHeight();
                        this.dragHandle = this.hoverLineContext.append("circle").attr("cx", 0).attr("cy", handleTop).attr("r", "6px").classed("drag-handle", !0);
                    }
                    for (var linesCount = catSelect.data().length; this.selectionCircles.length < linesCount; ) {
                        var addedCircle = this.hoverLineContext.append(LineChart.CircleElementName).classed(LineChart.CircleClassName, !0).attr("r", LineChart.CircleRadius).style("opacity", 0);
                        this.selectionCircles.push(addedCircle);
                    }
                    for (;this.selectionCircles.length > linesCount; ) this.selectionCircles.pop().remove();
                    var catUpdate = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector), lineSelection = catUpdate.select(LineChart.PathElementName).classed(this.lineClassAndSelector["class"], !0).style("stroke", function(d) {
                        return d.color;
                    }).style("stroke-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    });
                    lineSelection.transition().ease("linear").duration(duration).attr("d", function(d) {
                        return line(d.data);
                    });
                    var that = this, updateSelection = catUpdate.selectAll(LineChart.CategoryValuePoint.selector), transitions = updateSelection.style("fill", function() {
                        var lineSeries = d3.select(this.parentNode).datum();
                        return lineSeries.color;
                    }).style("fill-opacity", function() {
                        var lineSeries = d3.select(this.parentNode).datum();
                        return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, !1, hasSelection, !1);
                    }).transition().duration(duration).attr({
                        cx: function(d, i) {
                            var lineSeries = d3.select(this.parentNode).datum(), circleIndex = that.shouldDrawCircle(lineSeries, i);
                            return circleIndex ? xScale(that.getXValue(d)) : 0;
                        },
                        cy: function(d, i) {
                            var lineSeries = d3.select(this.parentNode).datum(), circleIndex = that.shouldDrawCircle(lineSeries, i);
                            return circleIndex ? yScale(d.value) : 0;
                        },
                        r: function(d, i) {
                            var lineSeries = d3.select(this.parentNode).datum(), circleIndex = that.shouldDrawCircle(lineSeries, i);
                            return circleIndex ? LineChart.CircleRadius : 0;
                        }
                    });
                    if (this.isInteractiveChart && this.hasDataPoint(data.series)) {
                        var selectionSize_1 = updateSelection.size(), endedTransitionCount_1 = 0;
                        transitions.each("end", function() {
                            endedTransitionCount_1++, endedTransitionCount_1 === selectionSize_1 && _this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(data.series), !0);
                        });
                    }
                    var dataPoints = null;
                    if (data.dataLabelsSettings.show) {
                        dataPoints = [];
                        for (var i = 0, ilen = data.series.length; ilen > i; i++) Array.prototype.push.apply(dataPoints, data.series[i].data);
                    }
                    catSelect.exit().remove();
                    var labelDataPointsGroups;
                    return data.dataLabelsSettings.show && (labelDataPointsGroups = this.createLabelDataPoints()), 
                    null == dataPoints ? null : {
                        dataPoints: dataPoints,
                        behaviorOptions: null,
                        labelDataPoints: null,
                        labelsAreNumeric: null,
                        labelDataPointGroups: labelDataPointsGroups
                    };
                }
            }, LineChart.prototype.getSeriesTooltipInfo = function(pointData) {
                for (var tooltipinfo = [], maxNumberOfItems = 10, count = 0, _i = 0, pointData_1 = pointData; _i < pointData_1.length; _i++) {
                    var point = pointData_1[_i];
                    if (count >= maxNumberOfItems) break;
                    null != point.value && (tooltipinfo.push({
                        header: point.category,
                        color: point.color,
                        displayName: point.label,
                        value: point.measure
                    }), count++);
                }
                return 0 === tooltipinfo.length ? null : tooltipinfo;
            }, LineChart.prototype.getTooltipInfoForCombo = function(tooltipEvent, pointX) {
                var dataPoint, categoryIndex = this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX), seriesData = tooltipEvent.data;
                return seriesData && seriesData.data && seriesData.data.length && (dataPoint = _.find(seriesData.data, function(dp) {
                    return dp.categoryIndex === categoryIndex;
                })), dataPoint ? dataPoint.tooltipInfo : void 0;
            }, LineChart.prototype.getCategoryIndexFromTooltipEvent = function(tooltipEvent, pointX) {
                if (tooltipEvent.data && null != tooltipEvent.data.categoryIndex) return tooltipEvent.data.categoryIndex;
                var seriesData = tooltipEvent.data, offsetX = 0;
                if (seriesData && !_.isEmpty(seriesData.data) && this.xAxisProperties) {
                    pointX = this.adjustPathXCoordinate(pointX);
                    var firstPathPoint = _.find(seriesData.data, function(dataPoint, index, dataPoints) {
                        var nextDataPoint = dataPoints[index + 1];
                        return null != dataPoint.value && nextDataPoint && null != nextDataPoint.value;
                    });
                    offsetX = this.xAxisProperties.scale(this.getXValue(firstPathPoint)) + this.getXOfFirstCategory();
                }
                return this.findIndex(pointX, offsetX);
            }, LineChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return this.data ? this.data.isScalar : !1;
            }, LineChart.prototype.getSupportedCategoryAxisType = function() {
                var dvCategories = this.dataViewCat ? this.dataViewCat.categories : void 0, categoryType = powerbi.ValueType.fromDescriptor({
                    text: !0
                });
                dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type);
                var isOrdinal = visuals.AxisHelper.isOrdinal(categoryType);
                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
            }, LineChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin, !0);
            }, LineChart.prototype.getCategoryCount = function(origCatgSize) {
                var availableWidth = this.getAvailableWidth(), categoryThickness = visuals.CartesianChart.MinOrdinalRectThickness;
                return Math.min(Math.round((availableWidth - categoryThickness * visuals.CartesianChart.OuterPaddingRatio * 2) / categoryThickness), origCatgSize);
            }, LineChart.prototype.getAvailableWidth = function() {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            }, LineChart.prototype.getAvailableHeight = function() {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            }, LineChart.sliceSeries = function(series, newLength, startIndex) {
                void 0 === startIndex && (startIndex = 0);
                var newSeries = [];
                if (series && series.length > 0) for (var i = 0, len = series.length; len > i; i++) newSeries[i] = powerbi.Prototype.inherit(series[i]), 
                newSeries[i].data = series[i].data.slice(startIndex, startIndex + newLength);
                return newSeries;
            }, LineChart.prototype.getXOfFirstCategory = function() {
                if (!this.data.isScalar) {
                    var xScale = this.xAxisProperties.scale;
                    if (xScale.rangeBand) return xScale.rangeBand() / 2;
                }
                return 0;
            }, LineChart.prototype.hasDataPoint = function(series) {
                if (0 === series.length) return !1;
                for (var i = 0, len = series.length; len > i; i++) if (series[i].data.length > 0) return !0;
                return !1;
            }, LineChart.prototype.getXValue = function(d) {
                return this.data.isScalar ? d.categoryValue : d.categoryIndex;
            }, LineChart.prototype.shouldDrawCircle = function(d, i) {
                var dataLength = d.data.length, isLastPoint = i === dataLength - 1, isFirstPoint = 0 === i;
                return i > dataLength - 1 || null === d.data[i] || null === d.data[i].value ? !1 : isFirstPoint && isLastPoint ? !0 : isFirstPoint && dataLength > 1 && null === d.data[i + 1].value ? !0 : !isFirstPoint && isLastPoint && null === d.data[i - 1].value ? !0 : !isFirstPoint && !isLastPoint && null === d.data[i - 1].value && null === d.data[i + 1].value;
            }, LineChart.prototype.selectColumnForTooltip = function(columnIndex, force) {
                void 0 === force && (force = !1);
                var x = this.getChartX(columnIndex) + this.getXOfFirstCategory(), dataPoints = this.createTooltipDataPoints(columnIndex);
                return dataPoints.length > 0 && this.setHoverLineForTooltip(x), this.setDotsForTooltip(x, dataPoints), 
                dataPoints;
            }, LineChart.prototype.setHoverLineForTooltip = function(chartX) {
                chartX = chartX || 0, this.hoverLine.attr("x1", chartX).attr("x2", chartX).attr("y1", 0).attr("y2", this.getAvailableHeight()).style("opacity", 1);
            }, LineChart.prototype.setDotsForTooltip = function(chartX, dataPoints) {
                var _this = this, isStackedArea = EnumExtensions.hasFlag(this.lineType, 16), dotYPosition = isStackedArea ? function(d) {
                    return _this.yAxisProperties.scale(d.stackedValue);
                } : function(d) {
                    return _this.yAxisProperties.scale(d.value);
                }, tooltipDots = this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).data(dataPoints);
                tooltipDots.enter().append(LineChart.CircleElementName).classed(LineChart.HoverLineCircleDot["class"], !0), 
                tooltipDots.filter(function(d) {
                    return d.value;
                }).attr("fill", function(d) {
                    return d.color;
                }).attr("r", 3).attr("cx", chartX).attr("cy", dotYPosition), tooltipDots.exit().remove();
            }, LineChart.prototype.selectColumn = function(columnIndex, force) {
                if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== columnIndex) {
                    this.lastInteractiveSelectedColumnIndex = columnIndex;
                    var x = this.getChartX(columnIndex);
                    this.setHoverLine(x, columnIndex);
                    var legendItems = this.createLegendDataPoints(columnIndex);
                    legendItems && this.options.cartesianHost.updateLegend(legendItems);
                }
            }, LineChart.prototype.setHoverLine = function(chartX, columnIndex) {
                this.hoverLine.attr("x1", chartX).attr("x2", chartX).attr("y1", 0).attr("y2", this.getAvailableHeight()).style("opacity", 1);
                var that = this;
                this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector).selectAll(LineChart.PathElementName).each(function(series) {
                    var _this = this, color = series.color, circleToChange = that.selectionCircles[series.lineIndex];
                    circleToChange.attr({
                        cx: chartX,
                        cy: function() {
                            var pathElement = d3.select(_this).node(), pos = that.getPosition(chartX, pathElement);
                            return pos.y;
                        }
                    }).style({
                        opacity: function() {
                            return _.some(series.data, function(value) {
                                return value.categoryIndex === columnIndex;
                            }) ? 1 : 0;
                        },
                        fill: color
                    }), that.dragHandle && that.dragHandle.attr("cx", chartX);
                });
            }, LineChart.prototype.getChartX = function(columnIndex) {
                var x = 0;
                this.data.isScalar ? columnIndex >= 0 && columnIndex < this.data.categoryData.length && (x = Math.max(0, this.xAxisProperties.scale(this.data.categoryData[columnIndex].categoryValue))) : x = Math.max(0, this.xAxisProperties.scale(columnIndex));
                var rangeEnd = powerbi.visuals.AxisHelper.extent(this.xAxisProperties.scale)[1];
                return x = Math.min(x, rangeEnd), isNaN(x) ? 0 : x;
            }, LineChart.prototype.findIndex = function(pointX, offsetX) {
                var svgNode = this.mainGraphicsSVG.node(), ratios = visuals.SVGUtil.getTransformScaleRatios(svgNode);
                powerbi.Double.equalWithPrecision(ratios.x, 1, 1e-5) || (pointX /= ratios.x), offsetX && (pointX += offsetX);
                var scaleX = powerbi.visuals.AxisHelper.invertScale(this.xAxisProperties.scale, pointX);
                return this.data.isScalar && (scaleX = visuals.AxisHelper.findClosestXAxisIndex(scaleX, this.data.categoryData)), 
                scaleX;
            }, LineChart.prototype.getPosition = function(x, pathElement) {
                for (var pos, target, pathLength = pathElement.getTotalLength(), beginning = 0, end = pathLength; ;) {
                    if (target = Math.floor((beginning + end) / 2), pos = pathElement.getPointAtLength(target), 
                    visuals.SVGUtil.ensureValidSVGPoint(pos), (target === end || target === beginning) && pos.x !== x) break;
                    if (pos.x > x) end = target; else {
                        if (!(pos.x < x)) break;
                        beginning = target;
                    }
                }
                return pos;
            }, LineChart.prototype.createTooltipDataPoints = function(columnIndex) {
                var data = this.data;
                if (!data || 0 === data.series.length || !data.categoryData) return [];
                var category, dataPoints = [], categoryDataPoint = data.categoryData[columnIndex];
                this.data.isScalar ? categoryDataPoint && (category = visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType) ? visuals.CartesianHelper.lookupXValue(this.data, categoryDataPoint.categoryValue, this.xAxisProperties.axisType, this.data.isScalar) : categoryDataPoint.categoryValue) : category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
                for (var formatStringProp = visuals.lineChartProps.general.formatString, _i = 0, _a = data.series; _i < _a.length; _i++) {
                    var series = _a[_i], lineData = series.data, lineDataPoint = void 0;
                    this.data.isScalar ? categoryDataPoint && (lineDataPoint = lineData.filter(function(data) {
                        return data.categoryValue === categoryDataPoint.categoryValue;
                    })[0]) : lineDataPoint = lineData[columnIndex];
                    var value = lineDataPoint && lineDataPoint.value;
                    if (null != value) {
                        var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                        dataPoints.push({
                            color: series.color,
                            label: label,
                            category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                            measure: visuals.valueFormatter.format(value, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                            value: value,
                            stackedValue: lineDataPoint.stackedValue
                        });
                    }
                }
                return dataPoints;
            }, LineChart.prototype.createLegendDataPoints = function(columnIndex) {
                var data = this.data;
                if (data && data.series && !(data.series.length < 1)) {
                    var category, legendDataPoints = [], categoryDataPoint = data.categoryData[columnIndex];
                    this.isInteractiveChart && categoryDataPoint && (this.data.isScalar ? (category = categoryDataPoint.categoryValue, 
                    visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType) && (category = new Date(category))) : category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar));
                    for (var formatStringProp = visuals.lineChartProps.general.formatString, seriesYCol = null, i = 0, len = data.series.length; len > i; i++) {
                        var series = data.series[i], lineData = series.data, measure = void 0;
                        if (this.isInteractiveChart) {
                            var lineDataPoint = void 0;
                            if (this.data.isScalar) {
                                if (categoryDataPoint) for (var targetCategoryValue = categoryDataPoint.categoryValue, i_1 = 0; i_1 < lineData.length; i_1++) if (lineData[i_1].categoryValue === targetCategoryValue) {
                                    lineDataPoint = lineData[i_1];
                                    break;
                                }
                            } else lineDataPoint = lineData[columnIndex];
                            measure = lineDataPoint && lineDataPoint.value;
                        }
                        var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                        seriesYCol = series.yCol, legendDataPoints.push({
                            color: series.color,
                            icon: visuals.LegendIcon.Line,
                            label: label,
                            category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                            identity: series.identity,
                            selected: series.selected
                        });
                    }
                    var dvValues = this.dataViewCat ? this.dataViewCat.values : null, title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                    return {
                        title: title,
                        dataPoints: legendDataPoints
                    };
                }
            }, LineChart.prototype.createLabelDataPoints = function() {
                var labelSettings, axisFormatter, seriesLabelDataPoints, seriesDataPointsCandidates, seriesIndex, seriesCount, _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, lineshift = this.getXOfFirstCategory(), bandRange = 2 * lineshift, innerPaddingRatio = visuals.CartesianChart.InnerPaddingRatio, horizontalInnerPadding = innerPaddingRatio * bandRange / (1 - innerPaddingRatio), data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), dataLabelsSettings = data.dataLabelsSettings, isStackedArea = EnumExtensions.hasFlag(this.lineType, 16), labelDataPointsGroups = [];
                for (seriesIndex = 0, seriesCount = series.length; seriesCount > seriesIndex; seriesIndex++) {
                    var currentSeries = series[seriesIndex];
                    if (labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : dataLabelsSettings, 
                    labelSettings.show) {
                        axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, labelSettings);
                        var dataPoints = currentSeries.data;
                        seriesLabelDataPoints = [], seriesDataPointsCandidates = [];
                        var createLabelDataPoint = function(dataPoint) {
                            if (null == dataPoint.value) return null;
                            var formatString = "";
                            formatString = dataPoint.labelFormatString;
                            var parentShape, formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties) + visuals.NewDataLabelUtils.LabelDensityPadding, textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0), isParentRect = !1;
                            if (isStackedArea) {
                                var bottomPos = Math.max(dataPoint.stackedValue - dataPoint.value, yScale.domain()[0]);
                                parentShape = {
                                    rect: {
                                        left: xScale(_this.getXValue(dataPoint)) - horizontalInnerPadding,
                                        top: yScale(Math.max(dataPoint.stackedValue, dataPoint.stackedValue - dataPoint.value)),
                                        width: bandRange + 2 * horizontalInnerPadding,
                                        height: Math.abs(yScale(dataPoint.stackedValue) - yScale(bottomPos))
                                    },
                                    orientation: dataPoint.value >= 0 ? 1 : 2,
                                    validPositions: LineChart.validStackedLabelPositions
                                }, isParentRect = !0;
                            } else parentShape = {
                                point: {
                                    x: xScale(_this.getXValue(dataPoint)) + lineshift,
                                    y: yScale(dataPoint.value)
                                },
                                radius: 0,
                                validPositions: _this.lineChartLabelDensityEnabled ? LineChart.validLabelPositions : [ 1 ]
                            };
                            var labelDataPoint = {
                                isPreferred: !1,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight
                                },
                                outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                                insideFill: labelSettings.labelColor && isStackedArea ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                                parentType: isParentRect ? 1 : 0,
                                parentShape: parentShape,
                                fontSize: labelSettings.fontSize,
                                identity: dataPoint.identity,
                                key: dataPoint.key
                            };
                            return labelDataPoint;
                        };
                        if (!_.isEmpty(dataPoints)) {
                            var categoryCount = dataPoints.length, lastDataPoint = dataPoints[categoryCount - 1], lastLabelDataPoint = createLabelDataPoint(lastDataPoint, seriesIndex);
                            lastLabelDataPoint && seriesLabelDataPoints.push(lastLabelDataPoint);
                            for (var categoryIndex = 0; categoryCount - 1 > categoryIndex; categoryIndex++) {
                                var labelDataPoint = createLabelDataPoint(dataPoints[categoryIndex], seriesIndex);
                                labelDataPoint && seriesLabelDataPoints.push(labelDataPoint);
                            }
                        }
                        var maxLabelsToRender = dataPoints.length;
                        labelDataPointsGroups[seriesIndex] = {
                            labelDataPoints: seriesLabelDataPoints,
                            maxNumberOfLabels: maxLabelsToRender
                        };
                    }
                }
                return labelDataPointsGroups;
            }, LineChart.prototype.adjustPathXCoordinate = function(x) {
                if (this.shouldAdjustMouseCoordsOnPathsForStroke) {
                    var svgNode = this.mainGraphicsSVG.node(), ratios = visuals.SVGUtil.getTransformScaleRatios(svgNode);
                    x -= powerbi.Double.equalWithPrecision(ratios.x, 1, 1e-5) ? LineChart.pathXAdjustment : LineChart.pathXAdjustment * ratios.x;
                }
                return x;
            }, LineChart.prototype.showLabelPerSeries = function() {
                var data = this.data;
                return !data.hasDynamicSeries && (data.series.length > 1 || !data.categoryMetadata);
            }, LineChart.ClassName = "lineChart", LineChart.MainGraphicsContextClassName = "mainGraphicsContext", 
            LineChart.CategorySelector = createClassAndSelector("cat"), LineChart.CategoryValuePoint = createClassAndSelector("dot"), 
            LineChart.CategoryPointSelector = createClassAndSelector("point"), LineChart.CategoryAreaSelector = createClassAndSelector("catArea"), 
            LineChart.HoverLineCircleDot = createClassAndSelector("circle-item"), LineChart.LineClassSelector = createClassAndSelector("line"), 
            LineChart.PointRadius = 5, LineChart.CircleRadius = 4, LineChart.PathElementName = "path", 
            LineChart.CircleElementName = "circle", LineChart.CircleClassName = "selection-circle", 
            LineChart.LineElementName = "line", LineChart.RectOverlayName = "rect", LineChart.ScalarOuterPadding = 10, 
            LineChart.interactivityStrokeWidth = 10, LineChart.pathXAdjustment = 5, LineChart.AreaFillOpacity = .4, 
            LineChart.DimmedAreaFillOpacity = .2, LineChart.validLabelPositions = [ 1, 2, 8, 4, 64, 128, 16, 32 ], 
            LineChart.validStackedLabelPositions = [ 1, 4, 2 ], LineChart;
        }();
        visuals.LineChart = LineChart;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var Color = jsCommon.Color, PixelConverter = jsCommon.PixelConverter, Polygon = visuals.shapes.Polygon, DataRoleHelper = powerbi.data.DataRoleHelper;
        visuals.MaxLevelOfDetail = 23, visuals.MinLevelOfDetail = 1, visuals.DefaultFillOpacity = .5, 
        visuals.DefaultBackgroundColor = "#000000", visuals.LeaderLineColor = "#000000";
        var MapBubbleDataPointRenderer = function() {
            function MapBubbleDataPointRenderer(tooltipsEnabled) {
                this.tooltipsEnabled = tooltipsEnabled;
            }
            return MapBubbleDataPointRenderer.prototype.init = function(mapControl, mapDiv, addClearCatcher) {
                this.mapControl = mapControl, this.root = mapDiv;
                var root = d3.select(mapDiv[0]);
                root.attr("drag-resize-disabled", "true");
                var svg = this.svg = root.append("svg").style("position", "absolute").style("pointer-events", "none");
                if (addClearCatcher) {
                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement()).append("svg").style("position", "absolute");
                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                }
                this.bubbleGraphicsContext = svg.append("g").classed("mapBubbles", !0), this.sliceGraphicsContext = svg.append("g").classed("mapSlices", !0), 
                this.labelBackgroundGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass["class"], !0), 
                this.labelGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                this.sliceLayout = d3.layout.pie().sort(null).value(function(d) {
                    return d.value;
                }), this.arc = d3.svg.arc(), this.clearMaxDataPointRadius(), this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
            }, MapBubbleDataPointRenderer.prototype.setData = function(data) {
                this.mapData = data;
            }, MapBubbleDataPointRenderer.prototype.clearDataPoints = function() {
                this.mapData = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: !1,
                    hasSize: !1
                };
            }, MapBubbleDataPointRenderer.prototype.getDataPointCount = function() {
                return this.mapData ? _.filter(this.mapData.dataPoints, function(value) {
                    return !!value.location;
                }).length : 0;
            }, MapBubbleDataPointRenderer.prototype.getDataPointPadding = function() {
                return 2 * this.maxDataPointRadius;
            }, MapBubbleDataPointRenderer.prototype.clearMaxDataPointRadius = function() {
                this.maxDataPointRadius = 0;
            }, MapBubbleDataPointRenderer.prototype.setMaxDataPointRadius = function(dataPointRadius) {
                this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
            }, MapBubbleDataPointRenderer.prototype.getDefaultMap = function(geocodingCategory, dataPointCount) {
                this.clearDataPoints();
            }, MapBubbleDataPointRenderer.prototype.converter = function(viewport, dataView, labelSettings, interactivityService, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var mapControl = this.mapControl, widthOverTwo = viewport.width / 2, heightOverTwo = viewport.height / 2, strokeWidth = 1;
                this.dataLabelsSettings = labelSettings;
                var radiusScale = Math.min(viewport.width, viewport.height) / 384;
                this.clearMaxDataPointRadius();
                var grouped, dataValuesSource, bubbleData = [], sliceData = [], categorical = dataView ? dataView.categorical : null, sizeIndex = -1;
                categorical && categorical.values && (grouped = categorical.values.grouped(), sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), 
                dataValuesSource = categorical.values.source);
                for (var dataPoints = this.mapData ? this.mapData.dataPoints : [], hasSize = this.mapData.hasSize, categoryIndex = 0, categoryCount = dataPoints.length; categoryCount > categoryIndex; categoryIndex++) {
                    var dataPoint = dataPoints[categoryIndex], categoryValue = dataPoint.categoryValue, location_2 = dataPoint.location;
                    if (location_2) {
                        var xy = mapControl.tryLocationToPixel(new Microsoft.Maps.Location(location_2.latitude, location_2.longitude)), x = xy.x + widthOverTwo, y = xy.y + heightOverTwo, radius = dataPoint.radius * radiusScale;
                        this.setMaxDataPointRadius(radius);
                        var subDataPoints = dataPoint.subDataPoints, seriesCount = subDataPoints.length;
                        if (1 === seriesCount) {
                            var subDataPoint = subDataPoints[0];
                            bubbleData.push({
                                x: x,
                                y: y,
                                labeltext: categoryValue,
                                radius: radius,
                                fill: subDataPoint.fill,
                                stroke: subDataPoint.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: subDataPoint.tooltipInfo,
                                identity: subDataPoint.identity,
                                selected: !1,
                                labelFill: labelSettings.labelColor
                            });
                        } else {
                            for (var slices = [], seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                                var subDataPoint = subDataPoints[seriesIndex], value = hasSize ? subDataPoint.value : 1;
                                slices.push({
                                    x: x,
                                    y: y,
                                    labeltext: categoryValue,
                                    radius: radius,
                                    fill: subDataPoint.fill,
                                    stroke: subDataPoint.stroke,
                                    strokeWidth: strokeWidth,
                                    value: value,
                                    tooltipInfo: subDataPoint.tooltipInfo,
                                    identity: subDataPoint.identity,
                                    selected: !1,
                                    labelFill: labelSettings.labelColor
                                });
                            }
                            interactivityService && interactivityService.applySelectionStateToData(slices), 
                            sliceData.push(slices);
                        }
                    }
                }
                return interactivityService && interactivityService.applySelectionStateToData(bubbleData), 
                {
                    bubbleData: bubbleData,
                    sliceData: sliceData
                };
            }, MapBubbleDataPointRenderer.prototype.updateInternal = function(data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                Map.removeTransform3d(this.root), this.mapRendererData = data, this.svg && this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                this.clearSvg && this.clearSvg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px");
                var arc = this.arc, hasSelection = interactivityService && interactivityService.hasSelection(), bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function(d) {
                    return d.identity.getKey();
                });
                bubbles.enter().append("circle").classed("bubble", !0), bubbles.attr("cx", function(d) {
                    return d.x;
                }).attr("cy", function(d) {
                    return d.y;
                }).attr("r", function(d) {
                    return d.radius;
                }).style("fill", function(d) {
                    return d.fill;
                }).style("stroke", function(d) {
                    return d.stroke;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                }).style("strokeWidth", function(d) {
                    return d.strokeWidth;
                }).style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                }).style("cursor", "default"), bubbles.exit().remove(), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(bubbles, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                }), bubbles.style("pointer-events", "all"));
                var sliceData = data.sliceData, sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
                sliceContainers.enter().append("g").classed("sliceContainer", !0), sliceContainers.exit().remove();
                var sliceLayout = this.sliceLayout, slices = sliceContainers.selectAll(".slice").data(function(d) {
                    return sliceLayout(d);
                }, function(d) {
                    return d.data.identity.getKey();
                });
                slices.enter().append("path").classed("slice", !0), slices.style("fill", function(t) {
                    return t.data.fill;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                }).style("stroke", function(t) {
                    return t.data.stroke;
                }).style("strokeWidth", function(t) {
                    return t.data.strokeWidth;
                }).style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                }).style("cursor", "default").attr("transform", function(t) {
                    return visuals.SVGUtil.translate(t.data.x, t.data.y);
                }).attr("d", function(t) {
                    return arc.innerRadius(0).outerRadius(function(t) {
                        return t.data.radius;
                    })(t);
                }), slices.exit().remove(), this.updateInternalDataLabels(viewport, redrawDataLabels), 
                this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(slices, function(tooltipEvent) {
                    return tooltipEvent.data.data.tooltipInfo;
                }), slices.style("pointer-events", "all"));
                for (var allData = data.bubbleData.slice(), i = 0, ilen = sliceData.length; ilen > i; i++) allData.push.apply(allData, sliceData[i]);
                var behaviorOptions = {
                    bubbles: bubbles,
                    slices: this.sliceGraphicsContext.selectAll("path"),
                    clearCatcher: this.clearCatcher,
                    dataPoints: allData
                };
                return behaviorOptions;
            }, MapBubbleDataPointRenderer.prototype.updateInternalDataLabels = function(viewport, redrawDataLabels) {
                var labelSettings = this.dataLabelsSettings, dataLabels = [];
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints(), labelLayout = new powerbi.LabelLayout({
                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                    }), labelDataPointsGroup = {
                        labelDataPoints: labelDataPoints,
                        maxNumberOfLabels: labelDataPoints.length
                    };
                    dataLabels = labelLayout.layout([ labelDataPointsGroup ], {
                        width: viewport.width,
                        height: viewport.height
                    });
                }
                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, dataLabels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity), 
                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, dataLabels, !1);
            }, MapBubbleDataPointRenderer.prototype.createLabelDataPoints = function() {
                var data = this.mapRendererData, labelDataPoints = [], dataPoints = data.bubbleData;
                dataPoints = dataPoints.concat(_.map(data.sliceData, function(value) {
                    return value[0];
                }));
                for (var labelSettings = this.dataLabelsSettings, _i = 0, dataPoints_3 = dataPoints; _i < dataPoints_3.length; _i++) {
                    var dataPoint = dataPoints_3[_i], text = dataPoint.labeltext, properties = {
                        text: text,
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                    }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    labelDataPoints.push({
                        isPreferred: !0,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight
                        },
                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 0,
                        parentShape: {
                            point: {
                                x: dataPoint.x,
                                y: dataPoint.y
                            },
                            radius: dataPoint.radius,
                            validPositions: MapBubbleDataPointRenderer.validLabelPositions
                        },
                        fontSize: labelSettings.fontSize,
                        identity: void 0,
                        hasBackground: !0
                    });
                }
                return labelDataPoints;
            }, MapBubbleDataPointRenderer.validLabelPositions = [ 1, 2, 4, 8 ], MapBubbleDataPointRenderer;
        }();
        visuals.MapBubbleDataPointRenderer = MapBubbleDataPointRenderer;
        var MapShapeDataPointRenderer = function() {
            function MapShapeDataPointRenderer(fillMapDataLabelsEnabled, tooltipsEnabled) {
                this.filledMapDataLabelsEnabled = fillMapDataLabelsEnabled, this.tooltipsEnabled = tooltipsEnabled;
            }
            return MapShapeDataPointRenderer.getFilledMapParams = function(category, dataCount) {
                switch (category) {
                  case visuals.MapUtil.CategoryTypes.Continent:
                  case visuals.MapUtil.CategoryTypes.CountryRegion:
                    return 10 > dataCount ? {
                        level: 2,
                        maxPolygons: 50,
                        strokeWidth: 0
                    } : 30 > dataCount ? {
                        level: 2,
                        maxPolygons: 20,
                        strokeWidth: 0
                    } : {
                        level: 1,
                        maxPolygons: 3,
                        strokeWidth: 0
                    };

                  default:
                    return 100 > dataCount ? {
                        level: 1,
                        maxPolygons: 5,
                        strokeWidth: 6
                    } : 200 > dataCount ? {
                        level: 0,
                        maxPolygons: 5,
                        strokeWidth: 6
                    } : {
                        level: 0,
                        maxPolygons: 5,
                        strokeWidth: 0
                    };
                }
            }, MapShapeDataPointRenderer.buildPaths = function(locations) {
                for (var paths = [], i = 0; i < locations.length; i++) {
                    var location_3 = locations[i], polygon = location_3.geographic;
                    polygon.length > 2 && paths.push(location_3);
                }
                return paths;
            }, MapShapeDataPointRenderer.prototype.init = function(mapControl, mapDiv, addClearCatcher) {
                this.mapControl = mapControl, this.polygonInfo = new visuals.MapPolygonInfo(), this.root = mapDiv;
                var root = d3.select(mapDiv[0]);
                root.attr("drag-resize-disabled", "true");
                var svg = this.svg = root.append("svg").style("position", "absolute").style("pointer-events", "none");
                if (addClearCatcher) {
                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement()).append("svg").style("position", "absolute");
                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                }
                this.shapeGraphicsContext = svg.append("g").classed("mapShapes", !0), this.labelBackgroundGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass["class"], !0), 
                this.labelGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                this.clearMaxShapeDimension(), this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
            }, MapShapeDataPointRenderer.prototype.setData = function(data) {
                this.mapData = data;
            }, MapShapeDataPointRenderer.prototype.clearDataPoints = function() {
                this.mapData = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: !1,
                    hasSize: !1
                };
            }, MapShapeDataPointRenderer.prototype.getDataPointCount = function() {
                return this.mapData ? _.filter(this.mapData.dataPoints, function(value) {
                    return !!value.paths;
                }).length : 0;
            }, MapShapeDataPointRenderer.prototype.converter = function(viewport, dataView, labelSettings, interactivityService) {
                this.clearMaxShapeDimension(), this.dataLabelsSettings = labelSettings;
                for (var strokeWidth = 1, shapeData = [], dataPoints = this.mapData ? this.mapData.dataPoints : [], categoryIndex = 0, categoryCount = dataPoints.length; categoryCount > categoryIndex; categoryIndex++) {
                    var categorical = dataView ? dataView.categorical : null, dataPoint = dataPoints[categoryIndex], subDataPoint = dataPoint.subDataPoints[0], paths = dataPoint.paths, grouped = void 0, sizeIndex = -1, dataValuesSource = void 0;
                    if (categorical && categorical.values && (grouped = categorical.values.grouped(), 
                    sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), dataValuesSource = categorical.values.source), 
                    paths) for (var value = dataPoint.value, categoryValue = dataPoint.categoryValue, identity = subDataPoint.identity, idKey = identity.getKey(), formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), mainShapeIndex = MapShapeDataPointRenderer.getIndexOfLargestShape(paths), pathIndex = 0, pathCount = paths.length; pathCount > pathIndex; pathIndex++) {
                        var path = paths[pathIndex], labelFormatString = dataView && dataView.categorical && !_.isEmpty(dataView.categorical.values) ? visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, visuals.filledMapProps.general.formatString) : void 0;
                        this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
                        var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings);
                        shapeData.push({
                            absolutePointArray: path.absolute,
                            path: path.absoluteString,
                            fill: subDataPoint.fill,
                            stroke: subDataPoint.stroke,
                            strokeWidth: strokeWidth,
                            tooltipInfo: subDataPoint.tooltipInfo,
                            identity: identity,
                            selected: !1,
                            key: JSON.stringify({
                                id: idKey,
                                pIdx: pathIndex
                            }),
                            displayLabel: pathIndex === mainShapeIndex,
                            labeltext: categoryValue,
                            catagoryLabeltext: null != value ? visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(value)) : void 0,
                            labelFormatString: labelFormatString
                        });
                    }
                }
                return interactivityService && interactivityService.applySelectionStateToData(shapeData), 
                {
                    shapeData: shapeData
                };
            }, MapShapeDataPointRenderer.prototype.updateInternal = function(data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                Map.removeTransform3d(this.root), this.mapRendererData = data, this.svg && this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                this.clearSvg && this.clearSvg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height), this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));
                var hasSelection = interactivityService && interactivityService.hasSelection(), shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, function(d) {
                    return d.key;
                });
                shapes.enter().append("polygon").classed("shape", !0).attr("points", function(d) {
                    return d.path;
                }), shapes.style("fill", function(d) {
                    return d.fill;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                }).style("cursor", "default"), dataChanged && shapes.attr("points", function(d) {
                    return d.path;
                }), shapes.exit().remove(), this.updateInternalDataLabels(viewport, redrawDataLabels), 
                this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                }), shapes.style("pointer-events", "all"));
                var behaviorOptions = {
                    shapes: shapes,
                    clearCatcher: this.clearCatcher,
                    dataPoints: data.shapeData
                };
                return behaviorOptions;
            }, MapShapeDataPointRenderer.prototype.getDataPointPadding = function() {
                return 12;
            }, MapShapeDataPointRenderer.getIndexOfLargestShape = function(paths) {
                for (var largestShapeIndex = 0, largestShapeArea = 0, pathIndex = 0, pathCount = paths.length; pathCount > pathIndex; pathIndex++) {
                    var path = paths[pathIndex], polygon = new Polygon(path.absolute), currentShapeArea = Math.abs(Polygon.calculateAbsolutePolygonArea(polygon.polygonPoints));
                    currentShapeArea > largestShapeArea && (largestShapeIndex = pathIndex, largestShapeArea = currentShapeArea);
                }
                return largestShapeIndex;
            }, MapShapeDataPointRenderer.prototype.updateInternalDataLabels = function(viewport, redrawDataLabels) {
                var labels, labelSettings = this.dataLabelsSettings;
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints();
                    void 0 === this.labelLayout && (this.labelLayout = new powerbi.FilledMapLabelLayout()), 
                    labels = this.labelLayout.layout(labelDataPoints, {
                        width: viewport.width,
                        height: viewport.height
                    }, this.polygonInfo.transform, redrawDataLabels);
                }
                this.drawLabelStems(this.labelGraphicsContext, labels, labelSettings.show, labelSettings.showCategory), 
                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, labels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity), 
                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, !1, labelSettings.show && labelSettings.showCategory);
            }, MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function() {
                this.maxShapeDimension = 0;
            }, MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function(width, height) {
                this.maxShapeDimension = Math.max(width, this.maxShapeDimension), this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
            }, MapShapeDataPointRenderer.prototype.createLabelDataPoints = function() {
                var data = this.mapRendererData, labelDataPoints = [];
                if (this.filledMapDataLabelsEnabled) for (var dataShapes = data.shapeData, labelSettings = this.dataLabelsSettings, _i = 0, dataShapes_1 = dataShapes; _i < dataShapes_1.length; _i++) {
                    var dataShape = dataShapes_1[_i];
                    if (dataShape.displayLabel) {
                        var text = void 0, secondRowText = void 0, secondRowTextWidth = 0, hasSecondRow = !1;
                        if (this.dataLabelsSettings.show && !this.dataLabelsSettings.showCategory) {
                            if (text = dataShape.catagoryLabeltext, void 0 === text) continue;
                        } else if (this.dataLabelsSettings.showCategory && !this.dataLabelsSettings.show) {
                            if (text = dataShape.labeltext, void 0 === text) continue;
                        } else if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show) {
                            if (text = dataShape.catagoryLabeltext, secondRowText = dataShape.labeltext, void 0 === text && void 0 === secondRowText) continue;
                            hasSecondRow = !0;
                        }
                        if (hasSecondRow) {
                            var secondRowProperties = {
                                text: secondRowText,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            };
                            secondRowTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(secondRowProperties);
                        }
                        var firstRowProperties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                        }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(firstRowProperties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(firstRowProperties);
                        secondRowText && void 0 !== dataShape.labeltext && void 0 !== dataShape.catagoryLabeltext && (textHeight = 2 * textHeight);
                        var labelDataPoint = {
                            parentType: 2,
                            parentShape: {
                                polygon: new Polygon(dataShape.absolutePointArray),
                                validPositions: MapShapeDataPointRenderer.validLabelPolygonPositions
                            },
                            text: text,
                            secondRowText: secondRowText,
                            textSize: {
                                width: Math.max(textWidth, secondRowTextWidth),
                                height: textHeight
                            },
                            insideFill: labelSettings.labelColor,
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            isPreferred: !1,
                            identity: void 0,
                            hasBackground: !0
                        };
                        labelDataPoints.push(labelDataPoint);
                    }
                }
                return labelDataPoints;
            }, MapShapeDataPointRenderer.prototype.drawLabelStems = function(labelsContext, dataLabels, showText, showCategory) {
                var filteredLabels = _.filter(dataLabels, function(d) {
                    return d.isVisible;
                }), key = function(d, index) {
                    return d.identity ? d.identity.getKeyWithoutHighlight() : index;
                };
                visuals.NewDataLabelUtils.drawLabelLeaderLines(labelsContext, filteredLabels, key, visuals.LeaderLineColor);
            }, MapShapeDataPointRenderer.validLabelPolygonPositions = [ 256, 2, 1, 8, 4, 16, 32, 64, 128 ], 
            MapShapeDataPointRenderer;
        }();
        visuals.MapShapeDataPointRenderer = MapShapeDataPointRenderer;
        var DefaultLocationZoomLevel = 11, Map = function() {
            function Map(options) {
                this.receivedExternalViewChange = !1, this.executingInternalViewChange = !1, options.filledMap ? (this.dataPointRenderer = new MapShapeDataPointRenderer(options.filledMapDataLabelsEnabled, options.tooltipsEnabled), 
                this.filledMapDataLabelsEnabled = options.filledMapDataLabelsEnabled, this.enableGeoShaping = !0) : (this.dataPointRenderer = new MapBubbleDataPointRenderer(options.tooltipsEnabled), 
                this.enableGeoShaping = !1), this.mapControlFactory = options.mapControlFactory ? options.mapControlFactory : this.getDefaultMapControlFactory(), 
                this.behavior = options.behavior, this.tooltipsEnabled = options.tooltipsEnabled, 
                this.disableZooming = options.disableZooming, this.disablePanning = options.disablePanning, 
                this.isLegendScrollable = !!options.behavior, this.viewChangeThrottleInterval = options.viewChangeThrottleInterval, 
                this.enableCurrentLocation = options.enableCurrentLocation;
            }
            return Map.prototype.init = function(options) {
                var _this = this, element = this.element = options.element;
                this.pendingGeocodingRender = !1, this.currentViewport = options.viewport, this.style = options.style, 
                this.colors = this.style.colorPalette.dataColors, this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings(), this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isLegendScrollable), 
                this.legendHeight = 0, this.legendData = {
                    dataPoints: []
                }, this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString), 
                this.host = options.host, options.host.locale && (this.locale = options.host.locale()), 
                this.geocoder = options.host.geocoder(), this.resetBounds(), this.mapControlFactory.ensureMap(this.locale, function() {
                    Microsoft.Maps.loadModule("Microsoft.Maps.Overlays.Style", {
                        callback: function() {
                            _this.initialize(element[0]), _this.enableCurrentLocation && _this.createCurrentLocation(element);
                        }
                    });
                });
            }, Map.prototype.createCurrentLocation = function(element) {
                var pushpin, _this = this, myLocBtn = InJs.DomFactory.div().addClass("mapCurrentLocation").appendTo(element);
                myLocBtn.on("click", function() {
                    _this.isCurrentLocation ? (pushpin && _this.mapControl.entities.remove(pushpin), 
                    _this.updateInternal(!1, !1), _this.isCurrentLocation = !1) : _this.host.geolocation().getCurrentPosition(function(position) {
                        var location = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude);
                        pushpin && _this.mapControl.entities.remove(pushpin), pushpin = visuals.MapUtil.CurrentLocation.createPushpin(location), 
                        _this.mapControl.entities.push(pushpin), _this.updateMapView(location, DefaultLocationZoomLevel), 
                        _this.isCurrentLocation = !0;
                    });
                });
            }, Map.prototype.addDataPoint = function(dataPoint) {
                var location = dataPoint.location;
                this.updateBounds(location.latitude, location.longitude), this.scheduleRedraw();
            }, Map.prototype.scheduleRedraw = function() {
                var _this = this;
                !this.pendingGeocodingRender && this.mapControl && (this.pendingGeocodingRender = !0, 
                setTimeout(function() {
                    _this.updateInternal(!0, !0), _this.pendingGeocodingRender = !1;
                }, 3e3));
            }, Map.prototype.enqueueGeoCode = function(dataPoint) {
                var _this = this;
                this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function(location) {
                    location && (dataPoint.location = location, _this.addDataPoint(dataPoint));
                });
            }, Map.prototype.enqueueGeoCodeAndGeoShape = function(dataPoint, params) {
                var _this = this;
                this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function(location) {
                    location && (dataPoint.location = location, _this.enqueueGeoShape(dataPoint, params));
                });
            }, Map.prototype.enqueueGeoShape = function(dataPoint, params) {
                var _this = this;
                this.geocoder.geocodeBoundary(dataPoint.location.latitude, dataPoint.location.longitude, this.geocodingCategory, params.level, params.maxPolygons).then(function(result) {
                    var paths;
                    0 === result.locations.length || result.locations[0].geographic ? paths = MapShapeDataPointRenderer.buildPaths(result.locations) : (visuals.MapUtil.calcGeoData(result), 
                    paths = MapShapeDataPointRenderer.buildPaths(result.locations)), dataPoint.paths = paths, 
                    _this.addDataPoint(dataPoint);
                });
            }, Map.prototype.getOptimumLevelOfDetail = function(width, height) {
                var dataPointCount = this.dataPointRenderer.getDataPointCount();
                if (0 === dataPointCount) return visuals.MapUtil.MinLevelOfDetail;
                for (var threshold = this.dataPointRenderer.getDataPointPadding(), levelOfDetail = visuals.MapUtil.MaxLevelOfDetail; levelOfDetail >= visuals.MapUtil.MinLevelOfDetail; levelOfDetail--) {
                    var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail), maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                    if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) return 2 > dataPointCount && (levelOfDetail = Math.min(visuals.MapUtil.MaxAutoZoomLevel, levelOfDetail)), 
                    levelOfDetail;
                }
                return visuals.MapUtil.MinLevelOfDetail;
            }, Map.prototype.getViewCenter = function(levelOfDetail) {
                var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail), maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                return visuals.MapUtil.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2, (maxXminY.y + minXmaxY.y) / 2, levelOfDetail);
            }, Map.prototype.resetBounds = function() {
                this.minLongitude = visuals.MapUtil.MaxAllowedLongitude, this.maxLongitude = visuals.MapUtil.MinAllowedLongitude, 
                this.minLatitude = visuals.MapUtil.MaxAllowedLatitude, this.maxLatitude = visuals.MapUtil.MinAllowedLatitude;
            }, Map.prototype.updateBounds = function(latitude, longitude) {
                longitude < this.minLongitude && (this.minLongitude = longitude), longitude > this.maxLongitude && (this.maxLongitude = longitude), 
                latitude < this.minLatitude && (this.minLatitude = latitude), latitude > this.maxLatitude && (this.maxLatitude = latitude);
            }, Map.legendObject = function(dataView) {
                return dataView && dataView.metadata && dataView.metadata.objects && dataView.metadata.objects.legend;
            }, Map.isLegendHidden = function(dataView) {
                var legendObject = Map.legendObject(dataView);
                return null != legendObject && legendObject[visuals.legendProps.show] === !1;
            }, Map.legendPosition = function(dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && visuals.LegendPosition[legendObject[visuals.legendProps.position]];
            }, Map.getLegendFontSize = function(dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && legendObject[visuals.legendProps.fontSize] || visuals.SVGLegend.DefaultFontSizeInPt;
            }, Map.isShowLegendTitle = function(dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && legendObject[visuals.legendProps.showTitle];
            }, Map.prototype.legendTitle = function() {
                var legendObject = Map.legendObject(this.dataView);
                return legendObject && legendObject[visuals.legendProps.titleText] || this.legendData.title;
            }, Map.prototype.renderLegend = function(legendData) {
                var hideLegend = Map.isLegendHidden(this.dataView), showTitle = Map.isShowLegendTitle(this.dataView), title = this.legendTitle(), clonedLegendData = {
                    dataPoints: hideLegend ? [] : legendData.dataPoints,
                    grouped: legendData.grouped,
                    title: showTitle ? title : "",
                    fontSize: Map.getLegendFontSize(this.dataView)
                }, targetOrientation = Map.legendPosition(this.dataView);
                void 0 !== targetOrientation ? this.legend.changeOrientation(targetOrientation) : this.legend.changeOrientation(visuals.LegendPosition.Top), 
                this.legend.drawLegend(clonedLegendData, this.currentViewport);
            }, Map.calculateGroupSizes = function(categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
                for (var categoryCount = categorical.values[0].values.length, seriesCount = grouped.length, i = 0, len = categoryCount; len > i; ++i) {
                    var groupTotal = null;
                    if (sizeMeasureIndex >= 0) for (var j = 0; seriesCount > j; ++j) {
                        var value = grouped[j].values[sizeMeasureIndex].values[i];
                        value && (null === groupTotal ? groupTotal = value : groupTotal += value);
                    }
                    groupSizeTotals.push(groupTotal), groupTotal && (currentValueScale ? (currentValueScale.min = Math.min(currentValueScale.min, groupTotal), 
                    currentValueScale.max = Math.max(currentValueScale.max, groupTotal)) : currentValueScale = {
                        min: groupTotal,
                        max: groupTotal
                    });
                }
                return currentValueScale;
            }, Map.calculateRadius = function(range, value) {
                var rangeDiff = range ? range.max - range.min : 0, radius = 6;
                return null != range && null != value && 0 !== rangeDiff && (radius = 14 * ((value - range.min) / rangeDiff) + 6), 
                radius;
            }, Map.getGeocodingCategory = function(categorical, geoTaggingAnalyzerService) {
                if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
                    var type = categorical.categories[0].source.type;
                    if (type && type.categoryString) return geoTaggingAnalyzerService.getFieldType(type.categoryString);
                    var categoryName = categorical.categories[0].source.displayName, geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
                    if (geotaggedResult) return geotaggedResult;
                    var roles = categorical.categories[0].source.roles;
                    if (roles) for (var roleNames = Object.keys(roles), i = 0, len = roleNames.length; len > i; ++i) {
                        var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                        if (typeFromRoleName) return typeFromRoleName;
                    }
                }
            }, Map.hasSizeField = function(values, defaultIndexIfNoRole) {
                if (_.isEmpty(values)) return !1;
                for (var i = 0, ilen = values.length; ilen > i; i++) {
                    var roles = values[i].source.roles;
                    if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric) return !0;
                    if (roles) for (var roleNames = Object.keys(roles), j = 0, jlen = roleNames.length; jlen > j; j++) {
                        var role = roleNames[j];
                        if ("Size" === role) return !0;
                    }
                }
                return !1;
            }, Map.shouldEnumerateDataPoints = function(dataView, usesSizeForGradient) {
                var hasSeries = DataRoleHelper.hasRoleInDataView(dataView, "Series"), gradientRole = usesSizeForGradient ? "Size" : "Gradient", hasGradientRole = DataRoleHelper.hasRoleInDataView(dataView, gradientRole);
                return hasSeries || !hasGradientRole;
            }, Map.shouldEnumerateCategoryLabels = function(enableGeoShaping, filledMapDataLabelsEnabled) {
                return !enableGeoShaping || filledMapDataLabelsEnabled;
            }, Map.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                  case "dataPoint":
                    if (Map.shouldEnumerateDataPoints(this.dataView, this.enableGeoShaping)) {
                        var bubbleData = [], hasDynamicSeries = this.hasDynamicSeries;
                        if (!hasDynamicSeries) {
                            var mapData = this.dataPointRenderer.converter(this.getMapViewPort(), this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
                            bubbleData = mapData.bubbleData;
                        }
                        Map.enumerateDataPoints(enumeration, this.dataPointsToEnumerate, this.colors, hasDynamicSeries, this.defaultDataPointColor, this.showAllDataPoints, bubbleData);
                    }
                    break;

                  case "categoryLabels":
                    Map.shouldEnumerateCategoryLabels(this.enableGeoShaping, this.filledMapDataLabelsEnabled) && visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.dataLabelsSettings, !0, !0);
                    break;

                  case "legend":
                    this.hasDynamicSeries && Map.enumerateLegend(enumeration, this.dataView, this.legend, this.legendTitle());
                    break;

                  case "labels":
                    if (this.filledMapDataLabelsEnabled) {
                        this.dataLabelsSettings = this.dataLabelsSettings ? this.dataLabelsSettings : visuals.dataLabelUtils.getDefaultMapLabelSettings();
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: this.dataLabelsSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                    }
                }
                return enumeration.complete();
            }, Map.enumerateDataPoints = function(enumeration, dataPoints, colors, hasDynamicSeries, defaultDataPointColor, showAllDataPoints, bubbleData) {
                var seriesLength = dataPoints && dataPoints.length;
                if (hasDynamicSeries) for (var i = 0; seriesLength > i; i++) {
                    var dataPoint = dataPoints[i];
                    enumeration.pushInstance({
                        objectName: "dataPoint",
                        displayName: dataPoint.label,
                        selector: dataPoint.identity.getSelector(),
                        properties: {
                            fill: {
                                solid: {
                                    color: dataPoint.color
                                }
                            }
                        }
                    });
                } else if (enumeration.pushInstance({
                    objectName: "dataPoint",
                    selector: null,
                    properties: {
                        defaultColor: {
                            solid: {
                                color: defaultDataPointColor || colors.getColorByIndex(0).value
                            }
                        }
                    }
                }).pushInstance({
                    objectName: "dataPoint",
                    selector: null,
                    properties: {
                        showAllDataPoints: !!showAllDataPoints
                    }
                }), bubbleData) for (var i = 0; i < bubbleData.length; i++) {
                    var bubbleDataPoint = bubbleData[i];
                    enumeration.pushInstance({
                        objectName: "dataPoint",
                        displayName: bubbleDataPoint.labeltext,
                        selector: bubbleDataPoint.identity.getSelector(),
                        properties: {
                            fill: {
                                solid: {
                                    color: Color.normalizeToHexString(bubbleDataPoint.fill)
                                }
                            }
                        }
                    });
                }
            }, Map.enumerateLegend = function(enumeration, dataView, legend, legendTitle) {
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: !Map.isLegendHidden(dataView),
                        position: visuals.LegendPosition[legend.getOrientation()],
                        showTitle: Map.isShowLegendTitle(dataView),
                        titleText: legendTitle,
                        fontSize: Map.getLegendFontSize(dataView)
                    },
                    objectName: "legend"
                });
            }, Map.prototype.onDataChanged = function(options) {
                var _this = this;
                this.resetBounds(), this.receivedExternalViewChange = !1, this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings(), 
                this.defaultDataPointColor = null, this.showAllDataPoints = null;
                var dataView = this.dataView = options.dataViews[0], enableGeoShaping = this.enableGeoShaping, warnings = [], data = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: !1,
                    hasSize: !1
                };
                if (dataView) {
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        if (this.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.mapProps.dataPoint.defaultColor), 
                        this.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.mapProps.dataPoint.showAllDataPoints), 
                        this.dataLabelsSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.categoryLabels.show, this.dataLabelsSettings.showCategory), 
                        enableGeoShaping) {
                            this.dataLabelsSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelPrecision, this.dataLabelsSettings.precision), 
                            this.dataLabelsSettings.precision = this.dataLabelsSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && this.dataLabelsSettings.precision < 0 ? 0 : this.dataLabelsSettings.precision, 
                            this.dataLabelsSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelDisplayUnits, this.dataLabelsSettings.displayUnits);
                            var datalabelsObj = objects.labels;
                            datalabelsObj && (this.dataLabelsSettings.show = void 0 !== datalabelsObj.show ? datalabelsObj.show : this.dataLabelsSettings.show, 
                            void 0 !== datalabelsObj.color && (this.dataLabelsSettings.labelColor = datalabelsObj.color.solid.color));
                        } else {
                            var categoryLabelsObj = objects.categoryLabels;
                            categoryLabelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelsObj, this.dataLabelsSettings);
                        }
                    }
                    var colorHelper = new visuals.ColorHelper(this.colors, visuals.mapProps.dataPoint.fill, this.defaultDataPointColor);
                    data = Map.converter(dataView, colorHelper, this.geoTaggingAnalyzerService), this.hasDynamicSeries = data.hasDynamicSeries, 
                    this.legendData = Map.createLegendData(dataView, colorHelper), this.dataPointsToEnumerate = this.legendData.dataPoints, 
                    this.renderLegend(this.legendData), null != data ? (this.geocodingCategory = data.geocodingCategory, 
                    this.mapControlFactory.ensureMap(this.locale, function() {
                        var params;
                        enableGeoShaping && (params = MapShapeDataPointRenderer.getFilledMapParams(_this.geocodingCategory, data.dataPoints.length));
                        for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                            var dataPoint = _a[_i];
                            dataPoint.location ? enableGeoShaping && !dataPoint.paths ? _this.enqueueGeoShape(dataPoint, params) : _this.addDataPoint(dataPoint) : _.isEmpty(dataPoint.categoryValue) || (enableGeoShaping ? _this.enqueueGeoCodeAndGeoShape(dataPoint, params) : _this.enqueueGeoCode(dataPoint));
                        }
                    })) : this.clearDataPoints(), enableGeoShaping && (this.geocodingCategory && this.geoTaggingAnalyzerService.isGeoshapable(this.geocodingCategory) || warnings.push(new visuals.FilledMapWithoutValidGeotagCategoryWarning()));
                } else this.clearDataPoints(), this.renderLegend({
                    dataPoints: [],
                    title: void 0
                }), this.dataPointsToEnumerate = [];
                _.isEmpty(warnings) || this.host.setWarnings(warnings), this.dataPointRenderer.setData(data), 
                this.updateInternal(!0, !0);
            }, Map.converter = function(dataView, colorHelper, geoTaggingAnalyzerService) {
                var reader = powerbi.data.createIDataViewCategoricalReader(dataView), dataPoints = [], hasDynamicSeries = reader.hasDynamicSeries(), seriesColumnIdentifier = reader.getSeriesColumnIdentityFields(), sizeQueryName = reader.getMeasureQueryName("Size");
                null == sizeQueryName && (sizeQueryName = "");
                var hasSize = reader.hasValues("Size"), geocodingCategory = null, formatStringProp = visuals.mapProps.general.formatString;
                if (reader.hasCategories()) {
                    var categoryTotals = [], categoryTotalRange = void 0;
                    if (hasSize) {
                        for (var categoryMin = void 0, categoryMax = void 0, categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryCount > categoryIndex; categoryIndex++) {
                            for (var categoryTotal = 0, seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesCount > seriesIndex; seriesIndex++) categoryTotal += reader.getValue("Size", categoryIndex, seriesIndex);
                            categoryTotals.push(categoryTotal), (void 0 === categoryMin || categoryMin > categoryTotal) && (categoryMin = categoryTotal), 
                            (void 0 === categoryMax || categoryTotal > categoryMax) && (categoryMax = categoryTotal);
                        }
                        categoryTotalRange = void 0 !== categoryMin && void 0 !== categoryMax ? {
                            max: categoryMax,
                            min: categoryMin
                        } : void 0;
                    }
                    var hasLatLongGroup = reader.hasCompositeCategories() && reader.hasCategoryWithRole("X") && reader.hasCategoryWithRole("Y"), hasCategoryGroup = reader.hasCategoryWithRole("Category");
                    if (geocodingCategory = Map.getGeocodingCategory(dataView.categorical, geoTaggingAnalyzerService), 
                    hasLatLongGroup || hasCategoryGroup) for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryCount > categoryIndex; categoryIndex++) {
                        var categoryValue = void 0, categoryObjects = reader.getCategoryObjects("Category", categoryIndex), location_4 = void 0, categoryTooltipItem = void 0, latitudeTooltipItem = void 0, longitudeTooltipItem = void 0, seriesTooltipItem = void 0, sizeTooltipItem = void 0, gradientTooltipItem = void 0;
                        if (hasCategoryGroup) {
                            if (categoryValue = reader.getCategoryValue("Category", categoryIndex), categoryTooltipItem = {
                                displayName: reader.getCategoryDisplayName("Category"),
                                value: visuals.converterHelper.formatFromMetadataColumn(categoryValue, reader.getCategoryMetadataColumn("Category"), formatStringProp)
                            }, reader.hasValues("Y") && reader.hasValues("X")) {
                                var latitude = reader.getFirstNonNullValueForCategory("Y", categoryIndex), longitude = reader.getFirstNonNullValueForCategory("X", categoryIndex);
                                null != latitude && null != longitude && (location_4 = {
                                    latitude: latitude,
                                    longitude: longitude
                                }), latitudeTooltipItem = {
                                    displayName: reader.getValueDisplayName("Y"),
                                    value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getValueMetadataColumn("Y"), formatStringProp)
                                }, longitudeTooltipItem = {
                                    displayName: reader.getValueDisplayName("X"),
                                    value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getValueMetadataColumn("X"), formatStringProp)
                                };
                            }
                        } else {
                            var latitude = reader.getCategoryValue("Y", categoryIndex), longitude = reader.getCategoryValue("X", categoryIndex);
                            null != latitude && null != longitude && (categoryValue = latitude + ", " + longitude, 
                            location_4 = {
                                latitude: latitude,
                                longitude: longitude
                            }, latitudeTooltipItem = {
                                displayName: reader.getCategoryDisplayName("Y"),
                                value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getCategoryMetadataColumn("Y"), formatStringProp)
                            }, longitudeTooltipItem = {
                                displayName: reader.getCategoryDisplayName("X"),
                                value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getCategoryMetadataColumn("X"), formatStringProp)
                            });
                        }
                        var value = hasSize ? categoryTotals[categoryIndex] : void 0, subDataPoints = [], seriesCount = reader.getSeriesCount();
                        hasSize || hasDynamicSeries || (seriesCount = 1);
                        for (var seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                            var color = void 0;
                            color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, reader.getSeriesName(seriesIndex)) : reader.hasCategoryWithRole("Series") ? colorHelper.getColorForSeriesValue(reader.getCategoryObjects("Series", categoryIndex), reader.getCategoryColumnIdentityFields("Series"), categoryValue) : colorHelper.getColorForMeasure(categoryObjects, sizeQueryName);
                            var colorRgb = Color.parseColorString(color), stroke = Color.hexString(Color.darken(colorRgb, Map.StrokeDarkenColorValue));
                            colorRgb.A = .6;
                            var fill = Color.rgbString(colorRgb), identityBuilder = new visuals.SelectionIdBuilder().withCategory(reader.getCategoryColumn(hasCategoryGroup ? "Category" : "Y"), categoryIndex).withMeasure(sizeQueryName);
                            hasDynamicSeries && (identityBuilder = identityBuilder.withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex))), 
                            hasDynamicSeries && (seriesTooltipItem = {
                                displayName: reader.getSeriesDisplayName(),
                                value: visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp)
                            });
                            var subsliceValue = void 0;
                            hasSize && (subsliceValue = reader.getValue("Size", categoryIndex, seriesIndex), 
                            sizeTooltipItem = {
                                displayName: reader.getValueDisplayName("Size"),
                                value: visuals.converterHelper.formatFromMetadataColumn(subsliceValue, reader.getValueMetadataColumn("Size", seriesIndex), formatStringProp)
                            }), reader.hasValues("Gradient") && (gradientTooltipItem = {
                                displayName: reader.getValueDisplayName("Gradient"),
                                value: visuals.converterHelper.formatFromMetadataColumn(reader.getValue("Gradient", categoryIndex, seriesIndex), reader.getValueMetadataColumn("Gradient", seriesIndex), formatStringProp)
                            });
                            var tooltipInfo = [];
                            categoryTooltipItem && tooltipInfo.push(categoryTooltipItem), seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), 
                            latitudeTooltipItem && tooltipInfo.push(latitudeTooltipItem), longitudeTooltipItem && tooltipInfo.push(longitudeTooltipItem), 
                            sizeTooltipItem && tooltipInfo.push(sizeTooltipItem), gradientTooltipItem && tooltipInfo.push(gradientTooltipItem), 
                            !subsliceValue && hasSize || subDataPoints.push({
                                value: subsliceValue,
                                fill: fill,
                                stroke: stroke,
                                identity: identityBuilder.createSelectionId(),
                                tooltipInfo: tooltipInfo
                            });
                        }
                        !value && hasSize || dataPoints.push({
                            geocodingQuery: categoryValue,
                            value: value,
                            categoryValue: categoryValue,
                            subDataPoints: subDataPoints,
                            radius: Map.calculateRadius(categoryTotalRange, value),
                            location: location_4
                        });
                    }
                }
                var mapData = {
                    dataPoints: dataPoints,
                    geocodingCategory: geocodingCategory,
                    hasDynamicSeries: hasDynamicSeries,
                    hasSize: hasSize
                };
                return mapData;
            }, Map.createLegendData = function(dataView, colorHelper) {
                var legendTitle, reader = powerbi.data.createIDataViewCategoricalReader(dataView), legendDataPoints = [];
                if (reader.hasDynamicSeries()) {
                    legendTitle = reader.getSeriesDisplayName();
                    for (var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields(), seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesCount > seriesIndex; seriesIndex++) {
                        var color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, reader.getSeriesName(seriesIndex)), identity = new visuals.SelectionIdBuilder().withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex)).createSelectionId();
                        legendDataPoints.push({
                            color: color,
                            label: visuals.valueFormatter.format(reader.getSeriesName(seriesIndex)),
                            icon: visuals.LegendIcon.Circle,
                            identity: identity,
                            selected: !1
                        });
                    }
                }
                var legendData = {
                    dataPoints: legendDataPoints,
                    title: legendTitle
                };
                return legendData;
            }, Map.prototype.swapLogoContainerChildElement = function() {
                var logoContainer = this.element.find(".LogoContainer");
                if (logoContainer) {
                    var aNode = logoContainer.find("a");
                    if (null == aNode) return;
                    var divNode = $("<div>");
                    aNode.children().clone().appendTo(divNode), aNode.remove(), divNode.appendTo(logoContainer);
                }
            }, Map.prototype.onResizing = function(viewport) {
                this.currentViewport.width === viewport.width && this.currentViewport.height === viewport.height || (this.currentViewport = viewport, 
                this.renderLegend(this.legendData), this.updateInternal(!1, !1));
            }, Map.prototype.initialize = function(container) {
                var _this = this, mapOptions = {
                    credentials: visuals.MapUtil.Settings.BingKey,
                    showMapTypeSelector: !1,
                    enableClickableLogo: !1,
                    enableSearchLogo: !1,
                    mapTypeId: Microsoft.Maps.MapTypeId.road,
                    customizeOverlays: !0,
                    showDashboard: !1,
                    showScalebar: !1,
                    disableKeyboardInput: !0,
                    disableZooming: this.disableZooming,
                    disablePanning: this.disablePanning
                }, divQuery = this.root = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
                this.mapControl = this.mapControlFactory.createMapControl(divQuery[0], mapOptions), 
                void 0 !== this.viewChangeThrottleInterval ? Microsoft.Maps.Events.addThrottledHandler(this.mapControl, "viewchange", function() {
                    _this.onViewChanged();
                }, this.viewChangeThrottleInterval) : Microsoft.Maps.Events.addHandler(this.mapControl, "viewchange", function() {
                    _this.onViewChanged();
                }), Microsoft.Maps.Events.addHandler(this.mapControl, "viewchangeend", function() {
                    _this.onViewChangeEnded();
                }), this.dataPointRenderer.init(this.mapControl, divQuery, !!this.behavior), this.pendingGeocodingRender || this.updateInternal(!0, !0);
            }, Map.prototype.onViewChanged = function() {
                this.executingInternalViewChange ? this.executingInternalViewChange = !1 : this.receivedExternalViewChange = !0, 
                this.updateOffsets(!1, !1), this.behavior && this.behavior.viewChanged(), this.swapLogoContainerChildElement();
            }, Map.prototype.onViewChangeEnded = function() {
                this.dataPointRenderer.updateInternalDataLabels(this.currentViewport, !0);
            }, Map.prototype.getMapViewPort = function() {
                var currentViewport = this.currentViewport, legendMargins = this.legend.getMargins(), mapViewport = {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height
                };
                return mapViewport;
            }, Map.removeTransform3d = function(mapRoot) {
                var userAgent = window.navigator.userAgent.toLowerCase();
                if (mapRoot && -1 === userAgent.indexOf("applewebkit")) {
                    var imageTiles = mapRoot.find("img");
                    imageTiles.css("transform", "");
                }
            }, Map.prototype.updateInternal = function(dataChanged, redrawDataLabels) {
                if (this.mapControl) {
                    var isLegendVisible = this.legend.isVisible();
                    isLegendVisible || (this.legendData = {
                        dataPoints: []
                    });
                    var mapDiv = this.element.children(Map.MapContainer.selector), mapViewport = this.getMapViewPort();
                    mapDiv.height(mapViewport.height), mapDiv.width(mapViewport.width), this.updateOffsets(dataChanged, redrawDataLabels);
                    var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height), center = this.getViewCenter(levelOfDetail);
                    this.updateMapView(center, levelOfDetail);
                }
            }, Map.prototype.updateMapView = function(center, levelOfDetail) {
                this.receivedExternalViewChange && this.interactivityService || (this.executingInternalViewChange = !0, 
                this.mapControl.setView({
                    center: center,
                    zoom: levelOfDetail,
                    animate: !0
                }));
            }, Map.prototype.updateOffsets = function(dataChanged, redrawDataLabels) {
                var data, dataView = this.dataView, viewport = this.getMapViewPort();
                data = dataView && dataView.categorical ? this.dataPointRenderer.converter(viewport, this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled) : {
                    bubbleData: [],
                    shapeData: [],
                    sliceData: []
                };
                var behaviorOptions = this.dataPointRenderer.updateInternal(data, viewport, dataChanged, this.interactivityService, redrawDataLabels);
                visuals.Legend.positionChartArea(d3.select(this.root[0]), this.legend), this.interactivityService && behaviorOptions && this.interactivityService.bind(behaviorOptions.dataPoints, this.behavior, behaviorOptions);
            }, Map.prototype.onClearSelection = function() {
                this.interactivityService.clearSelection(), this.updateOffsets(!1, !1);
            }, Map.prototype.clearDataPoints = function() {
                this.dataPointRenderer.clearDataPoints(), this.legend.drawLegend({
                    dataPoints: []
                }, this.currentViewport);
            }, Map.prototype.getDefaultMapControlFactory = function() {
                return {
                    createMapControl: function(element, options) {
                        return new Microsoft.Maps.Map(element, options);
                    },
                    ensureMap: jsCommon.ensureMap
                };
            }, Map.MapContainer = {
                cssClass: "mapControl",
                selector: ".mapControl"
            }, Map.StrokeDarkenColorValue = 63.75, Map;
        }();
        visuals.Map = Map;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function appendImage(selection) {
            selection.append("div").classed("imgCon", !0).append("img");
        }
        function setImageStyle(selection, imageStyle) {
            selection.selectAll(".imgCon").style({
                height: getPixelString(imageStyle.maxHeight)
            }).selectAll("img").style({
                "max-height": getPixelString(imageStyle.maxHeight),
                "max-width": getPixelString(imageStyle.maxWidth)
            });
        }
        function getPixelString(value) {
            return value + "px";
        }
        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, UrlUtils = jsCommon.UrlUtils, TitleFontFamily = "wf_segoe-ui_semibold", DefaultFontFamily = "wf_segoe-ui_normal", DefaultCaptionFontSizeInPt = 10, DefaultTitleFontSizeInPt = 13, DefaultDetailFontSizeInPt = 9, DefaultTitleColor = "#767676", DefaultTextColor = "#333333", MultiRowCard = function() {
            function MultiRowCard() {
                this.isInteractivityOverflowHidden = !1;
            }
            return MultiRowCard.prototype.init = function(options) {
                this.options = options, this.style = options.style;
                var viewport = this.currentViewport = options.viewport, interactivity = this.interactivity = options.interactivity;
                interactivity && "hidden" === interactivity.overflow && (this.isInteractivityOverflowHidden = !0);
                var multiRowCardDiv = this.element = $("<div/>").addClass(MultiRowCard.MultiRowCardRoot["class"]).css({
                    height: getPixelString(viewport.height)
                });
                options.element.append(multiRowCardDiv), this.initializeCardRowSelection();
            }, MultiRowCard.prototype.onDataChanged = function(options) {
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var dataView = this.dataView = dataViews[0], columnMetadata = dataView.table.columns, tableRows = dataView.table.rows, resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append, data_2 = this.data = MultiRowCard.converter(dataView, columnMetadata.length, tableRows.length, this.isInteractivityOverflowHidden);
                    this.setCardDimensions(), this.listView.data(data_2.dataModel, function(d) {
                        return data_2.dataModel.indexOf(d);
                    }, resetScrollbarPosition);
                } else this.data = {
                    dataModel: [],
                    cardTitleSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTitleColor, DefaultTitleFontSizeInPt),
                    categoryLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTextColor, DefaultDetailFontSizeInPt),
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTextColor, DefaultCaptionFontSizeInPt)
                };
                this.waitingForData = !1;
            }, MultiRowCard.prototype.onResizing = function(viewport) {
                var heightNotChanged = this.currentViewport.height === viewport.height;
                if (this.currentViewport = viewport, this.element.css("height", getPixelString(viewport.height)), 
                this.dataView) {
                    var previousMaxColPerRow = this.maxColPerRow;
                    this.maxColPerRow = this.getMaxColPerRow();
                    var widthNotChanged = previousMaxColPerRow === this.maxColPerRow;
                    heightNotChanged && widthNotChanged || this.listView.viewport(viewport);
                }
            }, MultiRowCard.converter = function(dataView, columnCount, maxCards, isDashboardVisual) {
                void 0 === isDashboardVisual && (isDashboardVisual = !1);
                var cardTitleSettings, dataLabelsSettings, categoryLabelsSettings, details = [], tableDataRows = dataView.table.rows, columnMetadata = dataView.table.columns;
                if (cardTitleSettings = visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTitleColor, DefaultTitleFontSizeInPt), 
                dataLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTextColor, DefaultCaptionFontSizeInPt), 
                categoryLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTextColor, DefaultDetailFontSizeInPt), 
                dataView.metadata && dataView.metadata.objects) {
                    var cardTitleLabelObjects = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "cardTitle");
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(cardTitleLabelObjects, cardTitleSettings);
                    var dataLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "dataLabels");
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(dataLabelObject, dataLabelsSettings);
                    var categoryLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "categoryLabels");
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelObject, categoryLabelsSettings);
                }
                for (var i = 0, len = maxCards; len > i; i++) {
                    for (var row = tableDataRows[i], isValuePromoted = void 0, title = void 0, showTitleAsURL = !1, showTitleAsImage = !1, showTitleAsKPI = !1, cardData = [], j = 0; columnCount > j; j++) {
                        var column = columnMetadata[j], statusGraphicInfo = getKpiImageMetadata(column, row[j]), columnCaption = void 0, statusGraphic = void 0;
                        statusGraphicInfo && (columnCaption = statusGraphicInfo["class"], statusGraphic = statusGraphicInfo.statusGraphic), 
                        columnCaption || (columnCaption = visuals.valueFormatter.format(row[j], visuals.valueFormatter.getFormatString(column, MultiRowCard.formatStringProp)));
                        var showKPI = void 0 !== statusGraphicInfo && void 0 !== statusGraphicInfo.caption, columnDetail = columnMetadata[j].displayName;
                        isDashboardVisual || column.type.numeric || (void 0 === isValuePromoted ? (isValuePromoted = !0, 
                        title = columnCaption, showTitleAsURL = visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(title), 
                        showTitleAsImage = visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption), 
                        showTitleAsKPI = showKPI) : isValuePromoted && (isValuePromoted = !1)), cardData.push({
                            caption: columnCaption,
                            details: columnDetail,
                            showURL: visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(columnCaption),
                            showImage: visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption),
                            showKPI: showKPI,
                            columnIndex: j
                        });
                    }
                    details.push({
                        title: isValuePromoted ? title : void 0,
                        showTitleAsURL: showTitleAsURL,
                        showTitleAsImage: showTitleAsImage,
                        showTitleAsKPI: showTitleAsKPI,
                        cardItemsData: isValuePromoted ? cardData.filter(function(d) {
                            return d.caption !== title;
                        }) : cardData
                    });
                }
                return {
                    dataModel: details,
                    cardTitleSettings: cardTitleSettings,
                    categoryLabelsSettings: categoryLabelsSettings,
                    dataLabelsSettings: dataLabelsSettings
                };
            }, MultiRowCard.prototype.initializeCardRowSelection = function() {
                var _this = this, isDashboardVisual = this.isInteractivityOverflowHidden, rowEnter = function(rowSelection) {
                    var cardRow = rowSelection.append("div").classed(MultiRowCard.Card["class"], !0);
                    isDashboardVisual ? cardRow.classed("mrtile", !0) : _this.cardHasTitle && cardRow.append("div").classed(MultiRowCard.Title["class"], !0).each(function(d) {
                        d.showTitleAsImage ? appendImage(d3.select(this)) : d.showTitleAsURL ? d3.select(this).append("a") : d.showTitleAsKPI && d3.select(this).append("div").classed(MultiRowCard.KPITitle["class"], !0).classed(d.title, !0).style({
                            display: "inline-block",
                            verticalAlign: "sub"
                        });
                    });
                    var cardItem = cardRow.selectAll(MultiRowCard.CardItemContainer.selector).data(function(d) {
                        return d.cardItemsData;
                    }).enter().append("div").classed(MultiRowCard.CardItemContainer["class"], !0);
                    cardItem.append("div").classed(MultiRowCard.Caption["class"], !0).each(function(d) {
                        d.showURL ? d3.select(this).append("a") : d.showImage ? appendImage(d3.select(this)) : d.showKPI && d3.select(this).append("div").classed(d.caption, !0).style({
                            display: "inline-block",
                            verticalAlign: "sub"
                        });
                    }), cardItem.append("div").classed(MultiRowCard.Details["class"], !0);
                }, rowUpdate = function(rowSelection) {
                    var style = _this.getStyle(), dataLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(!1, style.caption.fontSize)), categoryLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(!1, style.details.fontSize)), titleLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(!0, style.title.fontSize));
                    !isDashboardVisual && _this.cardHasTitle && (rowSelection.selectAll(MultiRowCard.Title.selector).filter(function(d) {
                        return !d.showTitleAsImage && !d.showTitleAsKPI;
                    }).style({
                        "font-size": PixelConverter.fromPoint(style.title.fontSize),
                        "line-height": PixelConverter.toString(titleLabelHeight),
                        color: style.title.color
                    }), rowSelection.selectAll(MultiRowCard.Title.selector).filter(function(d) {
                        return !d.showTitleAsURL && !d.showTitleAsImage && !d.showTitleAsKPI;
                    }).text(function(d) {
                        return d.title;
                    }).attr("title", function(d) {
                        return d.title;
                    }), rowSelection.selectAll(MultiRowCard.TitleUrlSelector).text(function(d) {
                        return d.title;
                    }).attr({
                        href: function(d) {
                            return d.title;
                        },
                        target: "_blank"
                    }), rowSelection.selectAll(MultiRowCard.TitleImageSelector).attr("src", function(d) {
                        return d.title;
                    }), setImageStyle(rowSelection.selectAll(MultiRowCard.Title.selector), style.imageTitle), 
                    rowSelection.selectAll(MultiRowCard.KPITitle.selector).each(function(d) {
                        var element = d3.select(this);
                        element.classed(d.title);
                    }));
                    var cardSelection = rowSelection.selectAll(MultiRowCard.Card.selector);
                    cardSelection.selectAll(MultiRowCard.Caption.selector).filter(function(d) {
                        return !d.showImage;
                    }).style({
                        "line-height": PixelConverter.toString(dataLabelHeight),
                        "font-size": PixelConverter.fromPoint(style.caption.fontSize)
                    }).filter(function(d) {
                        return !d.showKPI;
                    }).style({
                        color: style.caption.color
                    }).filter(function(d) {
                        return !d.showURL;
                    }).text(function(d) {
                        return d.caption;
                    }).attr("title", function(d) {
                        return d.caption;
                    }), cardSelection.selectAll(MultiRowCard.CaptionImageSelector).attr("src", function(d) {
                        return d.caption;
                    }).style(style.imageCaption), cardSelection.selectAll(MultiRowCard.CardItemContainer.selector).style({
                        "padding-right": function(d) {
                            return _this.isLastRowItem(d.columnIndex, _this.dataView.metadata.columns.length) ? "0px" : getPixelString(style.cardItemContainer.paddingRight);
                        },
                        width: function(d) {
                            return _this.getColumnWidth(d.columnIndex, _this.dataView.metadata.columns.length);
                        },
                        display: function(d) {
                            return _this.hideColumn(d.columnIndex) ? "none" : "inline-block";
                        }
                    }), setImageStyle(cardSelection.selectAll(MultiRowCard.Caption.selector), style.imageCaption), 
                    cardSelection.selectAll(MultiRowCard.CaptionUrlSelector).attr({
                        href: function(d) {
                            return d.caption;
                        },
                        target: "_blank"
                    }).text(function(d) {
                        return d.caption;
                    }), style.details.isVisible && cardSelection.selectAll(MultiRowCard.Details.selector).text(function(d) {
                        return d.details;
                    }).style({
                        "font-size": PixelConverter.fromPoint(style.details.fontSize),
                        "line-height": PixelConverter.toString(categoryLabelHeight),
                        color: style.details.color
                    }).attr("title", function(d) {
                        return d.details;
                    }), cardSelection.style("margin-bottom", isDashboardVisual ? "0px" : _this.isSingleRowCard ? "0px" : getPixelString(style.card.marginBottom));
                }, rowExit = function(rowSelection) {
                    rowSelection.remove();
                }, listViewOptions = {
                    rowHeight: void 0,
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function() {
                        return _this.onLoadMoreData();
                    },
                    viewport: this.currentViewport,
                    baseContainer: d3.select(this.element.get(0)),
                    scrollEnabled: !this.isInteractivityOverflowHidden,
                    isReadMode: function() {
                        return 1 !== _this.options.host.getViewMode();
                    }
                };
                this.listView = visuals.ListViewFactory.createListView(listViewOptions);
            }, MultiRowCard.prototype.getMaxColPerRow = function() {
                var rowWidth = this.currentViewport.width, minColumnWidth = this.getStyle().cardItemContainer.minWidth, columnCount = this.dataView.metadata.columns.length, maxColumnPerRow = Math.floor(rowWidth / minColumnWidth) || 1;
                return Math.min(columnCount, maxColumnPerRow);
            }, MultiRowCard.prototype.getRowIndex = function(fieldIndex) {
                return Math.floor(1 * fieldIndex / this.getMaxColPerRow());
            }, MultiRowCard.prototype.getStyle = function() {
                var defaultStyle = this.getOverridenStyle();
                if (!this.isInteractivityOverflowHidden) return $.extend(!0, {}, defaultStyle);
                for (var viewportWidth = this.currentViewport.width, overrideStyle = {}, _i = 0, _a = MultiRowCard.tileMediaQueries; _i < _a.length; _i++) {
                    var currentQuery = _a[_i];
                    if (viewportWidth <= currentQuery.maxWidth) {
                        overrideStyle = currentQuery.style;
                        break;
                    }
                }
                return $.extend(!0, {}, defaultStyle, overrideStyle);
            }, MultiRowCard.prototype.getOverridenStyle = function() {
                var defaultStyle = MultiRowCard.DefaultStyle, dataLabelsSettings = this.data.dataLabelsSettings, categoryLabelSettings = this.data.categoryLabelsSettings, titleLabelSettings = this.data.cardTitleSettings, overrideStyle = {
                    caption: {
                        fontSize: dataLabelsSettings.fontSize,
                        color: dataLabelsSettings.labelColor
                    },
                    title: {
                        fontSize: titleLabelSettings.fontSize,
                        color: titleLabelSettings.labelColor
                    },
                    details: {
                        fontSize: categoryLabelSettings.fontSize,
                        color: categoryLabelSettings.labelColor,
                        isVisible: categoryLabelSettings.show
                    }
                };
                return $.extend(!0, overrideStyle, defaultStyle);
            }, MultiRowCard.getTextProperties = function(isTitle, fontSizeInPt) {
                return {
                    fontFamily: isTitle ? TitleFontFamily : DefaultFontFamily,
                    fontSize: PixelConverter.fromPoint(fontSizeInPt)
                };
            }, MultiRowCard.prototype.hideColumn = function(fieldIndex) {
                var rowIndex = this.getRowIndex(fieldIndex), maxRows = this.getStyle().card.maxRows;
                return maxRows && rowIndex >= maxRows;
            }, MultiRowCard.prototype.getColumnWidth = function(fieldIndex, columnCount) {
                var maxColumnPerRow = this.getMaxColPerRow();
                if (maxColumnPerRow >= columnCount) return 100 / columnCount + "%";
                var rowIndex = this.getRowIndex(fieldIndex), totalRows = Math.ceil(1 * columnCount / maxColumnPerRow), lastRowCount = columnCount % maxColumnPerRow;
                return totalRows > rowIndex || 0 === lastRowCount ? 100 / maxColumnPerRow + "%" : 100 / lastRowCount + "%";
            }, MultiRowCard.prototype.isLastRowItem = function(fieldIndex, columnCount) {
                if (fieldIndex + 1 === columnCount) return !0;
                var maxColumnPerRow = this.getMaxColPerRow();
                return maxColumnPerRow - fieldIndex % maxColumnPerRow === 1;
            }, MultiRowCard.prototype.setCardDimensions = function() {
                this.cardHasTitle = !1;
                var dataModel = this.data.dataModel;
                !this.isInteractivityOverflowHidden && dataModel && dataModel.length > 0 && (this.cardHasTitle = void 0 !== dataModel[0].title, 
                this.isSingleRowCard = 1 === dataModel.length);
            }, MultiRowCard.prototype.onLoadMoreData = function() {
                !this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment && (this.options.host.loadMoreData(), 
                this.waitingForData = !0);
            }, MultiRowCard.getDataLabelSettingsOptions = function(enumeration, labelSettings, show) {
                return void 0 === show && (show = !1), {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: show,
                    fontSize: !0
                };
            }, MultiRowCard.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder(), cardTitleSettings = this.data.cardTitleSettings, dataLabelsSettings = this.data.dataLabelsSettings, categoryLabelsSettings = this.data.categoryLabelsSettings;
                switch (options.objectName) {
                  case "cardTitle":
                    !this.isInteractivityOverflowHidden && this.cardHasTitle && visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, cardTitleSettings));
                    break;

                  case "dataLabels":
                    visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, dataLabelsSettings));
                    break;

                  case "categoryLabels":
                    visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, categoryLabelsSettings, !0));
                }
                return enumeration.complete();
            }, MultiRowCard.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            }, MultiRowCard.MultiRowCardRoot = createClassAndSelector("multiRowCard"), MultiRowCard.Card = createClassAndSelector("card"), 
            MultiRowCard.Title = createClassAndSelector("title"), MultiRowCard.CardItemContainer = createClassAndSelector("cardItemContainer"), 
            MultiRowCard.Caption = createClassAndSelector("caption"), MultiRowCard.Details = createClassAndSelector("details"), 
            MultiRowCard.TitleUrlSelector = MultiRowCard.Title.selector + " a", MultiRowCard.CaptionUrlSelector = MultiRowCard.Caption.selector + " a", 
            MultiRowCard.TitleImageSelector = MultiRowCard.Title.selector + " img", MultiRowCard.CaptionImageSelector = MultiRowCard.Caption.selector + " img", 
            MultiRowCard.KPITitle = createClassAndSelector("kpiTitle"), MultiRowCard.DefaultStyle = {
                card: {
                    marginBottom: 20
                },
                cardItemContainer: {
                    paddingRight: 20,
                    minWidth: 120
                },
                imageCaption: {
                    maxHeight: 75,
                    maxWidth: 100
                },
                imageTitle: {
                    maxHeight: 75,
                    maxWidth: 100
                }
            }, MultiRowCard.tileMediaQueries = [ {
                maxWidth: 250,
                style: {
                    card: {
                        maxRows: 2
                    },
                    cardItemContainer: {
                        minWidth: 110
                    },
                    imageCaption: {
                        maxHeight: 45
                    }
                }
            }, {
                maxWidth: 490,
                style: {
                    card: {
                        maxRows: 2
                    },
                    cardItemContainer: {
                        minWidth: 130
                    },
                    imageCaption: {
                        maxHeight: 52
                    }
                }
            }, {
                maxWidth: 750,
                style: {
                    card: {
                        maxRows: 1
                    },
                    cardItemContainer: {
                        minWidth: 120
                    },
                    imageCaption: {
                        maxHeight: 53
                    }
                }
            } ], MultiRowCard;
        }();
        visuals.MultiRowCard = MultiRowCard;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, StringExtensions = jsCommon.StringExtensions, UrlUtils = jsCommon.UrlUtils, Textbox = function() {
            function Textbox() {}
            return Textbox.prototype.init = function(options) {
                this.element = options.element, this.host = options.host, this.viewport = options.viewport, 
                this.readOnly = 0 === this.host.getViewMode(), this.paragraphs = [], this.refreshView();
            }, Textbox.prototype.onResizing = function(viewport) {
                this.viewport = viewport, this.updateSize();
            }, Textbox.prototype.onDataChanged = function(options) {
                var dataViews = options.dataViews;
                if (this.paragraphs = [], dataViews && dataViews.length > 0) {
                    var objects = dataViews[0].metadata.objects;
                    objects && objects.general && (this.paragraphs = objects.general.paragraphs);
                }
                this.refreshView();
            }, Textbox.prototype.destroy = function() {}, Textbox.prototype.focus = function() {
                return this.editor ? (this.editor.focus(), !0) : void 0;
            }, Textbox.prototype.onViewModeChanged = function(viewMode) {
                this.readOnly = 0 === viewMode, this.refreshView();
            }, Textbox.prototype.setSelection = function(start, end) {
                this.editor && this.editor.setSelection(start, end);
            }, Textbox.prototype.refreshView = function() {
                var _this = this;
                if (this.readOnly) {
                    this.editor && (this.editor.formatUrls(), this.saveContents(), this.editor.destroy(), 
                    this.editor = null), this.element.empty();
                    var htmlContent = RichTextConversion.convertParagraphsToHtml(this.paragraphs);
                    htmlContent.addClass(Textbox.ClassName), htmlContent.css({
                        "font-family": RichText.defaultFont,
                        "font-size": RichText.defaultFontSize
                    }), this.element.append(htmlContent);
                } else {
                    if (!this.editor) {
                        this.editor = new RichText.QuillWrapper(this.readOnly, this.host), this.editor.textChanged = function(delta, source) {
                            return _this.saveContents();
                        }, this.element.empty();
                        var editorElement = this.editor.getElement();
                        editorElement.addClass(Textbox.ClassName), editorElement.css({
                            "font-family": RichText.defaultFont,
                            "font-size": RichText.defaultFontSize
                        }), this.element.append(editorElement);
                    }
                    this.editor.setContents(RichTextConversion.convertParagraphsToOps(this.paragraphs));
                }
                this.updateSize();
            }, Textbox.prototype.saveContents = function() {
                if (this.editor) {
                    var contents = this.editor.getContents();
                    this.paragraphs = RichTextConversion.convertDeltaToParagraphs(contents);
                    var changes = [ {
                        objectName: "general",
                        properties: {
                            paragraphs: this.paragraphs
                        },
                        selector: null
                    } ];
                    this.host.persistProperties(changes);
                }
            }, Textbox.prototype.updateSize = function() {
                this.editor && this.editor.resize(this.viewport);
            }, Textbox.ClassName = "textbox", Textbox;
        }();
        visuals.Textbox = Textbox;
        var RichTextConversion;
        !function(RichTextConversion) {
            function convertDeltaToParagraphs(contents) {
                for (var paragraphs = [], paragraph = {
                    textRuns: []
                }, i = 0, len = contents.ops.length; len > i; i++) {
                    var insertOp = contents.ops[i];
                    if ("string" == typeof insertOp.insert) {
                        var text = insertOp.insert, attributes = insertOp.attributes;
                        attributes && attributes.align && (paragraph.horizontalTextAlignment = attributes.align);
                        var start = 0, end = 0, newParagraph = void 0;
                        do {
                            if (end = text.indexOf("\n", start), 0 > end ? (newParagraph = !1, end = text.length) : newParagraph = !0, 
                            end - start > 0) {
                                var span = text.substring(start, end), textRun = {
                                    value: span
                                };
                                if (attributes) {
                                    void 0 !== attributes.link && UrlUtils.isValidUrl(attributes.link) && (textRun.url = attributes.link);
                                    var textStyle = convertFormatAttributesToTextStyle(attributes);
                                    textStyle && (textRun.textStyle = textStyle);
                                }
                                paragraph.textRuns.push(textRun);
                            }
                            newParagraph && (0 === paragraph.textRuns.length && paragraph.textRuns.push({
                                value: ""
                            }), paragraphs.push(paragraph), paragraph = {
                                textRuns: []
                            }), start = end + 1;
                        } while (start < text.length);
                    }
                }
                return paragraph.textRuns.length > 0 && paragraph.textRuns[0].value.length > 0 && paragraphs.push(paragraph), 
                paragraphs;
            }
            function convertParagraphsToHtml(paragraphs) {
                for (var $paragraphs = $(), paragraphIndex = 0, len = paragraphs.length; len > paragraphIndex; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex], isParagraphEmpty = !0, $paragraph = $("<div>");
                    paragraphDef.horizontalTextAlignment && $paragraph.css("text-align", paragraphDef.horizontalTextAlignment);
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; jlen > textRunIndex; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex], $textRun = $("<span>"), styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            var css = {};
                            styleDef.fontFamily && (css["font-family"] = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily))), 
                            styleDef.fontSize && (css["font-size"] = styleDef.fontSize), styleDef.fontStyle && (css["font-style"] = styleDef.fontStyle), 
                            styleDef.fontWeight && (css["font-weight"] = styleDef.fontWeight), styleDef.textDecoration && (css["text-decoration"] = styleDef.textDecoration), 
                            $textRun.css(css);
                        }
                        var text = textRunDef.value;
                        if (_.isEmpty(text) || (isParagraphEmpty = !1), void 0 !== textRunDef.url) {
                            var $link = void 0;
                            $link = UrlUtils.isValidUrl(textRunDef.url) ? $("<a>").attr("href", textRunDef.url).attr("target", "_blank").text(text) : $("<span>").text(text), 
                            $textRun.append($link);
                        } else $textRun.text(text);
                        $paragraph.append($textRun);
                    }
                    isParagraphEmpty && $paragraph.append($("<br>")), $paragraphs = $paragraphs.add($paragraph);
                }
                return $paragraphs;
            }
            function convertParagraphsToOps(paragraphs) {
                for (var ops = [], paragraphIndex = 0, len = paragraphs.length; len > paragraphIndex; ++paragraphIndex) for (var paragraphDef = paragraphs[paragraphIndex], textRunIndex = 0, jlen = paragraphDef.textRuns.length; jlen > textRunIndex; ++textRunIndex) {
                    var textRunDef = paragraphDef.textRuns[textRunIndex], formats = {};
                    paragraphDef.horizontalTextAlignment && (formats.align = paragraphDef.horizontalTextAlignment);
                    var styleDef = textRunDef.textStyle;
                    styleDef && (styleDef.fontFamily && (formats.font = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily))), 
                    styleDef.fontSize && (formats.size = styleDef.fontSize), formats.italic = "italic" === styleDef.fontStyle, 
                    formats.bold = "bold" === styleDef.fontWeight, formats.underline = "underline" === styleDef.textDecoration);
                    var text = textRunDef.value;
                    textRunDef.url && UrlUtils.isValidUrl(textRunDef.url) && (formats.link = textRunDef.url);
                    var op = {
                        insert: text,
                        attributes: formats
                    };
                    ops.push(op), textRunIndex !== jlen - 1 || StringExtensions.endsWith(text, "\n") || ops.push({
                        insert: "\n",
                        attributes: formats
                    });
                }
                return ops;
            }
            function convertFormatAttributesToTextStyle(attributes) {
                var style = {};
                if (attributes.bold && (style.fontWeight = "bold"), attributes.font) {
                    var font = removeQuotes(attributes.font);
                    font = RichText.getFontFamilyForBuiltInFont(font), style.fontFamily = font;
                }
                return attributes.italic && (style.fontStyle = "italic"), attributes.size && (style.fontSize = attributes.size), 
                attributes.underline && (style.textDecoration = "underline"), style;
            }
            function removeQuotes(text) {
                return StringExtensions.startsWith(text, "'") ? text.slice(1, text.length - 1) : text;
            }
            RichTextConversion.convertDeltaToParagraphs = convertDeltaToParagraphs, RichTextConversion.convertParagraphsToHtml = convertParagraphsToHtml, 
            RichTextConversion.convertParagraphsToOps = convertParagraphsToOps;
        }(RichTextConversion || (RichTextConversion = {}));
        var RichText;
        !function(RichText) {
            function getCssFontFamily(font) {
                var family = fontMap[font];
                return null == family && (family = font), family;
            }
            function getFontFamilyForBuiltInFont(font) {
                var fontFamily = _.findKey(fontMap, function(value) {
                    return value === font;
                });
                return fontFamily || font;
            }
            var fontMap = {
                "Segoe (Bold)": "wf_segoe-ui_bold",
                "Segoe UI": "wf_segoe-ui_normal",
                "Segoe UI Light": "wf_segoe-ui_light",
                Heading: "wf_segoe-ui_light",
                Body: "wf_segoe-ui_normal"
            }, fonts = [ "Arial", "Arial Black", "Arial Unicode MS", "Calibri", "Cambria", "Cambria Math", "Candara", "Comic Sans MS", "Consolas", "Constantia", "Corbel", "Courier New", "Georgia", "Lucida Sans Unicode", "Segoe (Bold)", "Segoe UI", "Segoe UI Light", "Symbol", "Tahoma", "Times New Roman", "Trebuchet MS", "Verdana", "Wingdings" ].map(function(font) {
                return {
                    label: font,
                    value: getCssFontFamily(font)
                };
            });
            RichText.defaultFont = getCssFontFamily("Segoe UI Light");
            var fontSizes = [ "8", "9", "10", "10.5", "11", "12", "14", "16", "18", "20", "24", "28", "32", "36", "40", "42", "44", "54", "60", "66", "72", "80", "88", "96" ].map(function(size) {
                return {
                    label: size,
                    value: size + "px"
                };
            });
            RichText.defaultFontSize = "14px";
            var textAlignments = [ "Left", "Center", "Right" ].map(function(alignment) {
                return {
                    label: alignment,
                    value: alignment.toLowerCase()
                };
            });
            RichText.getCssFontFamily = getCssFontFamily, RichText.getFontFamilyForBuiltInFont = getFontFamilyForBuiltInFont;
            var QuillWrapper = function() {
                function QuillWrapper(readOnly, host) {
                    var _this = this;
                    this.QuillPackage = {
                        javaScriptFiles: QuillWrapper.quillJsFiles,
                        cssFiles: QuillWrapper.quillCssFiles
                    }, this.textChanged = function(d, s) {}, this.host = host, this.$container = $("<div>"), 
                    this.readOnly = readOnly, this.localizationProvider = {
                        get: function(stringId) {
                            return _this.host.getLocalizedString(stringId);
                        }
                    }, this.dependenciesLoaded = $.Deferred(), QuillWrapper.loadQuillResources ? (this.initialized = !1, 
                    this.dependenciesLoaded.done(function() {
                        _this.rebuildQuillEditor(), _this.initialized = !0;
                    }), jsCommon.requires(this.QuillPackage, function() {
                        return _this.dependenciesLoaded.resolve();
                    })) : (this.rebuildQuillEditor(), this.initialized = !0, this.dependenciesLoaded.resolve());
                }
                return QuillWrapper.prototype.addModule = function(name, options) {
                    return this.editor ? this.editor.addModule(name, options) : void 0;
                }, QuillWrapper.prototype.getElement = function() {
                    return this.$container;
                }, QuillWrapper.prototype.getContents = function() {
                    return this.initialized ? this.editor.getContents() : void 0;
                }, QuillWrapper.prototype.setContents = function(contents) {
                    var _this = this;
                    return this.initialized ? (this.editor.setHTML("", "api"), contents && this.editor.setContents(contents, "api"), 
                    void this.formatUrls()) : void this.dependenciesLoaded.done(function() {
                        return _this.setContents(contents);
                    });
                }, QuillWrapper.prototype.resize = function(viewport) {
                    this.$container.width(viewport.width), this.$container.height(viewport.height);
                }, QuillWrapper.prototype.setReadOnly = function(readOnly) {
                    var readOnlyChanged = readOnly !== this.readOnly;
                    this.readOnly = readOnly, this.initialized && readOnlyChanged && this.rebuildQuillEditor();
                }, QuillWrapper.prototype.formatUrls = function() {
                    if (null != this.editor) {
                        for (var text = this.editor.getText(), urlMatches = UrlUtils.findAllValidUrls(text), _i = 0, urlMatches_1 = urlMatches; _i < urlMatches_1.length; _i++) {
                            var match = urlMatches_1[_i];
                            this.editor.formatText(match.start, match.end, "link", !1, "api"), this.editor.formatText(match.start, match.end, "link", match.text, "api");
                        }
                        this.editor.emit(Quill.events.SELECTION_CHANGE, this.getSelection(), "api");
                    }
                }, QuillWrapper.prototype.setSelection = function(start, end) {
                    this.editor && this.editor.setSelection(start, end, "api");
                }, QuillWrapper.prototype.getSelection = function() {
                    return this.editor ? this.editor.getSelection() : void 0;
                }, QuillWrapper.prototype.focus = function() {
                    this.editor && 0 === $(document.activeElement).closest(this.$container).length && this.editor.focus();
                }, QuillWrapper.prototype.destroy = function() {
                    this.host.setToolbar(null), this.$container.remove(), this.$container = null, this.$toolbarDiv = null, 
                    this.$editorDiv = null, this.editor = null;
                }, QuillWrapper.prototype.getSelectionAtCursor = function() {
                    var text = this.getTextWithoutTrailingBreak();
                    this.editor.focus();
                    var selection = this.getSelection();
                    return selection && selection.start === selection.end ? jsCommon.WordBreaker.find(selection.start, text) : selection;
                }, QuillWrapper.prototype.getWord = function() {
                    var selection = this.getSelectionAtCursor();
                    return this.getTextWithoutTrailingBreak().slice(selection.start, selection.end);
                }, QuillWrapper.prototype.insertLinkAtCursor = function(link, index) {
                    var endIndex = index + link.length;
                    return this.editor.insertText(index, link, "api"), this.editor.formatText(index, endIndex, "link", link, "api"), 
                    this.setSelection(index, endIndex), endIndex;
                }, QuillWrapper.prototype.getEditorContainer = function() {
                    return this.editor ? $(this.editor.container) : void 0;
                }, QuillWrapper.prototype.getTextWithoutTrailingBreak = function() {
                    return this.editor.getText().slice(0, -1);
                }, QuillWrapper.prototype.rebuildQuillEditor = function() {
                    var _this = this, contents = null;
                    this.editor && (this.editor.removeAllListeners(), contents = this.editor.getContents()), 
                    this.$container.empty(), this.$container.keydown(function(e) {
                        e.ctrlKey && _.contains(QuillWrapper.preventDefaultKeys, e.which) && e.stopPropagation();
                    });
                    var $editorDiv = this.$editorDiv = $("<div>");
                    $editorDiv.css("font-family", RichText.defaultFont), $editorDiv.css("font-size", RichText.defaultFontSize);
                    var configs = {
                        readOnly: this.readOnly,
                        formats: [ "bold", "italic", "underline", "font", "size", "link", "align" ],
                        styles: !1
                    };
                    if (this.editor = new Quill($editorDiv.get(0), configs), !this.readOnly) {
                        var $toolbarDiv = this.$toolbarDiv;
                        $toolbarDiv || (this.$toolbarDiv = $toolbarDiv = Toolbar.buildToolbar(this, this.localizationProvider)), 
                        $toolbarDiv.addClass("unselectable"), this.host.setToolbar($toolbarDiv), this.editor.addModule("toolbar", {
                            container: $toolbarDiv.get(0)
                        }), $editorDiv.attr("drag-resize-disabled", "true");
                    }
                    this.$container.append($editorDiv), contents && this.setContents(contents);
                    var textChangeThrottler = new jsCommon.ThrottleUtility(QuillWrapper.textChangeThrottle);
                    this.editor.on("text-change", function(delta, source) {
                        "api" !== source && textChangeThrottler.run(function() {
                            return _this.onTextChanged(delta, source);
                        });
                    });
                    var formatUrlThrottler = new jsCommon.ThrottleUtility(QuillWrapper.formatUrlThrottle);
                    this.editor.on("text-change", function(delta, source) {
                        "api" !== source && formatUrlThrottler.run(function() {
                            return _this.formatUrls();
                        });
                    }), this.editor.root.addEventListener("blur", function(event) {
                        var target = event.relatedTarget || document.activeElement;
                        target && "SELECT" === target.tagName || "INPUT" === target.tagName || target.getAttribute("contentEditable") || _this.setSelection(null, null);
                    }, !1);
                }, QuillWrapper.prototype.onTextChanged = function(delta, source) {
                    this.textChanged(delta, source);
                }, QuillWrapper.textChangeThrottle = 200, QuillWrapper.formatUrlThrottle = 1e3, 
                QuillWrapper.preventDefaultKeys = [ jsCommon.DOMConstants.aKeyCode, jsCommon.DOMConstants.cKeyCode, jsCommon.DOMConstants.xKeyCode, jsCommon.DOMConstants.vKeyCode ], 
                QuillWrapper.loadQuillResources = !0, QuillWrapper.quillJsFiles = [ powerbi.build + "/externals/quill.min.js" ], 
                QuillWrapper.quillCssFiles = [ powerbi.build + "/externals/quill.base.css" ], QuillWrapper;
            }();
            RichText.QuillWrapper = QuillWrapper;
            var Toolbar;
            !function(Toolbar) {
                function buildToolbar(quillWrapper, localizationProvider) {
                    var linkTooltipTemplate = buildToolbarLinkInputTemplate(localizationProvider);
                    quillWrapper.addModule("link-tooltip", {
                        template: linkTooltipTemplate
                    });
                    var toolbarLinkInput = buildToolbarLinkInput(quillWrapper, getTooltip("Link", localizationProvider), localizationProvider.get("RichTextbox_Link_DefaultText")), fontPicker = picker(getTooltip("Font", localizationProvider), fonts, "font", RichText.defaultFont, function($option, option) {
                        return $option.css("font-family", option.value), $option;
                    }), $container = div().addClass("toolbar ql-toolbar").append(formatGroup().append(label(localizationProvider.get("RichTextbox_Font_Label"))).append(fontPicker).append(picker(getTooltip("Size", localizationProvider), fontSizes, "size", RichText.defaultFontSize))).append(formatGroup().append(formatButton(getTooltip("Bold", localizationProvider), "bold")).append(formatButton(getTooltip("Italic", localizationProvider), "italic")).append(formatButton(getTooltip("Underline", localizationProvider), "underline"))).append(formatGroup().append(toggleGroup("Text Alignment", textAlignments, "align", "Left", localizationProvider))).append(toolbarLinkInput);
                    return $container.on("mousedown", function(event) {
                        var target = event.target || document.activeElement;
                        "INPUT" !== target.tagName && "SELECT" !== target.tagName && event.preventDefault();
                    }), $container;
                }
                function setSelectValue($select, value) {
                    $select.val(value);
                    var evt = document.createEvent("UIEvent");
                    evt.initUIEvent("change", !1, !1, null, 0), $select.get(0).dispatchEvent(evt);
                }
                function linkTooltipTemplateGenerator(removeText, doneText) {
                    return $('\n                        <a href="#" class="url" target="_blank"></a>\n                        <input class="input" type="text">\n                        <span class="bar">&nbsp;|&nbsp;</span>\n                        <a class="change"></a>\n                        <a class="remove">' + removeText + '</a>\n                        <a class="done">' + doneText + "</a>\n                    ");
                }
                function buildToolbarLinkInputTemplate(localizationProvider) {
                    var template = div(), doneText = localizationProvider.get("RichTextbox_Link_Done"), removeText = localizationProvider.get("RichTextbox_Link_Remove");
                    return template.append(linkTooltipTemplateGenerator(removeText, doneText)), template.html();
                }
                function formatGroup() {
                    return span().addClass("ql-format-group").attr("drag-resize-disabled", "true");
                }
                function label(text) {
                    return $("<label>").text(text);
                }
                function div() {
                    return $("<div>");
                }
                function span() {
                    return $("<span>");
                }
                function toggleGroup(title, list, format, defaultValue, localizationProvider) {
                    var tooltip = getTooltip(title, localizationProvider), $group = span().attr("title", tooltip).addClass("ql-toggle-group"), $select = selector(tooltip, list, defaultValue).addClass("ql-picker ql-" + format).css("display", "none"), $buttons = list.map(function(option) {
                        var $button = formatButton(getTooltip(option.label, localizationProvider), "align" + option.value).attr("data-value", option.value).click(function(e) {
                            return setSelectValue($select, option.value);
                        });
                        return $button;
                    });
                    return $select.change(function(e) {
                        for (var newValue = $select.val(), i = 0; i < $buttons.length; i++) $buttons[i].toggleClass("ql-active", $buttons[i].attr("data-value") === newValue);
                    }), $group.append($select), $group.append($buttons), $group;
                }
                function picker(tooltip, list, format, defaultValue, optionModifier) {
                    var $selector = selector(tooltip, list, defaultValue, optionModifier).addClass("ql-picker ql-" + format);
                    return $selector;
                }
                function selector(tooltip, list, defaultValue, optionModifier) {
                    for (var $selector = $("<select>").attr("title", tooltip), i = 0; i < list.length; i++) {
                        var option = list[i], $option = $("<option>").attr("value", option.value).text(option.label);
                        option.value === defaultValue && $option.attr("selected", "selected"), void 0 !== optionModifier && ($option = optionModifier($option, option)), 
                        $selector.append($option);
                    }
                    return $selector;
                }
                function formatButton(tooltip, format) {
                    var $button = span().addClass("ql-format-button");
                    return null != tooltip && $button.attr("title", tooltip), null != format && ($button.addClass("ql-" + format), 
                    $button.addClass("powervisuals-glyph " + format)), $button;
                }
                function getTooltip(name, localizationProvider) {
                    return localizationProvider.get("RichTextbox_" + name + "_ToolTip");
                }
                function clearLinkInput(linkTooltip) {
                    linkTooltip.removeClass("editing"), linkTooltip.removeClass("blank-editing"), linkTooltip.find(".input").val(DefaultLinkInputValue);
                }
                function buildToolbarLinkInput(quillWrapper, buttonTooltip, defaultLinkText) {
                    var linkTooltip = quillWrapper.getEditorContainer().find(Toolbar.selectors.linkTooltip.selector), toolbarLinkInput = formatGroup().addClass(Toolbar.selectors.toolbarUrlInput["class"]).append(formatButton(buttonTooltip, "link").append("<div>")).append(linkTooltip);
                    return toolbarLinkInput.on("keydown mousedown", function(event) {
                        if (event.keyCode === jsCommon.DOMConstants.enterKeyCode || event.target.classList.contains("done")) {
                            if (!linkTooltip.hasClass("blank-editing")) return !0;
                            var link = toolbarLinkInput.find(".input").val(), selection = quillWrapper.getSelectionAtCursor(), word = quillWrapper.getWord();
                            if (!word) {
                                var endCursor = quillWrapper.insertLinkAtCursor(link, selection.start);
                                return clearLinkInput(linkTooltip), quillWrapper.setSelection(endCursor, endCursor), 
                                !1;
                            }
                        }
                    }), toolbarLinkInput.find(".input").blur(function(event) {
                        var blurTarget = event.relatedTarget;
                        (null === blurTarget || blurTarget && !blurTarget.classList.contains("done")) && clearLinkInput(linkTooltip);
                    }), toolbarLinkInput.find(".ql-link div").click(function(event) {
                        var target = event.target.parentElement;
                        if (target && target.classList.contains("ql-active")) return toolbarLinkInput.find(".change")[0].click(), 
                        !1;
                        var word = quillWrapper.getWord();
                        if (!word) {
                            linkTooltip.addClass("editing blank-editing");
                            var inputElem = toolbarLinkInput.find(".input").get(0);
                            return inputElem.value = DefaultLinkInputValue, inputElem.selectionStart = inputElem.selectionEnd = DefaultLinkInputValue.length, 
                            inputElem.focus(), !1;
                        }
                    }).mousedown(function(event) {
                        var linkButton = event.target.parentElement;
                        if (linkButton && !linkButton.classList.contains("ql-active")) {
                            var selection = quillWrapper.getSelectionAtCursor();
                            quillWrapper.setSelection(selection.start, selection.end);
                        }
                    }), toolbarLinkInput;
                }
                var DefaultLinkInputValue = "http://";
                Toolbar.selectors = {
                    linkTooltip: createClassAndSelector("ql-link-tooltip"),
                    toolbarUrlInput: createClassAndSelector("toolbar-url-input")
                }, Toolbar.buildToolbar = buildToolbar, Toolbar.setSelectValue = setSelectValue;
            }(Toolbar || (Toolbar = {}));
        }(RichText = visuals.RichText || (visuals.RichText = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var SelectionManager = visuals.utility.SelectionManager;
        visuals.cheerMeterProps = {
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            }
        };
        var CheerMeter = function() {
            function CheerMeter() {
                this.isFirstTime = !0;
            }
            return CheerMeter.converter = function(dataView) {
                if (!dataView.categorical || !dataView.categorical.categories) return null;
                var cat = dataView.categorical.categories[0];
                if (!cat) return null;
                var catValues = cat.values;
                if (!catValues || _.isEmpty(dataView.categorical.values)) return null;
                var values = dataView.categorical.values[0].values, objects = dataView.categorical.categories[0].objects, object1 = objects && objects.length > 0 ? objects[0] : void 0, object2 = objects && objects.length > 1 ? objects[1] : void 0, metadataObjects = dataView.metadata.objects, backgroundColor = CheerMeter.DefaultBackgroundColor;
                if (metadataObjects) {
                    var general = metadataObjects.general;
                    if (general) {
                        var fill = general.fill;
                        fill && (backgroundColor = fill.solid.color);
                    }
                }
                var color1 = powerbi.DataViewObjects.getFillColor(object1, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor), color2 = powerbi.DataViewObjects.getFillColor(object2, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor), idn1 = visuals.SelectionIdBuilder.builder().withCategory(cat, 0).createSelectionId(), idn2 = visuals.SelectionIdBuilder.builder().withCategory(cat, 1).createSelectionId(), data = {
                    teamA: {
                        name: catValues[0],
                        value: values[0],
                        color: color1,
                        identity: idn1
                    },
                    teamB: {
                        name: catValues[1],
                        value: values[1],
                        color: color2,
                        identity: idn2
                    },
                    background: backgroundColor
                };
                return data;
            }, CheerMeter.prototype.init = function(options) {
                this.selectionManager = new SelectionManager({
                    hostServices: options.host
                });
                var svg = this.svg = d3.select(options.element.get(0)).append("svg");
                this.textOne = svg.append("text").style("font-family", CheerMeter.DefaultFontFamily), 
                this.textTwo = svg.append("text").style("font-family", CheerMeter.DefaultFontFamily);
            }, CheerMeter.prototype.update = function(options) {
                if (options.dataViews[0]) {
                    var data = this.data = CheerMeter.converter(options.dataViews[0]);
                    if (data) {
                        var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                        this.draw(data, duration, options.viewport);
                    }
                }
            }, CheerMeter.prototype.getRecomendedFontProperties = function(text1, text2, parentViewport) {
                for (var i, textProperties = {
                    fontSize: "",
                    fontFamily: CheerMeter.DefaultFontFamily,
                    text: text1 + text2
                }, min = 1, max = 1e3, maxWidth = parentViewport.width, width = 0; max >= min; ) if (i = (min + max) / 2 | 0, 
                textProperties.fontSize = i + "px", width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), 
                maxWidth > width) min = i + 1; else {
                    if (!(width > maxWidth)) break;
                    max = i - 1;
                }
                return textProperties.fontSize = i + "px", width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), 
                width > maxWidth && (i--, textProperties.fontSize = i + "px"), textProperties;
            }, CheerMeter.prototype.calculateLayout = function(data, viewport) {
                var text1 = data.teamA.name, text2 = data.teamB.name, avaliableViewport = {
                    height: viewport.height,
                    width: viewport.width - CheerMeter.PaddingBetweenText
                }, recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
                recomendedFontProperties.text = text1;
                var width1 = 0 | powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties);
                recomendedFontProperties.text = text2;
                var width2 = 0 | powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties), padding = (viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2 | 0;
                recomendedFontProperties.text = text1 + text2;
                var offsetHeight = 0 | powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties), max = data.teamA.value + data.teamB.value, availableHeight = viewport.height - offsetHeight, y1 = (max - data.teamA.value) / max * availableHeight + offsetHeight / 2 | 0, y2 = (max - data.teamB.value) / max * availableHeight + offsetHeight / 2 | 0;
                return {
                    x1: padding,
                    x2: padding + width1 + CheerMeter.PaddingBetweenText,
                    y1: y1,
                    y2: y2,
                    fontSize: recomendedFontProperties.fontSize
                };
            }, CheerMeter.prototype.ensureStartState = function(layout, viewport) {
                if (this.isFirstTime) {
                    this.isFirstTime = !1;
                    var startY = viewport.height / 2;
                    this.textOne.attr({
                        x: layout.x1,
                        y: startY
                    }), this.textTwo.attr({
                        x: layout.x2,
                        y: startY
                    });
                }
            }, CheerMeter.prototype.clearSelection = function() {
                var _this = this;
                this.selectionManager.clear().then(function() {
                    _this.clearSelectionUI();
                });
            }, CheerMeter.prototype.clearSelectionUI = function() {
                this.textOne.style("stroke", "#FFF").style("stroke-width", 0), this.textTwo.style("stroke", "#FFF").style("stroke-width", 0);
            }, CheerMeter.prototype.updateSelectionUI = function(ids) {
                this.textOne.style("stroke", "#FFF").style("stroke-width", SelectionManager.containsSelection(ids, this.data.teamA.identity) ? "2px" : "0px"), 
                this.textTwo.style("stroke", "#FFF").style("stroke-width", SelectionManager.containsSelection(ids, this.data.teamB.identity) ? "2px" : "0px");
            }, CheerMeter.prototype.draw = function(data, duration, viewport) {
                var _this = this, easeName = "back", textOne = this.textOne, textTwo = this.textTwo;
                this.svg.attr({
                    height: viewport.height,
                    width: viewport.width
                }).on("click", function() {
                    _this.clearSelection();
                }).style("background-color", data.background);
                var layout = this.calculateLayout(data, viewport);
                this.ensureStartState(layout, viewport), textOne.style("font-size", layout.fontSize).style("fill", data.teamA.color).on("click", function() {
                    _this.selectionManager.select(data.teamA.identity, d3.event.ctrlKey).then(function(ids) {
                        _this.updateSelectionUI(ids);
                    }), d3.event.stopPropagation();
                }).text(data.teamA.name), textTwo.style("font-size", layout.fontSize).style("fill", data.teamB.color).on("click", function() {
                    _this.selectionManager.select(data.teamB.identity, d3.event.ctrlKey).then(function(ids) {
                        _this.updateSelectionUI(ids);
                    }), d3.event.stopPropagation();
                }).text(data.teamB.name), textOne.transition().duration(duration).ease(easeName).attr({
                    y: layout.y1,
                    x: layout.x1
                }), textTwo.transition().duration(duration).ease(easeName).attr({
                    y: layout.y2,
                    x: layout.x2
                });
            }, CheerMeter.prototype.destroy = function() {
                this.svg = null, this.textOne = this.textTwo = null;
            }, CheerMeter.prototype.enumerateObjectInstances = function(options) {
                var instances = [], data = this.data;
                switch (options.objectName) {
                  case "dataPoint":
                    if (data) for (var teams = [ data.teamA, data.teamB ], i = 0; i < teams.length; i++) {
                        var slice = teams[i], color = slice.color, selector = slice.identity, dataPointInstance = {
                            objectName: "dataPoint",
                            displayName: slice.name,
                            selector: selector,
                            properties: {
                                fill: {
                                    solid: {
                                        color: color
                                    }
                                }
                            }
                        };
                        instances.push(dataPointInstance);
                    }
                    break;

                  case "general":
                    var general = {
                        objectName: "general",
                        displayName: "General",
                        selector: null,
                        properties: {
                            fill: {
                                solid: {
                                    color: data ? data.background : CheerMeter.DefaultBackgroundColor
                                }
                            }
                        }
                    };
                    instances.push(general);
                }
                return instances;
            }, CheerMeter.capabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping
                }, {
                    displayName: "Noise Measure",
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure
                } ],
                dataViewMappings: [ {
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            }
                        },
                        values: {
                            select: [ {
                                bind: {
                                    to: "Y"
                                }
                            } ]
                        }
                    }
                } ],
                objects: {
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            width: {
                                displayName: "",
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    general: {
                        displayName: "General",
                        properties: {
                            fill: {
                                displayName: "Background color",
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }, CheerMeter.DefaultFontFamily = "cursive", CheerMeter.DefaultFontColor = "rgb(165, 172, 175)", 
            CheerMeter.DefaultBackgroundColor = "#243C18", CheerMeter.PaddingBetweenText = 15, 
            CheerMeter;
        }();
        visuals.CheerMeter = CheerMeter;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var Color = jsCommon.Color, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, DataRoleHelper = powerbi.data.DataRoleHelper, ScatterChart = function() {
            function ScatterChart(options) {
                options && (this.tooltipsEnabled = options.tooltipsEnabled, this.interactivityService = options.interactivityService, 
                this.animator = options.animator), this.renderer = new SvgRenderer();
            }
            return ScatterChart.prototype.init = function(options) {
                this.options = options, this.element = options.element, this.currentViewport = options.viewport, 
                this.style = options.style, this.host = options.host, this.colors = this.style.colorPalette.dataColors, 
                this.interactivity = options.interactivity, this.cartesianVisualHost = options.cartesianHost, 
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
                var svg = this.svg = options.svg;
                svg.classed(ScatterChart.ClassName + " " + visuals.PlayChart.ClassName, !0), this.renderer.init(svg, options.labelsContext, this.isMobileChart, this.tooltipsEnabled);
            }, ScatterChart.getAdditionalTelemetry = function(dataView) {
                var telemetry = {
                    hasSize: DataRoleHelper.hasRoleInDataView(dataView, "Size"),
                    hasPlayAxis: DataRoleHelper.hasRoleInDataView(dataView, "Play")
                };
                return telemetry;
            }, ScatterChart.getObjectProperties = function(dataView, dataLabelsSettings) {
                var objects;
                objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : {};
                var objectProperties = {};
                objectProperties.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                objectProperties.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints, !1);
                var labelsObj = objects.categoryLabels;
                labelsObj && dataLabelsSettings && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                var hasGradient = dataView && visuals.GradientUtils.hasGradientRole(dataView.categorical);
                return objectProperties.fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, hasGradient), 
                objectProperties.colorBorder = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorBorder.show, !1), 
                objectProperties.colorByCategory = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorByCategory.show, !1), 
                objectProperties;
            }, ScatterChart.converter = function(dataView, options, playFrameInfo, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName, currentViewport = options.viewport, colorPalette = options.colors, interactivityService = options.interactivityService, categoryAxisProperties = options.categoryAxisProperties, valueAxisProperties = options.valueAxisProperties, dataViewCategorical = dataView.categorical, gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCategorical);
                dataViewCategorical.categories && dataViewCategorical.categories.length > 0 ? (categoryValues = dataViewCategorical.categories[0].values, 
                categoryFormatter = visuals.valueFormatter.create({
                    format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString),
                    value: categoryValues[0],
                    value2: categoryValues[categoryValues.length - 1]
                }), categoryIdentities = dataViewCategorical.categories[0].identity, categoryObjects = dataViewCategorical.categories[0].objects, 
                categoryQueryName = dataViewCategorical.categories[0].source.queryName) : (categoryValues = [ null ], 
                categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null));
                var categories = dataViewCategorical.categories, dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), dvSource = dataValues.source, scatterMetadata = ScatterChart.getMetadata(grouped, dvSource), dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), sizeRange = ScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size), objProps = ScatterChart.getObjectProperties(dataView, dataLabelsSettings), dataPointSeries = ScatterChart.createDataPointSeries(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, currentViewport, hasDynamicSeries, dataLabelsSettings, gradientValueColumn, objProps.defaultDataPointColor, categoryQueryName, objProps.colorByCategory, playFrameInfo, tooltipsEnabled), dataPoints = _.reduce(dataPointSeries, function(a, s) {
                    return a.concat(s.dataPoints);
                }, []), legendItems = hasDynamicSeries ? ScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), objProps.defaultDataPointColor) : [], legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                return legendTitle || (legendTitle = categories && categories.length > 0 && categories[0].source.displayName ? categories[0].source.displayName : ""), 
                categoryAxisProperties && null !== categoryAxisProperties.showAxisTitle && categoryAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.x = null), 
                valueAxisProperties && null !== valueAxisProperties.showAxisTitle && valueAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.y = null), 
                interactivityService && (interactivityService.applySelectionStateToData(dataPoints), 
                interactivityService.applySelectionStateToData(legendItems)), {
                    xCol: scatterMetadata.cols.x,
                    yCol: scatterMetadata.cols.y,
                    dataPoints: dataPoints,
                    dataPointSeries: dataPointSeries,
                    legendData: {
                        title: legendTitle,
                        dataPoints: legendItems
                    },
                    axesLabels: scatterMetadata.axesLabels,
                    size: scatterMetadata.cols.size,
                    sizeRange: sizeRange,
                    dataLabelsSettings: dataLabelsSettings,
                    defaultDataPointColor: objProps.defaultDataPointColor,
                    hasDynamicSeries: hasDynamicSeries,
                    showAllDataPoints: objProps.showAllDataPoints,
                    fillPoint: objProps.fillPoint,
                    colorBorder: objProps.colorBorder,
                    colorByCategory: objProps.colorByCategory
                };
            }, ScatterChart.getSizeRangeForGroups = function(dataViewValueGroups, sizeColumnIndex) {
                var result = {};
                return dataViewValueGroups && dataViewValueGroups.forEach(function(group) {
                    var sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values), currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                    (null == result.min || result.min > currentRange.min) && (result.min = currentRange.min), 
                    (null == result.max || result.max < currentRange.max) && (result.max = currentRange.max);
                }), result;
            }, ScatterChart.createDataPointSeries = function(dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, viewport, hasDynamicSeries, labelSettings, gradientValueColumn, defaultDataPointColor, categoryQueryName, colorByCategory, playFrameInfo, tooltipsEnabled) {
                for (var dataPointSeries = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), seriesIdx = 0, len = grouped.length; len > seriesIdx; seriesIdx++) {
                    var grouping = grouped[seriesIdx], seriesValues = grouping.values, measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues), measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues), measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues), seriesColor = void 0;
                    if (hasDynamicSeries) seriesColor = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else if (!colorByCategory && !categoryObjects) {
                        var measureSource = null != measureSize ? measureSize.source.queryName : "";
                        seriesColor = colorHelper.getColorForMeasure(null, measureSource);
                    }
                    var series = {
                        identityKey: grouping && grouping.identity && grouping.identity.key || "",
                        dataPoints: [],
                        hasSize: !(!measureSize || !measureSize.values),
                        fill: seriesColor
                    };
                    dataPointSeries.push(series);
                    for (var categoryIdx = 0, ilen = categoryValues.length; ilen > categoryIdx; categoryIdx++) {
                        var categoryValue = categoryValues[categoryIdx], xVal = visuals.AxisHelper.normalizeNonFiniteNumber(measureX && measureX.values ? measureX.values[categoryIdx] : null), yVal = visuals.AxisHelper.normalizeNonFiniteNumber(measureY && measureY.values ? measureY.values[categoryIdx] : 0), size = visuals.AxisHelper.normalizeNonFiniteNumber(measureSize && measureSize.values ? measureSize.values[categoryIdx] : null), hasNullValue = null == xVal || null == yVal;
                        if (!hasNullValue) {
                            var color = void 0;
                            if (hasDynamicSeries) color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else if (colorByCategory) color = colorHelper.getColorForSeriesValue(categoryObjects && categoryObjects[categoryIdx], dataValues.identityFields, categoryValue); else {
                                var measureSource = null != measureSize ? measureSize.source.queryName : "";
                                color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                            }
                            var category = categories && categories.length > 0 ? categories[0] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIdx).withSeries(dataValues, grouping).createSelectionId(), seriesData = [];
                            dataValueSource && seriesData.push({
                                value: grouping.name,
                                metadata: {
                                    source: dataValueSource,
                                    values: []
                                }
                            }), measureX && seriesData.push({
                                value: xVal,
                                metadata: measureX
                            }), measureY && seriesData.push({
                                value: yVal,
                                metadata: measureY
                            }), measureSize && measureSize.values && measureSize.values.length > 0 && seriesData.push({
                                value: measureSize.values[categoryIdx],
                                metadata: measureSize
                            }), playFrameInfo && seriesData.push({
                                value: playFrameInfo.label,
                                metadata: {
                                    source: playFrameInfo.column,
                                    values: []
                                }
                            });
                            var gradientToolTipData = visuals.TooltipBuilder.createGradientToolTipData(gradientValueColumn, categoryIdx);
                            null != gradientToolTipData && seriesData.push(gradientToolTipData);
                            var tooltipInfo = void 0;
                            tooltipsEnabled && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData));
                            var dataPoint = {
                                x: xVal,
                                y: yVal,
                                size: size,
                                radius: {
                                    sizeMeasure: measureSize,
                                    index: categoryIdx
                                },
                                fill: color,
                                formattedCategory: ScatterChart.createLazyFormattedCategory(categoryFormatter, null != categories ? categoryValue : grouping.name),
                                selected: !1,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                labelFill: labelSettings.labelColor
                            };
                            series.dataPoints.push(dataPoint);
                        }
                    }
                }
                return dataPointSeries;
            }, ScatterChart.createLazyFormattedCategory = function(formatter, value) {
                return new jsCommon.Lazy(function() {
                    return formatter.format(value);
                });
            }, ScatterChart.createSeriesLegend = function(dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                for (var grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), legendItems = [], i = 0, len = grouped.length; len > i; i++) {
                    var grouping = grouped[i], color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                    legendItems.push({
                        color: color,
                        icon: visuals.LegendIcon.Circle,
                        label: visuals.valueFormatter.format(grouping.name, formatString),
                        identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                        selected: !1
                    });
                }
                return legendItems;
            }, ScatterChart.getBubbleRadius = function(radiusData, sizeRange, viewport) {
                var actualSizeDataRange = null, bubblePixelAreaSizeRange = null, measureSize = radiusData.sizeMeasure;
                if (!measureSize) return ScatterChart.BubbleRadius;
                var minSize = sizeRange.min ? sizeRange.min : 0, maxSize = sizeRange.max ? sizeRange.max : 0, min = Math.min(minSize, 0), max = Math.max(maxSize, 0);
                if (actualSizeDataRange = {
                    minRange: min,
                    maxRange: max,
                    delta: max - min
                }, bubblePixelAreaSizeRange = ScatterChart.getBubblePixelAreaSizeRange(viewport, ScatterChart.MinSizeRange, ScatterChart.MaxSizeRange), 
                measureSize.values) {
                    var sizeValue = measureSize.values[radiusData.index];
                    if (null != sizeValue) return ScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
                }
                return ScatterChart.BubbleRadius;
            }, ScatterChart.getMeasureValue = function(measureIndex, seriesValues) {
                return measureIndex >= 0 ? seriesValues[measureIndex] : null;
            }, ScatterChart.getMetadata = function(grouped, source) {
                var xCol, yCol, sizeCol, xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X"), yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y"), sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), xAxisLabel = "", yAxisLabel = "";
                if (grouped && grouped.length) {
                    var firstGroup = grouped[0];
                    xIndex >= 0 && (xCol = firstGroup.values[xIndex].source, xAxisLabel = firstGroup.values[xIndex].source.displayName), 
                    yIndex >= 0 && (yCol = firstGroup.values[yIndex].source, yAxisLabel = firstGroup.values[yIndex].source.displayName), 
                    sizeIndex >= 0 && (sizeCol = firstGroup.values[sizeIndex].source);
                }
                return {
                    idx: {
                        x: xIndex,
                        y: yIndex,
                        size: sizeIndex
                    },
                    cols: {
                        x: xCol,
                        y: yCol,
                        size: sizeCol
                    },
                    axesLabels: {
                        x: xAxisLabel,
                        y: yAxisLabel
                    }
                };
            }, ScatterChart.getDefaultData = function() {
                return {
                    xCol: void 0,
                    yCol: void 0,
                    dataPoints: [],
                    dataPointSeries: [],
                    legendData: {
                        dataPoints: []
                    },
                    axesLabels: {
                        x: "",
                        y: ""
                    },
                    sizeRange: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                    defaultDataPointColor: null,
                    hasDynamicSeries: !1
                };
            }, ScatterChart.prototype.renderAtFrame = function(data) {
                this.data = data, this.cartesianVisualHost.triggerRender(!1);
            }, ScatterChart.prototype.setData = function(dataViews) {
                var _this = this;
                if (this.data = ScatterChart.getDefaultData(), dataViews.length > 0) {
                    var dataView = dataViews[0] || dataViews[1];
                    if (dataView) {
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata, !0), 
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata, !0), 
                        this.dataView = dataView;
                        var converterOptions_1 = {
                            viewport: this.currentViewport,
                            colors: this.colors,
                            interactivityService: this.interactivityService,
                            categoryAxisProperties: this.categoryAxisProperties,
                            valueAxisProperties: this.valueAxisProperties
                        };
                        if (visuals.PlayChart.isDataViewPlayable(dataView)) {
                            this.playAxis || (this.playAxis = new visuals.PlayAxis({
                                animator: this.animator,
                                interactivityService: this.interactivityService,
                                isScrollable: !1
                            }), this.playAxis.init(this.options));
                            var playData = this.playAxis.setData(dataView, function(dataView, playFrameInfo) {
                                return ScatterChart.converter(dataView, converterOptions_1, playFrameInfo, _this.tooltipsEnabled);
                            });
                            this.mergeSizeRanges(playData), this.data = playData.currentViewModel, this.playAxis.setRenderFunction(function(data) {
                                return _this.renderAtFrame(data);
                            });
                        } else this.playAxis && (this.playAxis.remove(), this.playAxis = null), dataView.categorical && dataView.categorical.values && (this.data = ScatterChart.converter(dataView, converterOptions_1, void 0, this.tooltipsEnabled));
                    }
                } else this.playAxis && (this.playAxis.remove(), this.playAxis = null);
            }, ScatterChart.prototype.mergeSizeRanges = function(playData) {
                if (playData && playData.currentViewModel) {
                    for (var mergedSizeRange = playData.currentViewModel.sizeRange, _i = 0, _a = playData.allViewModels; _i < _a.length; _i++) {
                        var data_3 = _a[_i], sizeRange = data_3.sizeRange;
                        null != sizeRange.min && (mergedSizeRange.min = Math.min(mergedSizeRange.min, sizeRange.min)), 
                        null != sizeRange.max && (mergedSizeRange.max = Math.max(mergedSizeRange.max, sizeRange.max));
                    }
                    for (var _b = 0, _c = playData.allViewModels; _b < _c.length; _b++) {
                        var data_4 = _c[_b];
                        data_4.sizeRange = mergedSizeRange;
                    }
                }
            }, ScatterChart.prototype.calculateLegend = function() {
                return this.data && this.data.legendData;
            }, ScatterChart.prototype.hasLegend = function() {
                return this.data && this.data.hasDynamicSeries;
            }, ScatterChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                switch (options.objectName) {
                  case "colorByCategory":
                    this.data && (this.data.hasDynamicSeries || enumeration.pushInstance({
                        objectName: "colorByCategory",
                        selector: null,
                        properties: {
                            show: this.data.colorByCategory
                        }
                    }));
                    break;

                  case "dataPoint":
                    if (!this.playAxis) {
                        var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                        if (!visuals.GradientUtils.hasGradientRole(categoricalDataView)) return this.enumerateDataPoints(enumeration);
                    }
                    break;

                  case "categoryAxis":
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            showAxisTitle: this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !0
                        },
                        objectName: "categoryAxis"
                    });
                    break;

                  case "valueAxis":
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            showAxisTitle: this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !0
                        },
                        objectName: "valueAxis"
                    });
                    break;

                  case "categoryLabels":
                    this.data ? visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, !0) : visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, !0);
                    break;

                  case "fillPoint":
                    if (this.hasSizeMeasure()) return;
                    enumeration.pushInstance({
                        objectName: "fillPoint",
                        selector: null,
                        properties: {
                            show: this.data.fillPoint
                        }
                    });
                    break;

                  case "colorBorder":
                    this.hasSizeMeasure() && enumeration.pushInstance({
                        objectName: "colorBorder",
                        selector: null,
                        properties: {
                            show: this.data.colorBorder
                        }
                    });
                }
            }, ScatterChart.prototype.hasSizeMeasure = function() {
                var sizeRange = this.data.sizeRange;
                return sizeRange && void 0 !== sizeRange.min;
            }, ScatterChart.prototype.enumerateDataPoints = function(enumeration) {
                var data = this.data;
                if (data) {
                    var seriesCount = data.dataPoints.length;
                    if (data.hasDynamicSeries) for (var legendDataPointLength = data.legendData.dataPoints.length, i = 0; legendDataPointLength > i; i++) {
                        var series = data.legendData.dataPoints[i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: series.label,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: series.color
                                    }
                                }
                            }
                        });
                    } else {
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            selector: null,
                            properties: {
                                defaultColor: {
                                    solid: {
                                        color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                    }
                                }
                            }
                        }).pushInstance({
                            objectName: "dataPoint",
                            selector: null,
                            properties: {
                                showAllDataPoints: !!data.showAllDataPoints
                            }
                        });
                        for (var i = 0; seriesCount > i; i++) {
                            var seriesDataPoints = data.dataPoints[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: seriesDataPoints.formattedCategory.getValue(),
                                selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), !0),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: seriesDataPoints.fill
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }, ScatterChart.prototype.supportsTrendLine = function() {
                var data = this.data;
                return data ? !this.hasSizeMeasure() && 1 === data.dataPointSeries.length : !1;
            }, ScatterChart.getExtents = function(data) {
                var dps = data.dataPoints;
                return _.isEmpty(dps) ? {
                    minY: 0,
                    maxY: 0,
                    minX: 0,
                    maxX: 0
                } : {
                    minY: d3.min(dps, function(d) {
                        return d.y;
                    }),
                    maxY: d3.max(dps, function(d) {
                        return d.y;
                    }),
                    minX: d3.min(dps, function(d) {
                        return d.x;
                    }),
                    maxX: d3.max(dps, function(d) {
                        return d.x;
                    })
                };
            }, ScatterChart.prototype.calculateAxesProperties = function(options) {
                var data = this.data, viewport = this.currentViewport = options.viewport, margin = options.margin;
                this.currentViewport = viewport, this.margin = margin;
                var width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), extents = {
                    minY: 0,
                    maxY: 10,
                    minX: 0,
                    maxX: 10
                };
                this.playAxis ? (extents = this.playAxis.getCartesianExtents(extents, ScatterChart.getExtents), 
                this.playAxis.setPlayControlPosition(options.playAxisControlLayout)) : _.isEmpty(data.dataPoints) || (extents = ScatterChart.getExtents(data));
                var xDomain = [ extents.minX, extents.maxX ], combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain, options.ensureXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedXDomain,
                    metaDataColumn: data.xCol,
                    formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !1,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !0,
                    scaleType: options.categoryAxisScaleType,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                }), this.xAxisProperties.axis.tickSize(-height, 0), this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ extents.minY, extents.maxY ], options.ensureYDomain);
                return this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: data.yCol,
                    formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: !0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    scaleType: options.valueAxisScaleType,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision
                }), this.yAxisProperties.axisLabel = this.data.axesLabels.y, [ this.xAxisProperties, this.yAxisProperties ];
            }, ScatterChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            }, ScatterChart.prototype.render = function(suppressAnimations, resizeMode) {
                if (this.data) {
                    var data = this.data, margin = this.margin, viewport = this.currentViewport, hasSelection = this.interactivityService && this.interactivityService.hasSelection(), plotArea = {
                        width: viewport.width - (margin.left + margin.right),
                        height: viewport.height - (margin.top + margin.bottom)
                    }, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    this.playAxis && (this.isMobileChart || duration > 0) && (duration = visuals.PlayChart.FrameAnimationDuration);
                    var easeType = this.playAxis ? "linear" : "cubic-in-out", fillMarkers = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint, drawBubbles = this.hasSizeMeasure(), suppressDataPointRendering = 1 === resizeMode && data.dataPoints && data.dataPoints.length > ScatterChart.NoRenderResizeThreshold, viewModel = {
                        data: data,
                        drawBubbles: drawBubbles,
                        isPlay: !!this.playAxis,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        viewport: plotArea,
                        hasSelection: hasSelection,
                        animationDuration: duration,
                        animationOptions: this.options.animation,
                        fillMarkers: fillMarkers,
                        easeType: easeType,
                        suppressDataPointRendering: suppressDataPointRendering
                    };
                    if (drawBubbles) {
                        var sortedData = data.dataPoints.sort(ScatterChart.sortBubbles);
                        viewModel.data = powerbi.Prototype.inherit(viewModel.data), viewModel.data.dataPoints = sortedData;
                    }
                    var labelDataPoints = [];
                    (data.dataLabelsSettings && data.dataLabelsSettings.show || data.dataLabelsSettings.showCategory) && (labelDataPoints = ScatterChartDataLabels.createLabelDataPoints(viewModel));
                    var behaviorOptions = this.renderer.render(viewModel, this.interactivityService);
                    this.isMobileChart && (behaviorOptions = {
                        data: behaviorOptions.data,
                        dataPointsSelection: behaviorOptions.dataPointsSelection,
                        eventGroup: behaviorOptions.eventGroup,
                        plotContext: behaviorOptions.plotContext,
                        host: this.cartesianVisualHost,
                        root: this.svg,
                        visualInitOptions: this.options,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        background: d3.select(this.element.get(0))
                    });
                    var playRenderResult;
                    if (this.playAxis && (playRenderResult = this.playAxis.render(suppressAnimations, viewModel, viewport, margin), 
                    this.interactivityService)) {
                        var playBehaviorOptions = {
                            traceLineRenderer: this.renderer.createTraceLineRenderer(playRenderResult.viewModel)
                        };
                        hasSelection && visuals.PlayChart.renderTraceLines(playRenderResult.allDataPoints, playBehaviorOptions.traceLineRenderer, !suppressAnimations), 
                        behaviorOptions.playOptions = playBehaviorOptions;
                    }
                    return {
                        dataPoints: playRenderResult ? playRenderResult.allDataPoints : data.dataPoints,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: labelDataPoints,
                        labelsAreNumeric: !1
                    };
                }
            }, ScatterChart.getStrokeFill = function(d, colorBorder) {
                if (null != d.size && colorBorder) {
                    var colorRgb = Color.parseColorString(d.fill);
                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                }
                return d.fill;
            }, ScatterChart.getBubblePixelAreaSizeRange = function(viewPort, minSizeRange, maxSizeRange) {
                var ratio = 1;
                if (viewPort.height > 0 && viewPort.width > 0) {
                    var minSize = Math.min(viewPort.height, viewPort.width);
                    ratio = minSize * minSize / ScatterChart.AreaOf300By300Chart;
                }
                var minRange = Math.round(minSizeRange * ratio), maxRange = Math.round(maxSizeRange * ratio);
                return {
                    minRange: minRange,
                    maxRange: maxRange,
                    delta: maxRange - minRange
                };
            }, ScatterChart.project = function(value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                if (0 === actualSizeDataRange.delta || 0 === bubblePixelAreaSizeRange.delta) return ScatterChart.rangeContains(actualSizeDataRange, value) ? bubblePixelAreaSizeRange.minRange : null;
                var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
            }, ScatterChart.projectSizeToPixels = function(size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                var projectedSize = 0;
                if (actualSizeDataRange) {
                    if (projectedSize = bubblePixelAreaSizeRange.maxRange, 0 !== actualSizeDataRange.delta) {
                        var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                        projectedSize = ScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                    }
                    projectedSize = 2 * Math.sqrt(projectedSize / Math.PI);
                }
                return Math.round(projectedSize);
            }, ScatterChart.rangeContains = function(range, value) {
                return range.minRange <= value && value <= range.maxRange;
            }, ScatterChart.getMarkerFillOpacity = function(hasSize, shouldEnableFill, hasSelection, isSelected) {
                return hasSize || shouldEnableFill ? hasSelection && !isSelected ? ScatterChart.DimmedBubbleOpacity : ScatterChart.DefaultBubbleOpacity : 0;
            }, ScatterChart.getMarkerStrokeOpacity = function(hasSize, colorBorder, hasSelection, isSelected) {
                return hasSize && colorBorder ? 1 : hasSelection && !isSelected ? ScatterChart.DimmedBubbleOpacity : ScatterChart.DefaultBubbleOpacity;
            }, ScatterChart.getMarkerStrokeFill = function(hasSize, colorBorder, fill) {
                if (hasSize && colorBorder) {
                    var colorRgb = Color.parseColorString(fill);
                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                }
                return fill;
            }, ScatterChart.getMarkerStyle = function(d, colorBorder, hasSelection, fillMarkers) {
                return {
                    "stroke-opacity": ScatterChart.getMarkerStrokeOpacity(null != d.size, colorBorder, hasSelection, d.selected),
                    "stroke-width": "1",
                    stroke: ScatterChart.getMarkerStrokeFill(null != d.size, colorBorder, d.fill),
                    fill: d.fill,
                    "fill-opacity": ScatterChart.getMarkerFillOpacity(null != d.size, fillMarkers, hasSelection, d.selected)
                };
            }, ScatterChart.getSeriesStyle = function(hasSize, colorBorder, hasSelection, fillMarkers, fill) {
                return {
                    "stroke-opacity": ScatterChart.getMarkerStrokeOpacity(hasSize, colorBorder, hasSelection, !1),
                    "stroke-width": "1",
                    stroke: ScatterChart.getMarkerStrokeFill(hasSize, colorBorder, fill),
                    fill: fill,
                    "fill-opacity": ScatterChart.getMarkerFillOpacity(hasSize, fillMarkers, hasSelection, !1)
                };
            }, ScatterChart.getBubbleOpacity = function(d, hasSelection) {
                return hasSelection && !d.selected ? ScatterChart.DimmedBubbleOpacity : ScatterChart.DefaultBubbleOpacity;
            }, ScatterChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, ScatterChart.prototype.getSupportedCategoryAxisType = function() {
                return visuals.axisType.scalar;
            }, ScatterChart.sortBubbles = function(a, b) {
                var diff = b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index];
                return 0 !== diff ? diff : b.identity.getKey().localeCompare(a.identity.getKey());
            }, ScatterChart.BubbleRadius = 6, ScatterChart.DefaultBubbleOpacity = .85, ScatterChart.DimmedBubbleOpacity = .4, 
            ScatterChart.StrokeDarkenColorValue = 63.75, ScatterChart.dataLabelLayoutStartingOffset = 2, 
            ScatterChart.dataLabelLayoutOffsetIterationDelta = 6, ScatterChart.dataLabelLayoutMaximumOffset = ScatterChart.dataLabelLayoutStartingOffset + 2 * ScatterChart.dataLabelLayoutOffsetIterationDelta, 
            ScatterChart.AreaOf300By300Chart = 9e4, ScatterChart.MinSizeRange = 200, ScatterChart.MaxSizeRange = 3e3, 
            ScatterChart.ClassName = "scatterChart", ScatterChart.NoAnimationThreshold = 1e3, 
            ScatterChart.NoRenderResizeThreshold = 1e3, ScatterChart;
        }();
        visuals.ScatterChart = ScatterChart;
        var ScatterChartDataLabels, SvgRenderer = function() {
            function SvgRenderer() {}
            return SvgRenderer.prototype.init = function(element, labelsContext, isMobileChart, tooltipsEnabled) {
                this.mainGraphicsG = element.append("g").classed(SvgRenderer.MainGraphicsContext["class"], !0), 
                this.isMobileChart = isMobileChart, isMobileChart && (this.mainGraphicsBackgroundRect = this.mainGraphicsG.append("rect").classed("backgroundRect", !0).attr({
                    width: "100%",
                    height: "100%"
                })), this.mainGraphicsContext = this.mainGraphicsG.append("svg"), this.labelGraphicsContext = labelsContext, 
                this.tooltipsEnabled = tooltipsEnabled;
            }, SvgRenderer.prototype.render = function(viewModel, interactivityService) {
                var viewport = viewModel.viewport;
                this.mainGraphicsContext.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                var scatterMarkers;
                return scatterMarkers = viewModel.suppressDataPointRendering ? this.removeScatterMarkers() : viewModel.animationDuration > 0 && viewModel.data.dataPoints.length <= ScatterChart.NoAnimationThreshold ? this.drawScatterMarkers(viewModel) : this.drawScatterMarkersNoAnimation(viewModel, viewModel.drawBubbles), 
                viewModel.drawBubbles && scatterMarkers.order(), this.tooltipsEnabled && visuals.TooltipManager.addTooltip(this.mainGraphicsContext, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(viewModel.animationOptions), {
                    dataPointsSelection: scatterMarkers,
                    eventGroup: this.mainGraphicsG,
                    data: viewModel.data,
                    plotContext: this.mainGraphicsContext
                };
            }, SvgRenderer.prototype.createTraceLineRenderer = function(viewModel) {
                return new ScatterTraceLineRenderer(viewModel, this.mainGraphicsContext, this.tooltipsEnabled);
            }, SvgRenderer.prototype.removeScatterMarkers = function() {
                return this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).remove(), 
                this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
            }, SvgRenderer.prototype.drawScatterMarkers = function(viewModel) {
                var data = viewModel.data, xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, fakeDataPointSeries = [ {
                    identityKey: "",
                    dataPoints: data.dataPoints
                } ], fakeSeriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(fakeDataPointSeries, function(s) {
                    return s.identityKey;
                });
                fakeSeriesGroups.enter().append("g").classed(SvgRenderer.ScatterMarkerSeriesGroup["class"], !0), 
                fakeSeriesGroups.exit().remove();
                var markers = fakeSeriesGroups.selectAll(SvgRenderer.DotClass.selector).data(function(s) {
                    return s.dataPoints;
                }, function(d) {
                    return d.identity.getKey();
                });
                return markers.enter().append("circle").classed(SvgRenderer.DotClass["class"], !0).style("opacity", 0).attr("r", 0), 
                markers.style({
                    "stroke-opacity": function(d) {
                        return ScatterChart.getMarkerStrokeOpacity(null != d.size, data.colorBorder, viewModel.hasSelection, d.selected);
                    },
                    "stroke-width": "1px",
                    stroke: function(d) {
                        return ScatterChart.getStrokeFill(d, data.colorBorder);
                    },
                    fill: function(d) {
                        return d.fill;
                    },
                    "fill-opacity": function(d) {
                        return ScatterChart.getMarkerFillOpacity(null != d.size, viewModel.fillMarkers, viewModel.hasSelection, d.selected);
                    }
                }).transition().ease(viewModel.easeType).duration(viewModel.animationDuration).style("opacity", 1).attr({
                    r: function(d) {
                        return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport);
                    },
                    cx: function(d) {
                        return xScale(d.x);
                    },
                    cy: function(d) {
                        return yScale(d.y);
                    }
                }), markers.exit().transition().ease(viewModel.easeType).duration(viewModel.animationDuration).style("opacity", 0).attr("r", 0).remove(), 
                markers;
            }, SvgRenderer.prototype.drawScatterMarkersNoAnimation = function(viewModel, isBubble) {
                var seriesGroups, data = viewModel.data, xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale;
                if (isBubble) {
                    var fakeDataPointSeries = [ {
                        identityKey: "",
                        dataPoints: data.dataPoints
                    } ];
                    seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(fakeDataPointSeries, function(s) {
                        return s.identityKey;
                    });
                } else seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(data.dataPointSeries, function(s) {
                    return s.identityKey;
                });
                return seriesGroups.enter().append("g").classed(SvgRenderer.ScatterMarkerSeriesGroup["class"], !0), 
                seriesGroups.exit().remove(), seriesGroups.each(function(s) {
                    var seriesStyle = ScatterChart.getSeriesStyle(s.hasSize, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers, s.fill), g = d3.select(this);
                    SvgRenderer.applyStyle(this, seriesStyle);
                    var markers = g.selectAll(SvgRenderer.DotClass.selector).data(s.dataPoints, function(m) {
                        return m.identity.getKey();
                    });
                    markers.enter().append("circle").classed(SvgRenderer.DotClass["class"], !0), markers.exit().remove(), 
                    markers.each(function(d) {
                        var style = ScatterChart.getMarkerStyle(d, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers);
                        SvgRenderer.styleException(style, seriesStyle), SvgRenderer.applyStyle(this, style);
                    }), markers.attr({
                        r: function(d) {
                            return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport);
                        },
                        cx: function(d) {
                            return xScale(d.x);
                        },
                        cy: function(d) {
                            return yScale(d.y);
                        }
                    });
                }), this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
            }, SvgRenderer.styleException = function(elementStyle, seriesStyle) {
                if (seriesStyle) for (var name_1 in elementStyle) elementStyle[name_1] === seriesStyle[name_1] && (elementStyle[name_1] = null);
            }, SvgRenderer.applyStyle = function(element, style) {
                for (var name_2 in style) {
                    var elementValue = element.style[name_2], styleValue = style[name_2];
                    if (null == styleValue) {
                        if ("" === elementValue) continue;
                    } else if (styleValue = styleValue.toString(), styleValue === elementValue) continue;
                    element.style[name_2] = styleValue;
                }
            }, SvgRenderer.DotClass = createClassAndSelector("dot"), SvgRenderer.MainGraphicsContext = createClassAndSelector("mainGraphicsContext"), 
            SvgRenderer.ScatterMarkerSeriesGroup = createClassAndSelector("scatterMarkerSeriesGroup"), 
            SvgRenderer;
        }();
        !function(ScatterChartDataLabels) {
            function createLabelDataPoints(viewModel) {
                for (var xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, sizeRange = viewModel.data.sizeRange, labelDataPoints = [], dataPoints = viewModel.data.dataPoints, labelSettings = viewModel.data.dataLabelsSettings, preferredLabelsKeys = getPreferredLabelsKeys(viewModel), _i = 0, dataPoints_4 = dataPoints; _i < dataPoints_4.length; _i++) {
                    var dataPoint = dataPoints_4[_i], text = dataPoint.formattedCategory.getValue(), properties = {
                        text: text,
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                    }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    labelDataPoints.push({
                        isPreferred: preferredLabelsKeys ? isLabelPreferred(dataPoint.identity.getKey(), preferredLabelsKeys) : !1,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight
                        },
                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 0,
                        parentShape: {
                            point: {
                                x: xScale(dataPoint.x),
                                y: yScale(dataPoint.y)
                            },
                            radius: ScatterChart.getBubbleRadius(dataPoint.radius, sizeRange, viewModel.viewport),
                            validPositions: validLabelPositions
                        },
                        identity: dataPoint.identity,
                        fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                    });
                }
                return labelDataPoints;
            }
            function getPreferredLabelsKeys(viewModel) {
                var width = viewModel.viewport.width, height = viewModel.viewport.height, visualCenter = new visuals.Point(width / 2, height / 2), quadrantsCenters = getQuadrantsCenters(width, height);
                return getCandidateLabels(visualCenter, quadrantsCenters, viewModel);
            }
            function getQuadrantsCenters(visualWidth, visualHeight) {
                var quadrantsCenters = [], quarterWidth = visualWidth / 4, quarterHeight = visualHeight / 4;
                return quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight)), quadrantsCenters.push(new visuals.Point(3 * quarterWidth, quarterHeight)), 
                quadrantsCenters.push(new visuals.Point(quarterWidth, 3 * quarterHeight)), quadrantsCenters.push(new visuals.Point(3 * quarterWidth, 3 * quarterHeight)), 
                quadrantsCenters;
            }
            function getCandidateLabels(visualCenter, quadrantsCenters, viewModel) {
                for (var distance, minDistances = [ Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE ], ids = [], xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, _i = 0, _a = viewModel.data.dataPoints; _i < _a.length; _i++) {
                    var dp = _a[_i], x = xScale(dp.x), y = yScale(dp.y), quadrantNumber = getPointQuadrantNumber(x, y, visualCenter);
                    viewModel.drawBubbles ? ids[quadrantNumber] || (ids[quadrantNumber] = dp.identity) : (distance = getDistanceBetweenPoints(quadrantsCenters[quadrantNumber].x, quadrantsCenters[quadrantNumber].y, x, y), 
                    distance < minDistances[quadrantNumber] && (ids[quadrantNumber] = dp.identity, minDistances[quadrantNumber] = distance));
                }
                for (var preferredLabelsKeys = [], _b = 0, ids_1 = ids; _b < ids_1.length; _b++) {
                    var id = ids_1[_b];
                    id && preferredLabelsKeys.push(id.getKey());
                }
                return preferredLabelsKeys;
            }
            function getPointQuadrantNumber(x, y, centerPoint) {
                return x > centerPoint.x && y <= centerPoint.y ? 0 : x <= centerPoint.x && y <= centerPoint.y ? 1 : x <= centerPoint.x && y > centerPoint.y ? 2 : 3;
            }
            function getDistanceBetweenPoints(x1, y1, x2, y2) {
                return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            }
            function isLabelPreferred(key, preferredLabelsKeys) {
                for (var _i = 0, preferredLabelsKeys_1 = preferredLabelsKeys; _i < preferredLabelsKeys_1.length; _i++) {
                    var preferredLabel = preferredLabelsKeys_1[_i];
                    if (0 === key.localeCompare(preferredLabel)) return !0;
                }
                return !1;
            }
            var validLabelPositions = [ 2, 1, 8, 4, 16, 32, 64, 128 ];
            ScatterChartDataLabels.createLabelDataPoints = createLabelDataPoints;
        }(ScatterChartDataLabels || (ScatterChartDataLabels = {}));
        var ScatterTraceLineRenderer = function() {
            function ScatterTraceLineRenderer(viewModel, element, tooltipsEnabled) {
                this.viewModel = viewModel, this.element = element, this.tooltipsEnabled = tooltipsEnabled;
            }
            return ScatterTraceLineRenderer.prototype.remove = function() {
                this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector).remove(), this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector).remove();
            }, ScatterTraceLineRenderer.prototype.render = function(selectedPoints, shouldAnimate) {
                var viewModel = this.viewModel, scatterViewModel = viewModel.viewModel, seriesPoints = [];
                if (_.isEmpty(selectedPoints) || scatterViewModel.suppressDataPointRendering) this.remove(); else {
                    for (var currentFrameIndex_1 = viewModel.data.currentFrameIndex, hasBubbleAtCurrentFrame = [], selectedIndex = 0, selectedLen = selectedPoints.length; selectedLen > selectedIndex; selectedIndex++) {
                        seriesPoints[selectedIndex] = [], hasBubbleAtCurrentFrame[selectedIndex] = !1;
                        for (var frameIndex = 0, frameLen = viewModel.data.allViewModels.length; frameLen > frameIndex && currentFrameIndex_1 >= frameIndex; frameIndex++) {
                            var value = _.find(viewModel.data.allViewModels[frameIndex].dataPoints, function(value, index) {
                                return value.identity.getKey() === selectedPoints[selectedIndex].identity.getKey();
                            });
                            null != value && (value.frameIndex = frameIndex, seriesPoints[selectedIndex].push(value), 
                            frameIndex === currentFrameIndex_1 && (hasBubbleAtCurrentFrame[selectedIndex] = !0));
                        }
                    }
                    var xScale_1 = scatterViewModel.xAxisProperties.scale, yScale_1 = scatterViewModel.yAxisProperties.scale, line_1 = d3.svg.line().x(function(d) {
                        return xScale_1(d.x);
                    }).y(function(d) {
                        return yScale_1(d.y);
                    }).defined(function(d) {
                        return null !== d.x && null !== d.y;
                    }), traceLines = this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector).data(selectedPoints, function(sp) {
                        return sp.identity.getKey();
                    });
                    traceLines.enter().append("path").classed(ScatterTraceLineRenderer.TraceLine["class"], !0);
                    var previousLengths_1 = [], newLengths_1 = [], reverse_1 = !1;
                    traceLines.each(function(d, i) {
                        var existingPath = this, previousLength = existingPath.hasAttribute("d") ? existingPath.getTotalLength() : 0;
                        previousLengths_1.push(previousLength);
                        var tempSvgPath = $("<svg><path></path></svg>"), tempPath = $("path", tempSvgPath);
                        tempPath.attr("d", line_1(seriesPoints[i]));
                        var newLength = seriesPoints[i].length > 0 ? tempPath.get()[0].getTotalLength() : 0;
                        newLengths_1.push(newLength), reverse_1 = reverse_1 || previousLength > newLength;
                    }), reverse_1 ? shouldAnimate ? traceLines.transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).attr("stroke-dashoffset", function(d, i) {
                        return previousLengths_1[i] - newLengths_1[i];
                    }).transition().ease("linear").duration(1).delay(visuals.PlayChart.FrameAnimationDuration).style("stroke", function(d) {
                        return ScatterChart.getStrokeFill(d, !0);
                    }).attr({
                        d: function(d, i) {
                            return line_1(seriesPoints[i]);
                        },
                        "stroke-dasharray": function(d, i) {
                            return newLengths_1[i] + " " + newLengths_1[i];
                        },
                        "stroke-dashoffset": 0
                    }) : traceLines.style("stroke", function(d) {
                        return ScatterChart.getStrokeFill(d, !0);
                    }).attr({
                        d: function(d, i) {
                            return line_1(seriesPoints[i]);
                        },
                        "stroke-dasharray": function(d, i) {
                            return newLengths_1[i] + " " + newLengths_1[i];
                        },
                        "stroke-dashoffset": 0
                    }) : (traceLines.style("stroke", function(d) {
                        return ScatterChart.getStrokeFill(d, !0);
                    }).attr({
                        d: function(d, i) {
                            return line_1(seriesPoints[i]);
                        },
                        "stroke-dasharray": function(d, i) {
                            return newLengths_1[i] + " " + newLengths_1[i];
                        },
                        "stroke-dashoffset": function(d, i) {
                            return newLengths_1[i] - previousLengths_1[i];
                        }
                    }), shouldAnimate ? traceLines.transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).attr("stroke-dashoffset", 0) : traceLines.attr("stroke-dashoffset", 0)), 
                    traceLines.exit().remove();
                    for (var circlePoints = [], selectedIndex_1 = 0; selectedIndex_1 < seriesPoints.length; selectedIndex_1++) {
                        var points = seriesPoints[selectedIndex_1], newPoints = hasBubbleAtCurrentFrame[selectedIndex_1] ? points.slice(0, points.length - 1) : points;
                        circlePoints = circlePoints.concat(newPoints);
                    }
                    var circles = this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector).data(circlePoints, function(d) {
                        return d.identity.getKey() + d.x + d.y + d.size;
                    });
                    circles.enter().append("circle").style("opacity", 0).classed(ScatterTraceLineRenderer.TraceBubble["class"], !0), 
                    circles.attr("cx", function(d) {
                        return xScale_1(d.x);
                    }).attr("cy", function(d) {
                        return yScale_1(d.y);
                    }).attr("r", function(d) {
                        return ScatterChart.getBubbleRadius(d.radius, viewModel.data.currentViewModel.sizeRange, viewModel.viewport);
                    }).style({
                        "stroke-opacity": function(d) {
                            return ScatterChart.getBubbleOpacity(d, !0);
                        },
                        "stroke-width": "1px",
                        stroke: function(d) {
                            return ScatterChart.getStrokeFill(d, viewModel.data.currentViewModel.colorBorder);
                        },
                        fill: function(d) {
                            return d.fill;
                        },
                        "fill-opacity": function(d) {
                            return null != d.size ? .2 + d.frameIndex / currentFrameIndex_1 * .6 : 0;
                        }
                    }).transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).style("opacity", 1), 
                    circles.exit().transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).style("opacity", 0).remove(), 
                    this.tooltipsEnabled && visuals.TooltipManager.addTooltip(circles, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }), circles.sort(function(d1, d2) {
                        return d2.size - d1.size;
                    });
                }
            }, ScatterTraceLineRenderer.TraceLine = createClassAndSelector("traceLine"), ScatterTraceLineRenderer.TraceBubble = createClassAndSelector("traceBubble"), 
            ScatterTraceLineRenderer;
        }();
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, DataViewMatrixUtils = powerbi.data.utils.DataViewMatrixUtils, PlayAxis = function() {
            function PlayAxis(options) {
                options && (this.interactivityService = options.interactivityService);
            }
            return PlayAxis.prototype.init = function(options) {
                var _this = this;
                this.element = options.element, this.svg = options.svg, this.host = options.host, 
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                this.interactivityService && (this.playControl = new PlayControl(this.element, function(frameIndex) {
                    return _this.moveToFrameAndRender(frameIndex);
                }, this.isMobileChart), this.playControl.onPlay(function() {
                    return _this.play();
                }));
            }, PlayAxis.prototype.setData = function(dataView, visualConverter) {
                if (dataView) {
                    if (this.ridiculousFlagForPersistProperties && dataView.metadata) return this.ridiculousFlagForPersistProperties = !1, 
                    this.playData;
                    dataView.matrix || dataView.categorical ? this.playData = PlayChart.converter(dataView, visualConverter) : this.playData = PlayChart.getDefaultPlayData();
                } else this.playData = PlayChart.getDefaultPlayData();
                return this.lastViewport = void 0, this.playData;
            }, PlayAxis.prototype.render = function(suppressAnimations, viewModel, viewport, margin) {
                var playData = this.playData, resized = !this.lastViewport || this.lastViewport.height !== viewport.height || this.lastViewport.width !== viewport.width;
                if (this.lastViewport = viewport, resized && this.stop(), playData) {
                    var playViewModel = {
                        data: this.playData,
                        viewModel: viewModel,
                        viewport: viewport
                    }, hasSelection = !1;
                    if (this.interactivityService) {
                        var data_5 = playData.currentViewModel;
                        this.interactivityService.applySelectionStateToData(data_5.dataPoints), hasSelection = this.interactivityService.hasSelection();
                    }
                    this.updateCallout(viewport, margin), this.playControl && resized && this.playControl.rebuild(playData, viewport);
                    var allDataPoints = playData.allViewModels.map(function(vm) {
                        return vm.dataPoints;
                    }), flatAllDataPoints = _.flatten(allDataPoints);
                    return {
                        allDataPoints: flatAllDataPoints,
                        viewModel: playViewModel
                    };
                }
            }, PlayAxis.prototype.updateCallout = function(viewport, margin) {
                var playData = this.playData, frameKeys = playData.frameKeys, currentFrameIndex = playData.currentFrameIndex, height = viewport.height, plotAreaHeight = height - margin.top - margin.bottom, width = viewport.width, plotAreaWidth = width - margin.left - margin.right, calloutDimension = Math.min(height, 1.3 * width), fontSize = Math.max(12, Math.round(calloutDimension / 7));
                fontSize = Math.min(fontSize, 70);
                var textProperties = {
                    fontSize: jsCommon.PixelConverter.toString(fontSize),
                    text: frameKeys[currentFrameIndex] || "",
                    fontFamily: "wf_segoe-ui_normal"
                }, textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties), calloutData = [];
                if (currentFrameIndex < frameKeys.length && currentFrameIndex >= 0 && plotAreaHeight > textHeight) {
                    var maxTextWidth = plotAreaWidth - 2 * PlayAxis.calloutOffsetMultiplier * textHeight, calloutText = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextWidth);
                    calloutData = [ calloutText ];
                }
                var callout = this.svg.selectAll(PlayAxis.PlayCallout.selector).data(calloutData);
                callout.enter().append("text").classed(PlayAxis.PlayCallout["class"], !0), callout.text(function(d) {
                    return d;
                }).attr({
                    x: plotAreaWidth - PlayAxis.calloutOffsetMultiplier * textHeight,
                    y: function() {
                        return textHeight;
                    }
                }).style({
                    "font-size": fontSize + "px",
                    "text-anchor": "end"
                }), callout.exit().remove();
            }, PlayAxis.prototype.play = function() {
                var playData = this.playData;
                if (this.isPlaying) this.stop(); else if (this.playControl) {
                    this.isPlaying = !0, this.playControl.play();
                    var indexToShow = Math.round(this.playControl.getCurrentIndex());
                    indexToShow >= playData.allViewModels.length - 1 ? playData.currentFrameIndex = -1 : playData.currentFrameIndex = indexToShow - 1, 
                    this.playNextFrame(playData);
                }
            }, PlayAxis.prototype.playNextFrame = function(playData, startFrame, endFrame) {
                var _this = this;
                if (!this.isPlaying) return void this.stop();
                var nextFrame = playData.currentFrameIndex + 1;
                null != startFrame && null != endFrame && (nextFrame = Math.abs(endFrame - startFrame + 1), 
                startFrame = nextFrame), nextFrame < playData.allViewModels.length && nextFrame > -1 ? (playData.currentFrameIndex = nextFrame, 
                playData.currentViewModel = playData.allViewModels[nextFrame], this.renderDelegate(playData.currentViewModel), 
                this.playControl.setFrame(nextFrame), nextFrame < playData.allViewModels.length && window.setTimeout(function() {
                    _this.playNextFrame(playData, startFrame, endFrame);
                }, PlayChart.FrameStepDuration)) : this.stop();
            }, PlayAxis.prototype.stop = function() {
                this.playControl && this.playControl.pause(), this.isPlaying = !1;
            }, PlayAxis.prototype.remove = function() {
                this.playControl && this.playControl.remove(), d3.selectAll(PlayAxis.PlayCallout.selector).remove();
            }, PlayAxis.prototype.setRenderFunction = function(fn) {
                this.renderDelegate = fn;
            }, PlayAxis.prototype.getCartesianExtents = function(existingExtents, getExtents) {
                return this.playData && this.playData.allViewModels && this.playData.allViewModels.length > 0 ? PlayChart.getMinMaxForAllFrames(this.playData, getExtents) : existingExtents;
            }, PlayAxis.prototype.setPlayControlPosition = function(playControlLayout) {
                if (this.playControl) {
                    var container = this.playControl.getContainer();
                    container.css("left", playControlLayout.left ? playControlLayout.left + "px" : ""), 
                    container.css("top", playControlLayout.top ? playControlLayout.top + "px" : "");
                }
            }, PlayAxis.prototype.moveToFrameAndRender = function(frameIndex) {
                var playData = this.playData;
                if (this.isPlaying = !1, playData && frameIndex >= 0 && frameIndex < playData.allViewModels.length && frameIndex !== playData.currentFrameIndex) {
                    playData.currentFrameIndex = frameIndex;
                    var data_6 = playData.allViewModels[frameIndex];
                    playData.currentViewModel = data_6, this.renderDelegate(data_6);
                }
            }, PlayAxis.PlayCallout = createClassAndSelector("play-callout"), PlayAxis.calloutOffsetMultiplier = .3, 
            PlayAxis;
        }();
        visuals.PlayAxis = PlayAxis;
        var PlayChart, PlayControl = function() {
            function PlayControl(element, renderDelegate, isMobileChart) {
                this.isMobileChart = isMobileChart, this.createSliderDOM(element), this.renderDelegate = renderDelegate;
            }
            return PlayControl.prototype.getContainer = function() {
                return this.playAxisContainer;
            }, PlayControl.prototype.remove = function() {
                this.playAxisContainer && this.playAxisContainer.remove();
            }, PlayControl.prototype.pause = function() {
                this.playButton.removeClass("pause").addClass("play");
            }, PlayControl.prototype.play = function() {
                this.playButton.removeClass("play").addClass("pause");
            }, PlayControl.prototype.getCurrentIndex = function() {
                return Math.round(this.noUiSlider.get());
            }, PlayControl.prototype.onPlay = function(handler) {
                this.playButtonCircle.off("click"), this.playButtonCircle.on("click", handler);
            }, PlayControl.calculateSliderWidth = function(labelData, viewportWidth) {
                var leftMargin = 0, rightMargin = 0;
                _.isEmpty(labelData.labelInfo) || (leftMargin = _.first(labelData.labelInfo).labelWidth / 2, 
                rightMargin = _.last(labelData.labelInfo).labelWidth / 2);
                var sliderLeftMargin = Math.max(leftMargin, PlayControl.SliderMarginLeft), sliderRightMargin = Math.max(rightMargin, PlayControl.SliderMarginRight);
                sliderLeftMargin = Math.min(PlayControl.SliderMaxMargin, sliderLeftMargin), sliderRightMargin = Math.min(PlayControl.SliderMaxMargin, sliderRightMargin);
                var sliderWidth = Math.max(viewportWidth - sliderLeftMargin - sliderRightMargin, 1);
                return sliderWidth;
            }, PlayControl.prototype.createSliderDOM = function(element) {
                this.playAxisContainer = $('<div class="play-axis-container"></div>').appendTo(element).css("height", PlayControl.PlayControlHeight + "px"), 
                this.playButtonCircle = $('<div class="button-container"></div>').appendTo(this.playAxisContainer), 
                this.isMobileChart && this.playButtonCircle.addClass("mobile-button-container"), 
                this.playButton = $('<div class="play"></div>').appendTo(this.playButtonCircle), 
                this.slider = $('<div class="sliders"></div>').appendTo(this.playAxisContainer);
            }, PlayControl.prototype.rebuild = function(playData, viewport) {
                var _this = this, slider = this.slider;
                this.noUiSlider && this.noUiSlider.destroy();
                var sliderElement = this.slider.get(0), labelData = playData.labelData, sliderWidth = PlayControl.calculateSliderWidth(labelData, viewport.width);
                this.slider.css("width", sliderWidth + "px");
                var numFrames = playData.frameKeys.length;
                if (numFrames > 0) {
                    var filterPipLabels = PlayChart.createPipsFilterFn(playData, sliderWidth, labelData), lastIndex = numFrames - 1;
                    noUiSlider.create(sliderElement, {
                        step: 1,
                        start: [ playData.currentFrameIndex ],
                        range: {
                            min: [ 0 ],
                            max: [ lastIndex ]
                        },
                        pips: {
                            mode: "steps",
                            density: Math.round(100 / numFrames),
                            format: {
                                to: function(index) {
                                    return playData.frameKeys[index];
                                },
                                from: function(value) {
                                    return playData.frameKeys.indexOf(value);
                                }
                            },
                            filter: filterPipLabels
                        }
                    });
                } else noUiSlider.create(sliderElement, {
                    step: 1,
                    start: [ 0 ],
                    range: {
                        min: [ 0 ],
                        max: [ 0 ]
                    }
                });
                this.noUiSlider = sliderElement.noUiSlider, this.noUiSlider.on("slide", function() {
                    var indexToShow = _this.getCurrentIndex();
                    _this.renderDelegate(indexToShow);
                }), $(".noUi-value", slider).each(function(idx, elem) {
                    var actualWidth = labelData.labelInfo.filter(function(l) {
                        return l.label === $(elem).text();
                    })[0].labelWidth;
                    $(elem).width(actualWidth), $(elem).css("margin-left", -actualWidth / 2 + "px");
                }), this.isMobileChart && $(".noUi-handle").addClass("mobile-noUi-handle");
            }, PlayControl.prototype.setFrame = function(frameIndex) {
                this.noUiSlider.set([ frameIndex ]);
            }, PlayControl.SliderMarginLeft = 44, PlayControl.SliderMarginRight = 20, PlayControl.SliderMaxMargin = 100, 
            PlayControl.PlayControlHeight = 80, PlayControl;
        }();
        !function(PlayChart) {
            function convertMatrixToCategorical(matrix, frame) {
                var categorical = {
                    categories: [],
                    values: powerbi.data.DataViewTransform.createValueColumns()
                };
                if (_.isEmpty(matrix.columns.levels) || matrix.rows.levels.length < 2 && matrix.columns.levels.length < 2) return categorical;
                var categorySource = matrix.rows.levels.length > 1 && !_.isEmpty(_.last(matrix.rows.levels).sources) ? _.last(matrix.rows.levels).sources[0] : null, category = {
                    source: categorySource,
                    values: [],
                    objects: void 0,
                    identity: []
                }, hasRowChildren = !_.isEmpty(matrix.rows.root.children), hasColChildren = !_.isEmpty(matrix.columns.root.children), hasSeries = matrix.columns.levels.length > 1 && hasColChildren, hasPlayAndCategory = matrix.rows.levels.length > 1 && hasRowChildren;
                if (hasSeries && !hasPlayAndCategory) {
                    categorical.categories = void 0;
                    var node_1 = matrix.columns.root;
                    categorical.values.source = matrix.columns.levels[0].sources[0];
                    for (var columnLength_1 = matrix.valueSources.length, i = 0, len = node_1.children.length; len > i; i++) for (var columnNode = node_1.children[i], j = 0; columnLength_1 > j; j++) {
                        var source = _.create(matrix.valueSources[j], {
                            groupName: void 0 === columnNode.value ? null : columnNode.value
                        }), dataViewColumn = {
                            identity: columnNode.identity,
                            values: [],
                            source: source
                        };
                        categorical.values.push(dataViewColumn);
                    }
                    var categoryFrameRootNode = matrix.rows.root.children[frame];
                    DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function(leafNode, leafNodeIndex) {
                        for (var i = 0, len = node_1.children.length; len > i; i++) for (var j = 0; columnLength_1 > j; j++) categorical.values[i * columnLength_1 + j].values.push(leafNode.values[i * columnLength_1 + j].value);
                    });
                } else if (hasSeries && hasRowChildren) {
                    var categoryFrameRootNode = matrix.rows.root.children[frame];
                    DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function(leafNode) {
                        category.identity.push(leafNode.identity), category.values.push(leafNode.value);
                    }), categorical.categories.push(category), categorical.values.source = matrix.columns.levels[0].sources[0];
                    for (var nodeQueue = [], columnNode = matrix.columns.root, seriesIndex_1 = -1; columnNode; ) {
                        if (columnNode.children && columnNode.children[0].children) for (var j = 0, jlen = columnNode.children.length; jlen > j; j++) nodeQueue.push(columnNode.children[j]); else if (columnNode.children && categoryFrameRootNode.children) {
                            for (var columnLength = columnNode.children.length, j = 0; columnLength > j; j++) {
                                var source = _.create(matrix.valueSources[j], {
                                    groupName: columnNode.value
                                }), dataViewColumn = {
                                    identity: columnNode.identity,
                                    values: [],
                                    source: source
                                };
                                categorical.values.push(dataViewColumn);
                            }
                            DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function(leafNode) {
                                for (var j = 0; columnLength > j; j++) categorical.values[seriesIndex_1 * columnLength + j].values.push(leafNode.values[seriesIndex_1 * columnLength + j].value);
                            });
                        }
                        nodeQueue.length > 0 ? (columnNode = nodeQueue[0], nodeQueue = nodeQueue.splice(1), 
                        seriesIndex_1++) : columnNode = void 0;
                    }
                } else if (hasPlayAndCategory) {
                    for (var categoryFrameRootNode = matrix.rows.root.children[frame], measureLength_1 = matrix.valueSources.length, j = 0; measureLength_1 > j; j++) {
                        var dataViewColumn = {
                            identity: void 0,
                            values: [],
                            source: matrix.valueSources[j]
                        };
                        categorical.values.push(dataViewColumn);
                    }
                    DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function(leafNode) {
                        category.identity.push(leafNode.identity), category.values.push(leafNode.value);
                        for (var j = 0; measureLength_1 > j; j++) categorical.values[j].values.push(leafNode.values[j].value);
                    }), categorical.categories.push(category);
                }
                return categorical;
            }
            function getObjectProperties(dataViewMetadata, dataLabelsSettings) {
                var objectProperties = {};
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    objectProperties.currentFrameIndex = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.currentFrameIndex.index, null);
                }
                return objectProperties;
            }
            function buildDataViewForFrame(metadata, categorical) {
                return {
                    metadata: metadata,
                    categorical: categorical
                };
            }
            function converter(dataView, visualConverter) {
                var keySourceColumn, dataViewMetadata = dataView.metadata, dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), objectProperties = getObjectProperties(dataViewMetadata, dataLabelsSettings), allViewModels = [], frameKeys = [], convertedData = void 0, matrixRows = dataView.matrix.rows, rowChildrenLength = matrixRows.root.children ? matrixRows.root.children.length : 0;
                if (dataView.matrix && rowChildrenLength > 0 && !_.isEmpty(matrixRows.levels) && !_.isEmpty(matrixRows.levels[0].sources)) {
                    keySourceColumn = matrixRows.levels[0].sources[0];
                    var formatString = visuals.valueFormatter.getFormatString(keySourceColumn, visuals.scatterChartProps.general.formatString), keyFormatter = void 0;
                    if (keySourceColumn.type.numeric) {
                        var valueRange = Math.abs(matrixRows.root.children[rowChildrenLength - 1].value - matrixRows.root.children[0].value);
                        keyFormatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: valueRange,
                            value2: 0
                        });
                    } else keyFormatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0);
                    for (var i = 0, len = rowChildrenLength; len > i; i++) {
                        var key = matrixRows.root.children[i], frameLabel = keyFormatter.format(key.value);
                        frameKeys.push(frameLabel);
                        var dataViewCategorical = convertMatrixToCategorical(dataView.matrix, i), frameInfo = {
                            label: frameLabel,
                            column: keySourceColumn
                        };
                        convertedData = visualConverter(buildDataViewForFrame(dataView.metadata, dataViewCategorical), frameInfo), 
                        allViewModels.push(convertedData);
                    }
                } else {
                    var dataViewCategorical = convertMatrixToCategorical(dataView.matrix, 0);
                    convertedData = visualConverter(buildDataViewForFrame(dataView.metadata, dataViewCategorical)), 
                    allViewModels.push(convertedData);
                }
                return objectProperties.currentFrameIndex = frameKeys.length - 1, {
                    allViewModels: allViewModels,
                    currentViewModel: convertedData,
                    frameKeys: frameKeys,
                    currentFrameIndex: objectProperties.currentFrameIndex,
                    labelData: getLabelData(frameKeys, keySourceColumn)
                };
            }
            function getDefaultPlayData() {
                var defaultData = {
                    frameKeys: [],
                    allViewModels: [],
                    currentFrameIndex: 0,
                    currentViewModel: void 0,
                    labelData: {
                        anyWordBreaks: !1,
                        labelInfo: []
                    }
                };
                return defaultData;
            }
            function getMinMaxForAllFrames(playData, getExtents) {
                var extents = {
                    minY: 0,
                    maxY: 10,
                    minX: 0,
                    maxX: 10
                };
                if (playData.allViewModels && playData.allViewModels.length > 0) {
                    extents.minY = extents.minX = Number.MAX_VALUE, extents.maxY = extents.maxX = Number.MIN_VALUE;
                    for (var i = 0, len = playData.allViewModels.length; len > i; i++) {
                        var data_7 = playData.allViewModels[i], e = getExtents(data_7);
                        extents = {
                            minY: d3.min([ e.minY, extents.minY ]),
                            maxY: d3.max([ e.maxY, extents.maxY ]),
                            minX: d3.min([ e.minX, extents.minX ]),
                            maxX: d3.max([ e.maxX, extents.maxX ])
                        };
                    }
                }
                return extents;
            }
            function getLabelData(keys, keyColumn) {
                for (var textProperties = {
                    fontFamily: "wf_segoe-ui_normal",
                    fontSize: jsCommon.PixelConverter.toString(14)
                }, labelInfo = [], anyWordBreaks = !1, _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i], labelWidth = jsCommon.WordBreaker.getMaxWordWidth(key, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    anyWordBreaks = anyWordBreaks || jsCommon.WordBreaker.hasBreakers(key) || key.indexOf("-") > -1, 
                    labelInfo.push({
                        label: key,
                        labelWidth: labelWidth
                    });
                }
                return {
                    labelInfo: labelInfo,
                    anyWordBreaks: anyWordBreaks,
                    labelFieldName: keyColumn && keyColumn.displayName
                };
            }
            function createPipsFilterFn(playData, sliderWidth, labelData) {
                var maxLabelWidth = _.max(_.map(labelData.labelInfo, function(l) {
                    return l.labelWidth;
                })), pipSize = 1, skipMod = 1, maxAllowedLabelWidth = playData.frameKeys.length > 1 ? sliderWidth / (playData.frameKeys.length - 1) : sliderWidth, widthRatio = maxLabelWidth / maxAllowedLabelWidth;
                widthRatio > 1.25 ? (skipMod = Math.ceil(widthRatio), pipSize = 2) : (widthRatio > 1 || labelData.anyWordBreaks) && (pipSize = 2);
                var filterPipLabels = function(index, type) {
                    return index % skipMod === 0 ? pipSize : 0;
                };
                return filterPipLabels;
            }
            function isDataViewPlayable(dataView, playRole) {
                void 0 === playRole && (playRole = "Play");
                var firstRowSourceRoles = dataView.matrix && dataView.matrix.rows && dataView.matrix.rows.levels && dataView.matrix.rows.levels[0] && dataView.matrix.rows.levels[0].sources && dataView.matrix.rows.levels[0].sources[0] && dataView.matrix.rows.levels[0].sources[0].roles;
                return firstRowSourceRoles && firstRowSourceRoles[playRole];
            }
            function renderTraceLines(allDataPoints, traceLineRenderer, shouldAnimate) {
                var selectedDataPoints = _.filter(allDataPoints, function(d) {
                    return d.selected;
                });
                selectedDataPoints = _.uniq(selectedDataPoints, function(d) {
                    return d.identity.getKey();
                }), traceLineRenderer.render(selectedDataPoints, shouldAnimate);
            }
            PlayChart.FrameStepDuration = 800, PlayChart.FrameAnimationDuration = 750, PlayChart.ClassName = "playChart", 
            PlayChart.convertMatrixToCategorical = convertMatrixToCategorical, PlayChart.converter = converter, 
            PlayChart.getDefaultPlayData = getDefaultPlayData, PlayChart.getMinMaxForAllFrames = getMinMaxForAllFrames, 
            PlayChart.createPipsFilterFn = createPipsFilterFn, PlayChart.isDataViewPlayable = isDataViewPlayable, 
            PlayChart.renderTraceLines = renderTraceLines;
        }(PlayChart = visuals.PlayChart || (visuals.PlayChart = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var PixelConverter = jsCommon.PixelConverter, VerticalSlicerRenderer = function() {
            function VerticalSlicerRenderer(options) {
                this.textProperties = {
                    fontFamily: "wf_segoe-ui_normal, helvetica, arial, sans-serif",
                    fontSize: "14px"
                }, options && (this.behavior = options.behavior), this.domHelper = options.domHelper;
            }
            return VerticalSlicerRenderer.prototype.getDefaultValue = function() {
                return this.data && this.data.defaultValue ? this.data.defaultValue.value : void 0;
            }, VerticalSlicerRenderer.prototype.getIdentityFields = function() {
                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
            }, VerticalSlicerRenderer.prototype.init = function(slicerInitOptions) {
                var _this = this;
                this.element = slicerInitOptions.visualInitOptions.element, this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var interactivityService, hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host, settings = this.settings = visuals.Slicer.DefaultStyleProperties(), domHelper = this.domHelper, bodyViewport = domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties);
                this.behavior && (interactivityService = visuals.createInteractivityService(hostServices));
                var containerDiv = document.createElement("div");
                containerDiv.className = Selectors.Container["class"];
                var container = this.container = d3.select(containerDiv), header = domHelper.createSlicerHeader(hostServices);
                containerDiv.appendChild(header), this.header = d3.select(header), this.body = container.append("div").classed(visuals.SlicerUtil.Selectors.Body["class"], !0).style({
                    height: PixelConverter.toString(bodyViewport.height),
                    width: PixelConverter.toString(bodyViewport.width)
                });
                var rowEnter = function(rowSelection) {
                    _this.onEnterSelection(rowSelection);
                }, rowUpdate = function(rowSelection) {
                    _this.onUpdateSelection(rowSelection, interactivityService);
                }, rowExit = function(rowSelection) {
                    rowSelection.remove();
                }, listViewOptions = {
                    rowHeight: domHelper.getRowHeight(settings, this.textProperties),
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function() {
                        return slicerInitOptions.loadMoreData();
                    },
                    scrollEnabled: !0,
                    viewport: domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties),
                    baseContainer: this.body,
                    isReadMode: function() {
                        return 1 !== _this.hostServices.getViewMode();
                    }
                };
                return this.listView = visuals.ListViewFactory.createListView(listViewOptions), 
                this.element.get(0).appendChild(containerDiv), interactivityService;
            }, VerticalSlicerRenderer.prototype.render = function(options) {
                var data = this.data = options.data;
                this.currentViewport = options.viewport;
                var dataView = options.dataView;
                if (!dataView || !data) return void this.listView.empty();
                this.dataView = dataView;
                var settings = this.settings = data.slicerSettings, domHelper = this.domHelper;
                domHelper.updateSlicerBodyDimensions(this.currentViewport, this.body, settings), 
                this.updateSelectionStyle(), this.listView.viewport(domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties)).rowHeight(domHelper.getRowHeight(settings, this.textProperties)).data(data.slicerDataPoints, function(d) {
                    return $.inArray(d, data.slicerDataPoints);
                }, options.resetScrollbarPosition);
            }, VerticalSlicerRenderer.prototype.updateSelectionStyle = function() {
                var settings = this.settings;
                this.container.classed("isMultiSelectEnabled", settings && settings.selection && !settings.selection.singleSelect);
            }, VerticalSlicerRenderer.prototype.onEnterSelection = function(rowSelection) {
                var settings = this.settings, listItemElement = rowSelection.append("li").classed(Selectors.ItemContainer["class"], !0), labelElement = listItemElement.append("div").classed(Selectors.Input["class"], !0);
                labelElement.append("input").attr("type", "checkbox"), labelElement.append("span").classed(Selectors.Checkbox["class"], !0), 
                listItemElement.each(function(d, i) {
                    var item = d3.select(this);
                    d.isImage ? item.append("img").classed(visuals.SlicerUtil.Selectors.LabelImage["class"], !0) : item.append("span").classed(visuals.SlicerUtil.Selectors.LabelText["class"], !0), 
                    null != d.count && item.append("span").classed(visuals.SlicerUtil.Selectors.CountText["class"], !0).style("font-size", PixelConverter.fromPoint(settings.slicerText.textSize));
                });
            }, VerticalSlicerRenderer.prototype.onUpdateSelection = function(rowSelection, interactivityService) {
                var settings = this.settings, data = this.data;
                if (data && settings) {
                    var domHelper = this.domHelper;
                    domHelper.styleSlicerHeader(this.header, settings, data.categorySourceName), this.header.attr("title", data.categorySourceName);
                    var labelText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                    labelText.text(function(d) {
                        return d.value;
                    }).attr("title", function(d) {
                        return d.tooltip;
                    }), domHelper.setSlicerTextStyle(labelText, settings);
                    var labelImage = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelImage.selector);
                    labelImage.empty() || labelImage.attr("src", function(d) {
                        return d.value;
                    });
                    var countText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.CountText.selector);
                    if (countText.empty() || (countText.text(function(d) {
                        return d.count;
                    }), domHelper.setSlicerTextStyle(countText, settings)), interactivityService && this.body) {
                        var body = this.body.attr("width", this.currentViewport.width), slicerItemContainers = body.selectAll(Selectors.ItemContainer.selector), slicerItemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), slicerItemInputs = body.selectAll(Selectors.Input.selector), slicerClear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector), behaviorOptions = {
                            dataPoints: data.slicerDataPoints,
                            slicerContainer: this.container,
                            itemContainers: slicerItemContainers,
                            itemLabels: slicerItemLabels,
                            itemInputs: slicerItemInputs,
                            clear: slicerClear,
                            interactivityService: interactivityService,
                            settings: data.slicerSettings
                        }, orientationBehaviorOptions = {
                            behaviorOptions: behaviorOptions,
                            orientation: 0
                        };
                        interactivityService.bind(data.slicerDataPoints, this.behavior, orientationBehaviorOptions, {
                            overrideSelectionFromData: !0,
                            hasSelectionOverride: data.hasSelectionOverride,
                            slicerDefaultValueHandler: this
                        }), visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), data.hasSelectionOverride, interactivityService.isSelectionModeInverted());
                    } else visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), !1, !1);
                }
            }, VerticalSlicerRenderer;
        }();
        visuals.VerticalSlicerRenderer = VerticalSlicerRenderer;
        var Selectors;
        !function(Selectors) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            Selectors.Container = createClassAndSelector("slicerContainer"), Selectors.ItemContainer = createClassAndSelector("slicerItemContainer"), 
            Selectors.Input = createClassAndSelector("slicerCheckbox"), Selectors.Checkbox = createClassAndSelector("checkbox");
        }(Selectors || (Selectors = {}));
        var CheckboxSprite;
        !function(CheckboxSprite) {
            CheckboxSprite.MinimumSize = 8, CheckboxSprite.Size = 13, CheckboxSprite.SizeRange = CheckboxSprite.Size - CheckboxSprite.MinimumSize;
        }(CheckboxSprite || (CheckboxSprite = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var PixelConverter = jsCommon.PixelConverter, ItemWidthSampleSize = 50, MinTextWidth = 80, LoadMoreDataThreshold = .8, DefaultStyleProperties = {
            labelText: {
                marginRight: 2,
                paddingLeft: 8,
                paddingRight: 8
            }
        }, HorizontalSlicerRenderer = function() {
            function HorizontalSlicerRenderer(options) {
                this.textProperties = {
                    fontFamily: "wf_segoe-ui_normal",
                    fontSize: "14px"
                }, options && (this.behavior = options.behavior), this.domHelper = options.domHelper, 
                this.dataStartIndex = 0;
            }
            return HorizontalSlicerRenderer.prototype.getDefaultValue = function() {
                return this.data && this.data.defaultValue ? this.data.defaultValue.value : void 0;
            }, HorizontalSlicerRenderer.prototype.getIdentityFields = function() {
                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
            }, HorizontalSlicerRenderer.prototype.init = function(slicerInitOptions) {
                this.element = slicerInitOptions.visualInitOptions.element, this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                this.behavior && (this.interactivityService = visuals.createInteractivityService(hostServices)), 
                this.loadMoreData = function() {
                    return slicerInitOptions.loadMoreData();
                };
                var containerDiv = document.createElement("div");
                containerDiv.className = Selectors.container["class"];
                var container = this.container = d3.select(containerDiv), header = this.domHelper.createSlicerHeader(this.hostServices);
                containerDiv.appendChild(header), this.header = d3.select(header);
                var body = this.body = container.append("div").classed(visuals.SlicerUtil.Selectors.Body["class"] + " " + Selectors.FlexDisplay["class"], !0);
                return this.leftNavigationArrow = body.append("button").classed(Selectors.NavigationArrow["class"] + " " + Selectors.LeftNavigationArrow["class"], !0), 
                this.itemsContainer = body.append("div").classed(Selectors.ItemsContainer["class"] + " " + Selectors.FlexDisplay["class"], !0), 
                this.rightNavigationArrow = body.append("button").classed(Selectors.NavigationArrow["class"] + " " + Selectors.RightNavigationArrow["class"], !0), 
                this.element.get(0).appendChild(containerDiv), this.bindNavigationEvents(), this.interactivityService;
            }, HorizontalSlicerRenderer.prototype.render = function(options) {
                var data = options.data, dataView = options.dataView;
                if (!dataView || !data) return void this.itemsContainer.selectAll("*").remove();
                this.data = data, this.dataView = dataView;
                var resized = this.currentViewport && options.viewport && (this.currentViewport.height !== options.viewport.height || this.currentViewport.width !== options.viewport.width);
                this.isMaxWidthCalculated() && resized || (this.calculateAndSetMaxItemWidth(), this.calculateAndSetTotalItemWidth()), 
                this.currentViewport = options.viewport, this.updateStyle();
                var availableWidthForItemsContainer = this.element.find(Selectors.ItemsContainer.selector).width();
                this.itemsToDisplay = this.getNumberOfItemsToDisplay(availableWidthForItemsContainer), 
                0 !== this.itemsToDisplay && this.renderCore();
            }, HorizontalSlicerRenderer.prototype.renderCore = function() {
                var data = this.data;
                if (data && data.slicerDataPoints) {
                    this.normalizePosition(data.slicerDataPoints);
                    var itemsToDisplay = this.itemsToDisplay, dataStartIndex = this.dataStartIndex;
                    this.container.classed(Selectors.CanScrollRight["class"], dataStartIndex + this.itemsToDisplay <= data.slicerDataPoints.length - 1), 
                    this.container.classed(Selectors.CanScrollLeft["class"], dataStartIndex > 0), this.renderItems(data.slicerSettings), 
                    this.bindInteractivityService(), dataStartIndex + itemsToDisplay >= data.slicerDataPoints.length * LoadMoreDataThreshold && this.loadMoreData();
                }
            }, HorizontalSlicerRenderer.prototype.updateStyle = function() {
                var viewport = this.currentViewport, data = this.data, defaultSettings = data.slicerSettings, domHelper = this.domHelper;
                this.container.classed(Selectors.MultiSelectEnabled["class"], !defaultSettings.selection.singleSelect).style({
                    width: PixelConverter.toString(viewport.width),
                    height: PixelConverter.toString(viewport.height)
                }), domHelper.styleSlicerHeader(this.header, defaultSettings, data.categorySourceName);
                var headerTextProperties = domHelper.getHeaderTextProperties(defaultSettings);
                this.header.attr("title", data.categorySourceName);
                var bodyViewport = this.bodyViewport = domHelper.getSlicerBodyViewport(viewport, defaultSettings, headerTextProperties);
                this.body.style({
                    height: PixelConverter.toString(bodyViewport.height),
                    width: PixelConverter.toString(bodyViewport.width)
                });
            }, HorizontalSlicerRenderer.prototype.renderItems = function(defaultSettings) {
                var _this = this, itemsToDisplay = this.itemsToDisplay, dataStartIndex = this.dataStartIndex, materializedDataPoints = this.data.slicerDataPoints.slice(dataStartIndex, dataStartIndex + itemsToDisplay), items = this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector).data(materializedDataPoints, function(d) {
                    return _.indexOf(_this.data.slicerDataPoints, d);
                });
                items.enter().append("div").classed(visuals.SlicerUtil.Selectors.LabelText["class"] + " " + Selectors.FlexDisplay["class"], !0), 
                items.order(), items.style({
                    "font-family": this.textProperties.fontFamily,
                    "padding-left": PixelConverter.toString(DefaultStyleProperties.labelText.paddingLeft),
                    "padding-right": PixelConverter.toString(DefaultStyleProperties.labelText.paddingRight),
                    "margin-right": function(d, i) {
                        return _this.isLastRowItem(i, itemsToDisplay) ? "0px" : PixelConverter.toString(DefaultStyleProperties.labelText.marginRight);
                    }
                }), this.domHelper.setSlicerTextStyle(items, defaultSettings), items.exit().remove(), 
                window.setTimeout(function() {
                    items.attr("title", function(d) {
                        return d.tooltip;
                    }).text(function(d) {
                        return d.value;
                    });
                    var labels = _this.element.find(visuals.SlicerUtil.Selectors.LabelText.selector), item = labels.first(), itemWidth = item.width(), itemHeight = item.height();
                    labels.each(function(i, element) {
                        powerbi.TextMeasurementService.wordBreakOverflowingText(element, itemWidth, itemHeight);
                    });
                });
            }, HorizontalSlicerRenderer.prototype.bindInteractivityService = function() {
                if (this.interactivityService && this.body) {
                    var body = this.body, itemsContainer = body.selectAll(Selectors.ItemsContainer.selector), itemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), clear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector), data_8 = this.data, behaviorOptions = {
                        dataPoints: data_8.slicerDataPoints,
                        slicerContainer: this.container,
                        itemsContainer: itemsContainer,
                        itemLabels: itemLabels,
                        clear: clear,
                        interactivityService: this.interactivityService,
                        settings: data_8.slicerSettings
                    }, orientationBehaviorOptions = {
                        behaviorOptions: behaviorOptions,
                        orientation: 1
                    };
                    this.interactivityService.bind(data_8.slicerDataPoints, this.behavior, orientationBehaviorOptions, {
                        overrideSelectionFromData: !0,
                        hasSelectionOverride: data_8.hasSelectionOverride
                    }), visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), this.interactivityService.hasSelection(), this.interactivityService.isSelectionModeInverted());
                } else visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), !1, !1);
            }, HorizontalSlicerRenderer.prototype.normalizePosition = function(points) {
                var dataStartIndex = this.dataStartIndex;
                dataStartIndex = Math.min(dataStartIndex, points.length - 1), this.dataStartIndex = Math.max(dataStartIndex, 0);
            }, HorizontalSlicerRenderer.prototype.bindNavigationEvents = function() {
                this.registerMouseWheelScrollEvents(), this.registerMouseClickEvents();
            }, HorizontalSlicerRenderer.prototype.registerMouseClickEvents = function() {
                var _this = this, rightNavigationArrow = this.container.selectAll(Selectors.RightNavigationArrow.selector), leftNavigationArrow = this.container.selectAll(Selectors.LeftNavigationArrow.selector);
                rightNavigationArrow.on("click", function() {
                    _this.scrollRight();
                }), leftNavigationArrow.on("click", function() {
                    _this.scrollLeft();
                });
            }, HorizontalSlicerRenderer.prototype.registerMouseWheelScrollEvents = function() {
                var _this = this, scrollableElement = this.body.node();
                scrollableElement.addEventListener("mousewheel", function(e) {
                    _this.onMouseWheel(e.wheelDelta);
                }), scrollableElement.addEventListener("DOMMouseScroll", function(e) {
                    _this.onMouseWheel(e.detail);
                });
            }, HorizontalSlicerRenderer.prototype.onMouseWheel = function(wheelDelta) {
                0 > wheelDelta ? this.scrollRight() : wheelDelta > 0 && this.scrollLeft();
            }, HorizontalSlicerRenderer.prototype.scrollRight = function() {
                var itemsToDisplay = this.itemsToDisplay, startIndex = this.dataStartIndex, dataPointsLength = this.data.slicerDataPoints.length, lastItemIndex = dataPointsLength - 1;
                itemsToDisplay + startIndex > lastItemIndex || (startIndex += 1 === itemsToDisplay ? itemsToDisplay : itemsToDisplay - 1, 
                itemsToDisplay + startIndex > lastItemIndex && (startIndex = lastItemIndex - itemsToDisplay + 1), 
                this.dataStartIndex = startIndex, this.renderCore());
            }, HorizontalSlicerRenderer.prototype.scrollLeft = function() {
                var itemsToDisplay = this.itemsToDisplay, startIndex = this.dataStartIndex, firstItemIndex = 0;
                0 !== startIndex && (1 === itemsToDisplay && (startIndex -= itemsToDisplay), startIndex = firstItemIndex > startIndex - itemsToDisplay ? firstItemIndex : startIndex - itemsToDisplay + 1, 
                this.dataStartIndex = startIndex, this.renderCore());
            }, HorizontalSlicerRenderer.prototype.isLastRowItem = function(fieldIndex, columnsToDisplay) {
                return fieldIndex === columnsToDisplay - 1;
            }, HorizontalSlicerRenderer.prototype.getScaledTextWidth = function(textSize) {
                return textSize / jsCommon.TextSizeDefaults.TextSizeMin * MinTextWidth;
            }, HorizontalSlicerRenderer.prototype.isMaxWidthCalculated = function() {
                return void 0 !== this.maxItemWidth;
            }, HorizontalSlicerRenderer.prototype.calculateAndSetMaxItemWidth = function() {
                var dataPointsLength = this.getDataPointsCount(), maxItemWidth = 0;
                if (0 === dataPointsLength) return void (this.maxItemWidth = maxItemWidth);
                var data = this.data, dataPoints = data.slicerDataPoints, sampleSize = Math.min(dataPointsLength, ItemWidthSampleSize), properties = jQuery.extend(!0, {}, this.textProperties), textSize = data.slicerSettings.slicerText.textSize;
                properties.fontSize = PixelConverter.fromPoint(textSize);
                for (var getMaxWordWidth = jsCommon.WordBreaker.getMaxWordWidth, i = 0; sampleSize > i; i++) {
                    var itemText = dataPoints[i].value;
                    properties.text = itemText, maxItemWidth = Math.max(maxItemWidth, getMaxWordWidth(itemText, powerbi.TextMeasurementService.measureSvgTextWidth, properties));
                }
                this.maxItemWidth = Math.min(maxItemWidth, this.getScaledTextWidth(textSize));
            }, HorizontalSlicerRenderer.prototype.calculateAndSetTotalItemWidth = function() {
                var data = this.data, itemPadding = DefaultStyleProperties.labelText.paddingLeft + DefaultStyleProperties.labelText.paddingRight + DefaultStyleProperties.labelText.marginRight, borderWidth = this.domHelper.getRowsOutlineWidth(data.slicerSettings.slicerText.outline, data.slicerSettings.general.outlineWeight);
                this.totalItemWidth = this.maxItemWidth + itemPadding + borderWidth;
            }, HorizontalSlicerRenderer.prototype.getNumberOfItemsToDisplay = function(widthAvailable) {
                var totalItemWidth = this.totalItemWidth;
                if (0 === totalItemWidth) return 0;
                var dataPointsLength = this.getDataPointsCount(), numberOfItems = Math.min(dataPointsLength, Math.round(widthAvailable / totalItemWidth));
                return Math.max(numberOfItems, 1);
            }, HorizontalSlicerRenderer.prototype.getDataPointsCount = function() {
                return _.size(this.data.slicerDataPoints);
            }, HorizontalSlicerRenderer;
        }();
        visuals.HorizontalSlicerRenderer = HorizontalSlicerRenderer;
        var Selectors;
        !function(Selectors) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            Selectors.container = createClassAndSelector("horizontalSlicerContainer"), Selectors.ItemsContainer = createClassAndSelector("slicerItemsContainer"), 
            Selectors.NavigationArrow = createClassAndSelector("navigationArrow"), Selectors.LeftNavigationArrow = createClassAndSelector("left"), 
            Selectors.RightNavigationArrow = createClassAndSelector("right"), Selectors.MultiSelectEnabled = createClassAndSelector("isMultiSelectEnabled"), 
            Selectors.FlexDisplay = createClassAndSelector("flexDisplay"), Selectors.CanScrollRight = createClassAndSelector("canScrollRight"), 
            Selectors.CanScrollLeft = createClassAndSelector("canScrollLeft");
        }(Selectors || (Selectors = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var DisplayNameKeys = visuals.SlicerUtil.DisplayNameKeys, DOMHelper = visuals.SlicerUtil.DOMHelper, SettingsHelper = visuals.SlicerUtil.SettingsHelper, Slicer = function() {
            function Slicer(options) {
                options && (this.behavior = options.behavior), this.domHelper = new DOMHelper();
            }
            return Slicer.DefaultStyleProperties = function() {
                return {
                    general: {
                        outlineColor: "#808080",
                        outlineWeight: 1,
                        orientation: 0
                    },
                    header: {
                        borderBottomWidth: 1,
                        show: !0,
                        outline: visuals.outline.bottomOnly,
                        fontColor: "#000000",
                        textSize: 10
                    },
                    slicerText: {
                        color: "#666666",
                        outline: visuals.outline.none,
                        textSize: 10
                    },
                    selection: {
                        selectAllCheckboxEnabled: !1,
                        singleSelect: !0
                    }
                };
            }, Slicer.prototype.init = function(options) {
                this.initOptions = options, this.element = options.element, this.currentViewport = options.viewport, 
                this.hostServices = options.host;
                var settings = this.settings = Slicer.DefaultStyleProperties();
                this.slicerOrientation = settings.general.orientation, this.waitingForData = !1, 
                this.initializeSlicerRenderer(this.slicerOrientation);
            }, Slicer.prototype.onDataChanged = function(options) {
                var dataViews = options.dataViews;
                if (!_.isEmpty(dataViews)) {
                    var existingDataView = this.dataView;
                    this.dataView = dataViews[0];
                    var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append && !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                    this.render(resetScrollbarPosition, !0);
                }
            }, Slicer.prototype.onResizing = function(finalViewport) {
                this.currentViewport = finalViewport, this.render(!1);
            }, Slicer.prototype.enumerateObjectInstances = function(options) {
                return ObjectEnumerator.enumerateObjectInstances(options, this.slicerData, this.settings, this.dataView);
            }, Slicer.prototype.loadMoreData = function() {
                var dataView = this.dataView;
                if (dataView) {
                    var dataViewMetadata = dataView.metadata;
                    !this.waitingForData && dataViewMetadata && dataViewMetadata.segment && (this.hostServices.loadMoreData(), 
                    this.waitingForData = !0);
                }
            }, Slicer.prototype.onClearSelection = function() {
                this.interactivityService && (this.interactivityService.clearSelection(), this.render(!1));
            }, Slicer.prototype.render = function(resetScrollbarPosition, stopWaitingForData) {
                var localizedSelectAllText = this.hostServices.getLocalizedString(DisplayNameKeys.SelectAll);
                if (this.slicerData = visuals.DataConversion.convert(this.dataView, localizedSelectAllText, this.interactivityService, this.hostServices), 
                this.slicerData) {
                    this.slicerData.slicerSettings.general.outlineWeight = Math.max(this.slicerData.slicerSettings.general.outlineWeight, 0), 
                    this.settings = this.slicerData.slicerSettings;
                    var slicerOrientation_1 = SettingsHelper.areSettingsDefined(this.slicerData) && this.slicerData.slicerSettings.general && this.slicerData.slicerSettings.general.orientation ? this.slicerData.slicerSettings.general.orientation : Slicer.DefaultStyleProperties().general.orientation, orientationHasChanged = this.orientationHasChanged(slicerOrientation_1);
                    orientationHasChanged && (this.slicerOrientation = slicerOrientation_1, this.element.empty(), 
                    this.initializeSlicerRenderer(slicerOrientation_1));
                }
                this.slicerRenderer.render({
                    dataView: this.dataView,
                    data: this.slicerData,
                    viewport: this.currentViewport,
                    resetScrollbarPosition: resetScrollbarPosition
                }), stopWaitingForData && (this.waitingForData = !1);
            }, Slicer.prototype.orientationHasChanged = function(slicerOrientation) {
                return this.slicerOrientation !== slicerOrientation;
            }, Slicer.prototype.initializeSlicerRenderer = function(slicerOrientation) {
                switch (slicerOrientation) {
                  case 1:
                    this.initializeHorizontalSlicer();
                    break;

                  case 0:
                    this.initializeVerticalSlicer();
                }
            }, Slicer.prototype.initializeVerticalSlicer = function() {
                var verticalSlicerRenderer = this.slicerRenderer = new visuals.VerticalSlicerRenderer({
                    domHelper: this.domHelper,
                    behavior: this.behavior
                }), options = this.createInitOptions();
                this.interactivityService = verticalSlicerRenderer.init(options);
            }, Slicer.prototype.initializeHorizontalSlicer = function() {
                var horizontalSlicerRenderer = this.slicerRenderer = new visuals.HorizontalSlicerRenderer({
                    domHelper: this.domHelper,
                    behavior: this.behavior
                }), options = this.createInitOptions();
                this.interactivityService = horizontalSlicerRenderer.init(options);
            }, Slicer.prototype.createInitOptions = function() {
                var _this = this;
                return {
                    visualInitOptions: this.initOptions,
                    loadMoreData: function() {
                        return _this.loadMoreData();
                    }
                };
            }, Slicer;
        }();
        visuals.Slicer = Slicer;
        var ObjectEnumerator;
        !function(ObjectEnumerator) {
            function enumerateObjectInstances(options, data, settings, dataView) {
                if (data) switch (options.objectName) {
                  case "items":
                    return enumerateItems(data, settings);

                  case "header":
                    return enumerateHeader(data, settings);

                  case "general":
                    return enumerateGeneral(data, settings);

                  case "selection":
                    if (shouldShowSelectionOption(dataView)) return enumerateSelection(data, settings);
                }
            }
            function shouldShowSelectionOption(dataView) {
                return !(dataView && dataView.metadata && dataView.metadata.columns && _.some(dataView.metadata.columns, function(column) {
                    return column.discourageAggregationAcrossGroups;
                }));
            }
            function enumerateSelection(data, settings) {
                var slicerSettings = settings, areSelectionSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.selection, selectAllCheckboxEnabled = areSelectionSettingsDefined && data.slicerSettings.selection.selectAllCheckboxEnabled ? data.slicerSettings.selection.selectAllCheckboxEnabled : slicerSettings.selection.selectAllCheckboxEnabled, singleSelect = data && data.slicerSettings && data.slicerSettings.selection && void 0 !== data.slicerSettings.selection.singleSelect ? data.slicerSettings.selection.singleSelect : slicerSettings.selection.singleSelect;
                return [ {
                    selector: null,
                    objectName: "selection",
                    properties: {
                        selectAllCheckboxEnabled: selectAllCheckboxEnabled,
                        singleSelect: singleSelect
                    }
                } ];
            }
            function enumerateHeader(data, settings) {
                var slicerSettings = settings, areHeaderSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.header, fontColor = areHeaderSettingsDefined && data.slicerSettings.header.fontColor ? data.slicerSettings.header.fontColor : slicerSettings.header.fontColor, background = areHeaderSettingsDefined && data.slicerSettings.header.background ? data.slicerSettings.header.background : slicerSettings.header.background;
                return [ {
                    selector: null,
                    objectName: "header",
                    properties: {
                        show: slicerSettings.header.show,
                        fontColor: fontColor,
                        background: background,
                        outline: slicerSettings.header.outline,
                        textSize: slicerSettings.header.textSize
                    }
                } ];
            }
            function enumerateItems(data, settings) {
                var slicerSettings = settings, areTextSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.slicerText, fontColor = areTextSettingsDefined && data.slicerSettings.slicerText.color ? data.slicerSettings.slicerText.color : slicerSettings.slicerText.color, background = areTextSettingsDefined && data.slicerSettings.slicerText.background ? data.slicerSettings.slicerText.background : slicerSettings.slicerText.background;
                return [ {
                    selector: null,
                    objectName: "items",
                    properties: {
                        fontColor: fontColor,
                        background: background,
                        outline: slicerSettings.slicerText.outline,
                        textSize: slicerSettings.slicerText.textSize
                    }
                } ];
            }
            function enumerateGeneral(data, settings) {
                var slicerSettings = settings, areGeneralSettingsDefined = SettingsHelper.areSettingsDefined(data) && null != data.slicerSettings.general, outlineColor = areGeneralSettingsDefined && data.slicerSettings.general.outlineColor ? data.slicerSettings.general.outlineColor : slicerSettings.general.outlineColor, outlineWeight = areGeneralSettingsDefined && data.slicerSettings.general.outlineWeight ? data.slicerSettings.general.outlineWeight : slicerSettings.general.outlineWeight, orientation = areGeneralSettingsDefined && null != data.slicerSettings.general.orientation ? data.slicerSettings.general.orientation : slicerSettings.general.orientation;
                return [ {
                    selector: null,
                    objectName: "general",
                    properties: {
                        outlineColor: outlineColor,
                        outlineWeight: outlineWeight,
                        orientation: orientation
                    }
                } ];
            }
            ObjectEnumerator.enumerateObjectInstances = enumerateObjectInstances;
        }(ObjectEnumerator || (ObjectEnumerator = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var TablixUtils = visuals.controls.internal.TablixUtils, TablixObjects = visuals.controls.internal.TablixObjects, TableHierarchyNavigator = function() {
            function TableHierarchyNavigator(tableDataView, formatter) {
                this.tableDataView = tableDataView, this.formatter = formatter;
            }
            return TableHierarchyNavigator.prototype.getColumnHierarchyDepth = function() {
                return 1;
            }, TableHierarchyNavigator.prototype.getRowHierarchyDepth = function() {
                return 1;
            }, TableHierarchyNavigator.prototype.getLeafCount = function(hierarchy) {
                return hierarchy.length;
            }, TableHierarchyNavigator.prototype.getLeafAt = function(hierarchy, index) {
                return hierarchy[index];
            }, TableHierarchyNavigator.prototype.getParent = function(item) {
                return null;
            }, TableHierarchyNavigator.prototype.getIndex = function(item) {
                return item ? this.isRow(item) ? item.index : this.getColumnIndex(item) : -1;
            }, TableHierarchyNavigator.prototype.isRow = function(item) {
                if (!item) return !1;
                var row = item;
                return void 0 !== row.index && void 0 !== row.values;
            }, TableHierarchyNavigator.prototype.getColumnIndex = function(item) {
                return TableHierarchyNavigator.getIndex(this.tableDataView.columns, item);
            }, TableHierarchyNavigator.prototype.isLeaf = function(item) {
                return !0;
            }, TableHierarchyNavigator.prototype.isRowHierarchyLeaf = function(cornerItem) {
                return !1;
            }, TableHierarchyNavigator.prototype.isColumnHierarchyLeaf = function(cornerItem) {
                return !0;
            }, TableHierarchyNavigator.prototype.isFirstItem = function(item, items) {
                return 0 === item.index;
            }, TableHierarchyNavigator.prototype.areAllParentsFirst = function(item, items) {
                return this.isFirstItem(item, items);
            }, TableHierarchyNavigator.prototype.isLastItem = function(item, items) {
                return items[items.length - 1] === item;
            }, TableHierarchyNavigator.prototype.areAllParentsLast = function(item, items) {
                return this.isLastItem(item, items);
            }, TableHierarchyNavigator.prototype.getChildren = function(item) {
                return null;
            }, TableHierarchyNavigator.prototype.getChildrenLevelDifference = function(item) {
                return 1 / 0;
            }, TableHierarchyNavigator.prototype.getCount = function(items) {
                return items.length;
            }, TableHierarchyNavigator.prototype.getAt = function(items, index) {
                return items[index];
            }, TableHierarchyNavigator.prototype.getLevel = function(item) {
                return 0;
            }, TableHierarchyNavigator.prototype.getIntersection = function(rowItem, columnItem) {
                var value, isTotal = !1, position = new TablixUtils.CellPosition(), columnIndex = TableHierarchyNavigator.getIndex(this.tableDataView.columns, columnItem);
                position.column.index = columnIndex, position.column.isFirst = 0 === columnIndex, 
                position.column.isLast = columnIndex === this.tableDataView.columns.length - 1;
                var totalRow = rowItem;
                if (null != totalRow.totalCells) isTotal = !0, value = totalRow.totalCells[columnIndex]; else {
                    var row = rowItem, rowIndex = row.index;
                    position.row.index = rowIndex, position.row.isFirst = 0 === rowIndex, position.row.isLast = rowIndex === this.tableDataView.rows.length - 1, 
                    value = row.values[columnIndex];
                }
                var cellItem = new TablixUtils.TablixVisualCell(value, isTotal, columnItem, this.formatter);
                cellItem.position = position;
                var tableRow = rowItem;
                if (tableRow && tableRow.values) {
                    var rowObjects = tableRow.values.objects;
                    if (rowObjects) {
                        var cellObject = rowObjects[columnIndex];
                        cellObject && (cellItem.backColorCustomFormatting = TablixObjects.PropValuesBackColorPrimary.getValue(cellObject));
                    }
                }
                return cellItem;
            }, TableHierarchyNavigator.prototype.getCorner = function(rowLevel, columnLevel) {
                return null;
            }, TableHierarchyNavigator.prototype.headerItemEquals = function(item1, item2) {
                if (item1 === item2) return !0;
                if (item1.displayName && item2.displayName) {
                    var column1 = item1, column2 = item2;
                    return powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(column1, column2);
                }
                return this.isRow(item1) && this.isRow(item2) ? item1.index === item2.index : !1;
            }, TableHierarchyNavigator.prototype.bodyCellItemEquals = function(item1, item2) {
                return item1.isMatch(item2);
            }, TableHierarchyNavigator.prototype.cornerCellItemEquals = function(item1, item2) {
                return !0;
            }, TableHierarchyNavigator.prototype.update = function(table) {
                this.tableDataView = table;
            }, TableHierarchyNavigator.getIndex = function(items, item) {
                for (var index = 0, len = items.length; len > index; index++) {
                    var arrayItem = items[index];
                    if (null != arrayItem.index && null != item.index && arrayItem.index === item.index) return index;
                    if (item === items[index]) return index;
                }
                return -1;
            }, TableHierarchyNavigator;
        }();
        visuals.TableHierarchyNavigator = TableHierarchyNavigator;
        var TableBinder = function() {
            function TableBinder(options) {
                this.options = options;
            }
            return TableBinder.prototype.onDataViewChanged = function(dataView) {
                this.tableDataView = dataView, this.formattingProperties = dataView.formattingProperties;
            }, TableBinder.prototype.onStartRenderingSession = function() {}, TableBinder.prototype.onEndRenderingSession = function() {}, 
            TableBinder.prototype.bindRowHeader = function(item, cell) {
                this.ensureHeight(item, cell), TablixUtils.clearCellStyle(cell), this.options.onBindRowHeader && this.options.onBindRowHeader(item);
            }, TableBinder.prototype.unbindRowHeader = function(item, cell) {}, TableBinder.prototype.bindColumnHeader = function(item, cell) {
                var _this = this;
                if (cell.extension.disableDragResize(), TablixUtils.resetCellCssClass(cell), TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader), 
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf), this.sortIconsEnabled() ? TablixUtils.createColumnHeaderWithSortIcon(item, cell) : TablixUtils.setCellTextAndTooltip(cell, item.displayName), 
                this.options.onColumnHeaderClick) {
                    var handler = function(e) {
                        if (TablixUtils.isValidSortClick(e)) {
                            var sortDirection = TablixUtils.reverseSort(item.sort);
                            _this.options.onColumnHeaderClick(item.queryName ? item.queryName : item.displayName, sortDirection);
                        }
                    };
                    cell.extension.registerClickHandler(handler);
                }
                this.formattingProperties.isFormattingEnabled && this.getColumnHeaderStyle(cell).applyStyle(cell);
            }, TableBinder.prototype.getColumnHeaderStyle = function(cell) {
                var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.columnHeaders, propsTotal = this.formattingProperties.total, style = new TablixUtils.CellStyle();
                return style.borders.top = new TablixUtils.EdgeSettings(), style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.bottom = new TablixUtils.EdgeSettings(), style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.left = new TablixUtils.EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                !visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsTotal.outline) && (style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft)), 
                style.borders.right = new TablixUtils.EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                !visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsTotal.outline) && (style.paddings.right = propsGrid.outlineWeight + TablixUtils.CellPaddingRight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor), 
                style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, 
                style;
            }, TableBinder.prototype.unbindColumnHeader = function(item, cell) {
                TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell), this.sortIconsEnabled() && TablixUtils.removeSortIcons(cell), 
                this.options.onColumnHeaderClick && cell.extension.unregisterClickHandler();
            }, TableBinder.prototype.bindBodyCell = function(item, cell) {
                TablixUtils.resetCellCssClass(cell), item.isValidUrl ? TablixUtils.appendATagToBodyCell(item.textContent, cell, this.formattingProperties.isFormattingEnabled && this.formattingProperties.values.urlIcon) : item.isValidImage ? TablixUtils.appendImgTagToBodyCell(item.textContent, cell) : _.isEmpty(item.domContent) ? item.textContent ? TablixUtils.setCellTextAndTooltip(cell, item.textContent) : TablixUtils.setCellTextAndTooltip(cell, " ") : $(cell.extension.contentHost).append(item.domContent), 
                item.isTotal ? (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal), 
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableFooter)) : item.position.row.isLast ? TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCellBottom) : TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCell), 
                item.isNumeric && TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric), 
                this.formattingProperties.isFormattingEnabled && (item.isTotal ? this.getFooterStyle(cell).applyStyle(cell) : this.getBodyStyle(item, cell).applyStyle(cell));
            }, TableBinder.prototype.getBodyStyle = function(item, cell) {
                var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.values, propsTotal = this.formattingProperties.total, style = new TablixUtils.CellStyle();
                return style.borders.top = new TablixUtils.EdgeSettings(), cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.bottom = new TablixUtils.EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor), 
                style.borders.left = new TablixUtils.EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                !visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsTotal.outline) && (style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft)), 
                style.borders.right = new TablixUtils.EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                !visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsTotal.outline) && (style.paddings.right = propsGrid.outlineWeight + TablixUtils.CellPaddingRight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor), 
                style.fontColor = cell.position.row.index % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary, 
                this.formattingProperties.isConditionalFormattingEnabled && this.formattingProperties.values.conditionalFormatting && item.backColorCustomFormatting ? style.backColor = item.backColorCustomFormatting : style.backColor = cell.position.row.index % 2 === 0 ? props.backColorPrimary : props.backColorSecondary, 
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, style;
            }, TableBinder.prototype.getFooterStyle = function(cell) {
                var props = this.formattingProperties.total, propsGrid = this.formattingProperties.grid, propsValues = this.formattingProperties.values, propsColumns = this.formattingProperties.columnHeaders, style = new TablixUtils.CellStyle();
                return style.borders.top = new TablixUtils.EdgeSettings(), style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.bottom = new TablixUtils.EdgeSettings(), style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.left = new TablixUtils.EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                visuals.outline.showLeft(props.outline) || !visuals.outline.showLeft(propsValues.outline) && !visuals.outline.showLeft(propsColumns.outline) || (style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft)), 
                style.borders.right = new TablixUtils.EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                visuals.outline.showRight(props.outline) || !visuals.outline.showRight(propsValues.outline) && !visuals.outline.showRight(propsColumns.outline) || (style.paddings.right = propsGrid.outlineWeight + TablixUtils.CellPaddingRight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor), 
                style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, 
                style;
            }, TableBinder.prototype.unbindBodyCell = function(item, cell) {
                TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
            }, TableBinder.prototype.bindCornerCell = function(item, cell) {}, TableBinder.prototype.unbindCornerCell = function(item, cell) {}, 
            TableBinder.prototype.bindEmptySpaceHeaderCell = function(cell) {}, TableBinder.prototype.unbindEmptySpaceHeaderCell = function(cell) {}, 
            TableBinder.prototype.bindEmptySpaceFooterCell = function(cell) {}, TableBinder.prototype.unbindEmptySpaceFooterCell = function(cell) {}, 
            TableBinder.prototype.getHeaderLabel = function(item) {
                return item.displayName;
            }, TableBinder.prototype.getCellContent = function(item) {
                return item;
            }, TableBinder.prototype.hasRowGroups = function() {
                return !1;
            }, TableBinder.prototype.ensureHeight = function(item, cell) {
                if (item.values) {
                    var count = item.values.length;
                    if (0 !== count) {
                        for (var allValuesEmpty = !0, i = 0; count > i; i++) if (item.values[i]) {
                            allValuesEmpty = !1;
                            break;
                        }
                        allValuesEmpty && (cell.extension.contentHost.innerHTML = TablixUtils.StringNonBreakingSpace);
                    }
                }
            }, TableBinder.prototype.sortIconsEnabled = function() {
                return 0 === this.options.layoutKind;
            }, TableBinder;
        }();
        visuals.TableBinder = TableBinder;
        var Table = function() {
            function Table(options) {
                options && (this.isFormattingPropertiesEnabled = options.isFormattingPropertiesEnabled, 
                this.isConditionalFormattingEnabled = options.isConditionalFormattingEnabled, this.isTouchEnabled = options.isTouchEnabled);
            }
            return Table.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (dataViewMapping && dataViewMapping.table && dataViewMapping.metadata) {
                    var dataViewTableRows = dataViewMapping.table.rows, objects = dataViewMapping.metadata.objects;
                    dataViewTableRows["for"]["in"].subtotalType = TablixObjects.shouldShowTableTotals(objects) ? 1 : 0;
                }
            }, Table.getSortableRoles = function() {
                return [ "Values" ];
            }, Table.prototype.init = function(options) {
                this.element = options.element, this.style = options.style, this.updateViewport(options.viewport), 
                this.formatter = visuals.valueFormatter.formatValueColumn, this.isInteractive = options.interactivity && null != options.interactivity.selection, 
                this.getLocalizedString = options.host.getLocalizedString, this.hostServices = options.host, 
                this.persistingObjects = !1, this.waitingForData = !1, this.lastAllowHeaderResize = !0, 
                this.waitingForSort = !1;
            }, Table.converter = function(dataView, isFormattingEnabled, isConditionalFormattingEnabled) {
                var table = dataView.table, visualTable = powerbi.Prototype.inherit(table);
                visualTable.visualRows = [];
                for (var i = 0; i < table.rows.length; i++) {
                    var visualRow = {
                        index: i,
                        values: table.rows[i]
                    };
                    visualTable.visualRows.push(visualRow);
                }
                return visualTable.formattingProperties = TablixObjects.getTableObjects(dataView, isFormattingEnabled, isConditionalFormattingEnabled), 
                visualTable;
            }, Table.prototype.onResizing = function(finalViewport) {
                this.updateViewport(finalViewport);
            }, Table.prototype.getColumnWidthManager = function() {
                return this.columnWidthManager;
            }, Table.prototype.onDataChanged = function(options) {
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var previousDataView = this.dataView;
                    if (this.dataView = dataViews[0], this.persistingObjects) return void (this.persistingObjects = !1);
                    var visualTable = Table.converter(this.dataView, this.isFormattingPropertiesEnabled, this.isConditionalFormattingEnabled), textSize = visualTable.formattingProperties.general.textSize;
                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) this.hierarchyNavigator.update(visualTable), 
                    this.tablixControl.updateModels(!1, visualTable.visualRows, visualTable.columns), 
                    this.refreshControl(!1); else {
                        this.createOrUpdateHierarchyNavigator(visualTable), this.createColumnWidthManager(), 
                        this.createTablixControl(textSize);
                        var binder = this.tablixControl.getBinder();
                        binder.onDataViewChanged(visualTable), this.updateInternal(textSize, previousDataView, visualTable);
                    }
                }
                this.waitingForData = !1, this.waitingForSort = !1;
            }, Table.prototype.createColumnWidthManager = function() {
                var _this = this;
                this.columnWidthManager ? this.columnWidthManager.updateDataView(this.dataView) : this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, !1, function(objectInstances) {
                    return _this.persistColumnWidths(objectInstances);
                });
            }, Table.prototype.persistColumnWidths = function(objectInstances) {
                this.persistingObjects = !0, this.hostServices.persistProperties(objectInstances);
            }, Table.prototype.updateViewport = function(newViewport) {
                this.currentViewport = newViewport, this.tablixControl && (this.tablixControl.viewport = this.currentViewport, 
                this.verifyHeaderResize(), this.refreshControl(!1));
            }, Table.prototype.refreshControl = function(clear) {
                (visuals.visibilityHelper.partiallyVisible(this.element) || 1 === this.getLayoutKind()) && this.tablixControl.refresh(clear);
            }, Table.prototype.getLayoutKind = function() {
                return this.isInteractive ? 0 : 1;
            }, Table.prototype.createOrUpdateHierarchyNavigator = function(visualTable) {
                if (this.tablixControl) this.hierarchyNavigator.update(visualTable); else {
                    var dataNavigator = new TableHierarchyNavigator(visualTable, this.formatter);
                    this.hierarchyNavigator = dataNavigator;
                }
            }, Table.prototype.createTablixControl = function(textSize) {
                this.tablixControl || (this.tablixControl = this.createControl(this.hierarchyNavigator, textSize));
            }, Table.prototype.createControl = function(dataNavigator, textSize) {
                var _this = this, layoutKind = this.getLayoutKind(), tableBinderOptions = {
                    onBindRowHeader: function(item) {
                        return _this.onBindRowHeader(item);
                    },
                    onColumnHeaderClick: function(queryName, sortDirection) {
                        return _this.onColumnHeaderClick(queryName, sortDirection);
                    },
                    layoutKind: layoutKind,
                    formattingEnabled: this.isFormattingPropertiesEnabled
                }, tableBinder = new TableBinder(tableBinderOptions), layoutManager = 1 === layoutKind ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(tableBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(tableBinder, this.columnWidthManager), tablixContainer = document.createElement("div");
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: this.isTouchEnabled,
                    layoutKind: layoutKind,
                    fontSize: TablixObjects.getTextSizeInPx(textSize)
                };
                return new visuals.controls.TablixControl(dataNavigator, layoutManager, tableBinder, tablixContainer, tablixOptions);
            }, Table.prototype.updateInternal = function(textSize, previousDataView, visualTable) {
                var _this = this;
                1 === this.getLayoutKind() && this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView)), 
                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize), this.verifyHeaderResize(), 
                this.tablixControl.updateModels(!0, visualTable.visualRows, visualTable.columns);
                var totals = this.createTotalsRow(this.dataView);
                this.tablixControl.rowDimension.setFooter(totals), this.tablixControl.viewport = this.currentViewport;
                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                setTimeout(function() {
                    _this.refreshControl(shouldClearControl), _this.columnWidthManager.shouldPersistAllColumnWidths() && _this.columnWidthManager.persistAllColumnWidths(_this.tablixControl.layoutManager.columnWidthsToPersist);
                }, 0);
            }, Table.prototype.shouldClearControl = function(previousDataView, newDataView) {
                return this.waitingForSort && previousDataView && newDataView ? !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata) : !0;
            }, Table.prototype.createTotalsRow = function(dataView) {
                if (!TablixObjects.shouldShowTableTotals(dataView.metadata.objects)) return null;
                var totals = dataView.table.totals;
                if (!totals || 0 === totals.length) return null;
                for (var totalRow = [], columns = dataView.table.columns, i = 0, len = columns.length; len > i; ++i) {
                    var column = columns[i], totalValue = totals[column.index];
                    null != totalValue ? totalRow.push(totalValue) : totalRow.push(0 === i ? this.getLocalizedString("TableTotalLabel") : "");
                }
                return {
                    totalCells: totalRow
                };
            }, Table.prototype.onBindRowHeader = function(item) {
                this.needsMoreData(item) && (this.hostServices.loadMoreData(), this.waitingForData = !0);
            }, Table.prototype.onColumnHeaderClick = function(queryName, sortDirection) {
                this.waitingForSort = !0, this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
            }, Table.prototype.needsMoreData = function(item) {
                if (this.waitingForData || !this.dataView.metadata || !this.dataView.metadata.segment) return !1;
                var leafCount = this.tablixControl.rowDimension.getItemsCount(), loadMoreThreshold = leafCount * Table.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getIndex(item) >= loadMoreThreshold;
            }, Table.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                return this.dataView && TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, this.isFormattingPropertiesEnabled, this.isConditionalFormattingEnabled, visuals.controls.TablixType.Table), 
                enumeration.complete();
            }, Table.prototype.shouldAllowHeaderResize = function() {
                return 1 === this.hostServices.getViewMode();
            }, Table.prototype.onViewModeChanged = function(viewMode) {
                this.updateViewport(this.currentViewport);
            }, Table.prototype.verifyHeaderResize = function() {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                currentAllowHeaderResize !== this.lastAllowHeaderResize && (this.lastAllowHeaderResize = currentAllowHeaderResize, 
                this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize));
            }, Table.preferredLoadMoreThreshold = .8, Table;
        }();
        visuals.Table = Table;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        function createMatrixHierarchyNavigator(matrix, formatter) {
            return new MatrixHierarchyNavigator(matrix, formatter);
        }
        var TablixUtils = visuals.controls.internal.TablixUtils, TablixObjects = visuals.controls.internal.TablixObjects, UrlUtils = jsCommon.UrlUtils, MatrixVisualBodyItem = function(_super) {
            function MatrixVisualBodyItem() {
                _super.apply(this, arguments);
            }
            return __extends(MatrixVisualBodyItem, _super), Object.defineProperty(MatrixVisualBodyItem.prototype, "isMeasure", {
                get: function() {
                    return !0;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidUrl", {
                get: function() {
                    return !1;
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidImage", {
                get: function() {
                    return !1;
                },
                enumerable: !0,
                configurable: !0
            }), MatrixVisualBodyItem;
        }(TablixUtils.TablixVisualCell);
        visuals.MatrixVisualBodyItem = MatrixVisualBodyItem, visuals.createMatrixHierarchyNavigator = createMatrixHierarchyNavigator;
        var MatrixHierarchyNavigator = function() {
            function MatrixHierarchyNavigator(matrix, formatter) {
                this.matrix = matrix, this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.rows), 
                this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.columns), 
                this.formatter = formatter, this.update();
            }
            return MatrixHierarchyNavigator.prototype.getDataViewMatrix = function() {
                return this.matrix;
            }, MatrixHierarchyNavigator.prototype.getColumnHierarchyDepth = function() {
                return Math.max(this.columnHierarchy.levels.length, 1);
            }, MatrixHierarchyNavigator.prototype.getRowHierarchyDepth = function() {
                return Math.max(this.rowHierarchy.levels.length, 1);
            }, MatrixHierarchyNavigator.prototype.getLeafCount = function(hierarchy) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                return matrixHierarchy ? matrixHierarchy.leafNodes.length : 0;
            }, MatrixHierarchyNavigator.prototype.getLeafAt = function(hierarchy, index) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                return matrixHierarchy ? matrixHierarchy.leafNodes[index] : null;
            }, MatrixHierarchyNavigator.prototype.getLeafIndex = function(item) {
                return item.leafIndex;
            }, MatrixHierarchyNavigator.prototype.getParent = function(item) {
                return 0 === item.level ? null : item.parent;
            }, MatrixHierarchyNavigator.prototype.getIndex = function(item) {
                return item.index;
            }, MatrixHierarchyNavigator.prototype.isLeaf = function(item) {
                return !item.children || 0 === item.children.length;
            }, MatrixHierarchyNavigator.prototype.isRowHierarchyLeaf = function(item) {
                return !0;
            }, MatrixHierarchyNavigator.prototype.isColumnHierarchyLeaf = function(item) {
                return !1;
            }, MatrixHierarchyNavigator.prototype.isFirstItem = function(item, items) {
                return item === _.first(items);
            }, MatrixHierarchyNavigator.prototype.areAllParentsFirst = function(item, items) {
                if (!item) return !1;
                var parent = this.getParent(item);
                return parent ? this.isFirstItem(item, item.siblings) && this.areAllParentsFirst(parent, parent.siblings) : this.isFirstItem(item, item.siblings);
            }, MatrixHierarchyNavigator.prototype.isLastItem = function(item, items) {
                return item === _.last(items);
            }, MatrixHierarchyNavigator.prototype.areAllParentsLast = function(item, items) {
                if (!item) return !1;
                var parent = this.getParent(item);
                return parent ? this.isLastItem(item, item.siblings) && this.areAllParentsLast(parent, parent.siblings) : this.isLastItem(item, item.siblings);
            }, MatrixHierarchyNavigator.prototype.getChildren = function(item) {
                return item.children;
            }, MatrixHierarchyNavigator.prototype.getChildrenLevelDifference = function(item) {
                for (var diff = 1 / 0, children = this.getChildren(item), i = 0, ilen = children.length; ilen > i; i++) diff = Math.min(diff, children[i].level - item.level);
                return diff;
            }, MatrixHierarchyNavigator.prototype.getCount = function(items) {
                return items.length;
            }, MatrixHierarchyNavigator.prototype.getAt = function(items, index) {
                return items[index];
            }, MatrixHierarchyNavigator.prototype.getLevel = function(item) {
                return item.level;
            }, MatrixHierarchyNavigator.prototype.getIntersection = function(rowItem, columnItem) {
                var node, valueSource, bodyCell, isSubtotalItem = rowItem.isSubtotal === !0 || columnItem.isSubtotal === !0, rowIndex = rowItem.leafIndex, colIndex = columnItem.leafIndex;
                return node = rowItem.values ? rowItem.values[columnItem.leafIndex] : void 0, node ? (valueSource = this.matrix.valueSources[node.valueSourceIndex || 0], 
                bodyCell = new MatrixVisualBodyItem(node.value, isSubtotalItem, valueSource, this.formatter)) : bodyCell = new MatrixVisualBodyItem(void 0, isSubtotalItem, void 0, this.formatter), 
                bodyCell.position.row.index = rowIndex, bodyCell.position.row.isFirst = 0 === rowIndex, 
                bodyCell.position.row.isLast = rowIndex === this.rowHierarchy.leafNodes.length - 1, 
                bodyCell.position.column.index = colIndex, bodyCell.position.column.isFirst = 0 === colIndex, 
                bodyCell.position.column.isLast = colIndex === this.columnHierarchy.leafNodes.length - 1, 
                bodyCell;
            }, MatrixHierarchyNavigator.prototype.getCorner = function(rowLevel, columnLevel) {
                var columnLevels = this.columnHierarchy.levels, rowLevels = this.rowHierarchy.levels;
                if (columnLevel === columnLevels.length - 1 || 0 === columnLevels.length) {
                    var levelSource = rowLevels[rowLevel];
                    if (levelSource) return {
                        metadata: levelSource.sources[0],
                        isColumnHeaderLeaf: !0,
                        isRowHeaderLeaf: rowLevel === rowLevels.length - 1
                    };
                }
                if (rowLevel === rowLevels.length - 1) {
                    var levelSource = columnLevels[columnLevel];
                    if (levelSource) return {
                        metadata: levelSource.sources[0],
                        isColumnHeaderLeaf: !1,
                        isRowHeaderLeaf: !0
                    };
                }
                return {
                    metadata: null,
                    isColumnHeaderLeaf: !1,
                    isRowHeaderLeaf: !1
                };
            }, MatrixHierarchyNavigator.prototype.headerItemEquals = function(item1, item2) {
                return item1 && item2 ? item1 === item2 : !1;
            }, MatrixHierarchyNavigator.prototype.bodyCellItemEquals = function(item1, item2) {
                return item1.position.isMatch(item2.position);
            }, MatrixHierarchyNavigator.prototype.cornerCellItemEquals = function(item1, item2) {
                return item1 === item2;
            }, MatrixHierarchyNavigator.prototype.getMatrixColumnHierarchy = function() {
                return this.columnHierarchy;
            }, MatrixHierarchyNavigator.prototype.getMatrixRowHierarchy = function() {
                return this.rowHierarchy;
            }, MatrixHierarchyNavigator.prototype.update = function(dataViewMatrix, updateColumns) {
                void 0 === updateColumns && (updateColumns = !0), dataViewMatrix && (this.matrix = dataViewMatrix, 
                this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.rows), 
                updateColumns && (this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.columns))), 
                this.updateHierarchy(this.rowHierarchy), updateColumns && (this.updateHierarchy(this.columnHierarchy), 
                MatrixHierarchyNavigator.updateStaticColumnHeaders(this.columnHierarchy));
            }, MatrixHierarchyNavigator.wrapMatrixHierarchy = function(hierarchy) {
                var matrixHierarchy = powerbi.Prototype.inherit(hierarchy);
                return matrixHierarchy.leafNodes = [], matrixHierarchy;
            }, MatrixHierarchyNavigator.prototype.updateHierarchy = function(hierarchy) {
                hierarchy.leafNodes.length > 0 && (hierarchy.leafNodes.length = 0), hierarchy.root.children && this.updateRecursive(hierarchy, hierarchy.root.children, null, hierarchy.leafNodes);
            }, MatrixHierarchyNavigator.prototype.updateRecursive = function(hierarchy, nodes, parent, cache) {
                for (var level, i = 0, ilen = nodes.length; ilen > i; i++) {
                    var node = nodes[i];
                    if (node.siblings = nodes, parent && (node.parent = parent), level || (level = hierarchy.levels[node.level]), 
                    level) {
                        var source = level.sources[node.levelSourceIndex ? node.levelSourceIndex : 0], formatString = visuals.valueFormatter.getFormatString(source, TablixObjects.PropColumnFormatString.getPropertyID());
                        formatString && (node.name = this.formatter(node.value, source, TablixObjects.PropColumnFormatString.getPropertyID())), 
                        node.queryName = source.queryName;
                    }
                    node.index = i, node.children && node.children.length > 0 ? this.updateRecursive(hierarchy, node.children, node, cache) : (node.leafIndex = cache.length, 
                    cache.push(node));
                }
            }, MatrixHierarchyNavigator.updateStaticColumnHeaders = function(columnHierarchy) {
                var columnLeafNodes = columnHierarchy.leafNodes;
                if (columnLeafNodes && columnLeafNodes.length > 0) for (var columnLeafSources = columnHierarchy.levels[columnLeafNodes[0].level].sources, i = 0, ilen = columnLeafNodes.length; ilen > i; i++) {
                    var columnLeafNode = columnLeafNodes[i];
                    if (!columnLeafNode.identity && void 0 === columnLeafNode.value) {
                        var source = columnLeafSources[columnLeafNode.levelSourceIndex ? columnLeafNode.levelSourceIndex : 0];
                        source && (columnLeafNode.name = source.displayName);
                    }
                }
            }, MatrixHierarchyNavigator.prototype.getMatrixHierarchy = function(rootNodes) {
                var rowHierarchyRootNodes = this.rowHierarchy.root.children;
                if (rowHierarchyRootNodes && rootNodes === rowHierarchyRootNodes) return this.rowHierarchy;
                var columnHierarchyRootNodes = this.columnHierarchy.root.children;
                return columnHierarchyRootNodes && rootNodes === columnHierarchyRootNodes ? this.columnHierarchy : null;
            }, MatrixHierarchyNavigator;
        }(), MatrixBinder = function() {
            function MatrixBinder(hierarchyNavigator, options) {
                this.hierarchyNavigator = hierarchyNavigator, this.options = options, this.formattingProperties = {
                    isFormattingEnabled: !1
                };
            }
            return MatrixBinder.prototype.onDataViewChanged = function(formattingProperties) {
                this.formattingProperties = formattingProperties;
            }, MatrixBinder.prototype.onStartRenderingSession = function() {}, MatrixBinder.prototype.onEndRenderingSession = function() {}, 
            MatrixBinder.prototype.bindRowHeader = function(item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                isLeaf && TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf), 
                item.isSubtotal && (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderSubTotal), 
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal)), this.bindHeader(item, cell, this.getRowHeaderMetadata(item)), 
                this.options.onBindRowHeader && this.options.onBindRowHeader(item), this.formattingProperties.isFormattingEnabled && this.getRowHeaderStyle(cell).applyStyle(cell);
            }, MatrixBinder.prototype.getRowHeaderStyle = function(cell) {
                var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.rowHeaders, style = new TablixUtils.CellStyle();
                return style.borders.top = new TablixUtils.EdgeSettings(), cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.bottom = new TablixUtils.EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor), 
                style.borders.left = new TablixUtils.EdgeSettings(), cell.position.column.isFirst && style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.right = new TablixUtils.EdgeSettings(), cell.position.column.isLast ? style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor), 
                style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, 
                style;
            }, MatrixBinder.prototype.unbindRowHeader = function(item, cell) {
                TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
            }, MatrixBinder.prototype.bindColumnHeader = function(item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var overwriteTotalLabel = !1, isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf), TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
                    var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                    sortableHeaderColumnMetadata && this.options.showSortIcons && (this.registerColumnHeaderClickHandler(sortableHeaderColumnMetadata, cell), 
                    TablixUtils.createColumnHeaderWithSortIcon(sortableHeaderColumnMetadata, cell)), 
                    item.isSubtotal && item.parent && item.parent.children.length > 1 && item.parent.children[0].isSubtotal && (overwriteTotalLabel = !0);
                }
                item.isSubtotal && TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal), 
                cell.extension.disableDragResize(), this.bindHeader(item, cell, this.getColumnHeaderMetadata(item), overwriteTotalLabel), 
                this.formattingProperties.isFormattingEnabled && this.getColumnHeaderStyle(cell).applyStyle(cell);
            }, MatrixBinder.prototype.getColumnHeaderStyle = function(cell) {
                var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.columnHeaders, style = new TablixUtils.CellStyle();
                return style.borders.top = new TablixUtils.EdgeSettings(), cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.bottom = new TablixUtils.EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor), 
                style.borders.left = new TablixUtils.EdgeSettings(), style.borders.right = new TablixUtils.EdgeSettings(), 
                cell.position.column.isLast ? style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor), 
                style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, 
                style;
            }, MatrixBinder.prototype.unbindColumnHeader = function(item, cell) {
                TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
                var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                sortableHeaderColumnMetadata && this.unregisterColumnHeaderClickHandler(cell), this.options.showSortIcons && TablixUtils.removeSortIcons(cell);
            }, MatrixBinder.prototype.registerColumnHeaderClickHandler = function(columnMetadata, cell) {
                var _this = this;
                if (this.options.onColumnHeaderClick) {
                    var handler = function(e) {
                        if (TablixUtils.isValidSortClick(e)) {
                            var sortDirection = TablixUtils.reverseSort(columnMetadata.sort);
                            _this.options.onColumnHeaderClick(columnMetadata.queryName ? columnMetadata.queryName : columnMetadata.displayName, sortDirection);
                        }
                    };
                    cell.extension.registerClickHandler(handler);
                }
            }, MatrixBinder.prototype.unregisterColumnHeaderClickHandler = function(cell) {
                this.options.onColumnHeaderClick && cell.extension.unregisterClickHandler();
            }, MatrixBinder.prototype.bindBodyCell = function(item, cell) {
                TablixUtils.resetCellCssClass(cell), TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric), 
                item.isTotal && TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal), 
                item.textContent ? TablixUtils.setCellTextAndTooltip(cell, item.textContent) : _.isEmpty(item.domContent) || $(cell.extension.contentHost).append(item.domContent), 
                this.formattingProperties.isFormattingEnabled && this.getBodyCellStyle(cell, item).applyStyle(cell);
            }, MatrixBinder.prototype.getBodyCellStyle = function(cell, item) {
                var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.values, propsTotal = this.formattingProperties.subtotals, style = new TablixUtils.CellStyle();
                return style.borders.top = new TablixUtils.EdgeSettings(), cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.bottom = new TablixUtils.EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor), 
                style.borders.left = new TablixUtils.EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft), style.borders.right = new TablixUtils.EdgeSettings(), 
                cell.position.column.isLast ? style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor), 
                item.isTotal && propsTotal.fontColor ? style.fontColor = propsTotal.fontColor : style.fontColor = cell.position.row.index % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary, 
                item.isTotal && propsTotal.backColor ? style.backColor = propsTotal.backColor : style.backColor = cell.position.row.index % 2 === 0 ? props.backColorPrimary : props.backColorSecondary, 
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, style;
            }, MatrixBinder.prototype.unbindBodyCell = function(item, cell) {
                TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
            }, MatrixBinder.prototype.bindCornerCell = function(item, cell) {
                if (TablixUtils.resetCellCssClass(cell), item.isColumnHeaderLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                    var cornerHeaderMetadata = this.getSortableCornerColumnMetadata(item);
                    cornerHeaderMetadata && this.registerColumnHeaderClickHandler(cornerHeaderMetadata, cell), 
                    this.options.showSortIcons ? TablixUtils.createColumnHeaderWithSortIcon(cornerHeaderMetadata, cell) : TablixUtils.setCellTextAndTooltip(cell, cornerHeaderMetadata.displayName);
                } else {
                    var itemText = item.metadata ? item.metadata.displayName : "";
                    TablixUtils.setCellTextAndTooltip(cell, itemText);
                }
                item.isRowHeaderLeaf && TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf), 
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader), this.formattingProperties.isFormattingEnabled && this.getCornerCellsStyle(cell).applyStyle(cell), 
                cell.extension.disableDragResize();
            }, MatrixBinder.prototype.getCornerCellsStyle = function(cell) {
                var propsGrid = this.formattingProperties.grid, propsCol = this.formattingProperties.columnHeaders, propsRow = this.formattingProperties.rowHeaders, style = new TablixUtils.CellStyle();
                return style.borders.top = new TablixUtils.EdgeSettings(), cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.bottom = new TablixUtils.EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor), 
                style.borders.left = new TablixUtils.EdgeSettings(), cell.position.column.isFirst && style.borders.left.applyParams(visuals.outline.showLeft(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor), 
                style.borders.right = new TablixUtils.EdgeSettings(), style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor), 
                style.fontColor = propsCol.fontColor || propsRow.fontColor, style.backColor = propsCol.backColor || propsRow.backColor, 
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, style;
            }, MatrixBinder.prototype.unbindCornerCell = function(item, cell) {
                TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell), this.options.showSortIcons && TablixUtils.removeSortIcons(cell), 
                item.isColumnHeaderLeaf && this.unregisterColumnHeaderClickHandler(cell);
            }, MatrixBinder.prototype.bindEmptySpaceHeaderCell = function(cell) {}, MatrixBinder.prototype.unbindEmptySpaceHeaderCell = function(cell) {}, 
            MatrixBinder.prototype.bindEmptySpaceFooterCell = function(cell) {}, MatrixBinder.prototype.unbindEmptySpaceFooterCell = function(cell) {}, 
            MatrixBinder.prototype.getHeaderLabel = function(item) {
                return MatrixBinder.getNodeLabel(item);
            }, MatrixBinder.prototype.getCellContent = function(item) {
                return item.textContent || "";
            }, MatrixBinder.prototype.hasRowGroups = function() {
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                return !!(dataView && dataView.rows && dataView.rows.levels && 0 !== dataView.rows.levels.length);
            }, MatrixBinder.getNodeLabel = function(node) {
                return node.name ? node.name : null != node.value ? node.value.toString() : "";
            }, MatrixBinder.prototype.bindHeader = function(item, cell, metadata, overwriteSubtotalLabel) {
                if (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader), item.isSubtotal && !overwriteSubtotalLabel) return void TablixUtils.setCellTextAndTooltip(cell, this.options.totalLabel);
                var value = MatrixBinder.getNodeLabel(item);
                return value ? void (visuals.converterHelper.isWebUrlColumn(metadata) && UrlUtils.isValidUrl(value) ? TablixUtils.appendATagToBodyCell(item.value, cell) : visuals.converterHelper.isImageUrlColumn(metadata) && UrlUtils.isValidImageUrl(value) ? TablixUtils.appendImgTagToBodyCell(item.value, cell) : TablixUtils.setCellTextAndTooltip(cell, value)) : void (cell.extension.contentHost.innerHTML = TablixUtils.StringNonBreakingSpace);
            }, MatrixBinder.prototype.getSortableCornerColumnMetadata = function(item) {
                return item.isColumnHeaderLeaf ? item.metadata : null;
            }, MatrixBinder.prototype.getRowHeaderMetadata = function(item) {
                if (this.hierarchyNavigator && item) {
                    var dataView = this.hierarchyNavigator.getDataViewMatrix();
                    if (dataView && dataView.rows) return this.getHierarchyMetadata(dataView.rows, item.level);
                }
            }, MatrixBinder.prototype.getColumnHeaderMetadata = function(item) {
                if (this.hierarchyNavigator && item) {
                    var dataView = this.hierarchyNavigator.getDataViewMatrix();
                    if (dataView && dataView.columns) return this.getHierarchyMetadata(dataView.columns, item.level);
                }
            }, MatrixBinder.prototype.getHierarchyMetadata = function(hierarchy, level) {
                if (hierarchy && hierarchy.levels && !(hierarchy.levels.length < level)) {
                    var levelInfo = hierarchy.levels[level];
                    if (levelInfo && levelInfo.sources && 0 !== levelInfo.sources.length) return levelInfo.sources[0];
                }
            }, MatrixBinder.prototype.getSortableHeaderColumnMetadata = function(item) {
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView.rows || !dataView.rows.levels || 0 === dataView.rows.levels.length) return null;
                var columnGroupCount = dataView.columns ? dataView.columns.levels.length : 0, valueIndex = -1;
                if (0 === columnGroupCount) valueIndex = item.levelSourceIndex; else if (item.isSubtotal) {
                    var isMultiMeasure = dataView.valueSources && dataView.valueSources.length > 1;
                    isMultiMeasure ? item.parent && 0 === item.parent.level && (valueIndex = item.levelSourceIndex) : 0 === item.level && (valueIndex = item.levelSourceIndex);
                }
                return -1 !== valueIndex ? (valueIndex = valueIndex ? valueIndex : 0, dataView.valueSources[valueIndex]) : null;
            }, MatrixBinder;
        }();
        visuals.MatrixBinder = MatrixBinder;
        var Matrix = function() {
            function Matrix(options) {
                options && (this.isFormattingPropertiesEnabled = options.isFormattingPropertiesEnabled, 
                this.isTouchEnabled = options.isTouchEnabled);
            }
            return Matrix.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (dataViewMapping && dataViewMapping.matrix && dataViewMapping.metadata) {
                    var dataViewMatrix = dataViewMapping.matrix;
                    _.isEmpty(dataViewMatrix.columns["for"]["in"].items) || (dataViewMatrix.rows.dataReductionAlgorithm.window.count = 100);
                    var objects = dataViewMapping.metadata.objects;
                    dataViewMatrix.rows["for"]["in"].subtotalType = TablixObjects.shouldShowRowSubtotals(objects) ? 2 : 0, 
                    dataViewMatrix.columns["for"]["in"].subtotalType = TablixObjects.shouldShowColumnSubtotals(objects) ? 2 : 0;
                }
            }, Matrix.getSortableRoles = function() {
                return [ "Rows", "Values" ];
            }, Matrix.prototype.init = function(options) {
                this.element = options.element, this.style = options.style, this.updateViewport(options.viewport), 
                this.formatter = visuals.valueFormatter.formatValueColumn, this.isInteractive = options.interactivity && null != options.interactivity.selection, 
                this.hostServices = options.host, this.persistingObjects = !1, this.waitingForData = !1, 
                this.lastAllowHeaderResize = !0, this.waitingForSort = !1;
            }, Matrix.converter = function(dataView, isFormattingEnabled) {
                return TablixObjects.getMatrixObjects(dataView, isFormattingEnabled);
            }, Matrix.prototype.onResizing = function(finalViewport) {
                this.updateViewport(finalViewport);
            }, Matrix.prototype.getColumnWidthManager = function() {
                return this.columnWidthManager;
            }, Matrix.prototype.onDataChanged = function(options) {
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var previousDataView = this.dataView;
                    this.dataView = dataViews[0];
                    var formattingProperties = Matrix.converter(this.dataView, this.isFormattingPropertiesEnabled);
                    formattingProperties.isFormattingEnabled = this.isFormattingPropertiesEnabled;
                    var textSize = formattingProperties.general.textSize;
                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
                        var rootChanged = previousDataView.matrix.rows.root !== this.dataView.matrix.rows.root;
                        this.hierarchyNavigator.update(this.dataView.matrix, rootChanged), rootChanged && this.tablixControl.updateModels(!1, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children), 
                        this.refreshControl(!1);
                    } else {
                        this.createOrUpdateHierarchyNavigator(), this.createColumnWidthManager(), this.createTablixControl(textSize);
                        var binder = this.tablixControl.getBinder();
                        binder.onDataViewChanged(formattingProperties), this.updateInternal(textSize, previousDataView);
                    }
                }
                this.waitingForData = !1, this.waitingForSort = !1;
            }, Matrix.prototype.createColumnWidthManager = function() {
                var _this = this, columnHierarchy = this.hierarchyNavigator.getMatrixColumnHierarchy();
                this.columnWidthManager ? this.persistingObjects || this.columnWidthManager.updateDataView(this.dataView, columnHierarchy.leafNodes) : this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, !0, function(objectInstances) {
                    return _this.persistColumnWidths(objectInstances);
                }, columnHierarchy.leafNodes);
            }, Matrix.prototype.persistColumnWidths = function(objectInstances) {
                this.persistingObjects = !0, this.hostServices.persistProperties(objectInstances);
            }, Matrix.prototype.updateViewport = function(newViewport) {
                this.currentViewport = newViewport, this.tablixControl && (this.tablixControl.viewport = this.currentViewport, 
                this.verifyHeaderResize(), this.refreshControl(!1));
            }, Matrix.prototype.refreshControl = function(clear) {
                (visuals.visibilityHelper.partiallyVisible(this.element) || 1 === this.getLayoutKind()) && this.tablixControl.refresh(clear);
            }, Matrix.prototype.getLayoutKind = function() {
                return this.isInteractive ? 0 : 1;
            }, Matrix.prototype.createOrUpdateHierarchyNavigator = function() {
                if (this.tablixControl) this.hierarchyNavigator.update(this.dataView.matrix); else {
                    var matrixNavigator = createMatrixHierarchyNavigator(this.dataView.matrix, this.formatter);
                    this.hierarchyNavigator = matrixNavigator;
                }
            }, Matrix.prototype.createTablixControl = function(textSize) {
                this.tablixControl || (this.tablixControl = this.createControl(this.hierarchyNavigator, textSize));
            }, Matrix.prototype.createControl = function(matrixNavigator, textSize) {
                var _this = this, layoutKind = this.getLayoutKind(), matrixBinderOptions = {
                    onBindRowHeader: function(item) {
                        _this.onBindRowHeader(item);
                    },
                    totalLabel: this.hostServices.getLocalizedString(Matrix.TotalLabel),
                    onColumnHeaderClick: function(queryName, sortDirection) {
                        return _this.onColumnHeaderClick(queryName, sortDirection);
                    },
                    showSortIcons: 0 === layoutKind
                }, matrixBinder = new MatrixBinder(this.hierarchyNavigator, matrixBinderOptions), layoutManager = 1 === layoutKind ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(matrixBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(matrixBinder, this.columnWidthManager), tablixContainer = document.createElement("div");
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: this.isTouchEnabled,
                    layoutKind: layoutKind,
                    fontSize: TablixObjects.getTextSizeInPx(textSize)
                };
                return new visuals.controls.TablixControl(matrixNavigator, layoutManager, matrixBinder, tablixContainer, tablixOptions);
            }, Matrix.prototype.updateInternal = function(textSize, previousDataView) {
                var _this = this;
                1 === this.getLayoutKind() && this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView)), 
                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize), this.verifyHeaderResize(), 
                this.tablixControl.updateModels(!this.persistingObjects, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children), 
                this.tablixControl.viewport = this.currentViewport;
                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                setTimeout(function() {
                    return _this.refreshControl(shouldClearControl), _this.persistingObjects ? void (_this.persistingObjects = !1) : void (_this.columnWidthManager.shouldPersistAllColumnWidths() && _this.columnWidthManager.persistAllColumnWidths(_this.tablixControl.layoutManager.columnWidthsToPersist));
                }, 0);
            }, Matrix.prototype.shouldClearControl = function(previousDataView, newDataView) {
                return this.waitingForSort && previousDataView && newDataView ? !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata) : !0;
            }, Matrix.prototype.onBindRowHeader = function(item) {
                this.needsMoreData(item) && (this.hostServices.loadMoreData(), this.waitingForData = !0);
            }, Matrix.prototype.onColumnHeaderClick = function(queryName, sortDirection) {
                this.waitingForSort = !0, this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
            }, Matrix.prototype.needsMoreData = function(item) {
                if (this.waitingForData || !this.hierarchyNavigator.isLeaf(item) || !this.dataView.metadata || !this.dataView.metadata.segment) return !1;
                var leafCount = this.tablixControl.rowDimension.getItemsCount(), loadMoreThreshold = leafCount * Matrix.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getLeafIndex(item) >= loadMoreThreshold;
            }, Matrix.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                return this.dataView && TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, this.isFormattingPropertiesEnabled, !1, visuals.controls.TablixType.Matrix), 
                enumeration.complete();
            }, Matrix.prototype.shouldAllowHeaderResize = function() {
                return 1 === this.hostServices.getViewMode();
            }, Matrix.prototype.onViewModeChanged = function(viewMode) {
                this.updateViewport(this.currentViewport);
            }, Matrix.prototype.verifyHeaderResize = function() {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                currentAllowHeaderResize !== this.lastAllowHeaderResize && (this.lastAllowHeaderResize = currentAllowHeaderResize, 
                this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize));
            }, Matrix.preferredLoadMoreThreshold = .8, Matrix.TotalLabel = "TableTotalLabel", 
            Matrix;
        }();
        visuals.Matrix = Matrix;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var CssConstants = jsCommon.CssConstants, Treemap = function() {
            function Treemap(options) {
                this.tooltipsEnabled = options && options.tooltipsEnabled, options && options.animator && (this.animator = options.animator, 
                this.isScrollable = options.isScrollable ? options.isScrollable : !1, this.behavior = options.behavior);
            }
            return Treemap.getLayout = function(labelsSettings, alternativeScale) {
                var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), majorLabelsEnabled = labelsSettings.showCategory, minorLabelsEnabled = labelsSettings.show || labelsSettings.showCategory;
                return {
                    shapeClass: function(d) {
                        return Treemap.getNodeClass(d, !1);
                    },
                    shapeLayout: Treemap.createTreemapShapeLayout(!1),
                    highlightShapeClass: function(d) {
                        return Treemap.getNodeClass(d, !0);
                    },
                    highlightShapeLayout: Treemap.createTreemapShapeLayout(!0),
                    zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
                    majorLabelClass: function(d) {
                        return Treemap.MajorLabelClassName;
                    },
                    majorLabelLayout: {
                        x: function(d) {
                            return d.x + Treemap.TextMargin;
                        },
                        y: function(d) {
                            return d.y + Treemap.TextMargin + Treemap.MajorLabelTextSize;
                        }
                    },
                    majorLabelText: function(d) {
                        return Treemap.createMajorLabelText(d, labelsSettings, alternativeScale, formattersCache);
                    },
                    minorLabelClass: function(d) {
                        return Treemap.MinorLabelClassName;
                    },
                    minorLabelLayout: {
                        x: function(d) {
                            return d.x + Treemap.TextMargin;
                        },
                        y: function(d) {
                            return d.y + d.dy - Treemap.TextMargin;
                        }
                    },
                    minorLabelText: function(d) {
                        return Treemap.createMinorLabelText(d, labelsSettings, alternativeScale, formattersCache);
                    },
                    areMajorLabelsEnabled: function() {
                        return majorLabelsEnabled;
                    },
                    areMinorLabelsEnabled: function() {
                        return minorLabelsEnabled;
                    }
                };
            }, Treemap.prototype.init = function(options) {
                this.options = options;
                var element = options.element;
                element.empty(), this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(Treemap.ClassName, !0), 
                this.shapeGraphicsContext = this.svg.append("g").classed(Treemap.ShapesClassName, !0), 
                this.labelGraphicsContext = this.svg.append("g").classed(Treemap.LabelsGroupClassName, !0), 
                this.element = element, this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width
                }, this.style = options.style, this.treemap = d3.layout.treemap().sticky(!1).sort(function(a, b) {
                    return a.size - b.size;
                }).value(function(d) {
                    return d.size;
                }).round(!1), this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable), 
                this.colors = this.style.colorPalette.dataColors, this.hostService = options.host;
            }, Treemap.converter = function(dataView, colors, labelSettings, interactivityService, viewport, legendObjectProperties, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var hasHighlights, rootNode = {
                    key: "root",
                    name: "root",
                    children: [],
                    selected: !1,
                    highlightMultiplier: 0,
                    identity: visuals.SelectionId.createNull(),
                    color: void 0
                }, allNodes = [], legendDataPoints = [], legendTitle = "", colorHelper = new visuals.ColorHelper(colors, visuals.treemapProps.dataPoint.fill), dataWasCulled = void 0;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    labelSettings.show = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.show, labelSettings.show), 
                    labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.treemapProps.labels.color, labelSettings.labelColor), 
                    labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelDisplayUnits, labelSettings.displayUnits), 
                    labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelPrecision, labelSettings.precision), 
                    labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.categoryLabels.show, labelSettings.showCategory);
                }
                if (dataView && dataView.categorical && dataView.categorical.values) {
                    var data_9 = dataView.categorical, valueColumns = data_9.values;
                    hasHighlights = !!(valueColumns.length > 0 && valueColumns[0].highlights);
                    var formatStringProp = visuals.treemapProps.general.formatString, result = Treemap.getValuesFromCategoricalDataView(data_9, hasHighlights), values = result.values, highlights = result.highlights, totalValue = result.totalValue;
                    result.highlightsOverflow && (hasHighlights = !1, values = highlights);
                    var cullableValue = Treemap.getCullableValue(totalValue, viewport), grouped = valueColumns.grouped(), isMultiSeries = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1, hasDynamicSeries = !!valueColumns.source;
                    dataWasCulled = !1;
                    var shouldCullValue = void 0, highlight = void 0, gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(data_9), gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(data_9);
                    if (null != data_9.categories || _.isEmpty(values)) {
                        if (data_9.categories && data_9.categories.length > 0) {
                            var valueColumnCount = valueColumns.length - (-1 !== gradientMeasureIndex ? 1 : 0), omitSecondLevel = 1 === valueColumnCount && null == valueColumns[0].source.groupName, categoryColumn = data_9.categories[0];
                            legendTitle = categoryColumn.source ? categoryColumn.source.displayName : "";
                            for (var categorical = void 0, categoryFormat = visuals.valueFormatter.getFormatString(categoryColumn.source, formatStringProp), categoryIndex = 0, categoryLen = values.length; categoryLen > categoryIndex; categoryIndex++) {
                                var identity = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, categoryIndex).createSelectionId(), key = JSON.stringify({
                                    nodeKey: identity.getKey(),
                                    depth: 1
                                }), objects = categoryColumn.objects && categoryColumn.objects[categoryIndex], color = colorHelper.getColorForSeriesValue(objects, categoryColumn.identityFields, categoryColumn.values[categoryIndex]), categoryValue = visuals.valueFormatter.format(categoryColumn.values[categoryIndex], categoryFormat), currentValues = values[categoryIndex];
                                categorical = dataView.categorical;
                                var seriesIndex = 0 === gradientMeasureIndex ? 1 : 0, value = currentValues[seriesIndex], highlightValue = hasHighlights && highlights ? highlights[categoryIndex][seriesIndex] : void 0, tooltipInfo = void 0, highlightedTooltipInfo = void 0;
                                tooltipsEnabled && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, seriesIndex, categoryIndex, null, omitSecondLevel ? gradientValueColumn : void 0), 
                                void 0 !== highlightValue && (highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, seriesIndex, categoryIndex, highlightValue, omitSecondLevel ? gradientValueColumn : void 0)));
                                var node = {
                                    key: key,
                                    name: categoryValue,
                                    color: color,
                                    selected: !1,
                                    identity: identity,
                                    tooltipInfo: tooltipInfo,
                                    highlightedTooltipInfo: highlightedTooltipInfo,
                                    labelFormatString: 1 === valueColumnCount ? visuals.valueFormatter.getFormatString(data_9.values[0].source, formatStringProp) : categoryFormat
                                };
                                hasHighlights && (node.highlightMultiplier = 0 !== value ? highlightValue / value : 0, 
                                node.highlightValue = highlightValue), legendDataPoints.push({
                                    label: categoryValue,
                                    color: color,
                                    icon: visuals.LegendIcon.Box,
                                    identity: identity,
                                    selected: !1
                                });
                                for (var total = 0, highlightTotal = 0, j = 0, jlen = currentValues.length; jlen > j; j++) if (j !== gradientMeasureIndex) {
                                    var valueColumn = valueColumns[j], value_1 = currentValues[j], highlight_1 = void 0;
                                    if (shouldCullValue = cullableValue > value_1, Treemap.checkValueForShape(value_1) && !shouldCullValue) {
                                        if (total += value_1, hasHighlights && (highlight_1 = highlights[categoryIndex][j], 
                                        highlightTotal += highlight_1), !omitSecondLevel) {
                                            var childName = null;
                                            childName = isMultiSeries ? valueColumn.source.displayName : valueColumn.source.groupName;
                                            var categoricalValues = categorical ? categorical.values : null, measureId = isMultiSeries ? valueColumn.source.queryName : void 0, childIdentity = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, categoryIndex).withSeries(categoricalValues, valueColumn).withMeasure(measureId).createSelectionId(), childKey = JSON.stringify({
                                                nodeKey: childIdentity.getKey(),
                                                depth: 2
                                            }), highlightedValue = hasHighlights && 0 !== highlight_1 ? highlight_1 : void 0;
                                            categorical = dataView.categorical;
                                            var tooltipInfo_4 = void 0, highlightedTooltipInfo_1 = void 0;
                                            tooltipsEnabled && (tooltipInfo_4 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value_1, null, null, j, categoryIndex, null, gradientValueColumn), 
                                            void 0 !== highlightedValue && (highlightedTooltipInfo_1 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value_1, null, null, j, categoryIndex, highlightedValue, gradientValueColumn)));
                                            var childNode = {
                                                key: childKey,
                                                name: childName,
                                                size: value_1,
                                                color: color,
                                                selected: !1,
                                                identity: childIdentity,
                                                tooltipInfo: tooltipInfo_4,
                                                highlightedTooltipInfo: highlightedTooltipInfo_1,
                                                labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp)
                                            };
                                            hasHighlights && (childNode.highlightMultiplier = 0 !== value_1 ? highlight_1 / value_1 : 0, 
                                            childNode.highlightValue = highlight_1), null == node.children && (node.children = []), 
                                            node.children.push(childNode), allNodes.push(childNode);
                                        }
                                    } else dataWasCulled = dataWasCulled || shouldCullValue;
                                }
                                Treemap.checkValueForShape(total) && (node.size = total, rootNode.children.push(node), 
                                allNodes.push(node)), hasHighlights && (node.highlightMultiplier = total ? highlightTotal / total : 0);
                            }
                        }
                    } else for (var i = 0, ilen = values[0].length; ilen > i; i++) if (i !== gradientMeasureIndex) {
                        var value = values[0][i];
                        if (Treemap.checkValueForShape(value)) if (cullableValue > value) dataWasCulled = dataWasCulled || shouldCullValue; else {
                            var valueColumn = valueColumns[i], nodeName = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, valueColumns, formatStringProp), identity = hasDynamicSeries ? visuals.SelectionId.createWithId(valueColumns[i].identity) : visuals.SelectionId.createWithMeasure(valueColumns[i].source.queryName), key = identity.getKey(), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(grouped[i] && grouped[i].objects, data_9.values.identityFields, visuals.converterHelper.getSeriesName(valueColumn.source)) : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName), highlightedValue = hasHighlights && 0 !== highlight ? highlight : void 0, categorical = dataView.categorical, valueIndex = i, tooltipInfo = void 0, highlightedTooltipInfo = void 0;
                            tooltipsEnabled && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, nodeName, value, null, null, valueIndex, i), 
                            void 0 !== highlightedValue && (highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, nodeName, value, null, null, valueIndex, i, highlightedValue)));
                            var node = {
                                key: key,
                                name: nodeName,
                                size: value,
                                color: color,
                                selected: !1,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo,
                                labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp)
                            };
                            hasHighlights && highlights && (node.highlightMultiplier = 0 !== value ? highlights[0][i] / value : 0, 
                            node.highlightValue = highlights[0][i]), rootNode.children.push(node), allNodes.push(node), 
                            legendDataPoints.push({
                                label: nodeName,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                identity: identity,
                                selected: !1
                            });
                        }
                    }
                }
                return interactivityService && (interactivityService.applySelectionStateToData(allNodes), 
                interactivityService.applySelectionStateToData(legendDataPoints)), {
                    root: rootNode,
                    hasHighlights: hasHighlights,
                    legendData: {
                        title: legendTitle,
                        dataPoints: legendDataPoints,
                        fontSize: visuals.SVGLegend.DefaultFontSizeInPt
                    },
                    dataLabelsSettings: labelSettings,
                    legendObjectProperties: legendObjectProperties,
                    dataWasCulled: dataWasCulled
                };
            }, Treemap.getValuesFromCategoricalDataView = function(data, hasHighlights) {
                var categoryValueCount, valueColumns = data.values;
                valueColumns && null == data.categories ? categoryValueCount = 1 : valueColumns && data.categories && data.categories.length > 0 && (categoryValueCount = data.categories[0].values.length);
                for (var values = [], highlights = [], totalValue = 0, i = 0; categoryValueCount > i; i++) values.push([]), 
                hasHighlights && highlights.push([]);
                for (var highlightsOverflow, j = 0; j < valueColumns.length; j++) for (var valueColumn = valueColumns[j], i = 0; categoryValueCount > i; i++) {
                    var value = valueColumn.values[i];
                    if (values[i].push(value), totalValue += isNaN(value) ? 0 : value, hasHighlights) {
                        var highlight = valueColumn.highlights[i];
                        highlight || (highlight = 0), highlights[i].push(highlight), highlight > value && (highlightsOverflow = !0);
                    }
                }
                return {
                    values: values,
                    highlights: hasHighlights ? highlights : void 0,
                    highlightsOverflow: hasHighlights ? highlightsOverflow : void 0,
                    totalValue: totalValue
                };
            }, Treemap.getCullableValue = function(totalValue, viewport) {
                var totalArea = viewport.width * viewport.height, culledPercent = Treemap.CullableArea / totalArea;
                return culledPercent * totalValue;
            }, Treemap.prototype.update = function(options) {
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                var dataViewCategorical = dataViews && dataViews.length > 0 && dataViews[0].categorical ? dataViews[0].categorical : void 0, labelSettings = visuals.dataLabelUtils.getDefaultTreemapLabelSettings(), legendObjectProperties = null;
                if (dataViewCategorical) {
                    var dataView = dataViews[0], dataViewMetadata = dataView.metadata, objects = void 0;
                    dataViewMetadata && (objects = dataViewMetadata.objects), objects && (legendObjectProperties = objects.legend), 
                    this.data = Treemap.converter(dataView, this.colors, labelSettings, this.interactivityService, this.currentViewport, legendObjectProperties, this.tooltipsEnabled);
                } else {
                    var rootNode = {
                        key: "root",
                        name: "root",
                        children: [],
                        selected: !1,
                        highlightMultiplier: 0,
                        identity: visuals.SelectionId.createNull(),
                        color: void 0
                    }, legendData = {
                        title: "",
                        dataPoints: []
                    }, treeMapData = {
                        root: rootNode,
                        hasHighlights: !1,
                        legendData: legendData,
                        dataLabelsSettings: labelSettings,
                        dataWasCulled: !1
                    };
                    this.data = treeMapData;
                }
                if (this.updateInternal(options.suppressAnimations), dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                    this.hostService.setWarnings(warnings);
                }
            }, Treemap.prototype.onDataChanged = function(options) {
                this.update({
                    suppressAnimations: options.suppressAnimations,
                    dataViews: options.dataViews,
                    viewport: this.currentViewport
                });
            }, Treemap.prototype.onResizing = function(viewport) {
                this.update({
                    suppressAnimations: !0,
                    dataViews: this.dataViews,
                    viewport: viewport
                });
            }, Treemap.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, Treemap.prototype.enumerateObjectInstances = function(options) {
                var data = this.data;
                if (data) {
                    var objectName = options.objectName, enumeration = new visuals.ObjectEnumerationBuilder(), dataLabelsSettings = this.data.dataLabelsSettings ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                    switch (objectName) {
                      case "dataPoint":
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical, hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        hasGradientRole || this.enumerateDataPoints(enumeration, data);
                        break;

                      case "legend":
                        return this.enumerateLegend(data);

                      case "labels":
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: dataLabelsSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;

                      case "categoryLabels":
                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, dataLabelsSettings, !1, !0);
                    }
                    return enumeration.complete();
                }
            }, Treemap.prototype.enumerateDataPoints = function(enumeration, data) {
                var rootChildren = data.root.children;
                if (!_.isEmpty(rootChildren)) for (var y = 0; y < rootChildren.length; y++) {
                    var treemapNode = rootChildren[y];
                    enumeration.pushInstance({
                        displayName: treemapNode.name,
                        selector: treemapNode.identity.getSelector(),
                        properties: {
                            fill: {
                                solid: {
                                    color: treemapNode.color
                                }
                            }
                        },
                        objectName: "dataPoint"
                    });
                }
            }, Treemap.prototype.enumerateLegend = function(data) {
                var legendObjectProperties = {
                    legend: data.legendObjectProperties
                }, show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.show, this.legend.isVisible()), showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.showTitle, !0), titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.titleText, this.data.legendData.title), labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData ? this.data.legendData.labelColor : visuals.LegendData.DefaultLegendLabelFillColor), labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData && this.data.legendData.fontSize ? this.data.legendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
                return [ {
                    selector: null,
                    objectName: "legend",
                    properties: {
                        show: show,
                        position: visuals.LegendPosition[this.legend.getOrientation()],
                        showTitle: showTitle,
                        titleText: titleText,
                        labelColor: labelColor,
                        fontSize: labelFontSize
                    }
                } ];
            }, Treemap.checkValueForShape = function(value) {
                return value ? value > 0 : !1;
            }, Treemap.prototype.calculateTreemapSize = function() {
                var legendMargins = this.legend.getMargins();
                return {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
            }, Treemap.prototype.initViewportDependantProperties = function(duration) {
                void 0 === duration && (duration = 0);
                var viewport = this.calculateTreemapSize();
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                }), visuals.Legend.positionChartArea(this.svg, this.legend), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            }, Treemap.hasChildrenWithIdentity = function(node) {
                var children = node.children;
                if (!children) return !1;
                var count = children.length;
                if (0 === count) return !1;
                for (var i = count - 1; i >= 0; i--) if (children[i].identity.hasIdentity()) return !0;
                return !1;
            }, Treemap.canDisplayMajorLabel = function(node) {
                if (1 !== node.depth) return !1;
                if (_.isEmpty(node.name)) return !1;
                var availableWidth = node.dx - 2 * Treemap.TextMargin;
                if (availableWidth < Treemap.MinTextWidthForMajorLabel) return !1;
                var textHeightWithMargin = Treemap.MajorLabelTextSize + 2 * Treemap.TextMargin;
                return !(node.dy < textHeightWithMargin);
            }, Treemap.canDisplayMinorLabel = function(node, labelSettings) {
                if (node.depth < 1 || node.depth > 2) return !1;
                if (1 === node.depth && (node.children || !labelSettings.show)) return !1;
                if (_.isEmpty(node.name)) return !1;
                var availableWidth = node.dx - 2 * Treemap.TextMargin;
                if (availableWidth < Treemap.MinTextWidthForMinorLabel) return !1;
                var textHeightWithMargin = Treemap.MinorLabelTextSize + 2 * Treemap.TextMargin;
                if (node.dy < textHeightWithMargin) return !1;
                if (1 === node.depth) {
                    var roomTop = node.y + Treemap.MajorLabelTextSize + 2 * Treemap.TextMargin;
                    if (node.y + node.dy - roomTop < textHeightWithMargin) return !1;
                } else if (2 === node.depth) {
                    var parent_1 = node.parent, roomTop = Math.max(parent_1.y + Treemap.MajorLabelTextSize + 2 * Treemap.TextMargin, node.y);
                    if (node.y + node.dy - roomTop < textHeightWithMargin) return !1;
                }
                return !0;
            }, Treemap.createMajorLabelText = function(node, labelsSettings, alternativeScale, formattersCache) {
                var spaceAvaliableForLabels = node.dx - 2 * Treemap.TextMargin, baseTextProperties = Treemap.MajorLabelTextProperties, textProperties = {
                    text: node.name,
                    fontFamily: baseTextProperties.fontFamily,
                    fontSize: baseTextProperties.fontSize
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
            }, Treemap.createMinorLabelText = function(node, labelsSettings, alternativeScale, formattersCache) {
                var spaceAvaliableForLabels = node.dx - 2 * Treemap.TextMargin, label = node.name;
                if (labelsSettings.show) {
                    var measureFormatter = formattersCache.getOrCreate(node.labelFormatString, labelsSettings, alternativeScale);
                    label = visuals.dataLabelUtils.getLabelFormattedText({
                        label: null != node.highlightValue ? node.highlightValue : node.value,
                        maxWidth: spaceAvaliableForLabels,
                        formatter: measureFormatter
                    }), labelsSettings.showCategory && 2 === node.depth && (label = visuals.dataLabelUtils.getLabelFormattedText({
                        label: node.name,
                        maxWidth: spaceAvaliableForLabels
                    }) + " " + label);
                }
                return visuals.dataLabelUtils.getLabelFormattedText({
                    label: label,
                    maxWidth: spaceAvaliableForLabels,
                    fontSize: labelsSettings.fontSize
                });
            }, Treemap.getFill = function(d, isHighlightRect) {
                return d.depth > 1 && !d.identity.hasIdentity() && !isHighlightRect ? CssConstants.noneValue : Treemap.hasChildrenWithIdentity(d) ? CssConstants.noneValue : d.color;
            }, Treemap.getFillOpacity = function(d, hasSelection, hasHighlights, isHighlightRect) {
                return hasHighlights ? isHighlightRect ? null : Treemap.DimmedShapeOpacity.toString() : !hasSelection || d.selected ? null : d.depth > 1 && d.parent.selected ? null : Treemap.hasChildrenWithIdentity(d) ? null : Treemap.DimmedShapeOpacity.toString();
            }, Treemap.prototype.updateInternal = function(suppressAnimations) {
                var data = this.data, hasHighlights = data && data.hasHighlights, labelSettings = data ? data.dataLabelsSettings : null, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.options.interactivity && this.options.interactivity.isInteractiveLegend || !this.data || this.renderLegend(), 
                this.initViewportDependantProperties(duration);
                var viewport = this.calculateTreemapSize();
                this.treemap.size([ viewport.width, viewport.height ]);
                var nodes = data && data.root ? this.treemap.nodes(data.root) : [], highlightNodes = nodes.filter(function(value) {
                    return null != value.highlightMultiplier && (!value.children || 0 === value.children.length);
                }), majorLabeledNodes = [], minorLabeledNodes = [], alternativeScale = null;
                labelSettings.showCategory && (majorLabeledNodes = nodes.filter(function(d) {
                    return Treemap.canDisplayMajorLabel(d);
                })), (labelSettings.show || labelSettings.showCategory) && (minorLabeledNodes = nodes.filter(function(d) {
                    return Treemap.canDisplayMinorLabel(d, labelSettings);
                }), 0 === labelSettings.displayUnits && (alternativeScale = d3.max(minorLabeledNodes, function(d) {
                    return Math.abs(d.value);
                })));
                var shapes, highlightShapes, majorLabels, minorLabels, result, treemapLayout = Treemap.getLayout(labelSettings, alternativeScale);
                if (this.animator && !suppressAnimations) {
                    var options = {
                        viewModel: data,
                        nodes: nodes,
                        highlightNodes: highlightNodes,
                        majorLabeledNodes: majorLabeledNodes,
                        minorLabeledNodes: minorLabeledNodes,
                        shapeGraphicsContext: this.shapeGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        interactivityService: this.interactivityService,
                        layout: treemapLayout,
                        labelSettings: labelSettings
                    };
                    result = this.animator.animate(options), shapes = result.shapes, highlightShapes = result.highlightShapes, 
                    majorLabels = result.majorLabels, minorLabels = result.minorLabels;
                }
                if (!this.animator || suppressAnimations || result.failed) {
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), shapeGraphicsContext = this.shapeGraphicsContext;
                    shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasSelection, hasHighlights, treemapLayout), 
                    highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights, treemapLayout);
                    var labelGraphicsContext = this.labelGraphicsContext;
                    majorLabels = Treemap.drawDefaultMajorLabels(labelGraphicsContext, majorLabeledNodes, labelSettings, treemapLayout), 
                    minorLabels = Treemap.drawDefaultMinorLabels(labelGraphicsContext, minorLabeledNodes, labelSettings, treemapLayout);
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        majorLabels: majorLabels,
                        minorLabels: minorLabels,
                        nodes: nodes,
                        hasHighlights: data.hasHighlights
                    };
                    this.interactivityService.bind(nodes, this.behavior, behaviorOptions);
                }
                this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                    return tooltipEvent.data.highlightedTooltipInfo ? tooltipEvent.data.highlightedTooltipInfo : tooltipEvent.data.tooltipInfo;
                }), visuals.TooltipManager.addTooltip(highlightShapes, function(tooltipEvent) {
                    return tooltipEvent.data.highlightedTooltipInfo;
                })), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            }, Treemap.prototype.renderLegend = function() {
                var legendObjectProperties = this.data.legendObjectProperties;
                if (legendObjectProperties) {
                    var legendData = this.data.legendData;
                    visuals.LegendData.update(legendData, legendObjectProperties);
                    var position = legendObjectProperties[visuals.legendProps.position];
                    position && this.legend.changeOrientation(visuals.LegendPosition[position]), this.legend.drawLegend(legendData, this.currentViewport);
                } else this.legend.changeOrientation(visuals.LegendPosition.Top), this.legend.drawLegend({
                    dataPoints: []
                }, this.currentViewport);
            }, Treemap.getNodeClass = function(d, highlight) {
                var nodeClass;
                switch (d.depth) {
                  case 1:
                    nodeClass = Treemap.ParentGroupClassName;
                    break;

                  case 2:
                    nodeClass = Treemap.NodeGroupClassName;
                    break;

                  case 0:
                    nodeClass = Treemap.RootNodeClassName;
                }
                return nodeClass += " " + (highlight ? Treemap.HighlightNodeClassName : Treemap.TreemapNodeClassName);
            }, Treemap.createTreemapShapeLayout = function(isHighlightRect) {
                return void 0 === isHighlightRect && (isHighlightRect = !1), {
                    x: function(d) {
                        return d.x;
                    },
                    y: function(d) {
                        return d.y + (isHighlightRect ? d.dy * (1 - d.highlightMultiplier) : 0);
                    },
                    width: function(d) {
                        return Math.max(0, d.dx);
                    },
                    height: function(d) {
                        return Math.max(0, d.dy * (isHighlightRect ? d.highlightMultiplier : 1));
                    }
                };
            }, Treemap.createTreemapZeroShapeLayout = function() {
                return {
                    x: function(d) {
                        return d.x;
                    },
                    y: function(d) {
                        return d.y + d.dy;
                    },
                    width: function(d) {
                        return Math.max(0, d.dx);
                    },
                    height: function(d) {
                        return 0;
                    }
                };
            }, Treemap.drawDefaultShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = !1, shapes = context.selectAll("." + Treemap.TreemapNodeClassName).data(nodes, function(d) {
                    return d.key;
                });
                return shapes.enter().append("rect").attr("class", layout.shapeClass), shapes.style("fill", function(d) {
                    return Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
            }, Treemap.drawDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = !0, highlightShapes = context.selectAll("." + Treemap.HighlightNodeClassName).data(nodes, function(d) {
                    return d.key + "highlight";
                });
                return highlightShapes.enter().append("rect").attr("class", layout.highlightShapeClass), 
                highlightShapes.style("fill", function(d) {
                    return Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(layout.highlightShapeLayout), highlightShapes.exit().remove(), highlightShapes;
            }, Treemap.drawDefaultMajorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + Treemap.MajorLabelClassName).data(nodes, function(d) {
                    return d.key;
                });
                return labels.enter().append("text").attr("class", layout.majorLabelClass), labels.attr(layout.majorLabelLayout).text(layout.majorLabelText).style("fill", function() {
                    return labelSettings.labelColor;
                }), labels.exit().remove(), labels;
            }, Treemap.drawDefaultMinorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + Treemap.MinorLabelClassName).data(nodes, function(d) {
                    return d.key;
                });
                return labels.enter().append("text").attr("class", layout.minorLabelClass), labels.attr(layout.minorLabelLayout).text(layout.minorLabelText).style("fill", function() {
                    return labelSettings.labelColor;
                }), labels.exit().remove(), labels;
            }, Treemap.cleanMinorLabels = function(context) {
                var empty = [], labels = context.selectAll("." + Treemap.LabelsGroupClassName).selectAll("." + Treemap.MinorLabelClassName).data(empty);
                labels.exit().remove();
            }, Treemap.DimmedShapeOpacity = .4, Treemap.ClassName = "treemap", Treemap.LabelsGroupClassName = "labels", 
            Treemap.MajorLabelClassName = "majorLabel", Treemap.MinorLabelClassName = "minorLabel", 
            Treemap.ShapesClassName = "shapes", Treemap.TreemapNodeClassName = "treemapNode", 
            Treemap.RootNodeClassName = "rootNode", Treemap.ParentGroupClassName = "parentGroup", 
            Treemap.NodeGroupClassName = "nodeGroup", Treemap.HighlightNodeClassName = "treemapNodeHighlight", 
            Treemap.TextMargin = 5, Treemap.MinorLabelTextSize = 10, Treemap.MinTextWidthForMinorLabel = 18, 
            Treemap.MajorLabelTextSize = 12, Treemap.MinTextWidthForMajorLabel = 22, Treemap.MajorLabelTextProperties = {
                fontFamily: "wf_segoe-ui_normal",
                fontSize: Treemap.MajorLabelTextSize + "px"
            }, Treemap.CullableArea = 9, Treemap;
        }();
        visuals.Treemap = Treemap;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, Card = function(_super) {
            function Card(options) {
                _super.call(this, Card.cardClassName), this.isScrollable = !1, this.displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits, 
                options && (this.isScrollable = !!options.isScrollable, options.animator && (this.animator = options.animator), 
                null != options.displayUnitSystemType && (this.displayUnitSystemType = options.displayUnitSystemType));
            }
            return __extends(Card, _super), Card.prototype.init = function(options) {
                this.animationOptions = options.animation;
                var element = options.element;
                this.kpiImage = d3.select(element.get(0)).append("div").classed(Card.KPIImage["class"], !0);
                var svg = this.svg = d3.select(element.get(0)).append("svg");
                this.graphicsContext = svg.append("g"), this.currentViewport = options.viewport, 
                this.hostServices = options.host, this.style = options.style, this.updateViewportProperties(), 
                this.isScrollable && (svg.attr("class", Card.cardClassName), this.labelContext = svg.append("g"));
            }, Card.prototype.onDataChanged = function(options) {
                var value, dataView = options.dataViews[0];
                if (dataView) {
                    this.getMetaDataColumn(dataView), dataView.single && (value = dataView.single.value), 
                    this.cardFormatSetting = this.getDefaultFormatSettings();
                    var dataViewMetadata = dataView.metadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var labelSettings = this.cardFormatSetting.labelSettings;
                            labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.labels.color, labelSettings.labelColor), 
                            labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelPrecision, labelSettings.precision), 
                            labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.fontSize, labelSettings.fontSize), 
                            labelSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && labelSettings.precision < 0 && (labelSettings.precision = 0), 
                            labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelDisplayUnits, labelSettings.displayUnits), 
                            labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.show, labelSettings.showCategory), 
                            labelSettings.categoryLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.categoryLabels.color, labelSettings.categoryLabelColor), 
                            this.cardFormatSetting.wordWrap = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.wordWrap.show, this.cardFormatSetting.wordWrap), 
                            this.cardFormatSetting.textSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.fontSize, this.cardFormatSetting.textSize);
                        }
                    }
                }
                this.updateInternal(value, !0, !0);
            }, Card.prototype.onResizing = function(viewport) {
                this.currentViewport = viewport, this.updateViewportProperties(), this.updateInternal(this.value, !0, !0);
            }, Card.prototype.updateViewportProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            }, Card.prototype.setTextProperties = function(text, fontSize) {
                Card.cardTextProperties.fontSize = jsCommon.PixelConverter.fromPoint(fontSize), 
                Card.cardTextProperties.text = text;
            }, Card.prototype.getCardFormatTextSize = function() {
                return this.cardFormatSetting.textSize;
            }, Card.prototype.getAdjustedFontHeight = function(availableWidth, textToMeasure, seedFontHeight) {
                var adjustedFontHeight = _super.prototype.getAdjustedFontHeight.call(this, availableWidth, textToMeasure, seedFontHeight);
                return Math.min(adjustedFontHeight, Card.DefaultStyle.card.maxFontSize);
            }, Card.prototype.clear = function(valueOnly) {
                void 0 === valueOnly && (valueOnly = !1), this.svg.select(Card.Value.selector).text(""), 
                valueOnly || this.svg.select(Card.Label.selector).text(""), _super.prototype.clear.call(this);
            }, Card.prototype.updateInternal = function(target, suppressAnimations, forceUpdate) {
                void 0 === forceUpdate && (forceUpdate = !1);
                var start = this.value, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (void 0 === target) return void (void 0 !== start && this.clear());
                var metaDataColumn = this.metaDataColumn, labelSettings = this.cardFormatSetting.labelSettings, isDefaultDisplayUnit = 0 === labelSettings.displayUnits, format = this.getFormatString(metaDataColumn), formatter = visuals.valueFormatter.create({
                    format: format,
                    value: isDefaultDisplayUnit ? target : labelSettings.displayUnits,
                    precision: visuals.dataLabelUtils.getLabelPrecision(labelSettings.precision, format),
                    displayUnitSystemType: isDefaultDisplayUnit && labelSettings.precision === visuals.dataLabelUtils.defaultLabelPrecision ? this.displayUnitSystemType : powerbi.DisplayUnitSystemType.WholeUnits,
                    formatSingleValues: !!isDefaultDisplayUnit,
                    allowFormatBeautification: !0,
                    columnType: metaDataColumn ? metaDataColumn.type : void 0
                }), formatSettings = this.cardFormatSetting, valueTextHeightInPx = jsCommon.PixelConverter.fromPointToPixel(labelSettings.fontSize), valueStyles = Card.DefaultStyle.value;
                this.setTextProperties(target, this.getCardFormatTextSize());
                var labelTextHeightInPx = powerbi.TextMeasurementService.estimateSvgTextHeight(Card.cardTextProperties), labelHeightWithPadding = labelTextHeightInPx + Card.DefaultStyle.label.paddingTop, width = this.currentViewport.width, height = this.currentViewport.height, translateX = this.getTranslateX(width), translateY = (height - labelHeightWithPadding - valueTextHeightInPx) / 2, statusGraphicInfo = getKpiImageMetadata(metaDataColumn, target, 1);
                if (this.isScrollable) {
                    if (!forceUpdate && start === target) return;
                    start !== target && (target = formatter.format(target));
                    var label = metaDataColumn ? metaDataColumn.displayName : void 0, labelData = labelSettings.showCategory ? [ label ] : [], translatedLabelY = this.getTranslateY(valueTextHeightInPx + labelHeightWithPadding + translateY), labelElement = this.labelContext.attr("transform", visuals.SVGUtil.translate(translateX, translatedLabelY)).selectAll("text").data(labelData);
                    labelElement.enter().append("text").attr("class", Card.Label["class"]), labelElement.text(function(d) {
                        return d;
                    }).style({
                        "font-size": jsCommon.PixelConverter.fromPoint(this.getCardFormatTextSize()),
                        fill: labelSettings.categoryLabelColor,
                        "text-anchor": this.getTextAnchor()
                    });
                    var labelElementNode = labelElement.node();
                    if (labelElementNode && (formatSettings.wordWrap ? powerbi.TextMeasurementService.wordBreak(labelElementNode, width / 2, height - translatedLabelY) : labelElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis)), 
                    labelElement.append("title").text(function(d) {
                        return d;
                    }), labelElement.exit().remove(), statusGraphicInfo) this.graphicsContext.selectAll("text").remove(), 
                    this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx); else {
                        this.kpiImage.selectAll("div").remove();
                        var valueElement = this.graphicsContext.attr("transform", visuals.SVGUtil.translate(translateX, this.getTranslateY(valueTextHeightInPx + translateY))).selectAll("text").data([ target ]);
                        valueElement.enter().append("text").attr("class", Card.Value["class"]), valueElement.text(function(d) {
                            return d;
                        }).style({
                            "font-size": jsCommon.PixelConverter.fromPoint(labelSettings.fontSize),
                            fill: labelSettings.labelColor,
                            "font-family": valueStyles.fontFamily,
                            "text-anchor": this.getTextAnchor()
                        }), valueElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis), 
                        valueElement.append("title").text(function(d) {
                            return d;
                        }), valueElement.exit().remove();
                    }
                } else statusGraphicInfo ? (this.graphicsContext.selectAll("text").remove(), this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx)) : (this.kpiImage.selectAll("div").remove(), 
                this.doValueTransition(start, target, this.displayUnitSystemType, this.animationOptions, duration, forceUpdate, formatter), 
                this.graphicsContext.call(visuals.tooltipUtils.tooltipUpdate, [ target ]));
                this.value = target;
            }, Card.prototype.displayStatusGraphic = function(statusGraphicInfo, translateX, translateY, labelTextSizeInPx) {
                this.graphicsContext.selectAll("text").remove();
                var kpiImageDiv = this.kpiImage.select("div");
                kpiImageDiv && !kpiImageDiv.empty() || (kpiImageDiv = this.kpiImage.append("div")), 
                kpiImageDiv.attr("class", statusGraphicInfo["class"]).style("position", "absolute").style("font-size", labelTextSizeInPx + "px");
                var imageWidth = kpiImageDiv.node().offsetWidth, imageHeight = kpiImageDiv.node().offsetHeight;
                kpiImageDiv.style("transform", visuals.SVGUtil.translateWithPixels(translateX - imageWidth / 2, this.getTranslateY(labelTextSizeInPx + translateY) - imageHeight));
            }, Card.prototype.getDefaultFormatSettings = function() {
                return {
                    labelSettings: visuals.dataLabelUtils.getDefaultCardLabelSettings(Card.DefaultStyle.value.color, Card.DefaultStyle.label.color, Card.DefaultStyle.value.textSize),
                    wordWrap: !1,
                    textSize: Card.DefaultStyle.label.textSize
                };
            }, Card.prototype.enumerateObjectInstances = function(options) {
                this.cardFormatSetting || (this.cardFormatSetting = this.getDefaultFormatSettings());
                var formatSettings = this.cardFormatSetting, enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                  case "categoryLabels":
                    visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, formatSettings.labelSettings, !0, !0, formatSettings.textSize);
                    break;

                  case "labels":
                    var labelSettingOptions = {
                        enumeration: enumeration,
                        dataLabelsSettings: formatSettings.labelSettings,
                        show: !0,
                        displayUnits: !0,
                        precision: !0,
                        fontSize: !0
                    };
                    visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                    break;

                  case "wordWrap":
                    enumeration.pushInstance({
                        objectName: "wordWrap",
                        selector: null,
                        properties: {
                            show: formatSettings.wordWrap
                        }
                    });
                }
                return enumeration.complete();
            }, Card.cardClassName = "card", Card.Label = createClassAndSelector("label"), Card.Value = createClassAndSelector("value"), 
            Card.KPIImage = createClassAndSelector("caption"), Card.cardTextProperties = {
                fontSize: null,
                text: null,
                fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily
            }, Card.DefaultStyle = {
                card: {
                    maxFontSize: 200
                },
                label: {
                    textSize: 12,
                    color: "#a6a6a6",
                    paddingTop: 8
                },
                value: {
                    textSize: 27,
                    color: "#333333",
                    fontFamily: "wf_segoe-ui_Semibold"
                }
            }, Card;
        }(visuals.AnimatedText);
        visuals.Card = Card;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var OwlHappiness;
        !function(OwlHappiness) {
            OwlHappiness[OwlHappiness.Sad = 0] = "Sad", OwlHappiness[OwlHappiness.Meh = 1] = "Meh", 
            OwlHappiness[OwlHappiness.Happy = 2] = "Happy";
        }(OwlHappiness || (OwlHappiness = {}));
        var OwlGauge = function() {
            function OwlGauge() {}
            return OwlGauge.converter = function(dataView) {
                return {};
            }, OwlGauge.getGaugeData = function(dataView) {
                var settings = {
                    max: 100,
                    min: 0,
                    target: void 0,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) for (var values = dataView.categorical.values, metadataColumns = dataView.metadata.columns, i = 0; i < values.length; i++) {
                    var col = metadataColumns[i], value = values[i].values[0] || 0;
                    col && col.roles && (col.roles[visuals.gaugeRoleNames.y] ? (settings.total = value, 
                    value && settings.tooltipItems.push({
                        value: value,
                        metadata: values[i]
                    })) : col.roles[visuals.gaugeRoleNames.minValue] ? settings.min = value : col.roles[visuals.gaugeRoleNames.maxValue] ? settings.max = value : col.roles[visuals.gaugeRoleNames.targetValue] && (settings.target = value, 
                    value && settings.tooltipItems.push({
                        value: value,
                        metadata: values[i]
                    })));
                }
                return settings;
            }, OwlGauge.prototype.init = function(options) {
                var _this = this;
                this.rootElem = options.element, this.rootElem.addClass("owlGaugeVisual"), this.svgTailElem = $(OwlGauge.owlTailSvg), 
                this.svgBgElem = $(OwlGauge.visualBgSvg), this.svgBodyElem = $(OwlGauge.owlBodySvg), 
                this.rootElem.append(this.svgBgElem).append(this.svgTailElem).append(this.svgBodyElem), 
                OwlGauge.OwlDemoMode && window.setInterval(function() {
                    var randomPercentage = 100 * Math.random() + 1;
                    _this.updateGauge(randomPercentage);
                }, 2e3), this.updateViewportSize(options.viewport.width, options.viewport.height);
            }, OwlGauge.prototype.update = function(options) {
                this.updateViewportSize(options.viewport.width, options.viewport.height);
                var dataView = options.dataViews.length > 0 ? options.dataViews[0] : null;
                if (dataView) {
                    var gaugeData = OwlGauge.getGaugeData(options.dataViews[0]), percentage = (gaugeData.total - gaugeData.min) / (gaugeData.max - gaugeData.min);
                    this.updateGauge(100 * percentage | 0);
                } else this.updateGauge(0);
            }, OwlGauge.prototype.updateGauge = function(percentage) {
                if (percentage >= 0 && 100 >= percentage) {
                    var rotationDeg = -180 + 180 * percentage / 100;
                    this.svgBgElem.css({
                        transform: "rotate(" + rotationDeg + "deg)"
                    }), percentage >= 66 ? this.happinessLevel = OwlHappiness.Happy : percentage >= 33 ? this.happinessLevel = OwlHappiness.Meh : this.happinessLevel = OwlHappiness.Sad;
                }
            }, Object.defineProperty(OwlGauge.prototype, "happinessLevel", {
                set: function(level) {
                    switch (this.rootElem.removeClass("sad").removeClass("meh").removeClass("happy"), 
                    level) {
                      case OwlHappiness.Sad:
                        this.rootElem.addClass("sad");
                        break;

                      case OwlHappiness.Meh:
                        this.rootElem.addClass("meh");
                        break;

                      case OwlHappiness.Happy:
                        this.rootElem.addClass("happy");
                    }
                },
                enumerable: !0,
                configurable: !0
            }), OwlGauge.prototype.updateViewportSize = function(width, height) {
                var _this = this, smoothingFn = window.setImmediate || window.requestAnimationFrame;
                smoothingFn(function() {
                    _this.rootElem.css({
                        height: height,
                        width: width
                    }), _this.svgBodyElem.height(_this.svgBodyElem.width() * OwlGauge.owlBodyHeightMultiplier), 
                    _this.svgBgElem.height(_this.svgBgElem.width() * OwlGauge.visualBgHeightMultiplier), 
                    _this.svgTailElem.height(_this.svgTailElem.width() * OwlGauge.owlTailHeightMultiplier);
                });
            }, OwlGauge.owlBodySvg = '<svg version="1.1" class="owlGaugeBody" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 267.7 291.2" style="enable-background:new 0 0 267.7 291.2;" xml:space="preserve"> <style type="text/css"> .owlGaugeBody .st0{fill:#A87D50;} .owlGaugeBody .st1{fill:#C2B59B;} .owlGaugeBody .st2{fill:#EB2227;} .owlGaugeBody .st3{fill:#FFFFFF;} .owlGaugeBody .st4{fill:#F9D018;} .owlGaugeBody .st5{fill:none;} .owlGaugeBody .st6{fill:#83381B;} .owlGaugeBody .st7{fill:#231F20;} </style> <g id="XMLID_31_"> <g id="XMLID_34_"> <ellipse id="XMLID_21_" transform="matrix(0.9998 1.947640e-02 -1.947640e-02 0.9998 2.8614 -2.5802)" class="st0" cx="133.9" cy="145.6" rx="133.9" ry="145.6"/> <polygon id="XMLID_20_" class="st0" points="199.2,32.8 184,11.3 209,9.7 "/> <polygon id="XMLID_19_" class="st0" points="73.9,31.2 62.1,7.7 87.1,9.8 "/> <circle id="XMLID_18_" class="st1" cx="134.8" cy="189.2" r="89.8"/> <path id="XMLID_17_" class="st2" d="M140.1,88c-2.7,3.8-7.9,4.7-11.7,2c-2.7-1.9-3.9-5.1-3.4-8.1c0,0,9.6-41.8,9.6-41.8l6.9,40.8 C142,83.2,141.6,85.8,140.1,88z"/> <path id="XMLID_16_" class="st3" d="M164.6,16.2c-14.2,0-26.3,9.2-30.6,21.9c-4.1-13.1-16.3-22.6-30.8-22.6 C85.4,15.6,71,30,71,47.8s14.4,32.3,32.3,32.3c14.2,0,26.3-9.2,30.6-21.9c4.1,13.1,16.3,22.6,30.8,22.6 c17.8,0,32.3-14.4,32.3-32.3S182.4,16.2,164.6,16.2z"/> <path id="XMLID_15_" class="st4" d="M122,58.7l23.3-0.1c0,0-9,14.8-10.2,16.6c-1.2,1.9-2.2,0.1-2.2,0.1L122,58.7z"/> <rect id="XMLID_14_" x="-11.4" y="-68.8" class="st5" width="288.3" height="259.7"/> <g id="XMLID_37_"> <path id="XMLID_13_" class="st6" d="M121.6,125.5c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_12_" class="st6" d="M160.1,126.5c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_11_" class="st6" d="M142.4,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_10_" class="st6" d="M183.1,148.8c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_9_" class="st6" d="M160.9,177.4c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_8_" class="st6" d="M201.6,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_7_" class="st6" d="M76.4,177.4c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_6_" class="st6" d="M117,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_5_" class="st6" d="M98.6,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> </g> <circle id="XMLID_4_" class="st7" cx="164.1" cy="49" r="6.4"/> <circle id="XMLID_3_" class="st7" cx="102.7" cy="47.7" r="6.4"/> </g> <path id="XMLID_2_" class="st0" d="M160.1,140.9c11.1-8.4,55.6-36,55.6-36l4.7,0.8l10.2,38.8c0,0-3,3-9.2,3.1 c-5.1,0.1-45.9-2.6-60.2-3.5C158.1,143.9,157.7,142.7,160.1,140.9z"/> <path id="XMLID_1_" class="st0" d="M110.6,140.8c-11.1-8.4-55.6-36-55.6-36l-4.7,0.8L40,144.4c0,0,3,3,9.2,3.1 c5.1,0.1,45.9-2.6,60.2-3.5C112.5,143.8,113,142.6,110.6,140.8z"/> </g> </svg>', 
            OwlGauge.owlTailSvg = '<svg version="1.1" class="owlGaugeTail" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 587.8 295.5" style="enable-background:new 0 0 587.8 295.5;" xml:space="preserve"> <style type="text/css"> .owlGaugeTail .st0{fill:#3B2416;} .owlGaugeTail .st1{fill:#5B4B43;} .owlGaugeTail .st2{fill:#603A17;} .owlGaugeTail .st3{fill:#726659;} </style> <g id="XMLID_55_"> <path id="XMLID_29_" class="st0" d="M85.2,106.2c-27.1,0-49.2,22-49.2,49.2c0,19.1,10.9,35.7,26.9,43.8c0,0,231.2,95.9,231.2,95.9 l-171-171C114.1,113.2,100.5,106.2,85.2,106.2z"/> <g id="XMLID_56_"> <path id="XMLID_28_" class="st1" d="M482.5,86.4c0-27.1-22-49.2-49.2-49.2c-19.1,0-35.7,10.9-43.8,26.9c0,0-95.9,231.2-95.9,231.2 l171-171C475.5,115.3,482.5,101.7,482.5,86.4z"/> <path id="XMLID_27_" class="st2" d="M573.5,281.3c19.2-19.2,19.2-50.3,0-69.5c-13.5-13.5-33-17.5-50-12c0,0-231.3,95.7-231.3,95.7 l241.8,0C548,296.9,562.6,292.1,573.5,281.3z"/> <path id="XMLID_26_" class="st3" d="M279.9,14.4c-19.2-19.2-50.3-19.2-69.5,0c-13.5,13.5-17.5,33-12,50c0,0,95.7,231.3,95.7,231.3 L294,54C295.4,39.8,290.7,25.2,279.9,14.4z"/> <path id="XMLID_25_" class="st2" d="M105.3,86.4c0-27.1,22-49.2,49.2-49.2c19.1,0,35.7,10.9,43.8,26.9c0,0,95.9,231.2,95.9,231.2 l-171-171C112.3,115.3,105.3,101.7,105.3,86.4z"/> <path id="XMLID_24_" class="st2" d="M14.4,281.4c-19.2-19.2-19.2-50.3,0-69.5c13.5-13.5,33-17.5,50-12c0,0,231.3,95.7,231.3,95.7 l-241.8,0C39.8,297,25.2,292.3,14.4,281.4z"/> <path id="XMLID_23_" class="st2" d="M308.2,14c19.2-19.2,50.3-19.2,69.5,0c13.5,13.5,17.5,33,12,50c0,0-95.7,231.3-95.7,231.3 l0-241.8C292.6,39.4,297.4,24.8,308.2,14z"/> <path id="XMLID_22_" class="st0" d="M503.2,106c27.1,0,49.2,22,49.2,49.2c0,19.1-10.9,35.7-26.9,43.8c0,0-231.2,95.9-231.2,95.9 l171-171C474.2,113,487.8,106,503.2,106z"/> </g> </g> </svg>', 
            OwlGauge.visualBgSvg = '<svg version="1.1" class="owlGaugeBg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="123.8 94.9 349.1 175.3" style="enable-background:new 123.8 94.9 349.1 175.3;" xml:space="preserve"> <style type="text/css"> .owlGaugeBg .st0{fill:#EF4137;} .owlGaugeBg .st1{fill:#FAAF42;} .owlGaugeBg .st2{fill:#F15B2A;} .owlGaugeBg .st3{fill:#F69321;} </style> <g id="XMLID_10_"> <path id="XMLID_8_" class="st0" d="M174.3,158c-16.1,0-29.2,13.1-29.2,29.2c0,11.4,6.5,21.2,16,26.1l137.3,57L196.9,168.7 C191.5,162.2,183.4,158,174.3,158z"/> <g id="XMLID_11_"> <path id="XMLID_7_" class="st1" d="M410.2,146.3c0-16.1-13.1-29.2-29.2-29.2c-11.4,0-21.2,6.5-26,16l-57,137.5L399.5,169 C406.1,163.5,410.2,155.4,410.2,146.3z"/> <path id="XMLID_6_" class="st0" d="M464.3,262.2c11.4-11.4,11.4-29.9,0-41.3c-8-8-19.6-10.4-29.7-7.1l-137.4,56.9h143.6 C449.2,271.4,457.9,268.6,464.3,262.2z"/> <path id="XMLID_5_" class="st2" d="M290,103.5c-11.4-11.4-29.9-11.4-41.3,0c-8,8-10.4,19.6-7.1,29.7l56.8,137.5V127 C299.2,118.6,296.4,109.9,290,103.5z"/> <path id="XMLID_4_" class="st3" d="M186.3,146.3c0-16.1,13.1-29.2,29.2-29.2c11.4,0,21.2,6.5,26,16l57,137.5L197,168.8 C190.5,163.5,186.3,155.4,186.3,146.3z"/> <path id="XMLID_3_" class="st2" d="M132.3,262.2c-11.4-11.4-11.4-29.9,0-41.3c8-8,19.6-10.4,29.7-7.1l137.4,56.9H155.8 C147.4,271.5,138.7,268.7,132.3,262.2z"/> <path id="XMLID_2_" class="st3" d="M306.8,103.2c11.4-11.4,29.9-11.4,41.3,0c8,8,10.4,19.6,7.1,29.7l-56.8,137.5V126.7 C297.5,118.3,300.3,109.7,306.8,103.2z"/> <path id="XMLID_1_" class="st2" d="M422.5,157.9c16.1,0,29.2,13.1,29.2,29.2c0,11.4-6.5,21.2-16,26.1l-137.3,57L400,168.6 C405.3,162.1,413.4,157.9,422.5,157.9z"/> </g> </g> </svg>', 
            OwlGauge.owlBodyHeightMultiplier = 291.2 / 267.7, OwlGauge.owlTailHeightMultiplier = 295.5 / 587.8, 
            OwlGauge.visualBgHeightMultiplier = 295.5 / 587.8, OwlGauge.OwlDemoMode = !1, OwlGauge.capabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure
                } ],
                dataViewMappings: [ {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        select: [ {
                            bind: {
                                to: "Y"
                            }
                        } ]
                    }
                } ]
            }, OwlGauge;
        }();
        visuals.OwlGauge = OwlGauge;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var NoMapLocationWarning = function() {
            function NoMapLocationWarning() {}
            return Object.defineProperty(NoMapLocationWarning.prototype, "code", {
                get: function() {
                    return "NoMapLocation";
                },
                enumerable: !0,
                configurable: !0
            }), NoMapLocationWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "NoMapLocationMessage", titleKey = "NoMapLocationKey", detailKey = "NoMapLocationValue", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            }, NoMapLocationWarning;
        }();
        visuals.NoMapLocationWarning = NoMapLocationWarning;
        var FilledMapWithoutValidGeotagCategoryWarning = function() {
            function FilledMapWithoutValidGeotagCategoryWarning() {}
            return Object.defineProperty(FilledMapWithoutValidGeotagCategoryWarning.prototype, "code", {
                get: function() {
                    return "NoValidGeotaggedCategory";
                },
                enumerable: !0,
                configurable: !0
            }), FilledMapWithoutValidGeotagCategoryWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "NoValidGeotaggedCategoryMessage", titleKey = "NoValidGeotaggedCategoryKey", detailKey = "NoValidGeotaggedCategoryValue", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            }, FilledMapWithoutValidGeotagCategoryWarning;
        }();
        visuals.FilledMapWithoutValidGeotagCategoryWarning = FilledMapWithoutValidGeotagCategoryWarning;
        var GeometryCulledWarning = function() {
            function GeometryCulledWarning() {}
            return Object.defineProperty(GeometryCulledWarning.prototype, "code", {
                get: function() {
                    return "GeometryCulledWarning";
                },
                enumerable: !0,
                configurable: !0
            }), GeometryCulledWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "GeometryCulledWarningMessage", titleKey = "GeometryCulledWarningKey", detailKey = "GeometryCulledWarningVal", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            }, GeometryCulledWarning;
        }();
        visuals.GeometryCulledWarning = GeometryCulledWarning;
        var NegativeValuesNotSupportedWarning = function() {
            function NegativeValuesNotSupportedWarning() {}
            return Object.defineProperty(NegativeValuesNotSupportedWarning.prototype, "code", {
                get: function() {
                    return "NegativeValuesNotSupported";
                },
                enumerable: !0,
                configurable: !0
            }), NegativeValuesNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_NegativeValues", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            }, NegativeValuesNotSupportedWarning;
        }();
        visuals.NegativeValuesNotSupportedWarning = NegativeValuesNotSupportedWarning;
        var AllNegativeValuesWarning = function() {
            function AllNegativeValuesWarning() {}
            return Object.defineProperty(AllNegativeValuesWarning.prototype, "code", {
                get: function() {
                    return "AllNegativeValuesNotSupported";
                },
                enumerable: !0,
                configurable: !0
            }), AllNegativeValuesWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_AllNegativeValues", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            }, AllNegativeValuesWarning;
        }();
        visuals.AllNegativeValuesWarning = AllNegativeValuesWarning;
        var NaNNotSupportedWarning = function() {
            function NaNNotSupportedWarning() {}
            return Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
                get: function() {
                    return "NaNNotSupported";
                },
                enumerable: !0,
                configurable: !0
            }), NaNNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_NanValues", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            }, NaNNotSupportedWarning;
        }();
        visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
        var InfinityValuesNotSupportedWarning = function() {
            function InfinityValuesNotSupportedWarning() {}
            return Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
                get: function() {
                    return "InfinityValuesNotSupported";
                },
                enumerable: !0,
                configurable: !0
            }), InfinityValuesNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_InfinityValues", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            }, InfinityValuesNotSupportedWarning;
        }();
        visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
        var ValuesOutOfRangeWarning = function() {
            function ValuesOutOfRangeWarning() {}
            return Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
                get: function() {
                    return "ValuesOutOfRange";
                },
                enumerable: !0,
                configurable: !0
            }), ValuesOutOfRangeWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_VisualizationOutOfRange", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            }, ValuesOutOfRangeWarning;
        }();
        visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
        var ZeroValueWarning = function() {
            function ZeroValueWarning() {}
            return Object.defineProperty(ZeroValueWarning.prototype, "code", {
                get: function() {
                    return "ZeroValuesNotSupported";
                },
                enumerable: !0,
                configurable: !0
            }), ZeroValueWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_ZeroValues", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            }, ZeroValueWarning;
        }();
        visuals.ZeroValueWarning = ZeroValueWarning;
        var VisualKPIDataMissingWarning = function() {
            function VisualKPIDataMissingWarning() {}
            return Object.defineProperty(VisualKPIDataMissingWarning.prototype, "code", {
                get: function() {
                    return "VisualKPIDataMissing";
                },
                enumerable: !0,
                configurable: !0
            }), VisualKPIDataMissingWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "Visual_KPI_DataMissing", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            }, VisualKPIDataMissingWarning;
        }();
        visuals.VisualKPIDataMissingWarning = VisualKPIDataMissingWarning;
        var ScriptVisualRefreshWarning = function() {
            function ScriptVisualRefreshWarning() {}
            return Object.defineProperty(ScriptVisualRefreshWarning.prototype, "code", {
                get: function() {
                    return "ScriptVisualNotRefreshed";
                },
                enumerable: !0,
                configurable: !0
            }), ScriptVisualRefreshWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "ScriptVisualRefreshWarningMessage", detailKey = "ScriptVisualRefreshWarningValue", visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            }, ScriptVisualRefreshWarning;
        }();
        visuals.ScriptVisualRefreshWarning = ScriptVisualRefreshWarning;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var PixelConverter = jsCommon.PixelConverter, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, WaterfallChart = function() {
            function WaterfallChart(options) {
                this.isScrollable = options.isScrollable, this.tooltipsEnabled = options.tooltipsEnabled, 
                this.interactivityService = options.interactivityService;
            }
            return WaterfallChart.prototype.init = function(options) {
                this.svg = options.svg, this.svg.classed(WaterfallChart.WaterfallClassName, !0), 
                this.style = options.style, this.currentViewport = options.viewport, this.hostServices = options.host, 
                this.interactivity = options.interactivity, this.cartesianVisualHost = options.cartesianHost, 
                this.options = options, this.element = options.element, this.colors = this.style.colorPalette.dataColors, 
                this.mainGraphicsSVG = this.svg.append("svg"), this.mainGraphicsContext = this.mainGraphicsSVG.append("g").classed(WaterfallChart.MainGraphicsContextClassName, !0), 
                this.labelGraphicsContext = this.mainGraphicsSVG.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0);
            }, WaterfallChart.converter = function(dataView, palette, hostServices, dataLabelSettings, sentimentColors, interactivityService, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var categoryMetadata, formatStringProp = WaterfallChart.formatStringProp, categories = dataView.categorical.categories || [], increaseColor = sentimentColors.increaseFill.solid.color, decreaseColor = sentimentColors.decreaseFill.solid.color, totalColor = sentimentColors.totalFill.solid.color, totalLabel = hostServices.getLocalizedString(WaterfallChart.TotalLabel), increaseLabel = hostServices.getLocalizedString(WaterfallChart.IncreaseLabel), decreaseLabel = hostServices.getLocalizedString(WaterfallChart.DecreaseLabel), legend = [ {
                    label: increaseLabel,
                    color: increaseColor,
                    icon: visuals.LegendIcon.Box,
                    identity: visuals.SelectionIdBuilder.builder().withMeasure("increase").createSelectionId(),
                    selected: !1
                }, {
                    label: decreaseLabel,
                    color: decreaseColor,
                    icon: visuals.LegendIcon.Box,
                    identity: visuals.SelectionIdBuilder.builder().withMeasure("decrease").createSelectionId(),
                    selected: !1
                }, {
                    label: totalLabel,
                    color: totalColor,
                    icon: visuals.LegendIcon.Box,
                    identity: visuals.SelectionIdBuilder.builder().withMeasure("total").createSelectionId(),
                    selected: !1
                } ], pos = 0, posMin = 0, posMax = 0, dataPoints = [], categoryValues = [], values = dataView.categorical.values, valuesMetadata = void 0;
                if (!_.isEmpty(values)) {
                    var column = values[0];
                    valuesMetadata = column.source;
                    var labelFormatString = valuesMetadata.format;
                    if (_.isEmpty(categories)) pos = posMax = column.values[0], posMin = 0; else {
                        var categoryColumn = categories[0];
                        categoryMetadata = categoryColumn.source, categoryValues = categoryColumn.values.slice(), 
                        categoryValues.push(totalLabel);
                        for (var categoryIndex = 0, catLen = column.values.length; catLen > categoryIndex; categoryIndex++) {
                            var category = categoryValues[categoryIndex], value = column.values[categoryIndex] || 0, identity = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, categoryIndex).createSelectionId(), tooltipInfo_5 = void 0;
                            tooltipsEnabled && (tooltipInfo_5 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categorical, category, value));
                            var color = value > 0 ? increaseColor : decreaseColor;
                            dataPoints.push({
                                value: value,
                                position: pos,
                                color: color,
                                categoryValue: category,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: !1,
                                identity: identity,
                                highlight: !1,
                                key: identity.getKey(),
                                tooltipInfo: tooltipInfo_5,
                                labelFill: dataLabelSettings.labelColor,
                                labelFormatString: labelFormatString
                            }), pos += value, pos > posMax && (posMax = pos), posMin > pos && (posMin = pos);
                        }
                    }
                    var tooltipInfo = void 0;
                    tooltipsEnabled && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categorical, totalLabel, pos));
                    var totalIdentity = visuals.SelectionId.createNull();
                    dataPoints.push({
                        value: pos,
                        position: 0,
                        color: totalColor,
                        categoryValue: totalLabel,
                        categoryIndex: categoryIndex,
                        identity: totalIdentity,
                        seriesIndex: 0,
                        selected: !1,
                        highlight: !1,
                        key: totalIdentity.getKey(),
                        tooltipInfo: tooltipInfo,
                        labelFill: dataLabelSettings.labelColor,
                        labelFormatString: labelFormatString,
                        isTotal: !0
                    });
                }
                interactivityService && interactivityService.applySelectionStateToData(dataPoints);
                var xAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata), yAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata), axesLabels = visuals.converterHelper.createAxesLabels(xAxisProperties, yAxisProperties, categoryMetadata, [ valuesMetadata ]);
                return {
                    series: [ {
                        data: dataPoints
                    } ],
                    categories: categoryValues,
                    categoryMetadata: categoryMetadata,
                    valuesMetadata: valuesMetadata,
                    legend: {
                        dataPoints: legend
                    },
                    hasHighlights: !1,
                    positionMin: posMin,
                    positionMax: posMax,
                    dataLabelsSettings: dataLabelSettings,
                    sentimentColors: sentimentColors,
                    axesLabels: {
                        x: axesLabels.xAxisLabel,
                        y: axesLabels.yAxisLabel
                    }
                };
            }, WaterfallChart.prototype.setData = function(dataViews) {
                var sentimentColors = this.getSentimentColorsFromObjects(null), dataView = dataViews.length > 0 ? dataViews[0] : void 0;
                if (this.data = {
                    series: [ {
                        data: []
                    } ],
                    categories: [],
                    valuesMetadata: null,
                    legend: {
                        dataPoints: []
                    },
                    hasHighlights: !1,
                    categoryMetadata: null,
                    scalarCategoryAxis: !1,
                    positionMax: 0,
                    positionMin: 0,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!1, void 0),
                    sentimentColors: sentimentColors,
                    axesLabels: {
                        x: null,
                        y: null
                    }
                }, dataView) {
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects, labelsObj = objects.labels;
                        labelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, this.data.dataLabelsSettings), 
                        sentimentColors = this.getSentimentColorsFromObjects(objects);
                    }
                    dataView.categorical && (this.data = WaterfallChart.converter(dataView, this.colors, this.hostServices, this.data.dataLabelsSettings, sentimentColors, this.interactivityService, this.tooltipsEnabled));
                }
            }, WaterfallChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                switch (options.objectName) {
                  case "sentimentColors":
                    this.enumerateSentimentColors(enumeration);
                    break;

                  case "labels":
                    var labelSettingOptions = {
                        enumeration: enumeration,
                        dataLabelsSettings: this.data.dataLabelsSettings,
                        show: !0,
                        displayUnits: !0,
                        precision: !0,
                        fontSize: !0
                    };
                    visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                }
            }, WaterfallChart.prototype.enumerateSentimentColors = function(enumeration) {
                var sentimentColors = this.data.sentimentColors;
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        increaseFill: sentimentColors.increaseFill,
                        decreaseFill: sentimentColors.decreaseFill,
                        totalFill: sentimentColors.totalFill
                    },
                    objectName: "sentimentColors"
                });
            }, WaterfallChart.prototype.calculateLegend = function() {
                return this.data.legend;
            }, WaterfallChart.prototype.hasLegend = function() {
                return !0;
            }, WaterfallChart.createClippedDataIfOverflowed = function(data, renderableDataCount) {
                var clipped = data, dataPoints = data.series[0].data;
                return data && renderableDataCount < dataPoints.length && (clipped = powerbi.Prototype.inherit(data), 
                clipped.series = [ {
                    data: dataPoints.slice(0, renderableDataCount)
                } ], clipped.categories = data.categories.slice(0, renderableDataCount)), clipped;
            }, WaterfallChart.prototype.calculateAxesProperties = function(options) {
                var _this = this;
                this.currentViewport = options.viewport, this.margin = options.margin;
                var data = this.clippedData = this.data, categoryCount = data.categories.length, preferredPlotArea = this.getPreferredPlotArea(!1, categoryCount, visuals.CartesianChart.MinOrdinalRectThickness), cartesianLayout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: preferredPlotArea.width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: !1,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
                this.isScrollable || (data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, cartesianLayout.categoryCount));
                var xAxisCreationOptions = WaterfallChart.getXAxisCreationOptions(data, preferredPlotArea.width, cartesianLayout, options), yAxisCreationOptions = WaterfallChart.getYAxisCreationOptions(data, preferredPlotArea.height, options), xAxisProperties = this.xAxisProperties = visuals.AxisHelper.createAxis(xAxisCreationOptions), yAxisProperties = this.yAxisProperties = visuals.AxisHelper.createAxis(yAxisCreationOptions), categoryWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), labelSettings = data.dataLabelsSettings, value2 = WaterfallChart.getDisplayUnitValueFromAxisFormatter(yAxisProperties, labelSettings);
                return this.layout = {
                    categoryCount: cartesianLayout.categoryCount,
                    categoryThickness: cartesianLayout.categoryThickness,
                    isScalar: cartesianLayout.isScalar,
                    outerPaddingRatio: cartesianLayout.outerPaddingRatio,
                    categoryWidth: categoryWidth,
                    labelText: function(d) {
                        var formatter = formattersCache.getOrCreate(d.labelFormatString, labelSettings, value2);
                        return visuals.dataLabelUtils.getLabelFormattedText({
                            label: formatter.format(d.value)
                        });
                    },
                    labelLayout: visuals.dataLabelUtils.getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, yAxisCreationOptions.dataDomain),
                    filter: function(d) {
                        return visuals.dataLabelUtils.doesDataLabelFitInShape(d, yAxisProperties, _this.layout);
                    },
                    style: {
                        fill: function(d) {
                            return d.isLabelInside ? visuals.dataLabelUtils.defaultInsideLabelColor : d.labelFill;
                        }
                    }
                }, this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null, 
                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null, 
                [ xAxisProperties, yAxisProperties ];
            }, WaterfallChart.getDisplayUnitValueFromAxisFormatter = function(yAxisProperties, labelSettings) {
                return yAxisProperties.formatter && yAxisProperties.formatter.displayUnit && 0 === labelSettings.displayUnits ? yAxisProperties.formatter.displayUnit.value : null;
            }, WaterfallChart.lookupXValue = function(data, index, type) {
                var dataPoints = data.series[0].data;
                return index === dataPoints.length - 1 ? dataPoints[index].categoryValue : visuals.CartesianHelper.lookupXValue(data, index, type, !1);
            }, WaterfallChart.getXAxisCreationOptions = function(data, width, layout, options) {
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata), domain = visuals.AxisHelper.createDomain(data.series, categoryDataType, !1, options.forcedXDomain, options.ensureXDomain), categoryThickness = layout.categoryThickness, outerPadding = categoryThickness * layout.outerPaddingRatio;
                return {
                    pixelSpan: width,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, WaterfallChart.formatStringProp),
                    isScalar: !1,
                    outerPadding: outerPadding,
                    categoryThickness: categoryThickness,
                    getValueFn: function(index, type) {
                        return WaterfallChart.lookupXValue(data, index, type);
                    },
                    forcedTickCount: options.forcedTickCount,
                    isCategoryAxis: !0,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                };
            }, WaterfallChart.getYAxisCreationOptions = function(data, height, options) {
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ data.positionMin, data.positionMax ], options.ensureYDomain);
                return {
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    isScalar: !0,
                    isVertical: !0,
                    metaDataColumn: data.valuesMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.valuesMetadata, WaterfallChart.formatStringProp),
                    outerPadding: 0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision
                };
            }, WaterfallChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin);
            }, WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return !1;
            }, WaterfallChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            }, WaterfallChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                return data.series = [ {
                    data: data.series[0].data.slice(startIndex, endIndex)
                } ], data.categories = data.categories.slice(startIndex, endIndex), data;
            }, WaterfallChart.prototype.createRects = function(data) {
                var mainGraphicsContext = this.mainGraphicsContext, colsSelection = mainGraphicsContext.selectAll(WaterfallChart.CategoryValueClasses.selector), cols = colsSelection.data(data, function(d) {
                    return d.key;
                });
                return cols.enter().append("rect").attr("class", function(d) {
                    return WaterfallChart.CategoryValueClasses["class"].concat(d.highlight ? "highlight" : "");
                }), cols.exit().remove(), cols;
            }, WaterfallChart.prototype.createConnectors = function(data) {
                var mainGraphicsContext = this.mainGraphicsContext, connectorSelection = mainGraphicsContext.selectAll(WaterfallChart.WaterfallConnectorClasses.selector), connectors = connectorSelection.data(data.slice(0, data.length - 1), function(d) {
                    return d.key;
                });
                return connectors.enter().append("line").classed(WaterfallChart.WaterfallConnectorClasses["class"], !0), 
                connectors.exit().remove(), connectors;
            }, WaterfallChart.prototype.render = function(suppressAnimations) {
                var _this = this, dataPoints = this.clippedData.series[0].data, bars = this.createRects(dataPoints), connectors = this.createConnectors(dataPoints);
                this.tooltipsEnabled && visuals.TooltipManager.addTooltip(bars, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, y0 = yScale(0);
                this.mainGraphicsSVG.attr("height", this.getAvailableHeight()).attr("width", this.getAvailableWidth()), 
                bars.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, _this.data.hasHighlights);
                }).attr("width", this.layout.categoryWidth).attr("x", function(d) {
                    return xScale(d.categoryIndex);
                }).attr("y", function(d) {
                    return WaterfallChart.getRectTop(yScale, d.position, d.value);
                }).attr("height", function(d) {
                    return y0 - yScale(Math.abs(d.value));
                }), connectors.attr({
                    x1: function(d) {
                        return xScale(d.categoryIndex);
                    },
                    y1: function(d) {
                        return yScale(d.position + d.value);
                    },
                    x2: function(d) {
                        return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth;
                    },
                    y2: function(d) {
                        return yScale(d.position + d.value);
                    }
                });
                var labelSettings = this.data.dataLabelsSettings, labelDataPoints = [];
                (labelSettings && labelSettings.show || labelSettings.showCategory) && (labelDataPoints = this.createLabelDataPoints());
                var behaviorOptions = void 0;
                return this.interactivityService && (behaviorOptions = {
                    bars: bars,
                    datapoints: dataPoints
                }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                    dataPoints: dataPoints,
                    behaviorOptions: behaviorOptions,
                    labelDataPoints: labelDataPoints,
                    labelsAreNumeric: !0
                };
            }, WaterfallChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, WaterfallChart.prototype.getSupportedCategoryAxisType = function() {
                return visuals.axisType.categorical;
            }, WaterfallChart.getRectTop = function(scale, pos, value) {
                return 0 > value ? scale(pos) : scale(pos) - (scale(0) - scale(value));
            }, WaterfallChart.prototype.getAvailableWidth = function() {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            }, WaterfallChart.prototype.getAvailableHeight = function() {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            }, WaterfallChart.prototype.getSentimentColorsFromObjects = function(objects) {
                var defaultSentimentColors = this.colors.getSentimentColors(), increaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.increaseFill, defaultSentimentColors[2].value), decreaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.decreaseFill, defaultSentimentColors[0].value), totalColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.totalFill, WaterfallChart.defaultTotalColor);
                return {
                    increaseFill: {
                        solid: {
                            color: increaseColor
                        }
                    },
                    decreaseFill: {
                        solid: {
                            color: decreaseColor
                        }
                    },
                    totalFill: {
                        solid: {
                            color: totalColor
                        }
                    }
                };
            }, WaterfallChart.prototype.createLabelDataPoints = function() {
                for (var labelDataPoints = [], data = this.data, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, y0 = yScale(0), series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, data.dataLabelsSettings), labelSettings = this.data.dataLabelsSettings, _i = 0, series_6 = series; _i < series_6.length; _i++) for (var currentSeries = series_6[_i], _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                    var dataPoint = _b[_a], parentRect = {
                        left: xScale(dataPoint.categoryIndex),
                        top: WaterfallChart.getRectTop(yScale, dataPoint.position, dataPoint.value),
                        width: this.layout.categoryWidth,
                        height: y0 - yScale(Math.abs(dataPoint.value))
                    }, formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, this.data.dataLabelsSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                        text: text,
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                    }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                    labelDataPoints.push({
                        isPreferred: !0,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight
                        },
                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 1,
                        parentShape: {
                            rect: parentRect,
                            orientation: dataPoint.value >= 0 ? 1 : 2,
                            validPositions: 0 === dataPoint.value ? WaterfallChart.validZeroLabelPosition : WaterfallChart.validLabelPositions
                        },
                        fontSize: labelSettings.fontSize,
                        identity: void 0
                    });
                }
                return labelDataPoints;
            }, WaterfallChart.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            }, WaterfallChart.WaterfallClassName = "waterfallChart", WaterfallChart.MainGraphicsContextClassName = "mainGraphicsContext", 
            WaterfallChart.IncreaseLabel = "Waterfall_IncreaseLabel", WaterfallChart.DecreaseLabel = "Waterfall_DecreaseLabel", 
            WaterfallChart.TotalLabel = "Waterfall_TotalLabel", WaterfallChart.CategoryValueClasses = createClassAndSelector("column"), 
            WaterfallChart.WaterfallConnectorClasses = createClassAndSelector("waterfall-connector"), 
            WaterfallChart.defaultTotalColor = "#00b8aa", WaterfallChart.validLabelPositions = [ 16, 4 ], 
            WaterfallChart.validZeroLabelPosition = [ 16, 8 ], WaterfallChart;
        }();
        visuals.WaterfallChart = WaterfallChart;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var TouchUtils = powerbi.visuals.controls.TouchUtils, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, ContainerClassName = createClassAndSelector("tooltip-container"), ContentContainerClassName = createClassAndSelector("tooltip-content-container"), ArrowClassName = createClassAndSelector("arrow"), TooltipHeaderClassName = createClassAndSelector("tooltip-header"), TooltipRowClassName = createClassAndSelector("tooltip-row"), TooltipColorCellClassName = createClassAndSelector("tooltip-color-cell"), TooltipTitleCellClassName = createClassAndSelector("tooltip-title-cell"), TooltipValueCellClassName = createClassAndSelector("tooltip-value-cell"), ToolTipComponent = function() {
            function ToolTipComponent(tooltipOptions) {
                this.tooltipOptions = tooltipOptions, this.isTooltipVisible = !1, tooltipOptions || (this.tooltipOptions = ToolTipComponent.DefaultTooltipOptions);
            }
            return ToolTipComponent.prototype.isTooltipComponentVisible = function() {
                return this.isTooltipVisible;
            }, ToolTipComponent.prototype.setTestScreenSize = function(width, height) {
                this.customScreenWidth = width, this.customScreenHeight = height;
            }, ToolTipComponent.prototype.show = function(tooltipData, clickedArea) {
                this.isTooltipVisible = !0, this.tooltipContainer || (this.tooltipContainer = this.createTooltipContainer()), 
                this.setTooltipContent(tooltipData), this.tooltipContainer.style("visibility", "visible").transition().duration(0).style("opacity", this.tooltipOptions.opacity), 
                this.setPosition(clickedArea);
            }, ToolTipComponent.prototype.move = function(tooltipData, clickedArea) {
                this.isTooltipVisible && (tooltipData && this.setTooltipContent(tooltipData), this.setPosition(clickedArea));
            }, ToolTipComponent.prototype.hide = function() {
                this.isTooltipVisible && (this.isTooltipVisible = !1, this.tooltipContainer.transition().duration(this.tooltipOptions.animationDuration).style("opacity", 0).each("end", function() {
                    this.style.visibility = "hidden";
                }));
            }, ToolTipComponent.prototype.createTooltipContainer = function() {
                var container = d3.select(ToolTipComponent.parentContainerSelector).append("div").attr("class", ContainerClassName["class"]);
                return container.append("div").attr("class", ArrowClassName["class"]), container.append("div").attr("class", ContentContainerClassName["class"]), 
                container;
            }, ToolTipComponent.prototype.setTooltipContent = function(tooltipData) {
                if (!_.isEqual(tooltipData, this.currentTooltipData)) {
                    this.currentTooltipData = tooltipData;
                    var rowsSelector = TooltipRowClassName.selector, contentContainer = this.tooltipContainer.select(ContentContainerClassName.selector);
                    if (contentContainer.selectAll(TooltipHeaderClassName.selector).remove(), contentContainer.selectAll(TooltipRowClassName.selector).remove(), 
                    0 !== tooltipData.length) {
                        tooltipData[0].header && contentContainer.append("div").attr("class", TooltipHeaderClassName["class"]).text(tooltipData[0].header);
                        var tooltipRow = contentContainer.selectAll(rowsSelector).data(tooltipData), newRow = tooltipRow.enter().append("div").attr("class", TooltipRowClassName["class"]);
                        if (tooltipData[0].color) {
                            var newColorCell = newRow.append("div").attr("class", TooltipColorCellClassName["class"]);
                            newColorCell.append("svg").attr({
                                width: "100%",
                                height: "15px"
                            }).append("circle").attr({
                                cx: "5",
                                cy: "8",
                                r: "5"
                            }).style({
                                fill: function(d) {
                                    return d.color;
                                }
                            });
                        }
                        var newTitleCell = newRow.append("div").attr("class", TooltipTitleCellClassName["class"]), newValueCell = newRow.append("div").attr("class", TooltipValueCellClassName["class"]);
                        newTitleCell.text(function(d) {
                            return d.displayName;
                        }), newValueCell.text(function(d) {
                            return d.value;
                        });
                    }
                }
            }, ToolTipComponent.prototype.getTooltipPosition = function(clickedArea, clickedScreenArea) {
                var tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect(), centerPointOffset = Math.floor(clickedArea.width / 2), offsetX = 0, offsetY = 0, centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset), arrowOffset = 7;
                return 0 === clickedScreenArea ? (offsetX += 3 * arrowOffset + centerPointOffset, 
                offsetY -= 2 * arrowOffset + centerPointOffset) : 1 === clickedScreenArea ? (offsetX -= 2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset, 
                offsetY -= 2 * arrowOffset + centerPointOffset) : 3 === clickedScreenArea ? (offsetX += 3 * arrowOffset + centerPointOffset, 
                offsetY -= tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset) : 2 === clickedScreenArea && (offsetX -= 2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset, 
                offsetY -= tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset), 
                centerPoint.offset(offsetX, offsetY), centerPoint;
            }, ToolTipComponent.prototype.setPosition = function(clickedArea) {
                var clickedScreenArea = this.getClickedScreenArea(clickedArea), tooltipPosition = this.getTooltipPosition(clickedArea, clickedScreenArea);
                this.tooltipContainer.style({
                    left: tooltipPosition.x + "px",
                    top: tooltipPosition.y + "px"
                }), this.setArrowPosition(clickedArea, clickedScreenArea);
            }, ToolTipComponent.prototype.setArrowPosition = function(clickedArea, clickedScreenArea) {
                var arrowClassName, arrow = this.getArrowElement();
                0 === clickedScreenArea ? arrowClassName = "top left" : 1 === clickedScreenArea ? arrowClassName = "top right" : 3 === clickedScreenArea ? arrowClassName = "bottom left" : 2 === clickedScreenArea && (arrowClassName = "bottom right"), 
                arrow.attr("class", "arrow").classed(arrowClassName, !0);
            }, ToolTipComponent.prototype.getArrowElement = function() {
                return this.tooltipContainer.select(ArrowClassName.selector);
            }, ToolTipComponent.prototype.getClickedScreenArea = function(clickedArea) {
                var screenWidth = this.customScreenWidth || window.innerWidth, screenHeight = this.customScreenHeight || window.innerHeight, centerPointOffset = clickedArea.width / 2, centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset), halfWidth = screenWidth / 2, halfHeight = screenHeight / 2;
                return centerPoint.x < halfWidth && centerPoint.y < halfHeight ? 0 : centerPoint.x >= halfWidth && centerPoint.y < halfHeight ? 1 : centerPoint.x < halfWidth && centerPoint.y >= halfHeight ? 3 : centerPoint.x >= halfWidth && centerPoint.y >= halfHeight ? 2 : void 0;
            }, ToolTipComponent.DefaultTooltipOptions = {
                opacity: 1,
                animationDuration: 250,
                offsetX: 10,
                offsetY: 10
            }, ToolTipComponent.parentContainerSelector = "body", ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName", 
            ToolTipComponent;
        }();
        visuals.ToolTipComponent = ToolTipComponent;
        var TooltipManager;
        !function(TooltipManager) {
            function addTooltip(selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove, onMouseOutDelegate) {
                if (TooltipManager.ShowTooltips) {
                    var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
                    selection.on("mouseover", function() {
                        var target = d3.event.target, data = d3.select(target).datum();
                        if (!handleTouchTimeoutId && canDisplayTooltip(d3.event)) {
                            mouseCoordinates = getCoordinates(rootNode, !0);
                            var elementCoordinates = getCoordinates(target, !0), tooltipEvent = {
                                data: data,
                                coordinates: mouseCoordinates,
                                elementCoordinates: elementCoordinates,
                                context: target,
                                isTouchEvent: !1
                            };
                            clearTooltipTimeout();
                            var delay = TooltipManager.ToolTipInstance.isTooltipComponentVisible() ? 16 : tooltipMouseOverDelay;
                            tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delay);
                        }
                    }), selection.on("mouseout", function() {
                        handleTouchTimeoutId || (clearTooltipTimeout(), tooltipTimeoutId = hideDelayedTooltip(tooltipMouseOutDelay)), 
                        onMouseOutDelegate && onMouseOutDelegate();
                    }), selection.on("mousemove", function() {
                        var target = d3.event.target, data = d3.select(target).datum();
                        if (!handleTouchTimeoutId && canDisplayTooltip(d3.event)) {
                            mouseCoordinates = getCoordinates(rootNode, !0);
                            var elementCoordinates = getCoordinates(target, !0), tooltipEvent = {
                                data: data,
                                coordinates: mouseCoordinates,
                                elementCoordinates: elementCoordinates,
                                context: target,
                                isTouchEvent: !1
                            };
                            moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
                        }
                    });
                    var touchStartEventName = getTouchStartEventName(), touchEndEventName = getTouchEndEventName(), isPointerEvent = "pointerdown" === touchStartEventName || "MSPointerDown" === touchStartEventName;
                    GlobalTooltipEventsAttached || (attachGlobalEvents(touchStartEventName), GlobalTooltipEventsAttached = !0), 
                    selection.on(touchStartEventName, function() {
                        var target = d3.event.target, data = d3.select(target).datum();
                        hideTooltipEventHandler();
                        var coordinates = getCoordinates(rootNode, isPointerEvent), elementCoordinates = getCoordinates(target, isPointerEvent), tooltipEvent = {
                            data: data,
                            coordinates: coordinates,
                            elementCoordinates: elementCoordinates,
                            context: target,
                            isTouchEvent: !0
                        };
                        clearTooltipTimeout(), tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipTouchDelay);
                    }), selection.on(touchEndEventName, function() {
                        clearTooltipTimeout(), handleTouchTimeoutId && clearTimeout(handleTouchTimeoutId), 
                        handleTouchTimeoutId = setTimeout(function() {
                            handleTouchTimeoutId = 0;
                        }, handleTouchDelay);
                    });
                }
            }
            function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
                return setTimeout(function() {
                    return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate);
                }, delayInMs);
            }
            function hideDelayedTooltip(delayInMs) {
                return setTimeout(function() {
                    return hideTooltipEventHandler();
                }, delayInMs);
            }
            function setLocalizedStrings(localizationOptions) {
                ToolTipComponent.localizationOptions = localizationOptions;
            }
            function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
                var tooltipInfo = tooltipData || getTooltipInfoDelegate(tooltipEvent);
                if (!_.isEmpty(tooltipInfo)) {
                    var coordinates = mouseCoordinates || tooltipEvent.coordinates, clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
                    TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
                }
            }
            function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                tooltipData = void 0, reloadTooltipDataOnMouseMove && (tooltipData = getTooltipInfoDelegate(tooltipEvent));
                var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
                TooltipManager.ToolTipInstance.move(tooltipData, clickedArea);
            }
            function hideTooltipEventHandler() {
                TooltipManager.ToolTipInstance.hide();
            }
            function clearTooltipTimeout() {
                tooltipTimeoutId && clearTimeout(tooltipTimeoutId);
            }
            function canDisplayTooltip(d3Event) {
                var cadDisplay = !0, mouseEvent = d3Event;
                if (void 0 !== mouseEvent.buttons) {
                    var hasMouseButtonPressed = 0 !== mouseEvent.buttons;
                    cadDisplay = !hasMouseButtonPressed;
                }
                return cadDisplay;
            }
            function getTouchStartEventName() {
                var eventName = "touchstart";
                return window.PointerEvent ? eventName = "pointerdown" : window.MSPointerEvent && (eventName = "MSPointerDown"), 
                eventName;
            }
            function getTouchEndEventName() {
                var eventName = "touchend";
                return window.PointerEvent ? eventName = "pointerup" : window.MSPointerEvent && (eventName = "MSPointerUp"), 
                eventName;
            }
            function getCoordinates(rootNode, isPointerEvent) {
                var coordinates;
                if (isPointerEvent) {
                    for (var e = d3.event, s = void 0; s = e.sourceEvent; ) e = s;
                    var rect = rootNode.getBoundingClientRect();
                    coordinates = [ e.clientX - rect.left - rootNode.clientLeft, e.clientY - rect.top - rootNode.clientTop ];
                } else {
                    var touchCoordinates = d3.touches(rootNode);
                    touchCoordinates && touchCoordinates.length > 0 && (coordinates = touchCoordinates[0]);
                }
                return coordinates;
            }
            function attachGlobalEvents(touchStartEventName) {
                d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, function(d, i) {
                    TooltipManager.ToolTipInstance.hide();
                });
            }
            function getClickedArea(x, y, isTouchEvent) {
                var width = 0, pointX = x, pointY = y;
                if (isTouchEvent) {
                    width = 12;
                    var offset = width / 2;
                    pointX = Math.max(x - offset, 0), pointY = Math.max(y - offset, 0);
                }
                return new TouchUtils.Rectangle(pointX, pointY, width, width);
            }
            TooltipManager.ShowTooltips = !0, TooltipManager.ToolTipInstance = new ToolTipComponent();
            var tooltipTimeoutId, mouseCoordinates, tooltipData, GlobalTooltipEventsAttached = !1, tooltipMouseOverDelay = 350, tooltipMouseOutDelay = 500, tooltipTouchDelay = 350, handleTouchDelay = 1e3, handleTouchTimeoutId = 0;
            TooltipManager.addTooltip = addTooltip, TooltipManager.showDelayedTooltip = showDelayedTooltip, 
            TooltipManager.hideDelayedTooltip = hideDelayedTooltip, TooltipManager.setLocalizedStrings = setLocalizedStrings;
        }(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
        var TooltipBuilder;
        !function(TooltipBuilder) {
            function createTooltipInfo(formatStringProp, dataViewCat, categoryValue, value, categories, seriesData, seriesIndex, categoryIndex, highlightedValue, gradientValueColumn) {
                var categorySource, seriesSource = [], valuesSource = void 0;
                seriesIndex = 0 | seriesIndex;
                var categoriesData = dataViewCat ? dataViewCat.categories : categories;
                if (categoriesData && categoriesData.length > 0) if (categoriesData.length > 1) {
                    for (var compositeCategoriesData = [], i = 0, ilen = categoriesData.length; ilen > i; i++) compositeCategoriesData.push(categoriesData[i].source);
                    categorySource = {
                        value: categoryValue,
                        metadata: compositeCategoriesData
                    };
                } else categorySource = {
                    value: categoryValue,
                    metadata: [ categoriesData[0].source ]
                };
                if (dataViewCat && dataViewCat.values) {
                    if (categorySource && categorySource.metadata[0] === dataViewCat.values.source || (valuesSource = dataViewCat.values.source), 
                    dataViewCat.values.length > 0) {
                        var valueColumn = dataViewCat.values[seriesIndex], isAutoGeneratedColumn = !!(valueColumn && valueColumn.source && valueColumn.source.isAutoGeneratedColumn);
                        isAutoGeneratedColumn || seriesSource.push({
                            value: value,
                            highlightedValue: highlightedValue,
                            metadata: valueColumn
                        });
                    }
                    var gradientToolTipData = createGradientToolTipData(gradientValueColumn, categoryIndex);
                    null != gradientToolTipData && seriesSource.push(gradientToolTipData);
                }
                if (seriesData) for (var i = 0, len = seriesData.length; len > i; i++) {
                    var singleSeriesData = seriesData[i];
                    categorySource && categorySource.metadata[0] === singleSeriesData.metadata.source || seriesSource.push({
                        value: singleSeriesData.value,
                        metadata: singleSeriesData.metadata
                    });
                }
                var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
                return tooltipInfo;
            }
            function createGradientToolTipData(gradientValueColumn, categoryIndex) {
                return gradientValueColumn ? {
                    value: gradientValueColumn.values[categoryIndex],
                    metadata: {
                        source: gradientValueColumn.source,
                        values: []
                    }
                } : null;
            }
            function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
                var items = [];
                if (categoryValue) if (categoryValue.metadata.length > 1) {
                    for (var displayName = "", i = 0, ilen = categoryValue.metadata.length; ilen > i; i++) 0 !== i && (displayName += "/"), 
                    displayName += categoryValue.metadata[i].displayName;
                    var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                    items.push({
                        displayName: displayName,
                        value: categoryFormattedValue
                    });
                } else {
                    var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                    items.push({
                        displayName: categoryValue.metadata[0].displayName,
                        value: categoryFormattedValue
                    });
                }
                if (valuesSource) {
                    var dynamicValue = void 0;
                    if (seriesValues.length > 0) {
                        var dynamicValueMetadata = seriesValues[0].metadata.source;
                        dynamicValue = getFormattedValue(valuesSource, formatStringProp, dynamicValueMetadata.groupName);
                    }
                    items.push({
                        displayName: valuesSource.displayName,
                        value: dynamicValue
                    });
                }
                for (var i = 0; i < seriesValues.length; i++) {
                    var seriesData = seriesValues[i];
                    if (seriesData && seriesData.metadata) {
                        var seriesMetadataColumn = seriesData.metadata.source, value = seriesData.value, highlightedValue = seriesData.highlightedValue;
                        if (value || 0 === value) {
                            var formattedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
                            items.push({
                                displayName: seriesMetadataColumn.displayName,
                                value: formattedValue
                            });
                        }
                        if (highlightedValue || 0 === highlightedValue) {
                            var formattedHighlightedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue), displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                            items.push({
                                displayName: displayName,
                                value: formattedHighlightedValue
                            });
                        }
                    }
                }
                return items;
            }
            function getFormattedValue(column, formatStringProp, value) {
                var formatString = getFormatStringFromColumn(column, formatStringProp);
                return visuals.valueFormatter.format(value, formatString);
            }
            function getFormatStringFromColumn(column, formatStringProp) {
                if (column) {
                    var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, !0);
                    return formatString || column.format;
                }
                return null;
            }
            TooltipBuilder.createTooltipInfo = createTooltipInfo, TooltipBuilder.createGradientToolTipData = createGradientToolTipData;
        }(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var visualStyles;
        !function(visualStyles) {
            function create(dataColors) {
                return void 0 === dataColors && (dataColors = new visuals.DataColorPalette()), {
                    titleText: {
                        color: {
                            value: "rgba(51,51,51,1)"
                        }
                    },
                    subTitleText: {
                        color: {
                            value: "rgba(145,145,145,1)"
                        }
                    },
                    colorPalette: {
                        dataColors: dataColors
                    },
                    labelText: {
                        color: {
                            value: "rgba(51,51,51,1)"
                        },
                        fontSize: "11px"
                    },
                    isHighContrast: !1
                };
            }
            visualStyles.create = create;
        }(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, DonutChart = function() {
            function DonutChart(options) {
                options && (this.sliceWidthRatio = options.sliceWidthRatio, this.animator = options.animator, 
                this.isScrollable = options.isScrollable ? options.isScrollable : !1, this.disableGeometricCulling = options.disableGeometricCulling ? options.disableGeometricCulling : !1, 
                this.behavior = options.behavior, this.tooltipsEnabled = options.tooltipsEnabled, 
                options.smallViewPortProperties && (this.maxHeightToScaleDonutLegend = options.smallViewPortProperties.maxHeightToScaleDonutLegend)), 
                null == this.sliceWidthRatio && (this.sliceWidthRatio = DonutChart.defaultSliceWidthRatio);
            }
            return DonutChart.converter = function(dataView, colors, defaultDataPointColor, viewport, disableGeometricCulling, interactivityService, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var converter = new DonutChartConversion.DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled);
                converter.convert();
                var d3PieLayout = d3.layout.pie().sort(null).value(function(d) {
                    return d.percentage;
                });
                interactivityService && (interactivityService.applySelectionStateToData(converter.dataPoints), 
                interactivityService.applySelectionStateToData(converter.legendData.dataPoints));
                var culledDataPoints = !disableGeometricCulling && viewport ? DonutChart.cullDataByViewport(converter.dataPoints, converter.maxValue, viewport) : converter.dataPoints;
                return {
                    dataPointsToDeprecate: culledDataPoints,
                    dataPoints: d3PieLayout(culledDataPoints),
                    unCulledDataPoints: converter.dataPoints,
                    dataPointsToEnumerate: converter.legendData.dataPoints,
                    legendData: converter.legendData,
                    hasHighlights: converter.hasHighlights,
                    dataLabelsSettings: converter.dataLabelsSettings,
                    legendObjectProperties: converter.legendObjectProperties,
                    maxValue: converter.maxValue,
                    visibleGeometryCulled: converter.dataPoints.length !== culledDataPoints.length
                };
            }, DonutChart.prototype.init = function(options) {
                this.options = options;
                var element = options.element;
                element.empty(), this.parentViewport = options.viewport, this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width
                }, this.formatter = visuals.valueFormatter.format, this.data = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: {
                        title: "",
                        dataPoints: [],
                        fontSize: visuals.SVGLegend.DefaultFontSizeInPt
                    },
                    hasHighlights: !1,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings()
                }, this.drilled = !1, this.allowDrilldown = !1, this.style = options.style, this.colors = this.style.colorPalette.dataColors, 
                this.radius = 0, this.isInteractive = options.interactivity && options.interactivity.isInteractiveLegend;
                var donutChartSettings = this.settings;
                if (this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable), 
                this.hostService = options.host, this.isInteractive) {
                    this.chartRotationAnimationDuration = donutChartSettings && donutChartSettings.chartRotationAnimationDuration ? donutChartSettings.chartRotationAnimationDuration : 0;
                    var legendContainer = this.legendContainer = d3.select(element.get(0)).append("div").classed(DonutChart.InteractiveLegendClassName, !0);
                    this.interactivityState = {
                        interactiveLegend: new DonutChartInteractiveLegend(this, legendContainer, this.colors, options, this.settings),
                        valueToAngleFactor: 0,
                        sliceAngles: [],
                        currentRotate: 0,
                        interactiveChosenSliceFinishedSetting: !1,
                        lastChosenInteractiveSliceIndex: 0,
                        totalDragAngleDifference: 0,
                        currentIndexDrag: 0,
                        previousIndexDrag: 0,
                        previousDragAngle: 0,
                        donutCenter: {
                            x: 0,
                            y: 0
                        }
                    };
                }
                this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(DonutChart.ClassName, !0), 
                this.behavior && (this.clearCatcher = visuals.appendClearCatcher(this.svg)), this.mainGraphicsContext = this.svg.append("g"), 
                this.mainGraphicsContext.append("g").classed("slices", !0), this.labelGraphicsContext = this.svg.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                this.pie = d3.layout.pie().sort(null).value(function(d) {
                    return d.percentage;
                });
            }, DonutChart.prototype.update = function(options) {
                var viewport = options.viewport;
                this.parentViewport = viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                    var dataViewMetadata = dataViews[0].metadata, defaultDataPointColor = void 0;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        objects && (defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.donutChartProps.dataPoint.defaultColor));
                    }
                    this.data = DonutChart.converter(dataViews[0], this.colors, defaultDataPointColor, this.currentViewport, this.disableGeometricCulling, this.interactivityService, this.tooltipsEnabled), 
                    this.data.defaultDataPointColor = defaultDataPointColor, this.options.interactivity && this.options.interactivity.isInteractiveLegend || this.renderLegend();
                } else this.data = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: {
                        title: "",
                        dataPoints: []
                    },
                    hasHighlights: !1,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings()
                };
                if (this.initViewportDependantProperties(), this.initDonutProperties(), this.updateInternal(this.data, options.suppressAnimations), 
                this.hasSetData = !0, dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                    this.hostService.setWarnings(warnings);
                }
            }, DonutChart.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            }, DonutChart.prototype.onResizing = function(viewport) {
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: !0,
                    viewport: viewport
                });
            }, DonutChart.prototype.enumerateObjectInstances = function(options) {
                var enumeration = new visuals.ObjectEnumerationBuilder(), dataLabelsSettings = this.data && this.data.dataLabelsSettings ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                switch (options.objectName) {
                  case "legend":
                    this.enumerateLegend(enumeration);
                    break;

                  case "dataPoint":
                    this.enumerateDataPoints(enumeration);
                    break;

                  case "labels":
                    var labelSettingOptions = {
                        enumeration: enumeration,
                        dataLabelsSettings: dataLabelsSettings,
                        show: !0,
                        displayUnits: !0,
                        precision: !0,
                        fontSize: !0,
                        labelStyle: !0
                    };
                    visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                }
                return enumeration.complete();
            }, DonutChart.prototype.enumerateDataPoints = function(enumeration) {
                var data = this.data;
                if (data) for (var dataPoints = data.dataPointsToEnumerate, dataPointsLength = dataPoints.length, i = 0; dataPointsLength > i; i++) {
                    var dataPoint = dataPoints[i];
                    enumeration.pushInstance({
                        objectName: "dataPoint",
                        displayName: dataPoint.label,
                        selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                        properties: {
                            fill: {
                                solid: {
                                    color: dataPoint.color
                                }
                            }
                        }
                    });
                }
            }, DonutChart.prototype.enumerateLegend = function(enumeration) {
                var data = this.data;
                if (data) {
                    var legendObjectProperties = {
                        legend: data.legendObjectProperties
                    }, show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.show, this.legend.isVisible()), showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.showTitle, !0), titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.titleText, this.data.legendData.title), labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData.labelColor), labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData.fontSize);
                    enumeration.pushInstance({
                        selector: null,
                        objectName: "legend",
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: labelFontSize
                        }
                    });
                }
            }, DonutChart.prototype.setInteractiveChosenSlice = function(sliceIndex) {
                var _this = this;
                if (0 !== this.interactivityState.sliceAngles.length) {
                    this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex, this.interactivityState.interactiveChosenSliceFinishedSetting = !1;
                    var viewport = this.currentViewport, moduledIndex = sliceIndex % this.data.dataPoints.length, angle = this.interactivityState.sliceAngles[moduledIndex];
                    this.svg.select("g").transition().duration(this.chartRotationAnimationDuration).ease("elastic").attr("transform", visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, angle)).each("end", function() {
                        _this.interactivityState.interactiveChosenSliceFinishedSetting = !0;
                    }), this.interactivityState.currentRotate = angle, this.interactivityState.interactiveLegend.updateLegend(moduledIndex), 
                    this.svg.selectAll(".slice").attr("opacity", function(d, index) {
                        return index === moduledIndex ? 1 : .6;
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                }
            }, DonutChart.prototype.calculateRadius = function() {
                var viewport = this.currentViewport;
                if (!this.isInteractive && this.data && this.data.dataLabelsSettings.show) {
                    var hw = viewport.height / viewport.width, denom = 2 + 1 / (1 + Math.exp(-5 * (hw - 1)));
                    return Math.min(viewport.height, viewport.width) / denom;
                }
                return Math.min(viewport.height, viewport.width) / 2;
            }, DonutChart.prototype.getScaleForLegendArrow = function() {
                var ratio = 1;
                return this.maxHeightToScaleDonutLegend && this.currentViewport.height < this.maxHeightToScaleDonutLegend && (ratio = this.currentViewport.height / this.maxHeightToScaleDonutLegend), 
                ratio;
            }, DonutChart.prototype.initViewportDependantProperties = function(duration) {
                void 0 === duration && (duration = 0), this.currentViewport.height = this.parentViewport.height, 
                this.currentViewport.width = this.parentViewport.width;
                var viewport = this.currentViewport;
                if (this.isInteractive) viewport.height -= DonutChart.InteractiveLegendContainerHeight; else {
                    var legendMargins = this.legend.getMargins();
                    viewport.height -= legendMargins.height, viewport.width -= legendMargins.width;
                }
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                }), this.isInteractive ? (this.legendContainer.style({
                    width: "100%",
                    height: DonutChart.InteractiveLegendContainerHeight + "px",
                    overflow: "hidden",
                    top: 0
                }), this.svg.style("top", DonutChart.InteractiveLegendContainerHeight)) : visuals.Legend.positionChartArea(this.svg, this.legend), 
                this.previousRadius = this.radius;
                var radius = this.radius = this.calculateRadius(), halfViewportWidth = viewport.width / 2, halfViewportHeight = viewport.height / 2;
                this.arc = d3.svg.arc(), this.outerArc = d3.svg.arc().innerRadius(radius * DonutChart.OuterArcRadiusRatio).outerRadius(radius * DonutChart.OuterArcRadiusRatio), 
                this.isInteractive ? (this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight)), 
                this.labelGraphicsContext.attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight))) : (this.mainGraphicsContext.transition().duration(duration).attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight)), 
                this.labelGraphicsContext.transition().duration(duration).attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight))), 
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            }, DonutChart.prototype.initDonutProperties = function() {
                this.donutProperties = {
                    viewport: this.currentViewport,
                    radius: this.radius,
                    arc: this.arc.innerRadius(0).outerRadius(this.radius * DonutChart.InnerArcRadiusRatio),
                    outerArc: this.outerArc,
                    innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
                    outerArcRadiusRatio: DonutChart.OuterArcRadiusRatio,
                    dataLabelsSettings: this.data.dataLabelsSettings
                };
            }, DonutChart.prototype.mergeDatasets = function(first, second) {
                var secondSet = d3.set();
                second.forEach(function(d) {
                    secondSet.add(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                });
                var onlyFirst = first.filter(function(d) {
                    return !secondSet.has(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                }).map(function(d) {
                    var derived = powerbi.Prototype.inherit(d);
                    return void 0 === derived.percentage ? derived.data.percentage = 0 : derived.percentage = 0, 
                    derived;
                });
                return d3.merge([ second, onlyFirst ]);
            }, DonutChart.prototype.updateInternal = function(data, suppressAnimations, duration) {
                void 0 === duration && (duration = 0);
                var viewport = this.currentViewport;
                if (duration = duration || visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), 
                this.animator) {
                    var shapes_1, layout = DonutChart.getLayout(this.radius, this.sliceWidthRatio, viewport), result = void 0, highlightShapes = void 0, labelSettings = data.dataLabelsSettings, labels = [];
                    if (labelSettings && labelSettings.show && (labels = this.createLabels()), !suppressAnimations) {
                        var animationOptions = {
                            viewModel: data,
                            colors: this.colors,
                            graphicsContext: this.mainGraphicsContext,
                            labelGraphicsContext: this.labelGraphicsContext,
                            interactivityService: this.interactivityService,
                            layout: layout,
                            radius: this.radius,
                            sliceWidthRatio: this.sliceWidthRatio,
                            viewport: viewport,
                            labels: labels,
                            innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio
                        };
                        result = this.animator.animate(animationOptions), shapes_1 = result.shapes, highlightShapes = result.highlightShapes;
                    }
                    (suppressAnimations || result.failed) && (shapes_1 = DonutChart.drawDefaultShapes(this.svg, data, layout, this.colors, this.radius, this.interactivityService && this.interactivityService.hasSelection(), this.sliceWidthRatio, this.data.defaultDataPointColor), 
                    highlightShapes = DonutChart.drawDefaultHighlightShapes(this.svg, data, layout, this.colors, this.radius, this.sliceWidthRatio), 
                    visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, !1, !0, !0), 
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels)), 
                    this.assignInteractions(shapes_1, highlightShapes, data), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(shapes_1, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    }), visuals.TooltipManager.addTooltip(highlightShapes, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    }));
                } else this.updateInternalToMove(data, duration);
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            }, DonutChart.prototype.createLabels = function() {
                var labelLayout = new powerbi.DonutLabelLayout({
                    maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                    startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                }, this.donutProperties), labelDataPoints = this.createLabelDataPoints();
                return labelLayout.layout(labelDataPoints);
            }, DonutChart.prototype.createLabelDataPoints = function() {
                var data = this.data, labelDataPoints = [], measureFormatterCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), alternativeScale = null;
                0 === data.dataLabelsSettings.displayUnits && (alternativeScale = d3.max(data.dataPoints, function(d) {
                    return Math.abs(d.data.measure);
                }));
                for (var i = 0; i < this.data.dataPoints.length; i++) {
                    var label = this.createLabelDataPoint(data.dataPoints[i], alternativeScale, measureFormatterCache);
                    labelDataPoints.push(label);
                }
                return labelDataPoints;
            }, DonutChart.prototype.createLabelDataPoint = function(d, alternativeScale, measureFormatterCache) {
                var dataLabel, dataLabelSize, categoryLabel, categoryLabelSize, textSize, labelPoint = this.outerArc.centroid(d), labelX = visuals.DonutLabelUtils.getXPositionForDonutLabel(labelPoint[0]), labelY = labelPoint[1], labelSettings = this.data.dataLabelsSettings, measureFormatter = measureFormatterCache.getOrCreate(d.data.labelFormatString, labelSettings, alternativeScale), position = 0 > labelX ? 4 : 8, pointPosition = {
                    point: {
                        x: labelX,
                        y: labelY
                    },
                    validPositions: [ position ],
                    radius: 0
                }, outsideFill = labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor, labelSettingsStyle = labelSettings.labelStyle, fontSize = labelSettings.fontSize, tooltip = "";
                switch (labelSettingsStyle !== visuals.labelStyle.both && labelSettingsStyle !== visuals.labelStyle.data || (dataLabel = measureFormatter.format(null != d.data.highlightValue ? d.data.highlightValue : d.data.measure), 
                dataLabelSize = visuals.NewDataLabelUtils.getTextSize(dataLabel, fontSize)), labelSettingsStyle !== visuals.labelStyle.both && labelSettingsStyle !== visuals.labelStyle.category || (categoryLabel = d.data.label, 
                categoryLabelSize = visuals.NewDataLabelUtils.getTextSize(categoryLabel, fontSize)), 
                labelSettingsStyle) {
                  case visuals.labelStyle.both:
                    var text = categoryLabel + " (" + dataLabel + ")";
                    tooltip = text, textSize = visuals.NewDataLabelUtils.getTextSize(text, fontSize);
                    break;

                  case visuals.labelStyle.category:
                    textSize = _.clone(categoryLabelSize), tooltip = categoryLabel;
                    break;

                  case visuals.labelStyle.data:
                    textSize = _.clone(dataLabelSize), tooltip = dataLabel;
                }
                var leaderLinePoints = visuals.DonutLabelUtils.getLabelLeaderLineForDonutChart(d, this.donutProperties, pointPosition.point), leaderLinesSize = visuals.DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
                return {
                    isPreferred: !0,
                    text: "",
                    tooltip: tooltip,
                    textSize: textSize,
                    outsideFill: outsideFill,
                    fontSize: fontSize,
                    identity: d.data.identity,
                    parentShape: pointPosition,
                    insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                    parentType: 0,
                    alternativeScale: alternativeScale,
                    donutArcDescriptor: d,
                    angle: (d.startAngle + d.endAngle) / 2 - Math.PI / 2,
                    dataLabel: dataLabel,
                    dataLabelSize: dataLabelSize,
                    categoryLabel: categoryLabel,
                    categoryLabelSize: categoryLabelSize,
                    leaderLinePoints: leaderLinePoints,
                    linesSize: leaderLinesSize
                };
            }, DonutChart.prototype.renderLegend = function() {
                if (!this.isInteractive) {
                    var legendObjectProperties = this.data.legendObjectProperties;
                    if (legendObjectProperties) {
                        var legendData = this.data.legendData;
                        visuals.LegendData.update(legendData, legendObjectProperties);
                        var position = legendObjectProperties[visuals.legendProps.position];
                        position && this.legend.changeOrientation(visuals.LegendPosition[position]), this.legend.drawLegend(legendData, this.parentViewport);
                    } else this.legend.changeOrientation(visuals.LegendPosition.Top), this.legend.drawLegend({
                        dataPoints: []
                    }, this.parentViewport);
                }
            }, DonutChart.prototype.addInteractiveLegendArrow = function() {
                var arrowHeightOffset = 11, arrowWidthOffset = 16.5;
                if (!this.interactiveLegendArrow) {
                    var interactiveLegendArrow = this.svg.append("g");
                    interactiveLegendArrow.append("path").classed(DonutChart.InteractiveLegendArrowClassName, !0).attr("d", "M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z"), 
                    this.interactiveLegendArrow = interactiveLegendArrow;
                }
                var viewport = this.currentViewport, scaleRatio = this.getScaleForLegendArrow(), distanceBetweenLegendAndArrow = (viewport.height - 2 * this.radius) / 2 + arrowHeightOffset * scaleRatio, middleOfChart = viewport.width / 2 - arrowWidthOffset * scaleRatio;
                this.interactiveLegendArrow.attr("transform", visuals.SVGUtil.translateAndScale(middleOfChart, distanceBetweenLegendAndArrow, scaleRatio));
            }, DonutChart.prototype.calculateSliceAngles = function() {
                var angles = [], data = this.data.dataPoints;
                if (0 === data.length) return this.interactivityState.valueToAngleFactor = 0, void (this.interactivityState.sliceAngles = []);
                for (var sum = 0, i = 0, ilen = data.length; ilen > i; i++) sum += data[i].data.percentage;
                this.interactivityState.valueToAngleFactor = 360 / sum;
                for (var currentAngle = 0, i = 0, ilen = data.length; ilen > i; i++) {
                    var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
                    currentAngle += relativeAngle, angles.push(relativeAngle / 2 - currentAngle);
                }
                this.interactivityState.sliceAngles = angles;
            }, DonutChart.prototype.assignInteractions = function(slices, highlightSlices, data) {
                if (this.isInteractive) this.assignInteractiveChartInteractions(slices); else if (this.interactivityService) {
                    var dataPoints = data.dataPoints.map(function(value) {
                        return value.data;
                    }), behaviorOptions = {
                        clearCatcher: this.clearCatcher,
                        slices: slices,
                        highlightSlices: highlightSlices,
                        allowDrilldown: this.allowDrilldown,
                        visual: this,
                        hasHighlights: data.hasHighlights,
                        svg: this.svg
                    };
                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                }
            }, DonutChart.prototype.setDrilldown = function(selection) {
                if (selection) {
                    var d3PieLayout = d3.layout.pie().sort(null).value(function(d) {
                        return d.percentage;
                    }), legendDataPoints = [ {
                        label: selection.label,
                        color: selection.color,
                        icon: visuals.LegendIcon.Box,
                        identity: selection.identity,
                        selected: selection.selected
                    } ], legendData = {
                        title: "",
                        dataPoints: legendDataPoints
                    }, drilledDataPoints = d3PieLayout(selection.internalDataPoints);
                    this.updateInternal({
                        dataPointsToDeprecate: selection.internalDataPoints,
                        dataPoints: drilledDataPoints,
                        unCulledDataPoints: drilledDataPoints.map(function(value) {
                            return value.data;
                        }),
                        legendData: legendData,
                        hasHighlights: !1,
                        dataLabelsSettings: this.data.dataLabelsSettings
                    }, !1, DonutChart.DrillDownAnimationDuration);
                } else this.updateInternal(this.data, !1, DonutChart.DrillDownAnimationDuration);
            }, DonutChart.prototype.assignInteractiveChartInteractions = function(slice) {
                var _this = this, svg = this.svg;
                this.interactivityState.interactiveChosenSliceFinishedSetting = !0;
                var svgRect = svg.node().getBoundingClientRect();
                this.interactivityState.donutCenter = {
                    x: svgRect.left + svgRect.width / 2,
                    y: svgRect.top + svgRect.height / 2
                }, this.interactivityState.totalDragAngleDifference = 0, this.interactivityState.currentRotate = 0, 
                this.calculateSliceAngles(), slice.on("click", function(d, clickedIndex) {
                    d3.event.defaultPrevented || _this.setInteractiveChosenSlice(clickedIndex);
                });
                var drag = d3.behavior.drag().origin(Object).on("dragstart", function() {
                    return _this.interactiveDragStart();
                }).on("drag", function() {
                    return _this.interactiveDragMove();
                }).on("dragend", function() {
                    return _this.interactiveDragEnd();
                });
                svg.style("touch-action", "none").call(drag);
            }, DonutChart.prototype.getAngleFromDragEvent = function() {
                var pageX, pageY, interactivityState = this.interactivityState, sourceEvent = d3.event.sourceEvent;
                if (-1 !== sourceEvent.type.toLowerCase().indexOf("touch")) {
                    if (1 !== sourceEvent.touches.length) return null;
                    var touch = sourceEvent.touches[0];
                    pageX = touch.pageX, pageY = touch.pageY;
                } else pageX = sourceEvent.pageX, pageY = sourceEvent.pageY;
                var adjustedCoordinates = {
                    x: pageX - interactivityState.donutCenter.x,
                    y: -pageY + interactivityState.donutCenter.y
                }, angleToThePlane = 180 * Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) / Math.PI;
                return angleToThePlane;
            }, DonutChart.prototype.interactiveDragStart = function() {
                this.interactivityState.totalDragAngleDifference = 0, this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
            }, DonutChart.prototype.interactiveDragMove = function() {
                var data = this.data.dataPoints, viewport = this.currentViewport, interactivityState = this.interactivityState;
                if (interactivityState.interactiveChosenSliceFinishedSetting === !0) {
                    var currentDragAngle = this.getAngleFromDragEvent();
                    if (!currentDragAngle) return;
                    var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
                    interactivityState.totalDragAngleDifference += angleDragDiff, interactivityState.previousDragAngle = currentDragAngle, 
                    interactivityState.currentRotate += angleDragDiff, this.svg.select("g").attr("transform", visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, this.interactivityState.currentRotate));
                    var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor, currentAngle = interactivityState.currentRotate <= 0 ? -1 * interactivityState.currentRotate % 360 : 360 - interactivityState.currentRotate % 360;
                    interactivityState.currentIndexDrag = 0;
                    for (var dataLength = data.length; interactivityState.currentIndexDrag < dataLength && currentAngle > currentHigherLimit; ) interactivityState.currentIndexDrag < dataLength - 1 && (currentHigherLimit += data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor), 
                    interactivityState.currentIndexDrag++;
                    interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag && (interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag), 
                    this.svg.selectAll(".slice").attr("opacity", function(d, index) {
                        return index === interactivityState.currentIndexDrag ? DonutChart.OpaqueOpacity : DonutChart.SemiTransparentOpacity;
                    }), interactivityState.previousIndexDrag = interactivityState.currentIndexDrag);
                }
            }, DonutChart.prototype.interactiveDragEnd = function() {
                0 !== this.interactivityState.totalDragAngleDifference && (this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag), 
                d3.event.sourceEvent.stopPropagation());
            }, DonutChart.prototype.updateInternalToMove = function(data, duration) {
                void 0 === duration && (duration = 0);
                var svg = this.svg, pie = this.pie, key = this.key, arc = this.arc, radius = this.radius, previousRadius = this.previousRadius, sliceWidthRatio = this.sliceWidthRatio, existingData = this.svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data().map(function(d) {
                    return d.data;
                });
                0 === existingData.length && (existingData = data.dataPointsToDeprecate);
                var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate), slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key);
                slice.enter().insert("path").classed(DonutChart.sliceClass["class"], !0).each(function(d) {
                    this._current = d;
                }), slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(is), key);
                var innerRadius = radius * sliceWidthRatio;
                if (DonutChart.isSingleColor(data.dataPoints), slice.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, !1, data.hasHighlights);
                }).style("stroke", "white").style("stroke-dasharray", function(d) {
                    return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio);
                }).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).transition().duration(duration).attrTween("d", function(d) {
                    var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, radius * DonutChart.InnerArcRadiusRatio);
                    return this._current = i(0), function(t) {
                        return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                    };
                }), slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key), 
                slice.exit().transition().delay(duration).duration(0).remove(), !this.isInteractive) {
                    var labelSettings = data.dataLabelsSettings, labels = [];
                    labelSettings && labelSettings.show && (labels = this.createLabels()), visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, !1, !0), 
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
                }
                var highlightSlices = void 0;
                data.hasHighlights ? (highlightSlices = svg.select(".slices").selectAll("path" + DonutChart.sliceHighlightClass.selector).data(pie(data.dataPointsToDeprecate), key), 
                highlightSlices.enter().insert("path").classed(DonutChart.sliceHighlightClass["class"], !0).each(function(d) {
                    this._current = d;
                }), DonutChart.isSingleColor(data.dataPoints), highlightSlices.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", 1).style("stroke", "white").style("stroke-dasharray", function(d) {
                    return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio);
                }).style("stroke-width", function(d) {
                    return 0 === d.data.highlightRatio ? 0 : d.data.strokeWidth;
                }).transition().duration(duration).attrTween("d", function(d) {
                    var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                    return this._current = i(0), function(t) {
                        return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                    };
                }), highlightSlices.exit().transition().delay(duration).duration(0).remove()) : svg.selectAll("path" + DonutChart.sliceHighlightClass.selector).transition().delay(duration).duration(0).remove(), 
                this.assignInteractions(slice, highlightSlices, data), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(slice, function(tooltipEvent) {
                    return tooltipEvent.data.data.tooltipInfo;
                }), data.hasHighlights && visuals.TooltipManager.addTooltip(highlightSlices, function(tooltipEvent) {
                    return tooltipEvent.data.data.tooltipInfo;
                })), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), this.isInteractive && (this.addInteractiveLegendArrow(), 
                this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate), 
                this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0));
            }, DonutChart.drawDefaultShapes = function(graphicsContext, donutData, layout, colors, radius, hasSelection, sliceWidthRatio, defaultColor) {
                var shapes = graphicsContext.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(donutData.dataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                return shapes.enter().insert("path").classed(DonutChart.sliceClass["class"], !0), 
                DonutChart.isSingleColor(donutData.dataPoints), shapes.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, donutData.hasHighlights);
                }).style("stroke-dasharray", function(d) {
                    return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio);
                }).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
            }, DonutChart.drawDefaultHighlightShapes = function(graphicsContext, donutData, layout, colors, radius, sliceWidthRatio) {
                var shapes = graphicsContext.select(".slices").selectAll("path" + DonutChart.sliceHighlightClass.selector).data(donutData.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                return shapes.enter().insert("path").classed(DonutChart.sliceHighlightClass["class"], !0).each(function(d) {
                    this._current = d;
                }), DonutChart.isSingleColor(donutData.dataPoints), shapes.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, donutData.hasHighlights);
                }).style("stroke", "white").style("stroke-dasharray", function(d) {
                    return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio);
                }).style("stroke-width", function(d) {
                    return 0 === d.data.highlightRatio ? 0 : d.data.strokeWidth;
                }).attr(layout.highlightShapeLayout), shapes.exit().remove(), shapes;
            }, DonutChart.isSingleColor = function(dataPoints) {
                if (dataPoints.length > 1) {
                    var lastPoint = dataPoints.length - 1;
                    dataPoints[lastPoint].data.isLastInDonut = dataPoints[lastPoint].data.color === dataPoints[0].data.color;
                }
            }, DonutChart.drawStrokeForDonutChart = function(radius, innerArcRadiusRatio, d, sliceWidthRatio, highlightRatio) {
                void 0 === highlightRatio && (highlightRatio = 1);
                var sectionWithoutStroke, sectionWithStroke, sliceRadius = radius * innerArcRadiusRatio * highlightRatio, sliceArc = (d.endAngle - d.startAngle) * sliceRadius;
                if (sliceWidthRatio) {
                    var innerRadius = radius * sliceWidthRatio, outerRadius = highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio), innerSliceArc = (d.endAngle - d.startAngle) * innerRadius;
                    if (d.data.highlightRatio && (sliceArc = (d.endAngle - d.startAngle) * (outerRadius + innerRadius)), 
                    d.data.isLastInDonut) return "0 " + sliceArc + " " + outerRadius + " " + innerSliceArc + " " + outerRadius;
                    sectionWithoutStroke = sliceArc + outerRadius + innerSliceArc, sectionWithStroke = outerRadius;
                } else d.data.isLastInDonut ? (sectionWithoutStroke = sliceArc, sectionWithStroke = 2 * sliceRadius) : (sectionWithoutStroke = sliceArc + sliceRadius, 
                sectionWithStroke = sliceRadius);
                return "0 " + sectionWithoutStroke + " " + sectionWithStroke;
            }, DonutChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, DonutChart.getLayout = function(radius, sliceWidthRatio, viewport) {
                var innerRadius = radius * sliceWidthRatio, arc = d3.svg.arc().innerRadius(innerRadius), arcWithRadius = arc.outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                return {
                    shapeLayout: {
                        d: function(d) {
                            return arcWithRadius(d);
                        }
                    },
                    highlightShapeLayout: {
                        d: function(d) {
                            var highlightArc = arc.outerRadius(DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                            return highlightArc(d);
                        }
                    },
                    zeroShapeLayout: {
                        d: function(d) {
                            var zeroWithZeroRadius = arc.outerRadius(innerRadius || DonutChart.EffectiveZeroValue);
                            return zeroWithZeroRadius(d);
                        }
                    }
                };
            }, DonutChart.getHighlightRadius = function(radius, sliceWidthRatio, highlightRatio) {
                var innerRadius = radius * sliceWidthRatio;
                return innerRadius + highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
            }, DonutChart.cullDataByViewport = function(dataPoints, maxValue, viewport) {
                for (var prevPointColor, estimatedRadius = Math.min(viewport.width, viewport.height) / 2, cullRatio = this.invisibleArcLengthInPixels / (estimatedRadius * DonutChart.twoPi), cullableValue = cullRatio * maxValue, culledDataPoints = [], _i = 0, dataPoints_5 = dataPoints; _i < dataPoints_5.length; _i++) {
                    var datapoint = dataPoints_5[_i];
                    datapoint.measure >= cullableValue && (datapoint.strokeWidth = prevPointColor === datapoint.color ? 1 : 0, 
                    prevPointColor = datapoint.color, culledDataPoints.push(datapoint));
                }
                return culledDataPoints;
            }, DonutChart.ClassName = "donutChart", DonutChart.InteractiveLegendClassName = "donutLegend", 
            DonutChart.InteractiveLegendArrowClassName = "donutLegendArrow", DonutChart.DrillDownAnimationDuration = 1e3, 
            DonutChart.OuterArcRadiusRatio = .9, DonutChart.InnerArcRadiusRatio = .8, DonutChart.OpaqueOpacity = 1, 
            DonutChart.SemiTransparentOpacity = .6, DonutChart.defaultSliceWidthRatio = .48, 
            DonutChart.invisibleArcLengthInPixels = 3, DonutChart.sliceClass = createClassAndSelector("slice"), 
            DonutChart.sliceHighlightClass = createClassAndSelector("slice-highlight"), DonutChart.twoPi = 2 * Math.PI, 
            DonutChart.InteractiveLegendContainerHeight = 70, DonutChart.EffectiveZeroValue = 1e-9, 
            DonutChart.PolylineOpacity = .5, DonutChart;
        }();
        visuals.DonutChart = DonutChart;
        var DonutChartConversion, DonutChartInteractiveLegend = function() {
            function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions, settings) {
                this.legendContainerParent = legendContainer, this.colors = colors, this.donutChart = donutChart, 
                this.visualInitOptions = visualInitOptions, this.legendItemsPositions = [], this.legendTransitionAnimationDuration = settings && settings.legendTransitionAnimationDuration ? settings.legendTransitionAnimationDuration : 0;
            }
            return DonutChartInteractiveLegend.prototype.drawLegend = function(data) {
                var _this = this;
                this.data = data, this.currentNumberOfLegendItems = data.length, this.currentIndex = 0, 
                this.leftMostIndex = 0, this.rightMostIndex = data.length - 1, this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty() && (this.legendContainer = this.legendContainerParent.append("div").classed(DonutChartInteractiveLegend.LegendContainerClassName, !0));
                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data), legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width, initialXOffset = legendContainerWidth / 2 - .4 * legendContainerWidth / 2 + DonutChartInteractiveLegend.ItemMargin, currX = initialXOffset;
                this.currentXOffset = initialXOffset;
                var createLegendItem = function(itemDiv, datum) {
                    itemDiv.attr("data-legend-index", datum.index).css({
                        position: "absolute",
                        left: currX
                    });
                    var itemCategory = visuals.valueFormatter.format(datum.label), itemValue = visuals.valueFormatter.format(datum.measure, datum.measureFormat), itemPercentage = visuals.valueFormatter.format(datum.percentage, "0.00 %;-0.00 %;0.00 %"), itemColor = datum.color, itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11), itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11), itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20), valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan), categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan), precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan), currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
                    itemDiv.css("width", currentLegendBoxWidth);
                    var getLeftValue = function(spanWidth) {
                        return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
                    }, marginLeftValue = getLeftValue(valueSpanWidth), marginLeftCategory = getLeftValue(categorySpanWidth), marginLeftPrecentage = getLeftValue(precentageSpanWidth);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory), 
                    DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue), 
                    DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css("color", itemColor), 
                    itemDiv.append(itemCategorySpan), itemDiv.append(itemPercentageSpan), itemDiv.append(itemValueSpan), 
                    _this.legendItemsPositions.push({
                        startX: currX,
                        boxWidth: currentLegendBoxWidth
                    }), currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
                };
                legendItems.enter().insert("div").classed(DonutChartInteractiveLegend.LegendItemClassName, !0).each(function(d) {
                    createLegendItem($(this), d);
                }), legendItems.exit().remove(), this.assignInteractions();
            }, DonutChartInteractiveLegend.prototype.updateLegend = function(sliceIndex) {
                var _this = this;
                if (!(this.currentNumberOfLegendItems <= 1)) {
                    var legendContainerWidth = this.legendContainerWidth;
                    this.currentIndex = sliceIndex, this.updateLabelBlocks(sliceIndex);
                    var legendTransitionAnimationDuration = this.legendTransitionAnimationDuration, nextXOffset = -1 * (this.legendItemsPositions[sliceIndex].startX + this.legendItemsPositions[sliceIndex].boxWidth / 2 - legendContainerWidth / 2);
                    this.legendContainer.transition().styleTween("-webkit-transform", function(d, i, a) {
                        return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                    }).styleTween("transform", function(d, i, a) {
                        return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                    }).duration(legendTransitionAnimationDuration).ease("bounce").each("end", function() {
                        _this.currentXOffset = nextXOffset;
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.visualInitOptions);
                }
            }, DonutChartInteractiveLegend.prototype.assignInteractions = function() {
                var _this = this, currentDX = 0, hasChanged = !1, dragStart = function() {
                    currentDX = 0, hasChanged = !1;
                }, dragMove = function() {
                    if (currentDX += d3.event.dx, !(hasChanged || Math.abs(currentDX) < DonutChartInteractiveLegend.MinimumSwipeDX)) {
                        var dragDirectionLeft = 0 > currentDX;
                        _this.dragLegend(dragDirectionLeft), hasChanged = !0;
                    }
                }, drag = d3.behavior.drag().origin(Object).on("drag", dragMove).on("dragstart", dragStart);
                this.legendContainer.style({
                    "touch-action": "none",
                    cursor: "pointer"
                }).call(drag);
            }, DonutChartInteractiveLegend.prototype.dragLegend = function(dragDirectionLeft) {
                this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1 ? this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft) : this.shouldChangeIndexInNonCycling(dragDirectionLeft) && (dragDirectionLeft ? this.currentIndex++ : this.currentIndex--), 
                this.donutChart.setInteractiveChosenSlice(this.currentIndex);
            }, DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function(dragDirectionLeft) {
                return !(0 === this.currentIndex && !dragDirectionLeft || this.currentIndex === this.currentNumberOfLegendItems - 1 && dragDirectionLeft);
            }, DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function(dragDirectionLeft) {
                var dataLen = this.data.length, delta = dragDirectionLeft ? 1 : -1, newIndex = (this.currentIndex + delta) % (dataLen || 1);
                return 0 > newIndex ? newIndex + dataLen : newIndex;
            }, DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function(rightSidedShift, numberOfLegendItemsBlocksToShift) {
                var legendContainer$ = $(this.legendContainer[0]);
                if (rightSidedShift) {
                    var smallestItem = legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]");
                    smallestItem.remove().insertAfter(legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]"));
                    var newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.leftMostIndex].startX = newX, smallestItem.css("left", newX), 
                    this.rightMostIndex = this.leftMostIndex, this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
                } else {
                    var highestItem = legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]");
                    highestItem.remove().insertBefore(legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]"));
                    var newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.rightMostIndex].startX = newX, highestItem.css("left", newX), 
                    this.leftMostIndex = this.rightMostIndex, this.rightMostIndex = this.rightMostIndex - 1 === -1 ? this.legendItemsPositions.length - 1 : this.rightMostIndex - 1;
                }
                numberOfLegendItemsBlocksToShift - 1 !== 0 && this.updateLegendItemsBlocks(rightSidedShift, numberOfLegendItemsBlocksToShift - 1);
            }, DonutChartInteractiveLegend.prototype.updateLabelBlocks = function(index) {
                this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled ? (this.rightMostIndex === index && this.updateLegendItemsBlocks(!0, 2), 
                this.leftMostIndex === index && this.updateLegendItemsBlocks(!1, 2), (this.rightMostIndex === index + 1 || 0 === this.rightMostIndex && index === this.currentNumberOfLegendItems - 1) && this.updateLegendItemsBlocks(!0, 1), 
                (this.leftMostIndex === index - 1 || this.leftMostIndex === this.currentNumberOfLegendItems - 1 && 0 === index) && this.updateLegendItemsBlocks(!1, 1)) : this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled && (this.rightMostIndex === index && this.updateLegendItemsBlocks(!0, 1), 
                this.leftMostIndex === index && this.updateLegendItemsBlocks(!1, 1));
            }, DonutChartInteractiveLegend.createBasicLegendItemSpan = function(spanClass, text, fontSize) {
                return $("<span/>").addClass(spanClass).css({
                    "white-space": "nowrap",
                    "font-size": fontSize + "px"
                }).text(text);
            }, DonutChartInteractiveLegend.createLegendItemSpan = function(existingSpan, marginLeft) {
                return existingSpan.css({
                    overflow: "hidden",
                    "text-overflow": "ellipsis",
                    display: "inline-block",
                    width: "100%",
                    "margin-left": marginLeft
                }), existingSpan;
            }, DonutChartInteractiveLegend.legendBoxSize = function(valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
                var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
                return boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth, 
                boxSize = boxSize > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : boxSize + 2;
            }, DonutChartInteractiveLegend.spanWidth = function(span) {
                return this.FakeElementSpan || (this.FakeElementSpan = $("<span>").hide().appendTo(document.body)), 
                this.FakeElementSpan.empty(), this.FakeElementSpan.append(span), this.FakeElementSpan.width();
            }, DonutChartInteractiveLegend.LegendContainerClassName = "legend-container", DonutChartInteractiveLegend.LegendContainerSelector = ".legend-container", 
            DonutChartInteractiveLegend.LegendItemClassName = "legend-item", DonutChartInteractiveLegend.LegendItemSelector = ".legend-item", 
            DonutChartInteractiveLegend.LegendItemCategoryClassName = "category", DonutChartInteractiveLegend.LegendItemPercentageClassName = "percentage", 
            DonutChartInteractiveLegend.LegendItemValueClassName = "value", DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160, 
            DonutChartInteractiveLegend.ItemMargin = 30, DonutChartInteractiveLegend.MinimumSwipeDX = 15, 
            DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3, DonutChartInteractiveLegend;
        }();
        !function(DonutChartConversion) {
            var DonutChartConverter = function() {
                function DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    var dataViewCategorical = dataView.categorical;
                    if (this.dataViewCategorical = dataViewCategorical, this.dataViewMetadata = dataView.metadata, 
                    this.tooltipsEnabled = tooltipsEnabled, this.seriesCount = dataViewCategorical.values ? dataViewCategorical.values.length : 0, 
                    this.colorHelper = new visuals.ColorHelper(colors, visuals.donutChartProps.dataPoint.fill, defaultDataPointColor), 
                    this.maxValue = 0, dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        var category = dataViewCategorical.categories[0];
                        this.categoryIdentities = category.identity, this.categoryValues = category.values, 
                        this.allCategoryObjects = category.objects, this.categoryColumnRef = category.identityFields, 
                        this.categoryFormatString = visuals.valueFormatter.getFormatString(category.source, visuals.donutChartProps.general.formatString);
                    }
                    var grouped = this.grouped = dataViewCategorical && dataViewCategorical.values ? dataViewCategorical.values.grouped() : void 0;
                    this.isMultiMeasure = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1, 
                    this.isSingleMeasure = grouped && 1 === grouped.length && grouped[0].values && 1 === grouped[0].values.length, 
                    this.isDynamicSeries = !(!dataViewCategorical.values || !dataViewCategorical.values.source), 
                    this.hasHighlights = this.seriesCount > 0 && !_.isEmpty(dataViewCategorical.values) && !!dataViewCategorical.values[0].highlights, 
                    this.highlightsOverflow = !1, this.total = 0, this.highlightTotal = 0, this.dataPoints = [], 
                    this.legendDataPoints = [], this.dataLabelsSettings = null;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) for (var seriesData = dataViewCategorical.values[seriesIndex], measureIndex = 0; measureIndex < seriesData.values.length; measureIndex++) this.total += Math.abs(seriesData.values[measureIndex]), 
                    this.highlightTotal += this.hasHighlights ? Math.abs(seriesData.highlights[measureIndex]) : 0;
                    this.total = visuals.AxisHelper.normalizeNonFiniteNumber(this.total), this.highlightTotal = visuals.AxisHelper.normalizeNonFiniteNumber(this.highlightTotal);
                }
                return DonutChartConverter.normalizedMeasureAndValue = function(measureAndValue) {
                    var normalized = $.extend(!0, {}, measureAndValue);
                    return normalized.measure = visuals.AxisHelper.normalizeNonFiniteNumber(normalized.measure), 
                    normalized.value = visuals.AxisHelper.normalizeNonFiniteNumber(normalized.value), 
                    normalized;
                }, DonutChartConverter.prototype.convert = function() {
                    var convertedData;
                    convertedData = 0 !== this.total ? this.categoryValues ? this.convertCategoricalWithSlicing() : this.isDynamicSeries ? this.convertSeries() : this.convertMeasures() : [];
                    for (var highlightsOverflow = !1, i = 0, dataPointCount = convertedData.length; dataPointCount > i && !highlightsOverflow; i++) {
                        var point = convertedData[i];
                        Math.abs(point.highlightMeasureValue.measure) > Math.abs(point.measureValue.measure) && (highlightsOverflow = !0);
                    }
                    this.dataLabelsSettings = this.convertDataLabelSettings();
                    var dataViewMetadata = this.dataViewMetadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        objects && (this.legendObjectProperties = objects.legend);
                    }
                    this.dataPoints = [];
                    for (var prevPointColor, formatStringProp = visuals.donutChartProps.general.formatString, i = 0, dataPointCount = convertedData.length; dataPointCount > i; i++) {
                        var point = convertedData[i], normalizedHighlight = DonutChartConverter.normalizedMeasureAndValue(point.highlightMeasureValue), normalizedNonHighlight = DonutChartConverter.normalizedMeasureAndValue(point.measureValue), measure = normalizedNonHighlight.measure, percentage = this.total > 0 ? normalizedNonHighlight.value / this.total : 0, highlightRatio = void 0;
                        normalizedNonHighlight.value > this.maxValue && (this.maxValue = normalizedNonHighlight.value), 
                        normalizedHighlight.value > this.maxValue && (this.maxValue = normalizedHighlight.value), 
                        this.hasHighlights && (highlightsOverflow ? (measure = normalizedHighlight.measure, 
                        percentage = this.highlightTotal > 0 ? normalizedHighlight.value / this.highlightTotal : 0, 
                        highlightRatio = 1) : highlightRatio = 0 !== normalizedNonHighlight.value ? normalizedHighlight.value / normalizedNonHighlight.value : 0, 
                        highlightRatio || (highlightRatio = DonutChart.EffectiveZeroValue));
                        var categoryValue = point.categoryLabel, categorical = this.dataViewCategorical, valueIndex = categorical.categories ? null : i;
                        valueIndex = void 0 !== point.seriesIndex ? point.seriesIndex : valueIndex;
                        var valuesMetadata = categorical.values[valueIndex].source, value = this.hasHighlights && highlightsOverflow ? point.highlightMeasureValue.measure : point.measureValue.measure, highlightValue = this.hasHighlights && !highlightsOverflow ? point.highlightMeasureValue.measure : void 0, tooltipInfo = void 0;
                        this.tooltipsEnabled && (tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, valueIndex, i, highlightValue));
                        var strokeWidth = prevPointColor === point.color && value && value > 0 ? 1 : 0;
                        prevPointColor = value && value > 0 ? point.color : prevPointColor, this.dataPoints.push({
                            identity: point.identity,
                            measure: measure,
                            measureFormat: point.measureFormat,
                            percentage: percentage,
                            index: point.index,
                            label: point.label,
                            highlightRatio: highlightRatio,
                            highlightValue: highlightValue,
                            selected: !1,
                            tooltipInfo: tooltipInfo,
                            color: point.color,
                            strokeWidth: strokeWidth,
                            labelFormatString: valuesMetadata.format
                        });
                    }
                    this.legendData = this.convertLegendData();
                }, DonutChartConverter.prototype.getLegendTitle = function() {
                    if (0 !== this.total) {
                        var dvValuesSourceName = this.dataViewCategorical.values && this.dataViewCategorical.values.source ? this.dataViewCategorical.values.source.displayName : "", dvCategorySourceName = this.dataViewCategorical.categories && this.dataViewCategorical.categories.length > 0 && this.dataViewCategorical.categories[0].source ? this.dataViewCategorical.categories[0].source.displayName : "";
                        return this.categoryValues ? dvCategorySourceName : dvValuesSourceName;
                    }
                    return "";
                }, DonutChartConverter.prototype.convertCategoricalWithSlicing = function() {
                    for (var dataViewCategorical = this.dataViewCategorical, formatStringProp = visuals.donutChartProps.general.formatString, dataPoints = [], categoryIndex = 0, categoryCount = this.categoryValues.length; categoryCount > categoryIndex; categoryIndex++) {
                        for (var categoryValue = this.categoryValues[categoryIndex], thisCategoryObjects = this.allCategoryObjects ? this.allCategoryObjects[categoryIndex] : void 0, legendIdentity = visuals.SelectionId.createWithId(this.categoryIdentities[categoryIndex]), color = this.colorHelper.getColorForSeriesValue(thisCategoryObjects, this.categoryColumnRef, categoryValue), categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString), seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                            var seriesData = dataViewCategorical.values[seriesIndex], label = this.isSingleMeasure ? categoryLabel : visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp), nonHighlight = seriesData.values[categoryIndex] || 0, highlight = this.hasHighlights ? seriesData.highlights[categoryIndex] || 0 : 0, measure = void 0, seriesGroup = void 0;
                            this.isMultiMeasure ? measure = seriesData.source.queryName : seriesData.identity && (seriesGroup = seriesData);
                            var identity = visuals.SelectionIdBuilder.builder().withCategory(dataViewCategorical.categories[0], categoryIndex).withSeries(seriesGroup, seriesGroup).withMeasure(measure).createSelectionId(), dataPoint = {
                                identity: identity,
                                measureFormat: visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, !0),
                                measureValue: {
                                    measure: nonHighlight,
                                    value: Math.abs(nonHighlight)
                                },
                                highlightMeasureValue: {
                                    measure: highlight,
                                    value: Math.abs(highlight)
                                },
                                index: categoryIndex * this.seriesCount + seriesIndex,
                                label: label,
                                categoryLabel: categoryLabel,
                                color: color,
                                seriesIndex: seriesIndex
                            };
                            dataPoints.push(dataPoint);
                        }
                        this.legendDataPoints.push({
                            label: categoryLabel,
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            identity: legendIdentity,
                            selected: !1
                        });
                    }
                    return dataPoints;
                }, DonutChartConverter.prototype.convertMeasures = function() {
                    for (var dataViewCategorical = this.dataViewCategorical, dataPoints = [], formatStringProp = visuals.donutChartProps.general.formatString, measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
                        var measureData = dataViewCategorical.values[measureIndex], measureFormat = visuals.valueFormatter.getFormatString(measureData.source, formatStringProp, !0), measureLabel = measureData.source.displayName, identity = visuals.SelectionId.createWithMeasure(measureData.source.queryName), nonHighlight = measureData.values[0] || 0, highlight = this.hasHighlights ? measureData.highlights[0] || 0 : 0, color = this.colorHelper.getColorForMeasure(measureData.source.objects, measureData.source.queryName), dataPoint = {
                            identity: identity,
                            measureFormat: measureFormat,
                            measureValue: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight)
                            },
                            highlightMeasureValue: {
                                measure: highlight,
                                value: Math.abs(highlight)
                            },
                            index: measureIndex,
                            label: measureLabel,
                            categoryLabel: measureLabel,
                            color: color
                        };
                        dataPoints.push(dataPoint), this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: visuals.LegendIcon.Box,
                            identity: dataPoint.identity,
                            selected: !1
                        });
                    }
                    return dataPoints;
                }, DonutChartConverter.prototype.convertSeries = function() {
                    for (var dataViewCategorical = this.dataViewCategorical, dataPoints = [], formatStringProp = visuals.donutChartProps.general.formatString, seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex], seriesFormat = visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, !0), label = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp), identity = visuals.SelectionId.createWithId(seriesData.identity), seriesName = visuals.converterHelper.getSeriesName(seriesData.source), objects = this.grouped && this.grouped[seriesIndex] && this.grouped[seriesIndex].objects, nonHighlight = seriesData.values[0] || 0, highlight = this.hasHighlights ? seriesData.highlights[0] || 0 : 0, color = this.colorHelper.getColorForSeriesValue(objects, dataViewCategorical.values.identityFields, seriesName), dataPoint = {
                            identity: identity,
                            measureFormat: seriesFormat,
                            measureValue: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight)
                            },
                            highlightMeasureValue: {
                                measure: highlight,
                                value: Math.abs(highlight)
                            },
                            index: seriesIndex,
                            label: label,
                            categoryLabel: label,
                            color: color,
                            seriesIndex: seriesIndex
                        };
                        dataPoints.push(dataPoint), this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: visuals.LegendIcon.Box,
                            identity: dataPoint.identity,
                            selected: !1
                        });
                    }
                    return dataPoints;
                }, DonutChartConverter.prototype.convertDataLabelSettings = function() {
                    var dataViewMetadata = this.dataViewMetadata, dataLabelsSettings = visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var labelsObj = objects.labels;
                            labelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                        }
                    }
                    return dataLabelsSettings;
                }, DonutChartConverter.prototype.convertLegendData = function() {
                    return {
                        dataPoints: this.legendDataPoints,
                        labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                        title: this.getLegendTitle(),
                        fontSize: visuals.SVGLegend.DefaultFontSizeInPt
                    };
                }, DonutChartConverter;
            }();
            DonutChartConversion.DonutChartConverter = DonutChartConverter;
        }(DonutChartConversion || (DonutChartConversion = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var Utility = jsCommon.Utility, ScriptVisual = function() {
            function ScriptVisual(options) {
                this.canRefresh = options.canRefresh;
            }
            return ScriptVisual.prototype.init = function(options) {
                this.element = options.element, this.hostServices = options.host, this.canRefresh || this.hostServices.setWarnings([ new visuals.ScriptVisualRefreshWarning() ]);
            }, ScriptVisual.prototype.update = function(options) {
                var dataViews = options.dataViews;
                if (dataViews && 0 !== dataViews.length) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.metadata) {
                        var imageUrl = this.getImageUrl(dataView), div = this.ensureHtmlElement();
                        if (imageUrl && Utility.isValidImageDataUrl(imageUrl)) {
                            var viewport = options.viewport;
                            div.css({
                                height: viewport.height,
                                width: viewport.width,
                                backgroundImage: "url(" + imageUrl + ")"
                            });
                        } else div.css({
                            backgroundImage: "none"
                        });
                    }
                }
            }, ScriptVisual.prototype.onResizing = function(finalViewport) {
                var div = this.ensureHtmlElement();
                div.css({
                    height: finalViewport.height,
                    width: finalViewport.width
                });
            }, ScriptVisual.prototype.getImageUrl = function(dataView) {
                return dataView.scriptResult && dataView.scriptResult.imageBase64 ? "data:image/png;base64," + dataView.scriptResult.imageBase64 : null;
            }, ScriptVisual.prototype.ensureHtmlElement = function() {
                var div = this.imageBackgroundElement;
                return div || (div = $("<div class='imageBackground' />"), this.imageBackgroundElement = div, 
                this.imageBackgroundElement.appendTo(this.element)), div;
            }, ScriptVisual;
        }();
        visuals.ScriptVisual = ScriptVisual;
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var plugins;
        !function(plugins) {
            plugins.animatedNumber = {
                name: "animatedNumber",
                capabilities: visuals.capabilities.animatedNumber,
                create: function() {
                    return new visuals.AnimatedNumber();
                }
            }, plugins.areaChart = {
                name: "areaChart",
                watermarkKey: "area",
                capabilities: visuals.capabilities.lineChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 1
                    });
                },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.barChart = {
                name: "barChart",
                watermarkKey: "bar",
                capabilities: visuals.capabilities.barChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 6
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.basicShape = {
                name: "basicShape",
                capabilities: visuals.basicShapeCapabilities,
                create: function() {
                    return new visuals.BasicShapeVisual();
                }
            }, plugins.card = {
                name: "card",
                watermarkKey: "card",
                capabilities: visuals.capabilities.card,
                create: function() {
                    return new visuals.Card();
                }
            }, plugins.multiRowCard = {
                name: "multiRowCard",
                watermarkKey: "multiRowCard",
                capabilities: visuals.capabilities.multiRowCard,
                create: function() {
                    return new visuals.MultiRowCard();
                }
            }, plugins.clusteredBarChart = {
                name: "clusteredBarChart",
                watermarkKey: "clusteredBar",
                capabilities: visuals.capabilities.clusteredBarChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 5
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.clusteredColumnChart = {
                name: "clusteredColumnChart",
                watermarkKey: "clusteredColumn",
                capabilities: visuals.capabilities.clusteredColumnChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 3
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.columnChart = {
                name: "columnChart",
                watermarkKey: "column",
                capabilities: visuals.capabilities.columnChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 4
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.comboChart = {
                name: "comboChart",
                watermarkKey: "combo",
                capabilities: visuals.capabilities.comboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 10
                    });
                },
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ComboChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.dataDotChart = {
                name: "dataDotChart",
                capabilities: visuals.capabilities.dataDotChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 11
                    });
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.dataDotClusteredColumnComboChart = {
                name: "dataDotClusteredColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.capabilities.dataDotClusteredColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 15
                    });
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.dataDotStackedColumnComboChart = {
                name: "dataDotStackedColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.capabilities.dataDotStackedColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 16
                    });
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.donutChart = {
                name: "donutChart",
                watermarkKey: "donut",
                capabilities: visuals.capabilities.donutChart,
                create: function() {
                    return new visuals.DonutChart();
                }
            }, plugins.funnel = {
                name: "funnel",
                watermarkKey: "funnel",
                capabilities: visuals.capabilities.funnel,
                create: function() {
                    return new visuals.FunnelChart();
                }
            }, plugins.gauge = {
                name: "gauge",
                watermarkKey: "gauge",
                capabilities: visuals.capabilities.gauge,
                create: function() {
                    return new visuals.Gauge();
                }
            }, plugins.hundredPercentStackedBarChart = {
                name: "hundredPercentStackedBarChart",
                watermarkKey: "100stackedbar",
                capabilities: visuals.capabilities.hundredPercentStackedBarChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 7
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.hundredPercentStackedColumnChart = {
                name: "hundredPercentStackedColumnChart",
                watermarkKey: "100stackedcolumn",
                capabilities: visuals.capabilities.hundredPercentStackedColumnChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 8
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.image = {
                name: "image",
                capabilities: visuals.capabilities.image,
                create: function() {
                    return new visuals.ImageVisual();
                }
            }, plugins.lineChart = {
                name: "lineChart",
                watermarkKey: "line",
                capabilities: visuals.capabilities.lineChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 0
                    });
                },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.LineChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.lineStackedColumnComboChart = {
                name: "lineStackedColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.capabilities.lineStackedColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 14
                    });
                },
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ComboChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.lineClusteredColumnComboChart = {
                name: "lineClusteredColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.capabilities.lineClusteredColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 13
                    });
                },
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ComboChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.map = {
                name: "map",
                watermarkKey: "map",
                capabilities: visuals.capabilities.map,
                create: function() {
                    return new visuals.Map({
                        filledMap: !1
                    });
                }
            }, plugins.filledMap = {
                name: "filledMap",
                watermarkKey: "filledMap",
                capabilities: visuals.capabilities.filledMap,
                create: function() {
                    return new visuals.Map({
                        filledMap: !0
                    });
                }
            }, plugins.treemap = {
                name: "treemap",
                watermarkKey: "tree",
                capabilities: visuals.capabilities.treemap,
                create: function() {
                    return new visuals.Treemap();
                }
            }, plugins.pieChart = {
                name: "pieChart",
                watermarkKey: "pie",
                capabilities: visuals.capabilities.donutChart,
                create: function() {
                    return new visuals.DonutChart({
                        sliceWidthRatio: 0
                    });
                }
            }, plugins.scatterChart = {
                name: "scatterChart",
                watermarkKey: "scatterplot",
                capabilities: visuals.capabilities.scatterChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 9
                    });
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.ScatterChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.stackedAreaChart = {
                name: "stackedAreaChart",
                watermarkKey: "stackedarea",
                capabilities: visuals.capabilities.lineChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 2
                    });
                },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.table = {
                name: "table",
                watermarkKey: "table",
                capabilities: visuals.capabilities.table,
                create: function() {
                    return new visuals.Table();
                },
                customizeQuery: visuals.Table.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.Table.getSortableRoles();
                }
            }, plugins.matrix = {
                name: "matrix",
                watermarkKey: "matrix",
                capabilities: visuals.capabilities.matrix,
                create: function() {
                    return new visuals.Matrix();
                },
                customizeQuery: visuals.Matrix.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.Matrix.getSortableRoles();
                }
            }, plugins.slicer = {
                name: "slicer",
                watermarkKey: "slicer",
                capabilities: visuals.capabilities.slicer,
                create: function() {
                    return new visuals.Slicer();
                }
            }, plugins.textbox = {
                name: "textbox",
                capabilities: visuals.capabilities.textbox,
                create: function() {
                    return new visuals.Textbox();
                }
            }, plugins.waterfallChart = {
                name: "waterfallChart",
                watermarkKey: "waterfall",
                capabilities: visuals.capabilities.waterfallChart,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 12
                    });
                },
                getAdditionalTelemetry: function(dataView) {
                    return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                }
            }, plugins.cheerMeter = {
                name: "cheerMeter",
                capabilities: visuals.CheerMeter.capabilities,
                create: function() {
                    return new visuals.CheerMeter();
                }
            }, plugins.owlGauge = {
                name: "owlGauge",
                watermarkKey: "gauge",
                capabilities: visuals.OwlGauge.capabilities,
                create: function() {
                    return new visuals.OwlGauge();
                }
            }, plugins.scriptVisual = {
                name: "scriptVisual",
                watermarkKey: "scriptvisual",
                capabilities: visuals.capabilities.scriptVisual,
                create: function() {
                    return new visuals.ScriptVisual({
                        canRefresh: !1
                    });
                }
            }, plugins.kpi = {
                name: "kpi",
                watermarkKey: "kpi",
                capabilities: visuals.capabilities.kpi,
                create: function() {
                    return new visuals.KPIStatusWithHistory();
                }
            };
        }(plugins = visuals.plugins || (visuals.plugins = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));

var powerbi;

!function(powerbi) {
    var visuals;
    !function(visuals) {
        var CanvasBackgroundHelper;
        !function(CanvasBackgroundHelper) {
            function getDefaultColor() {
                return "#FFFFFF";
            }
            function getDefaultValues() {
                return {
                    color: getDefaultColor()
                };
            }
            CanvasBackgroundHelper.getDefaultColor = getDefaultColor, CanvasBackgroundHelper.getDefaultValues = getDefaultValues;
        }(CanvasBackgroundHelper = visuals.CanvasBackgroundHelper || (visuals.CanvasBackgroundHelper = {}));
    }(visuals = powerbi.visuals || (powerbi.visuals = {}));
}(powerbi || (powerbi = {}));