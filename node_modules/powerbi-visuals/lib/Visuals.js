var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../Typedefs/d3/d3.d.ts"/>
///<reference path="../../Typedefs/jquery-visible/jquery-visible.d.ts"/>
///<reference path="../../Typedefs/jquery/jquery.d.ts"/>
///<reference path="../../Typedefs/microsoftMaps/Microsoft.Maps.d.ts" />
///<reference path="../../Typedefs/moment/moment.d.ts"/>
///<reference path="../../Typedefs/velocity/velocity-animate.d.ts"/>
///<reference path="../../Typedefs/lodash/lodash.d.ts"/>
///<reference path="../../Typedefs/quill/quill.d.ts"/>
///<reference path="../../Typedefs/ie/ie.d.ts"/>
///<reference path="../../Typedefs/noUiSlider/noUiSlider.d.ts"/>
///<reference path="../../Typedefs/jquery.scrollbar/jquery.scrollbar.d.ts"/>
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Point = (function () {
            function Point(x, y) {
                this.x = x || 0;
                this.y = y || 0;
            }
            return Point;
        }());
        visuals.Point = Point;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Rect = (function () {
            // Constructor
            function Rect(left, top, width, height) {
                this.left = left || 0;
                this.top = top || 0;
                this.width = width || 0;
                this.height = height || 0;
            }
            return Rect;
        }());
        visuals.Rect = Rect;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        (function (LegendIcon) {
            LegendIcon[LegendIcon["Box"] = 0] = "Box";
            LegendIcon[LegendIcon["Circle"] = 1] = "Circle";
            LegendIcon[LegendIcon["Line"] = 2] = "Line";
        })(visuals.LegendIcon || (visuals.LegendIcon = {}));
        var LegendIcon = visuals.LegendIcon;
        (function (LegendPosition) {
            LegendPosition[LegendPosition["Top"] = 0] = "Top";
            LegendPosition[LegendPosition["Bottom"] = 1] = "Bottom";
            LegendPosition[LegendPosition["Right"] = 2] = "Right";
            LegendPosition[LegendPosition["Left"] = 3] = "Left";
            LegendPosition[LegendPosition["None"] = 4] = "None";
            LegendPosition[LegendPosition["TopCenter"] = 5] = "TopCenter";
            LegendPosition[LegendPosition["BottomCenter"] = 6] = "BottomCenter";
            LegendPosition[LegendPosition["RightCenter"] = 7] = "RightCenter";
            LegendPosition[LegendPosition["LeftCenter"] = 8] = "LeftCenter";
        })(visuals.LegendPosition || (visuals.LegendPosition = {}));
        var LegendPosition = visuals.LegendPosition;
        visuals.legendProps = {
            show: 'show',
            position: 'position',
            titleText: 'titleText',
            showTitle: 'showTitle',
            labelColor: 'labelColor',
            fontSize: 'fontSize',
        };
        function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition) {
            if (isScrollable === void 0) { isScrollable = false; }
            if (legendPosition === void 0) { legendPosition = LegendPosition.Top; }
            if (interactive)
                return new CartesianChartInteractiveLegend(legendParentElement);
            else
                return new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable);
        }
        visuals.createLegend = createLegend;
        var Legend;
        (function (Legend) {
            function isLeft(orientation) {
                switch (orientation) {
                    case LegendPosition.Left:
                    case LegendPosition.LeftCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isLeft = isLeft;
            function isTop(orientation) {
                switch (orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isTop = isTop;
            function positionChartArea(chartArea, legend) {
                var legendMargins = legend.getMargins();
                var legendOrientation = legend.getOrientation();
                chartArea.style({
                    'margin-left': Legend.isLeft(legendOrientation) ? legendMargins.width + 'px' : null,
                    'margin-top': Legend.isTop(legendOrientation) ? legendMargins.height + 'px' : null,
                });
            }
            Legend.positionChartArea = positionChartArea;
        })(Legend = visuals.Legend || (visuals.Legend = {}));
        var SVGLegend = (function () {
            function SVGLegend(element, legendPosition, interactivityService, isScrollable) {
                this.legendDataStartIndex = 0;
                this.arrowPosWindow = 1;
                this.lastCalculatedWidth = 0;
                this.visibleLegendWidth = 0;
                this.visibleLegendHeight = 0;
                this.legendFontSizeMarginDifference = 0;
                this.legendFontSizeMarginValue = 0;
                this.svg = d3.select(element.get(0)).append('svg').style('position', 'absolute');
                this.svg.style('display', 'inherit');
                this.svg.classed('legend', true);
                if (interactivityService)
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.group = this.svg.append('g').attr('id', 'legendGroup');
                this.interactivityService = interactivityService;
                this.isScrollable = isScrollable;
                this.element = element;
                this.changeOrientation(legendPosition);
                this.parentViewport = { height: 0, width: 0 };
                this.calculateViewport();
                this.updateLayout();
            }
            SVGLegend.prototype.updateLayout = function () {
                var legendViewport = this.viewport;
                var orientation = this.orientation;
                this.svg.attr({
                    'height': legendViewport.height || (orientation === LegendPosition.None ? 0 : this.parentViewport.height),
                    'width': legendViewport.width || (orientation === LegendPosition.None ? 0 : this.parentViewport.width)
                });
                var isRight = orientation === LegendPosition.Right || orientation === LegendPosition.RightCenter;
                var isBottom = orientation === LegendPosition.Bottom || orientation === LegendPosition.BottomCenter;
                this.svg.style({
                    'margin-left': isRight ? (this.parentViewport.width - legendViewport.width) + 'px' : null,
                    'margin-top': isBottom ? (this.parentViewport.height - legendViewport.height) + 'px' : null,
                });
            };
            SVGLegend.prototype.calculateViewport = function () {
                switch (this.orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.Bottom:
                    case LegendPosition.TopCenter:
                    case LegendPosition.BottomCenter:
                        var pixelHeight = PixelConverter.fromPointToPixel(this.data && this.data.fontSize ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt);
                        var fontHeightSize = SVGLegend.TopLegendHeight + (pixelHeight - SVGLegend.DefaultFontSizeInPt);
                        this.viewport = { height: fontHeightSize, width: 0 };
                        return;
                    case LegendPosition.Right:
                    case LegendPosition.Left:
                    case LegendPosition.RightCenter:
                    case LegendPosition.LeftCenter:
                        var width = this.lastCalculatedWidth ? this.lastCalculatedWidth : this.parentViewport.width * SVGLegend.LegendMaxWidthFactor;
                        this.viewport = { height: 0, width: width };
                        return;
                    case LegendPosition.None:
                        this.viewport = { height: 0, width: 0 };
                }
            };
            SVGLegend.prototype.getMargins = function () {
                return this.viewport;
            };
            SVGLegend.prototype.isVisible = function () {
                return this.orientation !== LegendPosition.None;
            };
            SVGLegend.prototype.changeOrientation = function (orientation) {
                if (orientation) {
                    this.orientation = orientation;
                }
                else {
                    this.orientation = LegendPosition.Top;
                }
                this.svg.attr('orientation', orientation);
            };
            SVGLegend.prototype.getOrientation = function () {
                return this.orientation;
            };
            SVGLegend.prototype.drawLegend = function (data, viewport) {
                // clone because we modify legend item label with ellipsis if it is truncated
                var clonedData = powerbi.Prototype.inherit(data);
                var newDataPoints = [];
                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    newDataPoints.push(powerbi.Prototype.inherit(dp));
                }
                clonedData.dataPoints = newDataPoints;
                this.setTooltipToLegendItems(clonedData);
                this.drawLegendInternal(clonedData, viewport, true /* perform auto width */);
            };
            SVGLegend.prototype.drawLegendInternal = function (data, viewport, autoWidth) {
                this.parentViewport = viewport;
                this.data = data;
                if (this.interactivityService)
                    this.interactivityService.applySelectionStateToData(data.dataPoints);
                if (data.dataPoints.length === 0) {
                    this.changeOrientation(LegendPosition.None);
                }
                if (this.getOrientation() === LegendPosition.None) {
                    data.dataPoints = [];
                }
                // Adding back the workaround for Legend Left/Right position for Map
                var mapControl = this.element.children(".mapControl");
                if (mapControl.length > 0 && !this.isTopOrBottom(this.orientation)) {
                    mapControl.css("display", "inline-block");
                }
                this.calculateViewport();
                var layout = this.calculateLayout(data, autoWidth);
                var titleLayout = layout.title;
                var titleData = titleLayout ? [titleLayout] : [];
                var hasSelection = this.interactivityService && powerbi.visuals.dataHasSelection(data.dataPoints);
                var group = this.group;
                //transform the wrapping group if position is centered
                if (this.isCentered(this.orientation)) {
                    var centerOffset = 0;
                    if (this.isTopOrBottom(this.orientation)) {
                        centerOffset = Math.max(0, (this.parentViewport.width - this.visibleLegendWidth) / 2);
                        group.attr('transform', visuals.SVGUtil.translate(centerOffset, 0));
                    }
                    else {
                        centerOffset = Math.max((this.parentViewport.height - this.visibleLegendHeight) / 2);
                        group.attr('transform', visuals.SVGUtil.translate(0, centerOffset));
                    }
                }
                else {
                    group.attr('transform', null);
                }
                var legendTitle = group
                    .selectAll(SVGLegend.LegendTitle.selector)
                    .data(titleData);
                legendTitle.enter()
                    .append('text')
                    .classed(SVGLegend.LegendTitle.class, true);
                legendTitle
                    .style({
                    'fill': data.labelColor,
                    'font-size': PixelConverter.fromPoint(data.fontSize),
                    'font-family': SVGLegend.DefaultTitleFontFamily
                })
                    .text(function (d) { return d.text; })
                    .attr({
                    'x': function (d) { return d.x; },
                    'y': function (d) { return d.y; }
                })
                    .append('title').text(data.title);
                legendTitle.exit().remove();
                var virtualizedDataPoints = data.dataPoints.slice(this.legendDataStartIndex, this.legendDataStartIndex + layout.numberOfItems);
                var iconRadius = powerbi.TextMeasurementService.estimateSvgTextHeight(SVGLegend.getTextProperties(false, '', this.data.fontSize)) / SVGLegend.LegendIconRadiusFactor;
                iconRadius = (this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin) && iconRadius > SVGLegend.LegendIconRadius
                    ? iconRadius :
                    SVGLegend.LegendIconRadius;
                var legendItems = group
                    .selectAll(SVGLegend.LegendItem.selector)
                    .data(virtualizedDataPoints, function (d) { return d.identity.getKey(); });
                var itemsEnter = legendItems.enter()
                    .append('g')
                    .classed(SVGLegend.LegendItem.class, true);
                itemsEnter
                    .append('circle')
                    .classed(SVGLegend.LegendIcon.class, true);
                itemsEnter
                    .append('text')
                    .classed(SVGLegend.LegendText.class, true);
                itemsEnter
                    .append('title')
                    .text(function (d) { return d.tooltip; });
                itemsEnter
                    .style({
                    'font-family': SVGLegend.DefaultFontFamily
                });
                legendItems
                    .select(SVGLegend.LegendIcon.selector)
                    .attr({
                    'cx': function (d, i) { return d.glyphPosition.x; },
                    'cy': function (d) { return d.glyphPosition.y; },
                    'r': iconRadius,
                })
                    .style({
                    'fill': function (d) {
                        if (hasSelection && !d.selected)
                            return visuals.LegendBehavior.dimmedLegendColor;
                        else
                            return d.color;
                    }
                });
                legendItems
                    .select('title')
                    .text(function (d) { return d.tooltip; });
                legendItems
                    .select(SVGLegend.LegendText.selector)
                    .attr({
                    'x': function (d) { return d.textPosition.x; },
                    'y': function (d) { return d.textPosition.y; },
                })
                    .text(function (d) { return d.label; })
                    .style({
                    'fill': data.labelColor,
                    'font-size': PixelConverter.fromPoint(data.fontSize)
                });
                if (this.interactivityService) {
                    var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector);
                    var behaviorOptions = {
                        legendItems: legendItems,
                        legendIcons: iconsSelection,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.bind(data.dataPoints, new visuals.LegendBehavior(), behaviorOptions, { isLegend: true });
                }
                legendItems.exit().remove();
                this.drawNavigationArrows(layout.navigationArrows);
                this.updateLayout();
            };
            SVGLegend.prototype.normalizePosition = function (points) {
                if (this.legendDataStartIndex >= points.length) {
                    this.legendDataStartIndex = points.length - 1;
                }
                if (this.legendDataStartIndex < 0) {
                    this.legendDataStartIndex = 0;
                }
            };
            SVGLegend.prototype.calculateTitleLayout = function (title) {
                var width = 0;
                var hasTitle = !_.isEmpty(title);
                if (hasTitle) {
                    var isHorizontal = this.isTopOrBottom(this.orientation);
                    var maxMeasureLength = void 0;
                    if (isHorizontal) {
                        var fontSizeMargin = this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding;
                        var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius;
                        var fixedHorizontalTextShift = SVGLegend.LegendIconRadius + fontSizeMargin + fixedHorizontalIconShift;
                        maxMeasureLength = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                    }
                    else {
                        maxMeasureLength = this.legendFontSizeMarginValue < SVGLegend.DefaultTextMargin ? SVGLegend.MaxTitleLength :
                            SVGLegend.MaxTitleLength + (SVGLegend.DefaultMaxLegendFactor * this.legendFontSizeMarginDifference);
                    }
                    var textProperties = SVGLegend.getTextProperties(true, title, this.data.fontSize);
                    var text = title;
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (width > maxMeasureLength) {
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxMeasureLength);
                        width = maxMeasureLength;
                    }
                    ;
                    if (isHorizontal)
                        width += SVGLegend.TitlePadding;
                    else
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, this.viewport.width);
                    return {
                        x: 0,
                        y: 0,
                        text: text,
                        width: width,
                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
                    };
                }
                return null;
            };
            /** Performs layout offline for optimal perfomance */
            SVGLegend.prototype.calculateLayout = function (data, autoWidth) {
                var dataPoints = data.dataPoints;
                if (data.dataPoints.length === 0) {
                    return {
                        startIndex: null,
                        numberOfItems: 0,
                        title: null,
                        navigationArrows: []
                    };
                }
                this.legendFontSizeMarginValue = PixelConverter.fromPointToPixel(this.data && this.data.fontSize !== undefined ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt);
                this.legendFontSizeMarginDifference = (this.legendFontSizeMarginValue - SVGLegend.DefaultTextMargin);
                this.normalizePosition(dataPoints);
                if (this.legendDataStartIndex < dataPoints.length) {
                    dataPoints = dataPoints.slice(this.legendDataStartIndex);
                }
                var title = this.calculateTitleLayout(data.title);
                var navArrows;
                var numberOfItems;
                if (this.isTopOrBottom(this.orientation)) {
                    navArrows = this.isScrollable ? this.calculateHorizontalNavigationArrowsLayout(title) : [];
                    numberOfItems = this.calculateHorizontalLayout(dataPoints, title, navArrows);
                }
                else {
                    navArrows = this.isScrollable ? this.calculateVerticalNavigationArrowsLayout(title) : [];
                    numberOfItems = this.calculateVerticalLayout(dataPoints, title, navArrows, autoWidth);
                }
                return {
                    numberOfItems: numberOfItems,
                    title: title,
                    navigationArrows: navArrows
                };
            };
            SVGLegend.prototype.updateNavigationArrowLayout = function (navigationArrows, remainingDataLength, visibleDataLength) {
                if (this.legendDataStartIndex === 0) {
                    navigationArrows.shift();
                }
                var lastWindow = this.arrowPosWindow;
                this.arrowPosWindow = visibleDataLength;
                if (navigationArrows && navigationArrows.length > 0 && this.arrowPosWindow === remainingDataLength) {
                    this.arrowPosWindow = lastWindow;
                    navigationArrows.length = navigationArrows.length - 1;
                }
            };
            SVGLegend.prototype.calculateHorizontalNavigationArrowsLayout = function (title) {
                var height = SVGLegend.LegendArrowHeight;
                var width = SVGLegend.LegendArrowWidth;
                var translateY = (this.viewport.height / 2) - (height / 2);
                var data = [];
                var rightShift = title ? title.x + title.width : 0;
                var arrowLeft = visuals.SVGUtil.createArrow(width, height, 180 /*angle*/);
                var arrowRight = visuals.SVGUtil.createArrow(width, height, 0 /*angle*/);
                data.push({
                    x: rightShift,
                    y: translateY,
                    path: arrowLeft.path,
                    rotateTransform: arrowLeft.transform,
                    type: 1 /* Decrease */
                });
                data.push({
                    x: this.parentViewport.width - width,
                    y: translateY,
                    path: arrowRight.path,
                    rotateTransform: arrowRight.transform,
                    type: 0 /* Increase */
                });
                return data;
            };
            SVGLegend.prototype.calculateVerticalNavigationArrowsLayout = function (title) {
                var height = SVGLegend.LegendArrowHeight;
                var width = SVGLegend.LegendArrowWidth;
                var verticalCenter = this.viewport.height / 2;
                var data = [];
                var rightShift = verticalCenter + height / 2;
                var arrowTop = visuals.SVGUtil.createArrow(width, height, 270 /*angle*/);
                var arrowBottom = visuals.SVGUtil.createArrow(width, height, 90 /*angle*/);
                var titleHeight = title ? title.height : 0;
                data.push({
                    x: rightShift,
                    y: width + titleHeight,
                    path: arrowTop.path,
                    rotateTransform: arrowTop.transform,
                    type: 1 /* Decrease */
                });
                data.push({
                    x: rightShift,
                    y: this.parentViewport.height - height,
                    path: arrowBottom.path,
                    rotateTransform: arrowBottom.transform,
                    type: 0 /* Increase */
                });
                return data;
            };
            SVGLegend.prototype.calculateHorizontalLayout = function (dataPoints, title, navigationArrows) {
                debug.assertValue(navigationArrows, 'navigationArrows');
                // calculate the text shift
                var HorizontalTextShift = 4 + SVGLegend.LegendIconRadius;
                // check if we need more space for the margin, or use the default text padding
                var fontSizeBiggerThanDefault = this.legendFontSizeMarginDifference > 0;
                var fontSizeMargin = fontSizeBiggerThanDefault ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding;
                var fixedTextShift = (fontSizeMargin / (SVGLegend.LegendIconRadiusFactor / 2)) + HorizontalTextShift;
                var totalSpaceOccupiedThusFar = 0;
                // calculate the size of the space for both sides of the radius
                var iconTotalItemPadding = SVGLegend.LegendIconRadius * 2 + fontSizeMargin * 1.5;
                var numberOfItems = dataPoints.length;
                // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text 
                var defaultTextProperties = SVGLegend.getTextProperties(false, '', this.data.fontSize);
                var verticalCenter = this.viewport.height / 2;
                var textYCoordinate = verticalCenter + powerbi.TextMeasurementService.estimateSvgTextHeight(defaultTextProperties) / 2
                    - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(defaultTextProperties);
                if (title) {
                    totalSpaceOccupiedThusFar += title.width;
                    // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text 
                    title.y = verticalCenter + title.height / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(SVGLegend.getTextProperties(true, title.text, this.data.fontSize));
                }
                // if an arrow should be added, we add space for it
                if (this.legendDataStartIndex > 0) {
                    totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset;
                }
                // This bit expands the max lengh if there are only a few items
                // so longer labels can potentially get more space, and not be
                // ellipsed. 
                var dataPointsLength = dataPoints.length;
                var parentWidth = this.parentViewport.width;
                var maxTextLength = dataPointsLength > 0
                    ? (((parentWidth - totalSpaceOccupiedThusFar) - (iconTotalItemPadding * dataPointsLength)) / dataPointsLength) | 0
                    : 0;
                maxTextLength = maxTextLength > SVGLegend.MaxTextLength ? maxTextLength : SVGLegend.MaxTextLength;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dp = dataPoints[i];
                    var textProperties = SVGLegend.getTextProperties(false, dp.label, this.data.fontSize);
                    dp.glyphPosition = {
                        // the space taken so far + the radius + the margin / radiusFactor to prevent huge spaces
                        x: totalSpaceOccupiedThusFar + SVGLegend.LegendIconRadius + (this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor),
                        // The middle of the container but a bit lower due to text not being in the middle (qP for example making middle between q and P)
                        y: (this.viewport.height * SVGLegend.LegendIconYRatio),
                    };
                    dp.textPosition = {
                        x: totalSpaceOccupiedThusFar + fixedTextShift,
                        y: textYCoordinate,
                    };
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    var spaceTakenByItem = 0;
                    if (width < maxTextLength) {
                        spaceTakenByItem = iconTotalItemPadding + width;
                    }
                    else {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextLength);
                        dp.label = text;
                        spaceTakenByItem = iconTotalItemPadding + maxTextLength;
                    }
                    totalSpaceOccupiedThusFar += spaceTakenByItem;
                    if (totalSpaceOccupiedThusFar > parentWidth) {
                        numberOfItems = i;
                        break;
                    }
                }
                this.visibleLegendWidth = totalSpaceOccupiedThusFar;
                this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems);
                return numberOfItems;
            };
            SVGLegend.prototype.calculateVerticalLayout = function (dataPoints, title, navigationArrows, autoWidth) {
                var _this = this;
                // check if we need more space for the margin, or use the default text padding
                var fontSizeBiggerThenDefault = this.legendFontSizeMarginDifference > 0;
                var fontFactor = fontSizeBiggerThenDefault ? this.legendFontSizeMarginDifference : 0;
                // calculate the size needed after font size change
                var verticalLegendHeight = 20 + fontFactor;
                var spaceNeededByTitle = 15 + fontFactor;
                var extraShiftForTextAlignmentToIcon = 4 + fontFactor;
                var totalSpaceOccupiedThusFar = verticalLegendHeight;
                // the default space for text and icon radius + the margin after the font size change
                var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius + (this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor);
                var fixedHorizontalTextShift = fixedHorizontalIconShift * 2;
                // check how much space is needed
                var maxHorizontalSpaceAvaliable = autoWidth
                    ? this.parentViewport.width * SVGLegend.LegendMaxWidthFactor
                        - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth
                    : this.lastCalculatedWidth
                        - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                var numberOfItems = dataPoints.length;
                var maxHorizontalSpaceUsed = 0;
                var parentHeight = this.parentViewport.height;
                if (title) {
                    totalSpaceOccupiedThusFar += spaceNeededByTitle;
                    title.x = SVGLegend.TextAndIconPadding;
                    title.y = spaceNeededByTitle;
                    maxHorizontalSpaceUsed = title.width || 0;
                }
                // if an arrow should be added, we add space for it
                if (this.legendDataStartIndex > 0)
                    totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset;
                var dataPointsLength = dataPoints.length;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dp = dataPoints[i];
                    var textProperties = SVGLegend.getTextProperties(false, dp.label, this.data.fontSize);
                    dp.glyphPosition = {
                        x: fixedHorizontalIconShift,
                        y: (totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties)
                    };
                    dp.textPosition = {
                        x: fixedHorizontalTextShift,
                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
                    };
                    // TODO: [PERF] Get rid of this extra measurement, and modify
                    // getTailoredTextToReturnWidth + Text
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (width > maxHorizontalSpaceUsed) {
                        maxHorizontalSpaceUsed = width;
                    }
                    if (width > maxHorizontalSpaceAvaliable) {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxHorizontalSpaceAvaliable);
                        dp.label = text;
                    }
                    totalSpaceOccupiedThusFar += verticalLegendHeight;
                    if (totalSpaceOccupiedThusFar > parentHeight) {
                        numberOfItems = i;
                        break;
                    }
                }
                if (autoWidth) {
                    if (maxHorizontalSpaceUsed < maxHorizontalSpaceAvaliable) {
                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + SVGLegend.LegendEdgeMariginWidth);
                    }
                    else {
                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(this.parentViewport.width * SVGLegend.LegendMaxWidthFactor);
                    }
                }
                else {
                    this.viewport.width = this.lastCalculatedWidth;
                }
                this.visibleLegendHeight = totalSpaceOccupiedThusFar;
                navigationArrows.forEach(function (d) { return d.x = _this.lastCalculatedWidth / 2; });
                this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems);
                return numberOfItems;
            };
            SVGLegend.prototype.drawNavigationArrows = function (layout) {
                var _this = this;
                var arrows = this.group.selectAll(SVGLegend.NavigationArrow.selector)
                    .data(layout);
                arrows
                    .enter()
                    .append('g')
                    .on('click', function (d) {
                    var pos = _this.legendDataStartIndex;
                    _this.legendDataStartIndex = d.type === 0 /* Increase */
                        ? pos + _this.arrowPosWindow : pos - _this.arrowPosWindow;
                    _this.drawLegendInternal(_this.data, _this.parentViewport, false);
                })
                    .classed(SVGLegend.NavigationArrow.class, true)
                    .append('path');
                arrows
                    .attr('transform', function (d) { return visuals.SVGUtil.translate(d.x, d.y); })
                    .select('path')
                    .attr({
                    'd': function (d) { return d.path; },
                    'transform': function (d) { return d.rotateTransform; }
                });
                arrows.exit().remove();
            };
            SVGLegend.prototype.isTopOrBottom = function (orientation) {
                switch (orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.Bottom:
                    case LegendPosition.BottomCenter:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            };
            SVGLegend.prototype.isCentered = function (orientation) {
                switch (orientation) {
                    case LegendPosition.BottomCenter:
                    case LegendPosition.LeftCenter:
                    case LegendPosition.RightCenter:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            };
            SVGLegend.prototype.reset = function () {
                // Intentionally left blank. 
            };
            SVGLegend.getTextProperties = function (isTitle, text, fontSize) {
                return {
                    text: text,
                    fontFamily: isTitle ? SVGLegend.DefaultTitleFontFamily : SVGLegend.DefaultFontFamily,
                    fontSize: PixelConverter.fromPoint(fontSize || SVGLegend.DefaultFontSizeInPt)
                };
            };
            SVGLegend.prototype.setTooltipToLegendItems = function (data) {
                //we save the values to tooltip before cut
                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dataPoint = _a[_i];
                    dataPoint.tooltip = dataPoint.label;
                }
            };
            SVGLegend.DefaultFontSizeInPt = 8;
            SVGLegend.LegendIconRadius = 5;
            SVGLegend.LegendIconRadiusFactor = 5;
            SVGLegend.MaxTextLength = 60;
            SVGLegend.MaxTitleLength = 80;
            SVGLegend.TextAndIconPadding = 5;
            SVGLegend.TitlePadding = 15;
            SVGLegend.LegendEdgeMariginWidth = 10;
            SVGLegend.LegendMaxWidthFactor = 0.3;
            SVGLegend.TopLegendHeight = 24;
            SVGLegend.DefaultTextMargin = PixelConverter.fromPointToPixel(SVGLegend.DefaultFontSizeInPt);
            SVGLegend.DefaultMaxLegendFactor = SVGLegend.MaxTitleLength / SVGLegend.DefaultTextMargin;
            SVGLegend.LegendIconYRatio = 0.52;
            // Navigation Arrow constants
            SVGLegend.LegendArrowOffset = 10;
            SVGLegend.LegendArrowHeight = 15;
            SVGLegend.LegendArrowWidth = 7.5;
            SVGLegend.DefaultFontFamily = 'wf_segoe-ui_normal';
            SVGLegend.DefaultTitleFontFamily = 'wf_segoe-ui_Semibold';
            SVGLegend.LegendItem = createClassAndSelector('legendItem');
            SVGLegend.LegendText = createClassAndSelector('legendText');
            SVGLegend.LegendIcon = createClassAndSelector('legendIcon');
            SVGLegend.LegendTitle = createClassAndSelector('legendTitle');
            SVGLegend.NavigationArrow = createClassAndSelector('navArrow');
            return SVGLegend;
        }());
        visuals.SVGLegend = SVGLegend;
        var CartesianChartInteractiveLegend = (function () {
            function CartesianChartInteractiveLegend(element) {
                this.legendContainerParent = d3.select(element.get(0));
            }
            CartesianChartInteractiveLegend.prototype.getMargins = function () {
                return {
                    height: CartesianChartInteractiveLegend.LegendHeight,
                    width: 0
                };
            };
            CartesianChartInteractiveLegend.prototype.drawLegend = function (legendData) {
                debug.assertValue(legendData, 'legendData');
                var data = legendData.dataPoints;
                debug.assertValue(data, 'dataPoints');
                if (data.length < 1)
                    return;
                var legendContainerDiv = this.legendContainerParent.select(CartesianChartInteractiveLegend.LegendContainerSelector);
                if (legendContainerDiv.empty()) {
                    if (!data.length)
                        return;
                    var divToPrepend = $('<div></div>')
                        .height(this.getMargins().height)
                        .addClass(CartesianChartInteractiveLegend.LegendContainerClass);
                    // Prepending, as legend should always be on topmost visual.
                    $(this.legendContainerParent[0]).prepend(divToPrepend);
                    legendContainerDiv = d3.select(divToPrepend.get(0));
                }
                this.legendContainerDiv = legendContainerDiv;
                // Construct the legend title and items.
                this.drawTitle(data);
                this.drawLegendItems(data);
            };
            CartesianChartInteractiveLegend.prototype.reset = function () {
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.remove();
                    this.legendContainerDiv = null;
                }
            };
            CartesianChartInteractiveLegend.prototype.isVisible = function () {
                return true;
            };
            CartesianChartInteractiveLegend.prototype.changeOrientation = function (orientation) {
                // Not supported
            };
            CartesianChartInteractiveLegend.prototype.getOrientation = function () {
                return LegendPosition.Top;
            };
            /**
             * Draw the legend title
             */
            CartesianChartInteractiveLegend.prototype.drawTitle = function (data) {
                debug.assert(data && data.length > 0, 'data is null or empty');
                var titleDiv = this.legendContainerDiv.selectAll('div.' + CartesianChartInteractiveLegend.LegendTitleClass);
                var item = titleDiv.data([data[0]]);
                // Enter
                var itemEnter = item.enter();
                var titleDivEnter = itemEnter.append('div').attr('class', CartesianChartInteractiveLegend.LegendTitleClass);
                titleDivEnter
                    .filter(function (d) { return d.iconOnlyOnLabel; })
                    .append('span')
                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
                    .html(CartesianChartInteractiveLegend.legendPlaceSelector);
                titleDivEnter.append('span');
                // Update
                item.filter(function (d) { return d.iconOnlyOnLabel; })
                    .select('span.' + CartesianChartInteractiveLegend.legendIconClass)
                    .style(CartesianChartInteractiveLegend.legendColorCss, function (d) { return d.color; });
                item.select('span:last-child').text(function (d) { return d.category; });
            };
            /**
             * Draw the legend items
             */
            CartesianChartInteractiveLegend.prototype.drawLegendItems = function (data) {
                // Add Mesaures - the items of the category in the legend
                this.ensureLegendTableCreated();
                var dataPointsMatrix = CartesianChartInteractiveLegend.splitArrayToOddEven(data);
                var legendItemsContainer = this.legendContainerDiv.select('tbody').selectAll('tr').data(dataPointsMatrix);
                // trs is table rows. 
                // there are two table rows.
                // the order of insertion to the legend table is:
                // Even data points got inserted into the 1st line
                // Odd data points got inserted into the 2nd line
                // ----------------------------
                // | value0 | value 2 | value 4
                // ----------------------------
                // | value1 | value 3 | 
                // ----------------------------
                // 
                // Enter
                var legendItemsEnter = legendItemsContainer.enter();
                var rowEnter = legendItemsEnter.append('tr');
                var cellEnter = rowEnter.selectAll('td')
                    .data(function (d) { return d; }, function (d) { return d.label; })
                    .enter()
                    .append('td').attr('class', CartesianChartInteractiveLegend.LegendItem);
                var cellSpanEnter = cellEnter.append('span');
                cellSpanEnter.filter(function (d) { return !d.iconOnlyOnLabel; })
                    .append('span')
                    .html(CartesianChartInteractiveLegend.legendPlaceSelector)
                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
                    .attr('white-space', 'nowrap');
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemNameClass);
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemMeasureClass);
                // Update
                var legendCells = legendItemsContainer.selectAll('td').data(function (d) { return d; }, function (d) { return d.label; });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemNameClass).html(function (d) { return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label); });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemMeasureClass).html(function (d) { return '&nbsp;' + d.measure; });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendIconClass).style('color', function (d) { return d.color; });
                // Exit
                legendCells.exit().remove();
            };
            /**
             * Ensure legend table is created and set horizontal pan gestures on it
             */
            CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function () {
                if (this.legendContainerDiv.select('div table').empty()) {
                    var legendTable = this.legendContainerDiv.append('div').append('table');
                    legendTable.style('table-layout', 'fixed').append('tbody');
                    // Setup Pan Gestures of the legend
                    this.setPanGestureOnLegend(legendTable);
                }
            };
            /**
             * Set Horizontal Pan gesture for the legend
             */
            CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function (legendTable) {
                var viewportWidth = $(this.legendContainerDiv.select('div:nth-child(2)')[0]).width();
                var xscale = d3.scale.linear().domain([0, viewportWidth]).range([0, viewportWidth]);
                var zoom = d3.behavior.zoom()
                    .scaleExtent([1, 1]) // disable scaling
                    .x(xscale)
                    .on("zoom", function () {
                    // horizontal pan is valid only in case the legend items width are bigger than the viewport width
                    if ($(legendTable[0]).width() > viewportWidth) {
                        var t = zoom.translate();
                        var tx_1 = t[0];
                        var ty = t[1];
                        tx_1 = Math.min(tx_1, 0);
                        tx_1 = Math.max(tx_1, viewportWidth - $(legendTable[0]).width());
                        zoom.translate([tx_1, ty]);
                        legendTable.style("-ms-transform", function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        });
                        legendTable.style("-webkit-transform", function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        });
                        legendTable.style("transform", function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        });
                    }
                });
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.call(zoom);
                }
                else {
                    legendTable.call(zoom);
                }
            };
            /**
             * Split legend data points array into odd and even arrays
             * Even array will be the legend first line and Odd array will be the 2nd legend line
             */
            CartesianChartInteractiveLegend.splitArrayToOddEven = function (data) {
                var oddData = [];
                var evenData = [];
                for (var i = 0; i < data.length; ++i) {
                    if (i % 2 === 0) {
                        evenData.push(data[i]);
                    }
                    else {
                        oddData.push(data[i]);
                    }
                }
                return [evenData, oddData];
            };
            CartesianChartInteractiveLegend.LegendHeight = 70;
            CartesianChartInteractiveLegend.LegendContainerClass = 'interactive-legend';
            CartesianChartInteractiveLegend.LegendContainerSelector = '.interactive-legend';
            CartesianChartInteractiveLegend.LegendTitleClass = 'title';
            CartesianChartInteractiveLegend.LegendItem = 'item';
            CartesianChartInteractiveLegend.legendPlaceSelector = '\u25A0';
            CartesianChartInteractiveLegend.legendIconClass = 'icon';
            CartesianChartInteractiveLegend.legendColorCss = 'color';
            CartesianChartInteractiveLegend.legendItemNameClass = 'itemName';
            CartesianChartInteractiveLegend.legendItemMeasureClass = 'itemMeasure';
            return CartesianChartInteractiveLegend;
        }());
        var LegendData;
        (function (LegendData) {
            LegendData.DefaultLegendLabelFillColor = '#666666';
            function update(legendData, legendObject) {
                debug.assertValue(legendData, 'legendData');
                debug.assertValue(legendObject, 'legendObject');
                if (legendObject[visuals.legendProps.show] == null) {
                    legendObject[visuals.legendProps.show] = true;
                }
                if (legendObject[visuals.legendProps.show] === false)
                    legendData.dataPoints = [];
                if (legendObject[visuals.legendProps.show] === true && legendObject[visuals.legendProps.position] == null)
                    legendObject[visuals.legendProps.position] = visuals.legendPosition.top;
                if (legendObject[visuals.legendProps.fontSize] !== undefined)
                    legendData.fontSize = legendObject[visuals.legendProps.fontSize];
                if (legendObject[visuals.legendProps.labelColor] !== undefined) {
                    var fillColor = legendObject[visuals.legendProps.labelColor];
                    if (fillColor != null) {
                        legendData.labelColor = fillColor.solid.color;
                    }
                }
                if (legendObject[visuals.legendProps.showTitle] === false)
                    legendData.title = "";
                else if (legendObject[visuals.legendProps.titleText] !== undefined) {
                    legendData.title = legendObject[visuals.legendProps.titleText];
                }
            }
            LegendData.update = update;
        })(LegendData = visuals.LegendData || (visuals.LegendData = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisScale;
        (function (axisScale) {
            axisScale.linear = 'linear';
            axisScale.log = 'log';
            axisScale.type = powerbi.createEnumType([
                { value: axisScale.linear, displayName: function (resources) { return resources.get('Visual_Axis_Linear'); } },
                { value: axisScale.log, displayName: function (resources) { return resources.get('Visual_Axis_Log'); } }
            ]);
        })(axisScale = visuals.axisScale || (visuals.axisScale = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisStyle;
        (function (axisStyle) {
            axisStyle.showBoth = 'showBoth';
            axisStyle.showTitleOnly = 'showTitleOnly';
            axisStyle.showUnitOnly = 'showUnitOnly';
            axisStyle.type = powerbi.createEnumType([
                { value: axisStyle.showTitleOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowTitleOnly'); } },
                { value: axisStyle.showUnitOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowUnitOnly'); } },
                { value: axisStyle.showBoth, displayName: function (resources) { return resources.get('Visual_Axis_ShowBoth'); } }
            ]);
        })(axisStyle = visuals.axisStyle || (visuals.axisStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisType;
        (function (axisType) {
            axisType.scalar = 'Scalar';
            axisType.categorical = 'Categorical';
            axisType.both = 'Both';
            axisType.type = powerbi.createEnumType([
                { value: axisType.scalar, displayName: function (resources) { return resources.get('Visual_Axis_Scalar'); } },
                { value: axisType.categorical, displayName: function (resources) { return resources.get('Visual_Axis_Categorical'); } },
            ]);
        })(axisType = visuals.axisType || (visuals.axisType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var basicShapeType;
        (function (basicShapeType) {
            basicShapeType.rectangle = 'rectangle';
            basicShapeType.oval = 'oval';
            basicShapeType.line = 'line';
            basicShapeType.arrow = 'arrow';
            basicShapeType.triangle = 'triangle';
            basicShapeType.type = powerbi.createEnumType([
                { value: basicShapeType.rectangle, displayName: 'rectangle' },
                { value: basicShapeType.oval, displayName: 'oval' },
                { value: basicShapeType.line, displayName: 'line' },
                { value: basicShapeType.arrow, displayName: 'arrow' },
                { value: basicShapeType.triangle, displayName: 'triangle' }
            ]);
        })(basicShapeType = visuals.basicShapeType || (visuals.basicShapeType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var imageScalingType;
        (function (imageScalingType) {
            imageScalingType.normal = 'Normal';
            imageScalingType.fit = 'Fit';
            imageScalingType.fill = 'Fill';
            imageScalingType.type = powerbi.createEnumType([
                { value: imageScalingType.normal, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Normal'); } },
                { value: imageScalingType.fit, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fit'); } },
                { value: imageScalingType.fill, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fill'); } },
            ]);
        })(imageScalingType = visuals.imageScalingType || (visuals.imageScalingType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelPosition;
        (function (labelPosition) {
            labelPosition.insideEnd = 'InsideEnd';
            labelPosition.insideCenter = 'InsideCenter';
            labelPosition.outsideEnd = 'OutsideEnd';
            labelPosition.insideBase = 'InsideBase';
            labelPosition.type = powerbi.createEnumType([
                { value: labelPosition.insideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideEnd'); } },
                { value: labelPosition.outsideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_OutsideEnd'); } },
                { value: labelPosition.insideCenter, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideCenter'); } },
                { value: labelPosition.insideBase, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideBase'); } },
            ]);
        })(labelPosition = visuals.labelPosition || (visuals.labelPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelStyle;
        (function (labelStyle) {
            labelStyle.category = 'Category';
            labelStyle.data = 'Data';
            labelStyle.both = 'Both';
            labelStyle.type = powerbi.createEnumType([
                { value: labelStyle.category, displayName: function (resources) { return resources.get('Visual_LabelStyle_Category'); } },
                { value: labelStyle.data, displayName: function (resources) { return resources.get('Visual_LabelStyle_DataValue'); } },
                { value: labelStyle.both, displayName: function (resources) { return resources.get('Visual_LabelStyle_Both'); } },
            ]);
        })(labelStyle = visuals.labelStyle || (visuals.labelStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var legendPosition;
        (function (legendPosition) {
            legendPosition.top = 'Top';
            legendPosition.bottom = 'Bottom';
            legendPosition.left = 'Left';
            legendPosition.right = 'Right';
            legendPosition.topCenter = 'TopCenter';
            legendPosition.bottomCenter = 'BottomCenter';
            legendPosition.leftCenter = 'LeftCenter';
            legendPosition.rightCenter = 'RightCenter';
            legendPosition.type = powerbi.createEnumType([
                { value: legendPosition.top, displayName: function (resources) { return resources.get('Visual_LegendPosition_Top'); } },
                { value: legendPosition.bottom, displayName: function (resources) { return resources.get('Visual_LegendPosition_Bottom'); } },
                { value: legendPosition.left, displayName: function (resources) { return resources.get('Visual_LegendPosition_Left'); } },
                { value: legendPosition.right, displayName: function (resources) { return resources.get('Visual_LegendPosition_Right'); } },
                { value: legendPosition.topCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_TopCenter'); } },
                { value: legendPosition.bottomCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_BottomCenter'); } },
                { value: legendPosition.leftCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_LeftCenter'); } },
                { value: legendPosition.rightCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_RightCenter'); } },
            ]);
        })(legendPosition = visuals.legendPosition || (visuals.legendPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var kpiDirection;
        (function (kpiDirection) {
            kpiDirection.positive = 'Positive';
            kpiDirection.negative = 'Negative';
            kpiDirection.type = powerbi.createEnumType([
                { value: kpiDirection.positive, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Positive'); } },
                { value: kpiDirection.negative, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Negative'); } }
            ]);
        })(kpiDirection = visuals.kpiDirection || (visuals.kpiDirection = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var lineStyle;
        (function (lineStyle) {
            lineStyle.dashed = 'dashed';
            lineStyle.solid = 'solid';
            lineStyle.dotted = 'dotted';
            lineStyle.type = powerbi.createEnumType([
                { value: lineStyle.dashed, displayName: function (resources) { return resources.get('Visual_LineStyle_Dashed'); } },
                { value: lineStyle.solid, displayName: function (resources) { return resources.get('Visual_LineStyle_Solid'); } },
                { value: lineStyle.dotted, displayName: function (resources) { return resources.get('Visual_LineStyle_Dotted'); } }
            ]);
        })(lineStyle = visuals.lineStyle || (visuals.lineStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var outline;
        (function (outline_1) {
            outline_1.none = 'None';
            outline_1.bottomOnly = 'BottomOnly';
            outline_1.topOnly = 'TopOnly';
            outline_1.leftOnly = 'LeftOnly';
            outline_1.rightOnly = 'RightOnly';
            outline_1.topBottom = 'TopBottom';
            outline_1.leftRight = 'LeftRight';
            outline_1.frame = 'Frame';
            function showTop(outline) {
                return [outline_1.topOnly, outline_1.topBottom, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showTop = showTop;
            function showRight(outline) {
                return [outline_1.rightOnly, outline_1.leftRight, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showRight = showRight;
            function showBottom(outline) {
                return [outline_1.bottomOnly, outline_1.topBottom, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showBottom = showBottom;
            function showLeft(outline) {
                return [outline_1.leftOnly, outline_1.leftRight, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showLeft = showLeft;
            outline_1.type = powerbi.createEnumType([
                { value: outline_1.none, displayName: function (resources) { return resources.get('Visual_Outline_none'); } },
                { value: outline_1.bottomOnly, displayName: function (resources) { return resources.get('Visual_Outline_bottom_only'); } },
                { value: outline_1.topOnly, displayName: function (resources) { return resources.get('Visual_Outline_top_only'); } },
                { value: outline_1.leftOnly, displayName: function (resources) { return resources.get('Visual_Outline_LeftOnly'); } },
                { value: outline_1.rightOnly, displayName: function (resources) { return resources.get('Visual_Outline_RightOnly'); } },
                { value: outline_1.topBottom, displayName: function (resources) { return resources.get('Visual_Outline_top_Bottom'); } },
                { value: outline_1.leftRight, displayName: function (resources) { return resources.get('Visual_Outline_leftRight'); } },
                { value: outline_1.frame, displayName: function (resources) { return resources.get('Visual_Outline_frame'); } }
            ]);
        })(outline = visuals.outline || (visuals.outline = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var referenceLinePosition;
        (function (referenceLinePosition) {
            referenceLinePosition.back = 'back';
            referenceLinePosition.front = 'front';
            referenceLinePosition.type = powerbi.createEnumType([
                { value: referenceLinePosition.back, displayName: function (resources) { return resources.get('Visual_Reference_Line_Behind'); } },
                { value: referenceLinePosition.front, displayName: function (resources) { return resources.get('Visual_Reference_Line_InFront'); } },
            ]);
        })(referenceLinePosition = visuals.referenceLinePosition || (visuals.referenceLinePosition = {}));
        var referenceLineDataLabelHorizontalPosition;
        (function (referenceLineDataLabelHorizontalPosition) {
            referenceLineDataLabelHorizontalPosition.left = 'left';
            referenceLineDataLabelHorizontalPosition.right = 'right';
            referenceLineDataLabelHorizontalPosition.type = powerbi.createEnumType([
                { value: referenceLineDataLabelHorizontalPosition.left, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Left'); } },
                { value: referenceLineDataLabelHorizontalPosition.right, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Right'); } },
            ]);
        })(referenceLineDataLabelHorizontalPosition = visuals.referenceLineDataLabelHorizontalPosition || (visuals.referenceLineDataLabelHorizontalPosition = {}));
        var referenceLineDataLabelVerticalPosition;
        (function (referenceLineDataLabelVerticalPosition) {
            referenceLineDataLabelVerticalPosition.above = 'above';
            referenceLineDataLabelVerticalPosition.under = 'under';
            referenceLineDataLabelVerticalPosition.type = powerbi.createEnumType([
                { value: referenceLineDataLabelVerticalPosition.above, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Above'); } },
                { value: referenceLineDataLabelVerticalPosition.under, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Under'); } },
            ]);
        })(referenceLineDataLabelVerticalPosition = visuals.referenceLineDataLabelVerticalPosition || (visuals.referenceLineDataLabelVerticalPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var slicerOrientation;
        (function (slicerOrientation) {
            slicerOrientation.type = powerbi.createEnumType([
                { value: 0 /* Vertical */, displayName: function (resources) { return resources.get('Slicer_Orientation_Vertical'); } },
                { value: 1 /* Horizontal */, displayName: function (resources) { return resources.get('Slicer_Orientation_Horizontal'); } },
            ]);
        })(slicerOrientation = visuals.slicerOrientation || (visuals.slicerOrientation = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var yAxisPosition;
        (function (yAxisPosition) {
            yAxisPosition.left = 'Left';
            yAxisPosition.right = 'Right';
            yAxisPosition.type = powerbi.createEnumType([
                { value: yAxisPosition.left, displayName: function (resources) { return resources.get('Visual_yAxis_Left'); } },
                { value: yAxisPosition.right, displayName: function (resources) { return resources.get('Visual_yAxis_Right'); } },
            ]);
        })(yAxisPosition = visuals.yAxisPosition || (visuals.yAxisPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AnimatorCommon;
        (function (AnimatorCommon) {
            AnimatorCommon.MinervaAnimationDuration = 250;
            // The maximum number of data points we can performantly animate with SVG. If we have more, turn off animations.
            AnimatorCommon.MaxDataPointsToAnimate = 1000;
            function GetAnimationDuration(animator, suppressAnimations) {
                return (suppressAnimations || !animator) ? 0 : animator.getDuration();
            }
            AnimatorCommon.GetAnimationDuration = GetAnimationDuration;
        })(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
        /**
         * We just need to have a non-null animator to allow axis animations in cartesianChart.
         * Note: Use this temporarily for Line/Scatter until we add more animations (MinervaPlugins only).
         */
        var BaseAnimator = (function () {
            function BaseAnimator(options) {
                if (options && options.duration) {
                    this.animationDuration = options.duration;
                }
                this.animationDuration = this.animationDuration >= 0 ? this.animationDuration : AnimatorCommon.MinervaAnimationDuration;
            }
            BaseAnimator.prototype.getDuration = function () {
                return this.animationDuration;
            };
            BaseAnimator.prototype.animate = function (options) {
                return null;
            };
            return BaseAnimator;
        }());
        visuals.BaseAnimator = BaseAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebColumnChartAnimator = (function (_super) {
            __extends(WebColumnChartAnimator, _super);
            function WebColumnChartAnimator(options) {
                _super.call(this, options);
            }
            WebColumnChartAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                var dataPointCount = viewModel.categories.length * viewModel.series.length;
                if (dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate) {
                    // Too many data points to animate.
                    return result;
                }
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebColumnChartAnimator.prototype.animateNormalToHighlighted = function (options) {
                var data = options.viewModel;
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                var hasHighlights = data.hasHighlights;
                shapes
                    .enter()
                    .append('rect')
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); })
                    .attr(options.layout.shapeLayoutWithoutHighlights); // Start out at the non-highlight layout
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.shapeLayout);
                shapes
                    .exit()
                    .remove();
                return {
                    failed: false,
                    shapes: shapes,
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options.viewModel, options.series, options.layout, options.itemCS);
                return {
                    failed: false,
                    shapes: shapes,
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToNormal = function (options) {
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                shapes
                    .enter()
                    .append('rect')
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, d.selected, !d.selected); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.shapeLayout)
                    .transition()
                    .duration(0)
                    .delay(this.animationDuration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
                shapes
                    .exit()
                    .transition()
                    .duration(this.animationDuration)
                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayoutWithoutHighlights)
                    .remove();
                return {
                    failed: false,
                    shapes: shapes,
                };
            };
            WebColumnChartAnimator.prototype.animateDefaultShapes = function (data, series, layout, itemCS) {
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                shapes
                    .enter()
                    .append('rect')
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, data.hasHighlights); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayout);
                shapes
                    .exit()
                    .remove();
                return shapes;
            };
            return WebColumnChartAnimator;
        }(visuals.BaseAnimator));
        visuals.WebColumnChartAnimator = WebColumnChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebDonutChartAnimator = (function (_super) {
            __extends(WebDonutChartAnimator, _super);
            function WebDonutChartAnimator(options) {
                _super.call(this, options);
            }
            WebDonutChartAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebDonutChartAnimator.prototype.animateNormalToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice-highlight')
                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter()
                    .insert('path')
                    .classed('slice-highlight', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
                highlightShapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .attr(options.layout.shapeLayout) // Start at the non-highlight layout, then transition to the highlight layout.
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.highlightShapeLayout);
                highlightShapes.exit()
                    .remove();
                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = this.animateDefaultHighlightShapes(options);
                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToNormal = function (options) {
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                var duration = this.animationDuration;
                var shapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice')
                    .data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed('slice', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints);
                // For any slice that is selected we want to keep showing it as dimmed (partially highlighted). After the highlight animation
                // finishes we will set the opacity based on the selection state.
                shapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, d.data.selected, !d.data.selected); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(duration)
                    .attr(options.layout.shapeLayout)
                    .transition()
                    .duration(0)
                    .delay(duration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); });
                ;
                shapes.exit()
                    .remove();
                var highlightShapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice-highlight')
                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter()
                    .insert('path')
                    .classed('slice-highlight', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
                highlightShapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(false, true, false, true); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(duration)
                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout) // Transition to the non-highlight layout
                    .remove();
                highlightShapes.exit()
                    .remove();
                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateDefaultShapes = function (options) {
                var shapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice')
                    .data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed('slice', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints);
                shapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, options.viewModel.hasHighlights); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.shapeLayout);
                shapes.exit()
                    .remove();
                return shapes;
            };
            WebDonutChartAnimator.prototype.animateDefaultHighlightShapes = function (options) {
                var highlightShapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice-highlight')
                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter()
                    .insert('path')
                    .classed('slice-highlight', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
                highlightShapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.highlightShapeLayout);
                highlightShapes.exit()
                    .remove();
                return highlightShapes;
            };
            return WebDonutChartAnimator;
        }(visuals.BaseAnimator));
        visuals.WebDonutChartAnimator = WebDonutChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebFunnelAnimator = (function (_super) {
            __extends(WebFunnelAnimator, _super);
            function WebFunnelAnimator(options) {
                _super.call(this, options);
            }
            WebFunnelAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    dataLabels: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebFunnelAnimator.prototype.animateNormalToHighlighted = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasHighlights = true;
                var hasSelection = false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.slices, function (d) { return d.key; });
                shapes.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; })
                    .attr(layout.shapeLayoutWithoutHighlights); // Start by laying out all rectangles ignoring highlights
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayout); // Then transition to the layout that uses highlights
                shapes.exit().remove();
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                // Simply animate to the new shapes.
                var shapes = this.animateDefaultShapes(data, data.slices, options.shapeGraphicsContext, layout);
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToNormal = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.slices, function (d) { return d.key; });
                shapes.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !d.selected); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayoutWithoutHighlights) // Transition to layout without highlights
                    .transition()
                    .duration(0)
                    .delay(this.animationDuration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
                var exitShapes = shapes.exit();
                exitShapes
                    .transition()
                    .duration(this.animationDuration)
                    .attr(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights) // Transition to layout without highlights
                    .remove();
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateDefaultAxis = function (graphicsContext, axisOptions, isHidingPercentBars) {
                var xScaleForAxis = d3.scale.ordinal()
                    .domain(axisOptions.categoryLabels)
                    .rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : visuals.FunnelChart.PercentBarToBarRatio);
                var xAxis = d3.svg.axis()
                    .scale(xScaleForAxis)
                    .orient("right")
                    .tickPadding(visuals.FunnelChart.TickPadding)
                    .innerTickSize(visuals.FunnelChart.InnerTickSize);
                graphicsContext.classed('axis', true)
                    .transition()
                    .duration(this.animationDuration)
                    .attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top))
                    .call(xAxis);
            };
            WebFunnelAnimator.prototype.animateDefaultShapes = function (data, slices, graphicsContext, layout) {
                var hasHighlights = data.hasHighlights;
                var shapes = graphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(slices, function (d) { return d.key; });
                shapes.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); }; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebFunnelAnimator.prototype.animateDefaultDataLabels = function (options) {
                var dataLabels;
                if (options.viewModel.dataLabelsSettings.show && options.viewModel.canShowDataLabels) {
                    dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(options.viewModel.slices, options.labelGraphicsContext, options.labelLayout, true, this.animationDuration);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(options.labelGraphicsContext);
                }
                return dataLabels;
            };
            WebFunnelAnimator.prototype.animatePercentBars = function (options) {
                var data = options.viewModel;
                var isHidingPercentBars = options.isHidingPercentBars;
                if (isHidingPercentBars || !data.slices || (data.hasHighlights ? data.slices.length / 2 : data.slices.length) < 2) {
                    // TODO: call percentBarComponents with flag with empty data to clear drawing smoothly
                    this.animatePercentBarComponents([], options);
                    return;
                }
                var slices = [data.slices[data.hasHighlights ? 1 : 0], data.slices[data.slices.length - 1]];
                var baseline = visuals.FunnelChart.getFunnelSliceValue(slices[0]);
                if (baseline <= 0) {
                    // TODO: call percentBarComponents with flag with empty data to clear drawing smoothly
                    this.animatePercentBarComponents([], options);
                    return;
                }
                var percentData = slices.map(function (slice, i) { return {
                    value: visuals.FunnelChart.getFunnelSliceValue(slice),
                    percent: i === 0 ? 1 : visuals.FunnelChart.getFunnelSliceValue(slice) / baseline,
                    isTop: i === 0,
                }; });
                this.animatePercentBarComponents(percentData, options);
            };
            WebFunnelAnimator.prototype.animateToFunnelPercent = function (context, targetData, layout) {
                return context
                    .data(targetData)
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout);
            };
            WebFunnelAnimator.prototype.animatePercentBarComponents = function (data, options) {
                var graphicsContext = options.percentGraphicsContext;
                var layout = options.layout;
                var zeroData = [
                    { percent: 0, value: 0, isTop: true },
                    { percent: 0, value: 0, isTop: false },
                ];
                // Main line
                var mainLine = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                this.animateToFunnelPercent(mainLine.exit(), zeroData, layout.percentBarLayout.mainLine)
                    .remove();
                mainLine.enter()
                    .append('line')
                    .classed(visuals.FunnelChart.Selectors.percentBar.mainLine.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.mainLine);
                this.animateToFunnelPercent(mainLine, data, layout.percentBarLayout.mainLine);
                // Left tick
                var leftTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                this.animateToFunnelPercent(leftTick.exit(), zeroData, layout.percentBarLayout.leftTick)
                    .remove();
                leftTick.enter()
                    .append('line')
                    .classed(visuals.FunnelChart.Selectors.percentBar.leftTick.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.leftTick);
                this.animateToFunnelPercent(leftTick, data, layout.percentBarLayout.leftTick);
                // Right tick
                var rightTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                this.animateToFunnelPercent(rightTick.exit(), zeroData, layout.percentBarLayout.rightTick)
                    .remove();
                rightTick.enter()
                    .append('line')
                    .classed(visuals.FunnelChart.Selectors.percentBar.rightTick.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.rightTick);
                this.animateToFunnelPercent(rightTick, data, layout.percentBarLayout.rightTick);
                // Text
                var text = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.text.selector).data(data);
                this.animateToFunnelPercent(text.exit(), zeroData, layout.percentBarLayout.text)
                    .remove();
                text.enter()
                    .append('text')
                    .classed(visuals.FunnelChart.Selectors.percentBar.text.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.text);
                this.animateToFunnelPercent(text, data, layout.percentBarLayout.text)
                    .text(function (fp) {
                    return powerbi.formattingService.formatValue(fp.percent, visuals.valueFormatter.getLocalizedString("Percentage1"));
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(options.visualInitOptions);
            };
            return WebFunnelAnimator;
        }(visuals.BaseAnimator));
        visuals.WebFunnelAnimator = WebFunnelAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebTreemapAnimator = (function (_super) {
            __extends(WebTreemapAnimator, _super);
            function WebTreemapAnimator(options) {
                _super.call(this, options);
            }
            WebTreemapAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null,
                    majorLabels: null,
                    minorLabels: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebTreemapAnimator.prototype.animateNormalToHighlighted = function (options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(options.highlightNodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', options.layout.highlightShapeClass)
                    .attr(options.layout.shapeLayout); // Start using the normal shape layout
                highlightShapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, true); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, true); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.highlightShapeLayout); // Animate to the highlighted positions
                highlightShapes.exit().remove();
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels,
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
                options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(options.highlightNodes, function (d) { return d.key + "highlight"; });
                var highlightShapes = this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, hasHighlights, options.layout);
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels,
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToNormal = function (options) {
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                var shapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.TreemapNodeClassName)
                    .data(options.nodes, function (d) { return d.key; });
                shapes.enter().append('rect')
                    .attr('class', options.layout.shapeClass);
                shapes
                    .transition()
                    .duration(this.animationDuration)
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, false); })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, d.selected, !d.selected); })
                    .attr(options.layout.shapeLayout)
                    .transition()
                    .duration(0)
                    .delay(this.animationDuration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                shapes.exit().remove();
                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(options.nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', options.layout.highlightShapeClass);
                highlightShapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, true); })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, true, d.selected, !d.selected); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout) // Animate to the normal shape layout or zero shape layout depending on whether we have a selection or not
                    .remove();
                highlightShapes.exit().remove();
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels,
                };
            };
            WebTreemapAnimator.prototype.animateDefaultShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = false;
                var shapes = context.selectAll('.' + visuals.Treemap.TreemapNodeClassName)
                    .data(nodes, function (d) { return d.key; });
                shapes.enter().append('rect')
                    .attr('class', layout.shapeClass);
                shapes
                    .transition()
                    .duration(this.animationDuration)
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', layout.highlightShapeClass);
                highlightShapes
                    .transition()
                    .duration(this.animationDuration)
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            WebTreemapAnimator.prototype.animateDefaultMajorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + visuals.Treemap.MajorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.majorLabelClass);
                labels
                    .text(layout.majorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.majorLabelLayout);
                labels.exit().remove();
                return labels;
            };
            WebTreemapAnimator.prototype.animateDefaultMinorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + visuals.Treemap.MinorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.minorLabelClass);
                labels
                    .text(layout.minorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.minorLabelLayout);
                labels.exit().remove();
                return labels;
            };
            return WebTreemapAnimator;
        }(visuals.BaseAnimator));
        visuals.WebTreemapAnimator = WebTreemapAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.animatedTextObjectDescs = {
            general: {
                properties: {
                    formatString: {
                        type: { formatting: { formatString: true } },
                    },
                },
            }
        };
        visuals.animatedNumberCapabilities = {
            objects: visuals.animatedTextObjectDescs,
            dataViewMappings: [{
                    single: { role: "Values" }
                }],
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.basicShapeCapabilities = {
            objects: {
                line: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Line'),
                    properties: {
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_LineColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Background_TransparencyDescription'),
                            type: { numeric: true }
                        },
                        weight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Weight'),
                            type: { numeric: true }
                        },
                        roundEdge: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_RoundEdges'),
                            type: { numeric: true }
                        }
                    }
                },
                fill: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        fillColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_FillColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Background_TransparencyDescription'),
                            type: { numeric: true }
                        },
                    }
                },
                rotation: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Rotate'),
                    properties: {
                        angle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Rotate'),
                            type: { numeric: true }
                        }
                    }
                },
                general: {
                    properties: {
                        shapeType: {
                            type: { text: true }
                        }
                    }
                }
            },
            suppressDefaultTitle: true,
            suppressDefaultPadding: true,
            canRotate: false,
            supportsSelection: false,
        };
        visuals.basicShapeProps = {
            general: {
                shapeType: { objectName: 'general', propertyName: 'shapeType' },
            },
            line: {
                transparency: { objectName: 'line', propertyName: 'transparency' },
                weight: { objectName: 'line', propertyName: 'weight' },
                roundEdge: { objectName: 'line', propertyName: 'roundEdge' },
                lineColor: { objectName: 'line', propertyName: 'lineColor' }
            },
            fill: {
                transparency: { objectName: 'fill', propertyName: 'transparency' },
                fillColor: { objectName: 'fill', propertyName: 'fillColor' },
                show: { objectName: 'fill', propertyName: 'show' }
            },
            rotation: {
                angle: { objectName: 'rotation', propertyName: 'angle' }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function getColumnChartCapabilities(transposeAxes) {
            if (transposeAxes === void 0) { transposeAxes = false; }
            return {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription')
                    }, {
                        name: 'Series',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                    }, {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                    }, {
                        name: 'Gradient',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                    }
                ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: {
                                type: { formatting: { formatString: true } },
                            },
                        },
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                        description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                                type: { enumeration: visuals.legendPosition.type },
                            },
                            showTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                                type: { bool: true }
                            },
                            titleText: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                                description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                                type: { text: true },
                                suppressFormatPainterCopy: true
                            },
                            labelColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                                type: { fill: { solid: { color: true } } }
                            },
                            fontSize: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                type: { formatting: { fontSize: true } }
                            }
                        }
                    },
                    categoryAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_YAxis') : powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true },
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                description: powerbi.data.createDisplayNameGetter('Visual_YAxis_PositionDescription'),
                                type: { enumeration: visuals.yAxisPosition.type },
                            },
                            axisScale: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                type: { enumeration: visuals.axisScale.type }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                                type: { numeric: true },
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                suppressFormatPainterCopy: true,
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                type: { numeric: true },
                                suppressFormatPainterCopy: true,
                            },
                            axisType: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                                type: { enumeration: visuals.axisType.type },
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                description: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription') : powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                type: { enumeration: visuals.axisStyle.type }
                            },
                            labelColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                                type: { fill: { solid: { color: true } } }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                type: { formatting: { labelDisplayUnits: true } },
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits_Auto'),
                                type: { numeric: true },
                            },
                        }
                    },
                    valueAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_XAxis') : powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true },
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                description: powerbi.data.createDisplayNameGetter('Visual_YAxis_PositionDescription'),
                                type: { enumeration: visuals.yAxisPosition.type },
                            },
                            axisScale: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                type: { enumeration: visuals.axisScale.type }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                                type: { numeric: true },
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                suppressFormatPainterCopy: true,
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                                type: { numeric: true },
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                suppressFormatPainterCopy: true,
                            },
                            intersection: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Intersection'),
                                type: { numeric: true },
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                description: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription') : powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                type: { enumeration: visuals.axisStyle.type }
                            },
                            labelColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                                type: { fill: { solid: { color: true } } }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                type: { formatting: { labelDisplayUnits: true } },
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits_Auto'),
                                type: { numeric: true },
                            },
                        }
                    },
                    y1AxisReferenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
                        description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                                type: { numeric: true }
                            },
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
                                type: { fill: { solid: { color: true } } }
                            },
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style_Description'),
                                type: { enumeration: visuals.lineStyle.type }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
                                type: { enumeration: visuals.referenceLinePosition.type }
                            },
                            dataLabelShow: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
                                type: { bool: true }
                            },
                            dataLabelColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                                type: { fill: { solid: { color: true } } }
                            },
                            dataLabelDecimalPoints: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                type: { numeric: true }
                            },
                            dataLabelHorizontalPosition: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
                                type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
                            },
                            dataLabelVerticalPosition: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
                                type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
                            },
                            dataLabelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                                type: { formatting: { labelDisplayUnits: true } },
                                suppressFormatPainterCopy: true,
                            },
                        },
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            defaultColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                type: { fill: { solid: { color: true } } }
                            },
                            showAllDataPoints: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                type: { bool: true }
                            },
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                type: { fillRule: {} },
                                rule: {
                                    inputRole: 'Gradient',
                                    output: {
                                        property: 'fill',
                                        selector: ['Category'],
                                    },
                                },
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            showSeries: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            color: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                type: { fill: { solid: { color: true } } }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                                type: { formatting: { labelDisplayUnits: true } },
                                suppressFormatPainterCopy: true
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                type: { numeric: true },
                                suppressFormatPainterCopy: true
                            },
                            showAll: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                                type: { bool: true }
                            },
                            fontSize: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                type: { formatting: { fontSize: true } }
                            },
                        },
                    },
                    plotArea: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                        //description: data.createDisplayNameGetter('Visual_PlotDescription'),
                        properties: {
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                                type: { numeric: true },
                            },
                            image: {
                                type: { image: {} },
                            },
                        },
                    },
                },
                dataViewMappings: [{
                        conditions: [
                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { top: {} }
                            },
                            values: {
                                group: {
                                    by: 'Series',
                                    select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }],
                                    dataReductionAlgorithm: { top: {} }
                                }
                            },
                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                        },
                    }],
                supportsHighlight: true,
                sorting: {
                    default: {},
                },
                drilldown: {
                    roles: ['Category']
                },
            };
        }
        visuals.getColumnChartCapabilities = getColumnChartCapabilities;
        visuals.columnChartProps = {
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.comboChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Category'),
                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_CategoryDescription')
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Series'),
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y'),
                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_YDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Y2',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y2'),
                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y2Description'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                },
            ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                        visualType1: {
                            type: { text: true }
                        },
                        visualType2: {
                            type: { text: true }
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { enumeration: visuals.legendPosition.type }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true },
                            suppressFormatPainterCopy: true
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                            type: { enumeration: visuals.axisScale.type }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        axisType: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                            type: { enumeration: visuals.axisType.type },
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        axisLabel: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ColumnTitle'),
                            type: { none: true },
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            type: { enumeration: visuals.yAxisPosition.type },
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                            type: { enumeration: visuals.axisScale.type }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        },
                        secShow: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ShowSecondary'),
                            type: { bool: true },
                        },
                        secAxisLabel: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_LineTitle'),
                            type: { none: true },
                        },
                        secPosition: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            type: { enumeration: visuals.yAxisPosition.type },
                        },
                        secAxisScale: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                            type: { enumeration: visuals.axisScale.type },
                        },
                        secStart: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                        },
                        secEnd: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                        },
                        secShowAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true },
                        },
                        secAxisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type },
                        },
                        secLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        secLabelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColumnColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    },
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                            type: { numeric: true },
                        },
                        image: {
                            type: { image: {} },
                        },
                    },
                },
            },
            dataViewMappings: [
                {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { for: { in: 'Y' } }
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y2': { min: 1 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Y2': { min: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [
                                { for: { in: 'Y2' } }
                            ],
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                    },
                }
            ],
            supportsHighlight: true,
            sorting: {
                default: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.comboChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            valueAxis: {
                secShow: { objectName: 'valueAxis', propertyName: 'secShow' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            dataPoint: {
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.donutChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_DetailsDonutChartDescription'),
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { enumeration: visuals.legendPosition.type }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true },
                            suppressFormatPainterCopy: true
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DetailLabels'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } },
                            suppressFormatPainterCopy: true,
                        },
                        labelStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelStyle'),
                            type: { enumeration: visuals.labelStyle.type }
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ bind: { to: 'Y' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
                    },
                }],
            sorting: {
                default: {},
            },
            supportsHighlight: true,
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.donutChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        // I support a categorical (ordinal) X with measure Y for a single series
        visuals.dataDotChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [{ numeric: true }, { integer: true }],
                },
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{
                                    for: { in: 'Y' },
                                    dataReductionAlgorithm: { top: {} }
                                }]
                        },
                    },
                }]
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.filledMapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LocationFilledMapDescription'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Longitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LongitudeFilledMapDescription'),
                    preferredTypes: [
                        { geography: { longitude: true } }
                    ],
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Latitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LatitudeFilledMapDescription'),
                    preferredTypes: [
                        { geography: { latitude: true } }
                    ],
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { formatting: { legendPosition: true } }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                            description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Size',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                    },
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                    },
                }
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } }
                    },
                }],
            sorting: {
                custom: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.filledMapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                color: { objectName: 'labels', propertyName: 'color' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
            },
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.funnelChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GroupFunnelDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            dataViewMappings: [{
                    conditions: [
                        // NOTE: Ordering of the roles prefers to add measures to Y before Gradient.
                        { 'Category': { max: 0 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }],
                            dataReductionAlgorithm: { top: {} }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelPosition: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Position'),
                            type: { enumeration: visuals.labelPosition.type },
                            suppressFormatPainterCopy: true,
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    }
                },
                percentBarLabel: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_PercentBarLabel'),
                    description: powerbi.data.createDisplayNameGetter('Visual_PercentBarLabelDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    }
                },
            },
            supportsHighlight: true,
            sorting: {
                default: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.funnelChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.gaugeRoleNames = {
            y: 'Y',
            minValue: 'MinValue',
            maxValue: 'MaxValue',
            targetValue: 'TargetValue'
        };
        visuals.gaugeCapabilities = {
            dataRoles: [
                {
                    name: visuals.gaugeRoleNames.y,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.minValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MinValue'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_MinValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.maxValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MaxValue'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_MaxValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.targetValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_TargetValue'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_TargetValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                axis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis'),
                    properties: {
                        min: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Min'),
                            type: { numeric: true }
                        },
                        max: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Max'),
                            type: { numeric: true }
                        },
                        target: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Target'),
                            type: { numeric: true }
                        },
                    },
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    },
                },
                calloutValue: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_CalloutValue'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                    },
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        target: {
                            // TODO find a better string
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Target'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                }
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Y': { max: 1 }, 'MinValue': { max: 1 }, 'MaxValue': { max: 1 }, 'TargetValue': { max: 1 } },
                    ],
                    categorical: {
                        values: {
                            select: [
                                { bind: { to: 'Y' } },
                                { bind: { to: 'MinValue' } },
                                { bind: { to: 'MaxValue' } },
                                { bind: { to: 'TargetValue' } },
                            ]
                        },
                    },
                }],
            supportsSelection: false,
        };
        visuals.gaugeProps = {
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                target: { objectName: 'dataPoint', propertyName: 'target' }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.imageVisualCapabilities = {
            objects: {
                general: {
                    properties: {
                        imageUrl: {
                            type: { misc: { imageUrl: true } }
                        }
                    }
                },
                imageScaling: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Image_Scaling_Type'),
                    properties: {
                        imageScalingType: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Image_Scaling_Type'),
                            type: { enumeration: visuals.imageScalingType.type }
                        },
                    }
                },
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.scriptVisualCapabilities = {
            dataRoles: [{
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                }],
            dataViewMappings: [{
                    scriptResult: {
                        dataInput: {
                            table: {
                                rows: {
                                    for: {
                                        in: 'Values'
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                            },
                        },
                        script: {
                            source: {
                                objectName: 'script',
                                propertyName: 'source'
                            },
                            provider: {
                                objectName: 'script',
                                propertyName: 'provider'
                            },
                        }
                    }
                }],
            objects: {
                script: {
                    properties: {
                        provider: {
                            type: { text: true }
                        },
                        source: {
                            type: { scripting: { source: true }
                            }
                        },
                    }
                },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.lineChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription'),
                    cartesianKind: 0 /* X */,
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                },
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { enumeration: visuals.legendPosition.type }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true },
                            suppressFormatPainterCopy: true
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                trend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                            type: { enumeration: visuals.axisScale.type }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        axisType: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                            type: { enumeration: visuals.axisType.type },
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            description: powerbi.data.createDisplayNameGetter('Visual_YAxis_PositionDescription'),
                            type: { enumeration: visuals.yAxisPosition.type },
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                            type: { enumeration: visuals.axisScale.type }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        }
                    }
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
                            type: { enumeration: visuals.referenceLinePosition.type }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
                            type: { bool: true }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                    },
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        showSeries: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        showAll: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                            type: { bool: true }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                        labelDensity: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelDensity'),
                            type: { formatting: { labelDensity: true } },
                        },
                    },
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    //description: data.createDisplayNameGetter('Visual_PlotDescription'),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                            type: { numeric: true },
                        },
                        image: {
                            type: { image: {} },
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ for: { in: 'Y' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                    },
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { max: 1 } },
                    ],
                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                    usage: {
                        regression: {},
                    },
                    categorical: {
                        categories: {
                            for: { in: 'regression.X' },
                        },
                        values: {
                            for: { in: 'regression.Y' },
                        }
                    }
                }],
            sorting: {
                default: {},
            },
        };
        visuals.lineChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            trend: {
                show: { objectName: 'trend', propertyName: 'show' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            labels: {
                labelDensity: { objectName: 'labels', propertyName: 'labelDensity' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.mapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LocationMapDescription'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Longitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LongitudeMapDescription'),
                    preferredTypes: [
                        { geography: { longitude: true } }
                    ],
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Latitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LatitudeMapDescription'),
                    preferredTypes: [
                        { geography: { latitude: true } }
                    ],
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { enumeration: visuals.legendPosition.type }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { min: 1, max: 1 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { min: 1, max: 1 }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } }
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 0 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 0 }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                            ],
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } }
                    },
                }],
            sorting: {
                custom: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.mapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.multiRowCardCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldsDescription')
                }
            ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                cardTitle: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CardTitle'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CardTitleDescription'),
                    properties: {
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    }
                },
                dataLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    }
                }
            },
            dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: {} }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableVisualDetails: true,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.textboxCapabilities = {
            objects: {
                general: {
                    properties: {
                        paragraphs: {
                            type: { paragraphs: {} },
                            suppressFormatPainterCopy: true,
                        }
                    }
                }
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.cheerMeterCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                },
                {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [{ numeric: true }, { integer: true }],
                },
            ],
            dataViewMappings: [{
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                        },
                    },
                }],
            dataPoint: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                properties: {
                    fill: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                        type: { fill: { solid: { color: true } } }
                    },
                }
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.scatterChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_DetailsScatterChartDescription'),
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_X'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_XScatterChartDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 0 /* X */,
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_YScatterChartDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_SizeDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Play',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: 'Play Axis' //TODO: data.createDisplayNameGetter('Role_DisplayName_Play'),
                }
            ],
            objects: {
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                            type: { bool: true }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                trend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                            type: { enumeration: visuals.axisScale.type }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            description: powerbi.data.createDisplayNameGetter('Visual_YAxis_PositionDescription'),
                            type: { enumeration: visuals.yAxisPosition.type },
                        },
                        axisScale: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                            type: { enumeration: visuals.axisScale.type }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        }
                    }
                },
                xAxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_X'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
                            type: { enumeration: visuals.referenceLinePosition.type }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
                            type: { bool: true }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                    },
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Y'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
                            type: { enumeration: visuals.referenceLinePosition.type }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
                            type: { bool: true }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { enumeration: visuals.legendPosition.type }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true },
                            suppressFormatPainterCopy: true
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    },
                },
                colorBorder: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_ColorBorder'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                    },
                },
                fillPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_FillPoint'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                            type: { bool: true }
                        },
                    },
                },
                colorByCategory: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_ColorByCategory'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        }
                    }
                },
                currentFrameIndex: {
                    properties: {
                        index: {
                            type: { numeric: true },
                        }
                    }
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    //description: data.createDisplayNameGetter('Visual_PlotDescription'),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                            type: { numeric: true },
                        },
                        image: {
                            type: { image: {} },
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                ],
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataReductionAlgorithm: { sample: {} },
                        dataVolume: 4,
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { min: 1, max: 1 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { min: 1, max: 1 } },
                    ],
                    // Long term: consider adding the 'name' concept and have this be a reference to the other dataViewMapping above.
                    // Then we'd also move the splitting logic of Matrix->Categorical[] into DataViewTransform, and other visuals would benefit.
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'Play' } },
                                { bind: { to: 'Category' } },
                            ],
                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                            dataReductionAlgorithm: { bottom: { count: 5000 } }
                        },
                        columns: {
                            for: { in: 'Series' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                            dataReductionAlgorithm: { top: { count: 60 } }
                        },
                        values: {
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                                { bind: { to: 'Size' } },
                            ]
                        }
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                    ],
                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                    usage: {
                        regression: {},
                    },
                    categorical: {
                        categories: {
                            for: { in: 'regression.X' }
                        },
                        values: {
                            for: { in: 'regression.Y' }
                        },
                        dataReductionAlgorithm: { sample: {} },
                        dataVolume: 4,
                    }
                }],
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Play', direction: 1 /* Ascending */ }] //typically a datetime field, sort asc
                },
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.scatterChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            trend: {
                show: { objectName: 'trend', propertyName: 'show' },
            },
            colorBorder: {
                show: { objectName: 'colorBorder', propertyName: 'show' },
            },
            fillPoint: {
                show: { objectName: 'fillPoint', propertyName: 'show' },
            },
            colorByCategory: {
                show: { objectName: 'colorByCategory', propertyName: 'show' },
            },
            currentFrameIndex: {
                index: { objectName: 'currentFrameIndex', propertyName: 'index' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.slicerCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldDescription')
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        filter: {
                            type: { filter: {} },
                        },
                        defaultValue: {
                            type: { expression: { defaultValue: true } },
                        },
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                        outlineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outlineWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight'),
                            type: { numeric: true }
                        },
                        orientation: {
                            displayName: powerbi.data.createDisplayNameGetter('Slicer_Orientation'),
                            type: { enumeration: visuals.slicerOrientation.type }
                        },
                        count: {
                            type: { integer: true }
                        },
                    },
                },
                selection: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_SelectionControls'),
                    properties: {
                        selectAllCheckboxEnabled: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_SelectAll'),
                            type: { bool: true }
                        },
                        singleSelect: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_SingleSelect'),
                            type: { bool: true }
                        }
                    },
                },
                header: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Header'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        background: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    }
                },
                items: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Items'),
                    properties: {
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        background: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    }
                }
            },
            dataViewMappings: [{
                    conditions: [{ 'Values': { max: 1 } }],
                    categorical: {
                        categories: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: {} }
                        },
                        includeEmptyGroups: true,
                    }
                }],
            sorting: {
                default: {},
            },
            suppressDefaultTitle: true,
            disableVisualDetails: true,
        };
        // TODO: Generate these from above, defining twice just introduces potential for error
        visuals.slicerProps = {
            general: {
                outlineColor: { objectName: 'general', propertyName: 'outlineColor' },
                outlineWeight: { objectName: 'general', propertyName: 'outlineWeight' },
                orientation: { objectName: 'general', propertyName: 'orientation' },
                count: { objectName: 'general', propertyName: 'count' },
            },
            selection: {
                selectAllCheckboxEnabled: { objectName: 'selection', propertyName: 'selectAllCheckboxEnabled' },
                singleSelect: { objectName: 'selection', propertyName: 'singleSelect' }
            },
            header: {
                show: { objectName: 'header', propertyName: 'show' },
                fontColor: { objectName: 'header', propertyName: 'fontColor' },
                background: { objectName: 'header', propertyName: 'background' },
                outline: { objectName: 'header', propertyName: 'outline' },
                textSize: { objectName: 'header', propertyName: 'textSize' },
            },
            items: {
                fontColor: { objectName: 'items', propertyName: 'fontColor' },
                background: { objectName: 'items', propertyName: 'background' },
                outline: { objectName: 'items', propertyName: 'outline' },
                textSize: { objectName: 'items', propertyName: 'textSize' },
            },
            selectedPropertyIdentifier: { objectName: 'general', propertyName: 'selected' },
            filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },
            formatString: { objectName: 'general', propertyName: 'formatString' },
            defaultValue: { objectName: 'general', propertyName: 'defaultValue' },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.tableCapabilities = {
            dataRoles: [{
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                }],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                        columnWidth: {
                            type: { numeric: true }
                        },
                        totals: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Totals')
                        },
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Adjust_Column_Width')
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    },
                },
                grid: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outlineWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight_Desc'),
                            type: { numeric: true }
                        },
                        gridVertical: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_RowPadding'),
                            description: powerbi.data.createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                    }
                },
                columnHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
                values: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        // TODO: VSTS 7167767: Remove temporary code for product demo.
                        backgroundColorConditional: {
                            displayName: 'Conditional Formatting',
                            type: { bool: true }
                        },
                        fontColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        urlIcon: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_UrlIcon'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
                            type: { bool: true }
                        },
                    }
                },
                total: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_TotalGrand'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
            },
            dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            sorting: {
                custom: {},
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableVisualDetails: true,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.matrixRoleNames = {
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
        };
        visuals.matrixCapabilities = {
            dataRoles: [
                {
                    name: visuals.matrixRoleNames.rows,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_RowsDescription')
                }, {
                    name: visuals.matrixRoleNames.columns,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ColumnsDescription')
                }, {
                    name: visuals.matrixRoleNames.values,
                    kind: powerbi.VisualDataRoleKind.Measure
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                        columnWidth: {
                            type: { numeric: true }
                        },
                        rowSubtotals: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TotalRow')
                        },
                        columnSubtotals: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TotalColumn')
                        },
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Adjust_Column_Width')
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    },
                },
                grid: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outlineWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight_Desc'),
                            type: { numeric: true }
                        },
                        gridVertical: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_RowPadding'),
                            description: powerbi.data.createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                    },
                },
                columnHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
                rowHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_RowHeaders'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
                values: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        fontColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
                subTotals: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_TotalSub'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        fontColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Rows': { max: 0 }, 'Columns': { max: 0 }, 'Values': { min: 1 } },
                        { 'Rows': { min: 1 }, 'Columns': { min: 0 }, 'Values': { min: 0 } },
                        { 'Rows': { min: 0 }, 'Columns': { min: 1 }, 'Values': { min: 0 } }
                    ],
                    matrix: {
                        rows: {
                            for: { in: 'Rows' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        columns: {
                            for: { in: 'Columns' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { top: { count: 100 } }
                        },
                        values: {
                            for: { in: 'Values' }
                        }
                    }
                }],
            filterMappings: {
                measureFilter: {
                    targetRoles: [visuals.matrixRoleNames.rows]
                }
            },
            sorting: {
                custom: {},
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableVisualDetails: true,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.treemapCapabilities = {
            dataRoles: [
                {
                    name: 'Group',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GroupTreemapDescription')
                }, {
                    name: 'Details',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                }, {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { enumeration: visuals.legendPosition.type }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        fill: {
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Group'],
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Group': { max: 1 }, 'Details': { max: 0 }, 'Gradient': { max: 1 } },
                        { 'Group': { max: 1 }, 'Details': { min: 1, max: 1 }, 'Values': { max: 1 }, 'Gradient': { max: 0 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Group' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Details',
                                select: [{ bind: { to: 'Values' } }, { bind: { to: 'Gradient' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } }
                    }
                }],
            supportsHighlight: true,
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Values', direction: 2 /* Descending */ }]
                },
            },
            drilldown: {
                roles: ['Group']
            },
        };
        visuals.treemapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                color: { objectName: 'labels', propertyName: 'color' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
            },
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.cardCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldsDescription'),
                }
            ],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointLabel'),
                    properties: {
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        // NOTE: Consider adding a ValueType for fontSize.
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    },
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabel'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        // NOTE: Consider adding a ValueType for fontSize.
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    },
                },
                wordWrap: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_WordWrap'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Values': { max: 1 } }
                    ],
                    single: { role: "Values" }
                }],
            suppressDefaultTitle: true,
            supportsSelection: false,
        };
        visuals.cardProps = {
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
                color: { objectName: 'categoryLabels', propertyName: 'color' },
                fontSize: { objectName: 'categoryLabels', propertyName: 'fontSize' },
            },
            labels: {
                color: { objectName: 'labels', propertyName: 'color' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                fontSize: { objectName: 'labels', propertyName: 'fontSize' },
            },
            wordWrap: {
                show: { objectName: 'wordWrap', propertyName: 'show' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.waterfallChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_CategoryWaterfallDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                            type: { enumeration: visuals.legendPosition.type }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                            type: { bool: true }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                            type: { text: true },
                            suppressFormatPainterCopy: true,
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } }
                        },
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        fontSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { formatting: { fontSize: true } },
                        },
                    }
                },
                sentimentColors: {
                    displayName: powerbi.data.createDisplayNameGetter('Waterfall_SentimentColors'),
                    properties: {
                        increaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_IncreaseLabel'),
                            type: { fill: { solid: { color: true } } }
                        },
                        decreaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_DecreaseLabel'),
                            type: { fill: { solid: { color: true } } }
                        },
                        totalFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_TotalLabel'),
                            type: { fill: { solid: { color: true } } }
                        }
                    },
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type },
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true },
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            description: powerbi.data.createDisplayNameGetter('Visual_YAxis_PositionDescription'),
                            type: { enumeration: visuals.yAxisPosition.type },
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                            suppressFormatPainterCopy: true,
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                            type: { enumeration: visuals.axisStyle.type }
                        },
                        labelColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } },
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true },
                        }
                    }
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
                            type: { enumeration: visuals.referenceLinePosition.type }
                        },
                        dataLabelShow: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
                            type: { bool: true }
                        },
                        dataLabelColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        dataLabelDecimalPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        dataLabelHorizontalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
                        },
                        dataLabelVerticalPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
                            type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
                        },
                        dataLabelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } },
                            suppressFormatPainterCopy: true,
                        },
                    },
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    properties: {
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                            type: { numeric: true },
                        },
                        image: {
                            type: { image: {} },
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Y': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{ bind: { to: 'Y' } }]
                        },
                    },
                }],
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.waterfallChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            sentimentColors: {
                increaseFill: { objectName: 'sentimentColors', propertyName: 'increaseFill' },
                decreaseFill: { objectName: 'sentimentColors', propertyName: 'decreaseFill' },
                totalFill: { objectName: 'sentimentColors', propertyName: 'totalFill' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.KPIStatusWithHistoryCapabilities = {
            dataRoles: [
                {
                    name: 'Indicator',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription')
                }, {
                    name: 'TrendLine',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description')
                }, {
                    name: 'Goal',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goal'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_GoalDescription')
                }],
            dataViewMappings: [{
                    conditions: [
                        { 'Indicator': { max: 1 }, 'TrendLine': { max: 1 }, 'Goal': { max: 2 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'TrendLine' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [
                                { bind: { to: 'Indicator' } },
                                { bind: { to: 'Goal' } }
                            ]
                        }
                    },
                }],
            objects: {
                general: {
                    properties: {
                        formatString: {
                            type: { formatting: { formatString: true } },
                        },
                    },
                },
                indicator: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription'),
                    properties: {
                        indicatorDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        indicatorPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        kpiFormat: {
                            displayName: powerbi.data.createDisplayNameGetter('TaskPane_Format'),
                            type: { text: true },
                        }
                    }
                },
                trendline: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description'),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        }
                    }
                },
                goals: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
                    properties: {
                        showGoal: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Show_Goal'),
                            type: { bool: true }
                        },
                        showDistance: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Show_Distance'),
                            type: { bool: true }
                        },
                    }
                },
                status: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Status'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Status'),
                    properties: {
                        direction: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Direction'),
                            description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Direction'),
                            type: { enumeration: visuals.kpiDirection.type }
                        }
                    }
                }
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var capabilities;
        (function (capabilities) {
            // This file registers the built-in capabilities
            // Please use this file to register the capabilities in the plugins.ts/pluginsNotForOSS.ts
            capabilities.animatedNumber = powerbi.visuals.animatedNumberCapabilities;
            capabilities.areaChart = powerbi.visuals.lineChartCapabilities;
            capabilities.barChart = powerbi.visuals.getColumnChartCapabilities(true);
            capabilities.card = powerbi.visuals.cardCapabilities;
            capabilities.multiRowCard = powerbi.visuals.multiRowCardCapabilities;
            capabilities.clusteredBarChart = powerbi.visuals.getColumnChartCapabilities(true);
            capabilities.clusteredColumnChart = powerbi.visuals.getColumnChartCapabilities();
            capabilities.columnChart = powerbi.visuals.getColumnChartCapabilities();
            capabilities.comboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.dataDotChart = powerbi.visuals.dataDotChartCapabilities;
            capabilities.dataDotClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.dataDotStackedColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.donutChart = powerbi.visuals.donutChartCapabilities;
            capabilities.funnel = powerbi.visuals.funnelChartCapabilities;
            capabilities.gauge = powerbi.visuals.gaugeCapabilities;
            capabilities.hundredPercentStackedBarChart = powerbi.visuals.getColumnChartCapabilities(true);
            capabilities.hundredPercentStackedColumnChart = powerbi.visuals.getColumnChartCapabilities();
            capabilities.image = powerbi.visuals.imageVisualCapabilities;
            capabilities.lineChart = powerbi.visuals.lineChartCapabilities;
            capabilities.lineStackedColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.lineClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.map = powerbi.visuals.mapCapabilities;
            capabilities.filledMap = powerbi.visuals.filledMapCapabilities;
            capabilities.treemap = powerbi.visuals.treemapCapabilities;
            capabilities.pieChart = powerbi.visuals.donutChartCapabilities;
            capabilities.scatterChart = powerbi.visuals.scatterChartCapabilities;
            capabilities.table = powerbi.visuals.tableCapabilities;
            capabilities.matrix = powerbi.visuals.matrixCapabilities;
            capabilities.slicer = powerbi.visuals.slicerCapabilities;
            capabilities.textbox = powerbi.visuals.textboxCapabilities;
            capabilities.waterfallChart = powerbi.visuals.waterfallChartCapabilities;
            capabilities.cheerMeter = powerbi.visuals.cheerMeterCapabilities;
            capabilities.scriptVisual = powerbi.visuals.scriptVisualCapabilities;
            capabilities.kpi = powerbi.visuals.KPIStatusWithHistoryCapabilities;
        })(capabilities = visuals.capabilities || (visuals.capabilities = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ColumnChartWebBehavior = (function () {
            function ColumnChartWebBehavior() {
            }
            ColumnChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.options = options;
                var eventGroup = options.eventGroup;
                eventGroup.on('click', function () {
                    var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
                });
                eventGroup.on('contextmenu', function () {
                    if (d3.event.ctrlKey)
                        return;
                    d3.event.preventDefault();
                    var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
                    var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                    selectionHandler.handleContextMenu(d, position);
                });
            };
            ColumnChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                var options = this.options;
                options.bars.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && options.hasHighlights); });
            };
            ColumnChartWebBehavior.getDatumForLastInputEvent = function () {
                var target = d3.event.target;
                return d3.select(target).datum();
            };
            return ColumnChartWebBehavior;
        }());
        visuals.ColumnChartWebBehavior = ColumnChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataDotChartWebBehavior = (function () {
            function DataDotChartWebBehavior() {
            }
            DataDotChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var dots = this.dots = options.dots;
                var dotLabels = options.dotLabels;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler);
                if (dotLabels) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(dotLabels, selectionHandler);
                }
            };
            DataDotChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.dots.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
            };
            return DataDotChartWebBehavior;
        }());
        visuals.DataDotChartWebBehavior = DataDotChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DonutChartWebBehavior = (function () {
            function DonutChartWebBehavior() {
            }
            DonutChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var slices = this.slices = options.slices;
                var highlightSlices = this.highlightSlices = options.highlightSlices;
                var clearCatcher = options.clearCatcher;
                this.hasHighlights = options.hasHighlights;
                var clickHandler = function (d) {
                    selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                };
                var contextMenuHandler = function (d) {
                    if (d3.event.ctrlKey)
                        return;
                    var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                    selectionHandler.handleContextMenu(d.data, position);
                    d3.event.preventDefault();
                };
                slices.on('click', clickHandler);
                slices.on('contextmenu', contextMenuHandler);
                highlightSlices.on('click', clickHandler);
                highlightSlices.on('contextmenu', contextMenuHandler);
                clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            DonutChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.slices.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, hasHighlights && !d.data.selected); });
                this.highlightSlices.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, hasHighlights); });
            };
            return DonutChartWebBehavior;
        }());
        visuals.DonutChartWebBehavior = DonutChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var FunnelWebBehavior = (function () {
            function FunnelWebBehavior() {
            }
            FunnelWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var bars = this.bars = options.bars;
                var interactors = this.interactors = options.interactors;
                var clearCatcher = options.clearCatcher;
                this.hasHighlights = options.hasHighlights;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(bars, selectionHandler);
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactors, selectionHandler);
                clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            FunnelWebBehavior.prototype.renderSelection = function (hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.bars.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
            };
            return FunnelWebBehavior;
        }());
        visuals.FunnelWebBehavior = FunnelWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LineChartWebBehavior = (function () {
            function LineChartWebBehavior() {
            }
            LineChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.lines = options.lines;
                var interactivityLines = options.interactivityLines;
                var dots = this.dots = options.dots;
                var areas = this.areas = options.areas;
                var tooltipOverlay = this.tooltipOverlay = options.tooltipOverlay;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactivityLines, selectionHandler);
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler);
                if (areas) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(areas, selectionHandler);
                }
                if (tooltipOverlay)
                    tooltipOverlay.on('click', function () { return selectionHandler.handleClearSelection(); });
            };
            LineChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.lines.style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                this.dots.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                if (this.areas)
                    this.areas.style("fill-opacity", function (d) { return (hasSelection && !d.selected) ? visuals.LineChart.DimmedAreaFillOpacity : visuals.LineChart.AreaFillOpacity; });
            };
            return LineChartWebBehavior;
        }());
        visuals.LineChartWebBehavior = LineChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var MapBehavior = (function () {
            function MapBehavior() {
                this.mapPointerEventsDisabled = false;
                this.mapPointerTimeoutSet = false;
                this.viewChangedSinceLastClearMouseDown = false;
            }
            MapBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var _this = this;
                var bubbles = this.bubbles = options.bubbles;
                var slices = this.slices = options.slices;
                var shapes = this.shapes = options.shapes;
                var clearCatcher = options.clearCatcher;
                var clickHandler = function (d) {
                    if (bubbles)
                        bubbles.style("pointer-events", "all");
                    if (shapes)
                        shapes.style("pointer-events", "all");
                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
                };
                if (!this.mapPointerEventsDisabled) {
                    if (bubbles)
                        bubbles.style("pointer-events", "all");
                    if (slices)
                        slices.style("pointer-events", "all");
                    if (shapes)
                        shapes.style("pointer-events", "all");
                }
                if (bubbles) {
                    bubbles.on('click', clickHandler);
                    bubbles.on('mousewheel', function () {
                        if (!_this.mapPointerEventsDisabled)
                            bubbles.style("pointer-events", "none");
                        _this.mapPointerEventsDisabled = true;
                        if (!_this.mapPointerTimeoutSet) {
                            _this.mapPointerTimeoutSet = true;
                            setTimeout(function () {
                                if (bubbles)
                                    bubbles.style("pointer-events", "all");
                                _this.mapPointerEventsDisabled = false;
                                _this.mapPointerTimeoutSet = false;
                            }, 200);
                        }
                    });
                    visuals.InteractivityUtils.registerStandardContextMenuHandler(bubbles, selectionHandler);
                }
                if (slices) {
                    slices.on('click', function (d) {
                        slices.style("pointer-events", "all");
                        _this.mapPointerEventsDisabled = false;
                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                    });
                    slices.on('mousewheel', function () {
                        if (!_this.mapPointerEventsDisabled)
                            slices.style("pointer-events", "none");
                        _this.mapPointerEventsDisabled = true;
                        if (!_this.mapPointerTimeoutSet) {
                            _this.mapPointerTimeoutSet = true;
                            setTimeout(function () {
                                if (slices)
                                    slices.style("pointer-events", "all");
                                _this.mapPointerEventsDisabled = false;
                                _this.mapPointerTimeoutSet = false;
                            }, 200);
                        }
                    });
                }
                if (shapes) {
                    shapes.on('click', clickHandler);
                    shapes.on('mousewheel', function () {
                        if (!_this.mapPointerEventsDisabled) {
                            shapes.style("pointer-events", "none");
                        }
                        _this.mapPointerEventsDisabled = true;
                        if (!_this.mapPointerTimeoutSet) {
                            _this.mapPointerTimeoutSet = true;
                            setTimeout(function () {
                                if (shapes)
                                    shapes.style("pointer-events", "all");
                                _this.mapPointerEventsDisabled = false;
                                _this.mapPointerTimeoutSet = false;
                            }, 200);
                        }
                    });
                    visuals.InteractivityUtils.registerStandardContextMenuHandler(shapes, selectionHandler);
                }
                clearCatcher.on('mouseup', function () {
                    if (!_this.viewChangedSinceLastClearMouseDown)
                        selectionHandler.handleClearSelection();
                });
                clearCatcher.on('mousedown', function () {
                    _this.viewChangedSinceLastClearMouseDown = false;
                });
            };
            MapBehavior.prototype.renderSelection = function (hasSelection) {
                if (this.bubbles) {
                    this.bubbles
                        .style({
                        'fill-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                        'stroke-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                    });
                }
                if (this.slices) {
                    this.slices
                        .style({
                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
                    });
                }
                if (this.shapes) {
                    this.shapes
                        .style({
                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                    });
                }
            };
            MapBehavior.prototype.viewChanged = function () {
                this.viewChangedSinceLastClearMouseDown = true;
            };
            return MapBehavior;
        }());
        visuals.MapBehavior = MapBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var ScatterChartWebBehavior = (function () {
            function ScatterChartWebBehavior() {
            }
            ScatterChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var bubbles = this.bubbles = options.dataPointsSelection;
                var data = options.data;
                var eventGroup = options.eventGroup;
                // If we are removing play-axis, remove the trace lines as well
                // TODO: revisit this design, I think ideally this is done when rendering scatter.
                if (this.playOptions
                    && this.playOptions.traceLineRenderer
                    && (!options.playOptions || !options.playOptions.traceLineRenderer)) {
                    this.playOptions.traceLineRenderer.remove();
                }
                this.playOptions = options.playOptions;
                this.shouldEnableFill = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint;
                this.colorBorder = data.colorBorder;
                if (eventGroup) {
                    visuals.InteractivityUtils.registerGroupInteractivityHandlers(eventGroup, selectionHandler);
                }
                else {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(bubbles, selectionHandler);
                }
            };
            ScatterChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                var shouldEnableFill = this.shouldEnableFill;
                var colorBorder = this.colorBorder;
                this.bubbles.style("fill-opacity", function (d) { return visuals.ScatterChart.getMarkerFillOpacity(d.size != null, shouldEnableFill, hasSelection, d.selected); });
                this.bubbles.style("stroke-opacity", function (d) { return visuals.ScatterChart.getMarkerStrokeOpacity(d.size != null, colorBorder, hasSelection, d.selected); });
                if (this.playOptions && this.bubbles) {
                    var selectedPoints = this.bubbles.filter(function (d) { return d.selected; }).data();
                    var traceLineRenderer = this.playOptions.traceLineRenderer;
                    if (selectedPoints && selectedPoints.length > 0 && traceLineRenderer != null) {
                        traceLineRenderer.render(selectedPoints, true);
                    }
                    else {
                        traceLineRenderer.remove();
                    }
                }
            };
            return ScatterChartWebBehavior;
        }());
        visuals.ScatterChartWebBehavior = ScatterChartWebBehavior;
        var ScatterChartMobileBehavior = (function () {
            function ScatterChartMobileBehavior() {
            }
            ScatterChartMobileBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.setOptions(options);
                if (!options.visualInitOptions || !options.visualInitOptions.interactivity.isInteractiveLegend) {
                    // Don't bind events if we are not in interactiveLegend mode
                    // This case happend when on mobile we show the whole dashboard in still not on focus
                    return;
                }
                this.makeDataPointsSelectable(options.dataPointsSelection);
                this.makeRootSelectable(options.root);
                this.makeDragable(options.root);
                this.disableDefaultTouchInteractions(options.root);
                this.selectRoot();
            };
            ScatterChartMobileBehavior.prototype.renderSelection = function (HasSelection) { };
            ScatterChartMobileBehavior.prototype.setSelectionHandler = function (selectionHandler) { };
            ScatterChartMobileBehavior.prototype.makeDataPointsSelectable = function () {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    sel.on('click', function (d, i) {
                        _this.select(i);
                    });
                }
            };
            ScatterChartMobileBehavior.prototype.makeRootSelectable = function (selection) {
                var _this = this;
                selection.on('click', function (d, i) {
                    _this.selectRoot();
                });
            };
            ScatterChartMobileBehavior.prototype.makeDragable = function () {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    var drag = d3.behavior.drag()
                        .on('drag', function (d) { _this.drag(0 /* Drag */); })
                        .on('dragend', function (d) { _this.drag(1 /* DragEnd */); });
                    sel.call(drag);
                }
            };
            ScatterChartMobileBehavior.prototype.disableDefaultTouchInteractions = function (selection) {
                selection.style('touch-action', 'none');
            };
            ScatterChartMobileBehavior.prototype.setOptions = function (options) {
                this.data = options.data;
                this.mainGraphicsContext = options.plotContext;
                this.xAxisProperties = options.xAxisProperties;
                this.yAxisProperties = options.yAxisProperties;
                this.host = options.host;
            };
            ScatterChartMobileBehavior.prototype.select = function (index) {
                this.selectDotByIndex(index);
            };
            ScatterChartMobileBehavior.prototype.selectRoot = function () {
                var marker = jsCommon.PerformanceUtil.create('selectRoot');
                this.onClick();
                marker.end();
            };
            ScatterChartMobileBehavior.prototype.drag = function (t) {
                switch (t) {
                    case 0 /* Drag */:
                        this.onDrag();
                        break;
                    case 1 /* DragEnd */:
                        this.onClick();
                        break;
                    default:
                        debug.assertFail('Unknown Drag Type');
                }
            };
            ScatterChartMobileBehavior.prototype.onDrag = function () {
                //find the current x and y position
                var xy = this.getMouseCoordinates();
                //move the crosshair to the current position
                this.moveCrosshairToXY(xy.x, xy.y);
                //update the style and the legend of the dots
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                this.selectDot(selectedIndex);
                this.updateLegend(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.onClick = function () {
                //find the current x and y position
                var xy = this.getMouseCoordinates();
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                if (selectedIndex !== -1)
                    this.selectDotByIndex(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.getMouseCoordinates = function () {
                var mainGfxContext = this.mainGraphicsContext;
                // select (0,0) in cartesian coordinates
                var x = 0;
                var y = parseInt(mainGfxContext.attr('height'), 10);
                y = y || 0;
                try {
                    var mouse = d3.mouse(mainGfxContext.node());
                    x = mouse[0];
                    y = mouse[1];
                }
                catch (e) {
                }
                return { x: x, y: y, };
            };
            ScatterChartMobileBehavior.prototype.selectDotByIndex = function (index) {
                this.selectDot(index);
                this.moveCrosshairToIndexDot(index);
                this.updateLegend(index);
            };
            ScatterChartMobileBehavior.prototype.selectDot = function (dotIndex) {
                var _this = this;
                var root = this.mainGraphicsContext;
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).classed({ selected: false, notSelected: true });
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).filter(function (d, i) {
                    var dataPoints = _this.data.dataPoints;
                    debug.assert(dataPoints.length > dotIndex, "dataPoints length:" + dataPoints.length + "is smaller than index:" + dotIndex);
                    var currentPoint = dataPoints[dotIndex];
                    return (d.x === currentPoint.x) && (d.y === currentPoint.y);
                }).classed({ selected: true, notSelected: false });
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToIndexDot = function (index) {
                var dataPoints = this.data.dataPoints;
                var root = this.mainGraphicsContext;
                debug.assert(dataPoints.length > index, "dataPoints length:" + dataPoints.length + "is smaller than index:" + index);
                var x = this.xAxisProperties.scale(dataPoints[index].x);
                var y = this.yAxisProperties.scale(dataPoints[index].y);
                if (this.crosshair == null) {
                    var width = +root.attr('width');
                    var height = +root.attr('height');
                    this.crosshair = this.drawCrosshair(root, x, y, width, height);
                    this.crosshairHorizontal = this.crosshair.select(ScatterChartMobileBehavior.Horizontal.selector);
                    this.crosshairVertical = this.crosshair.select(ScatterChartMobileBehavior.Vertical.selector);
                }
                else {
                    this.moveCrosshairToXY(x, y);
                }
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToXY = function (x, y) {
                this.crosshairHorizontal.attr({ y1: y, y2: y });
                this.crosshairVertical.attr({ x1: x, x2: x });
            };
            ScatterChartMobileBehavior.prototype.drawCrosshair = function (addTo, x, y, width, height) {
                var crosshair = addTo.append("g");
                crosshair.classed(ScatterChartMobileBehavior.CrosshairClassName, true);
                crosshair.append('line').classed(ScatterChartMobileBehavior.Horizontal.class, true).attr({ x1: 0, x2: width, y1: y, y2: y });
                crosshair.append('line').classed(ScatterChartMobileBehavior.Vertical.class, true).attr({ x1: x, x2: x, y1: height, y2: 0 });
                return crosshair;
            };
            ScatterChartMobileBehavior.prototype.findClosestDotIndex = function (x, y) {
                var selectedIndex = -1;
                var minDistance = Number.MAX_VALUE;
                var dataPoints = this.data.dataPoints;
                var xAxisPropertiesScale = this.xAxisProperties.scale;
                var yAxisPropertiesScale = this.yAxisProperties.scale;
                for (var i in dataPoints) {
                    var currentPoint = dataPoints[i];
                    var circleX = xAxisPropertiesScale(currentPoint.x);
                    var circleY = yAxisPropertiesScale(currentPoint.y);
                    var horizontalDistance = circleX - x;
                    var verticalDistance = circleY - y;
                    var distanceSqrd = (horizontalDistance * horizontalDistance) + (verticalDistance * verticalDistance);
                    if (minDistance === Number.MAX_VALUE) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    }
                    else if (minDistance && minDistance > distanceSqrd) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    }
                }
                return selectedIndex;
            };
            ScatterChartMobileBehavior.prototype.updateLegend = function (dotIndex) {
                if (this.lastDotIndex == null || this.lastDotIndex !== dotIndex) {
                    var legendItems = this.createLegendDataPoints(dotIndex);
                    this.host.updateLegend(legendItems);
                    this.lastDotIndex = dotIndex;
                }
            };
            ScatterChartMobileBehavior.prototype.createLegendDataPoints = function (dotIndex) {
                var formatStringProp = visuals.scatterChartProps.general.formatString;
                var legendItems = [];
                var data = this.data;
                debug.assert(data.dataPoints.length > dotIndex, "dataPoints length:" + data.dataPoints.length + "is smaller than index:" + dotIndex);
                var point = data.dataPoints[dotIndex];
                //set the title of the legend to be the category or radius or group or blank
                var blank = visuals.valueFormatter.format(null);
                var title = blank;
                var legendData = data.legendData;
                debug.assertValue(legendData, "legendData");
                debug.assertValue(legendData.dataPoints, "legendData");
                var legendDataPoints = legendData.dataPoints;
                var category = point.formattedCategory.getValue();
                if (category !== blank) {
                    title = category;
                }
                else if (point.radius.sizeMeasure != null) {
                    title = visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName);
                }
                else if (legendDataPoints.length >= dotIndex && legendDataPoints[dotIndex].label !== blank) {
                    title = legendDataPoints[dotIndex].label;
                }
                if (data.xCol != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.xCol.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(this.data.axesLabels.x),
                        measure: visuals.valueFormatter.format(point.x, visuals.valueFormatter.getFormatString(data.xCol, formatStringProp)),
                        iconOnlyOnLabel: true,
                    });
                }
                if (data.yCol != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.yCol.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(data.axesLabels.y),
                        measure: visuals.valueFormatter.format(point.y, visuals.valueFormatter.getFormatString(data.yCol, formatStringProp)),
                        iconOnlyOnLabel: true,
                    });
                }
                if (data.size != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.size.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(data.size.displayName),
                        measure: visuals.valueFormatter.format(point.radius.sizeMeasure.values[point.radius.index], visuals.valueFormatter.getFormatString(data.size, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                return { dataPoints: legendItems };
            };
            ScatterChartMobileBehavior.CrosshairClassName = 'crosshair';
            ScatterChartMobileBehavior.ScatterChartCircleTagName = 'circle';
            ScatterChartMobileBehavior.DotClassName = 'dot';
            ScatterChartMobileBehavior.DotClassSelector = '.' + ScatterChartMobileBehavior.DotClassName;
            ScatterChartMobileBehavior.Horizontal = createClassAndSelector('horizontal');
            ScatterChartMobileBehavior.Vertical = createClassAndSelector('vertical');
            return ScatterChartMobileBehavior;
        }());
        visuals.ScatterChartMobileBehavior = ScatterChartMobileBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var HorizontalSlicerWebBehavior = (function () {
            function HorizontalSlicerWebBehavior() {
            }
            HorizontalSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.itemLabels = options.itemLabels;
                this.dataPoints = options.dataPoints;
                this.interactivityService = options.interactivityService;
                this.slicerSettings = options.settings;
                visuals.SlicerWebBehavior.bindSlicerEvents(options.slicerContainer, this.itemLabels, options.clear, selectionHandler, this.slicerSettings, this.interactivityService);
            };
            HorizontalSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemLabels, this.itemLabels, hasSelection, this.interactivityService, this.slicerSettings);
            };
            return HorizontalSlicerWebBehavior;
        }());
        visuals.HorizontalSlicerWebBehavior = HorizontalSlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var VerticalSlicerWebBehavior = (function () {
            function VerticalSlicerWebBehavior() {
            }
            VerticalSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var slicers = options.itemContainers;
                this.itemLabels = options.itemLabels;
                this.itemInputs = options.itemInputs;
                this.dataPoints = options.dataPoints;
                this.interactivityService = options.interactivityService;
                this.settings = options.settings;
                visuals.SlicerWebBehavior.bindSlicerEvents(options.slicerContainer, slicers, options.clear, selectionHandler, this.settings, this.interactivityService);
            };
            VerticalSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemInputs, this.itemLabels, hasSelection, this.interactivityService, this.settings);
            };
            return VerticalSlicerWebBehavior;
        }());
        visuals.VerticalSlicerWebBehavior = VerticalSlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SlicerWebBehavior = (function () {
            function SlicerWebBehavior() {
            }
            SlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.behavior = this.createWebBehavior(options);
                this.behavior.bindEvents(options.behaviorOptions, selectionHandler);
            };
            SlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.behavior.renderSelection(hasSelection);
            };
            SlicerWebBehavior.bindSlicerEvents = function (slicerContainer, slicers, slicerClear, selectionHandler, slicerSettings, interactivityService) {
                SlicerWebBehavior.bindSlicerItemSelectionEvent(slicers, selectionHandler, slicerSettings, interactivityService);
                SlicerWebBehavior.bindSlicerClearEvent(slicerClear, selectionHandler);
                SlicerWebBehavior.styleSlicerContainer(slicerContainer, interactivityService);
            };
            SlicerWebBehavior.setSelectionOnSlicerItems = function (selectableItems, itemLabel, hasSelection, interactivityService, slicerSettings) {
                if (!hasSelection && !interactivityService.isSelectionModeInverted()) {
                    selectableItems.filter('.selected').classed('selected', false);
                    selectableItems.filter('.partiallySelected').classed('partiallySelected', false);
                    var input = selectableItems.selectAll('input');
                    if (input) {
                        input.property('checked', false);
                    }
                    itemLabel.style('color', slicerSettings.slicerText.color);
                }
                else {
                    SlicerWebBehavior.styleSlicerItems(selectableItems, hasSelection, interactivityService.isSelectionModeInverted());
                }
            };
            SlicerWebBehavior.styleSlicerItems = function (slicerItems, hasSelection, isSelectionInverted) {
                slicerItems.each(function (d) {
                    var slicerItem = this;
                    var shouldCheck = false;
                    if (d.isSelectAllDataPoint) {
                        if (hasSelection) {
                            slicerItem.classList.add('partiallySelected');
                            shouldCheck = false;
                        }
                        else {
                            slicerItem.classList.remove('partiallySelected');
                            shouldCheck = isSelectionInverted;
                        }
                    }
                    else {
                        shouldCheck = jsCommon.LogicExtensions.XOR(d.selected, isSelectionInverted);
                    }
                    if (shouldCheck)
                        slicerItem.classList.add('selected');
                    else
                        slicerItem.classList.remove('selected');
                    // Set input selected state to match selection
                    var input = slicerItem.getElementsByTagName('input')[0];
                    if (input)
                        input.checked = shouldCheck;
                });
            };
            SlicerWebBehavior.bindSlicerItemSelectionEvent = function (slicers, selectionHandler, slicerSettings, interactivityService) {
                SlicerWebBehavior.isTouch = false;
                slicers.on("touchstart", function (d) {
                    SlicerWebBehavior.isTouch = true;
                });
                slicers.on("pointerdown", function (d) {
                    var e = d3.event;
                    if (e && e.pointerType === "touch") {
                        SlicerWebBehavior.isTouch = true;
                    }
                });
                slicers.on("click", function (d) {
                    d3.event.preventDefault();
                    if (d.isSelectAllDataPoint) {
                        selectionHandler.toggleSelectionModeInversion();
                    }
                    else {
                        selectionHandler.handleSelection(d, SlicerWebBehavior.isTouch || SlicerWebBehavior.isMultiSelect(d3.event, slicerSettings, interactivityService));
                    }
                    selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
                    SlicerWebBehavior.isTouch = false;
                });
            };
            SlicerWebBehavior.bindSlicerClearEvent = function (slicerClear, selectionHandler) {
                if (slicerClear) {
                    slicerClear.on("click", function (d) {
                        selectionHandler.handleClearSelection();
                        selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
                    });
                }
            };
            SlicerWebBehavior.styleSlicerContainer = function (slicerContainer, interactivityService) {
                var hasSelection = (interactivityService.hasSelection() && interactivityService.isDefaultValueEnabled() === undefined)
                    || interactivityService.isDefaultValueEnabled() === false;
                slicerContainer.classed('hasSelection', hasSelection);
            };
            SlicerWebBehavior.isMultiSelect = function (event, settings, interactivityService) {
                // If selection is inverted, assume we're always in multi-select mode;
                // Also, Ctrl can be used to multi-select even in single-select mode.
                return interactivityService.isSelectionModeInverted()
                    || !settings.selection.singleSelect
                    || event.ctrlKey;
            };
            SlicerWebBehavior.prototype.createWebBehavior = function (options) {
                var behavior;
                var orientation = options.orientation;
                switch (orientation) {
                    case 1 /* Horizontal */:
                        behavior = new visuals.HorizontalSlicerWebBehavior();
                        break;
                    case 0 /* Vertical */:
                    default:
                        behavior = new visuals.VerticalSlicerWebBehavior();
                        break;
                }
                return behavior;
            };
            return SlicerWebBehavior;
        }());
        visuals.SlicerWebBehavior = SlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LegendBehavior = (function () {
            function LegendBehavior() {
            }
            LegendBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var legendItems = options.legendItems;
                this.legendIcons = options.legendIcons;
                var clearCatcher = options.clearCatcher;
                visuals.InteractivityUtils.registerStandardSelectionHandler(legendItems, selectionHandler);
                clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            LegendBehavior.prototype.renderSelection = function (hasSelection) {
                if (hasSelection) {
                    this.legendIcons.style({
                        'fill': function (d) {
                            if (!d.selected)
                                return LegendBehavior.dimmedLegendColor;
                            else
                                return d.color;
                        }
                    });
                }
                else {
                    this.legendIcons.style({
                        'fill': function (d) {
                            return d.color;
                        }
                    });
                }
            };
            LegendBehavior.dimmedLegendColor = '#A6A6A6';
            return LegendBehavior;
        }());
        visuals.LegendBehavior = LegendBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TreemapWebBehavior = (function () {
            function TreemapWebBehavior() {
            }
            TreemapWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var shapes = this.shapes = options.shapes;
                var highlightShapes = this.highlightShapes = options.highlightShapes;
                var majorLabels = options.majorLabels;
                var minorLabels = options.minorLabels;
                this.hasHighlights = options.hasHighlights;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(shapes, selectionHandler);
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(highlightShapes, selectionHandler);
                if (majorLabels) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(majorLabels, selectionHandler);
                }
                if (minorLabels) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(minorLabels, selectionHandler);
                }
            };
            TreemapWebBehavior.prototype.renderSelection = function (hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.shapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, /* isHighlightRect */ false); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, /* isHighlightRect */ false); });
                this.highlightShapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, /* isHighlightRect */ true); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, /* isHighlightRect */ true); });
            };
            return TreemapWebBehavior;
        }());
        visuals.TreemapWebBehavior = TreemapWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WaterfallChartWebBehavior = (function () {
            function WaterfallChartWebBehavior() {
            }
            WaterfallChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var bars = this.bars = options.bars;
                bars.on('click', function (d) {
                    if (!d.isTotal) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }
                });
                bars.on('contextmenu', function (d) {
                    if (d3.event.ctrlKey)
                        return;
                    d3.event.preventDefault();
                    if (!d.isTotal) {
                        var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                        selectionHandler.handleContextMenu(d, position);
                    }
                });
            };
            WaterfallChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.bars.style("fill-opacity", function (d) { return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
            };
            return WaterfallChartWebBehavior;
        }());
        visuals.WaterfallChartWebBehavior = WaterfallChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LabelsBehavior = (function () {
            function LabelsBehavior() {
            }
            LabelsBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.labelItems = options.labelItems;
                visuals.InteractivityUtils.registerStandardSelectionHandler(this.labelItems, selectionHandler);
            };
            LabelsBehavior.prototype.renderSelection = function (hasSelection) {
                if (hasSelection) {
                    this.labelItems.style({
                        'opacity': function (d) {
                            if (!d.selected)
                                return LabelsBehavior.DimmedLabelOpacity;
                            else
                                return LabelsBehavior.DefaultLabelOpacity;
                        }
                    });
                }
                else {
                    this.labelItems.style({
                        'opacity': LabelsBehavior.DefaultLabelOpacity,
                    });
                }
            };
            LabelsBehavior.DefaultLabelOpacity = 1;
            LabelsBehavior.DimmedLabelOpacity = 0.6;
            return LabelsBehavior;
        }());
        visuals.LabelsBehavior = LabelsBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CartesianChartBehavior = (function () {
            function CartesianChartBehavior(behaviors) {
                this.behaviors = behaviors;
            }
            CartesianChartBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var behaviors = this.behaviors;
                for (var i = 0, ilen = behaviors.length; i < ilen; i++) {
                    behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                }
                options.clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            CartesianChartBehavior.prototype.renderSelection = function (hasSelection) {
                for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    behavior.renderSelection(hasSelection);
                }
            };
            return CartesianChartBehavior;
        }());
        visuals.CartesianChartBehavior = CartesianChartBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Default ranges are for when we have a field chosen for the axis,
         * but no values are returned by the query.
         */
        visuals.emptyDomain = [0, 0];
        var AxisHelper;
        (function (AxisHelper) {
            var XLabelMaxAllowedOverflow = 35;
            var TextHeightConstant = 10;
            var MinTickCount = 2;
            var DefaultBestTickCount = 3;
            var LeftPadding = 10;
            var ScalarTickLabelPadding = 3;
            function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                if (availableWidth < 300)
                    return 3;
                if (availableWidth < 500)
                    return 5;
                return 8;
            }
            AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis;
            function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                if (availableWidth < 150)
                    return 3;
                if (availableWidth < 300)
                    return 5;
                return 8;
            }
            AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis;
            /**
             * Get the best number of ticks based on minimum value, maximum value,
             * measure metadata and max tick count.
             *
             * @param min The minimum of the data domain.
             * @param max The maximum of the data domain.
             * @param valuesMetadata The measure metadata array.
             * @param maxTickCount The max count of intervals.
             * @param isDateTime - flag to show single tick when min is equal to max.
             */
            function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
                debug.assert(maxTickCount >= 0, "maxTickCount must be greater or equal to zero");
                if (isNaN(min) || isNaN(max))
                    return DefaultBestTickCount;
                debug.assert(min <= max, "min value needs to be less or equal to max value");
                if (maxTickCount <= 1 || (max <= 1 && min >= -1))
                    return maxTickCount;
                if (min === max) {
                    // datetime needs to only show one tick value in this case so formatting works correctly
                    if (!!isDateTime)
                        return 1;
                    return DefaultBestTickCount;
                }
                if (hasNonIntegerData(valuesMetadata))
                    return maxTickCount;
                // e.g. 5 - 2 + 1 = 4, => [2,3,4,5]
                return Math.min(max - min + 1, maxTickCount);
            }
            AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks;
            function hasNonIntegerData(valuesMetadata) {
                for (var i = 0, len = valuesMetadata.length; i < len; i++) {
                    var currentMetadata = valuesMetadata[i];
                    if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) {
                        return true;
                    }
                }
                return false;
            }
            AxisHelper.hasNonIntegerData = hasNonIntegerData;
            function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
                if (!isScalar || isOrdinalScale(scale)) {
                    return getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain());
                }
                else if (isDateTime(axisType)) {
                    return getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain());
                }
                return getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
            }
            AxisHelper.getRecommendedTickValues = getRecommendedTickValues;
            function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                var tickLabels = [];
                // return no ticks in this case
                if (maxTicks <= 0)
                    return tickLabels;
                var len = labels.length;
                if (maxTicks > len)
                    return labels;
                for (var i = 0, step = Math.ceil(len / maxTicks); i < len; i += step) {
                    tickLabels.push(labels[i]);
                }
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange;
            function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
                var tickLabels = [];
                //if maxticks is zero return none
                if (maxTicks === 0)
                    return tickLabels;
                var quantitiveScale = scale;
                if (quantitiveScale.ticks) {
                    tickLabels = quantitiveScale.ticks(maxTicks);
                    if (tickLabels.length > maxTicks && maxTicks > 1)
                        tickLabels = quantitiveScale.ticks(maxTicks - 1);
                    if (tickLabels.length < MinTickCount) {
                        tickLabels = quantitiveScale.ticks(maxTicks + 1);
                    }
                    tickLabels = createTrueZeroTickLabel(tickLabels);
                    if (minInterval && tickLabels.length > 1) {
                        var tickInterval = tickLabels[1] - tickLabels[0];
                        while (tickInterval > 0 && tickInterval < minInterval) {
                            for (var i = 1; i < tickLabels.length; i++) {
                                tickLabels.splice(i, 1);
                            }
                            tickInterval = tickInterval * 2;
                        }
                        // keep at least two labels - the loop above may trim all but one if we have odd # of tick labels and dynamic range < minInterval
                        if (tickLabels.length === 1) {
                            tickLabels.push(tickLabels[0] + minInterval);
                        }
                    }
                    return tickLabels;
                }
                debug.assertFail('must pass a quantitative scale to this method');
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange;
            /**
             * Round out very small zero tick values (e.g. -1e-33 becomes 0).
             *
             * @param ticks Array of numbers (from d3.scale.ticks([maxTicks])).
             * @param epsilon Max ratio of calculated tick interval which we will recognize as zero.
             *
             * e.g.
             *     ticks = [-2, -1, 1e-10, 3, 4]; epsilon = 1e-5;
             *     closeZero = 1e-5 * | 2 - 1 | = 1e-5
             *     // Tick values <= 1e-5 replaced with 0
             *     return [-2, -1, 0, 3, 4];
             */
            function createTrueZeroTickLabel(ticks, epsilon) {
                if (epsilon === void 0) { epsilon = 1e-5; }
                if (!ticks || ticks.length < 2)
                    return ticks;
                var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
                return ticks.map(function (tick) { return Math.abs(tick) <= closeZero ? 0 : tick; });
            }
            function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                var tickLabels = [];
                if (dataDomain[0] === 0 && dataDomain[1] === 0)
                    return [];
                var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                tickLabels = dateTimeTickLabels.map(function (d) { return d.getTime(); });
                tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
                return tickLabels;
            }
            function normalizeLinearDomain(domain) {
                if (isNaN(domain.min) || isNaN(domain.max)) {
                    domain.min = visuals.emptyDomain[0];
                    domain.max = visuals.emptyDomain[1];
                }
                else if (domain.min === domain.max) {
                    // d3 linear scale will give zero tickValues if max === min, so extend a little
                    domain.min = domain.min < 0 ? domain.min * 1.2 : domain.min * 0.8;
                    domain.max = domain.max < 0 ? domain.max * 0.8 : domain.max * 1.2;
                }
                else {
                    // Check that min is very small and is a negligable portion of the whole domain.
                    // (fix floating pt precision bugs)
                    // sometimes highlight value math causes small negative numbers which makes the axis add
                    // a large tick interval instead of just rendering at zero.
                    if (Math.abs(domain.min) < 0.0001 && domain.min / (domain.max - domain.min) < 0.0001) {
                        domain.min = 0;
                    }
                }
                return domain;
            }
            function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
                if (getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) === 0
                    || getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) === 0) {
                    return {
                        top: 0,
                        right: xMargin,
                        bottom: yMargin,
                        left: 0
                    };
                }
                return {
                    top: 20,
                    right: 30,
                    bottom: 40,
                    left: 30
                };
            }
            AxisHelper.getMargin = getMargin;
            // TODO: Put the parameters into one object
            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, properties, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                debug.assertValue(axes, 'axes');
                var xAxisProperties = axes.x;
                var y1AxisProperties = axes.y1;
                var y2AxisProperties = axes.y2;
                debug.assertValue(viewport, 'viewport');
                debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');
                debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');
                debug.assertValue(xAxisProperties, 'xAxis');
                debug.assertValue(y1AxisProperties, 'yAxis');
                var xLabels = xAxisProperties.values;
                var y1Labels = y1AxisProperties.values;
                var leftOverflow = 0;
                var rightOverflow = 0;
                var maxWidthY1 = 0;
                var maxWidthY2 = 0;
                var xMax = 0; // bottom margin
                var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;
                var scaleIsOrdinal = isOrdinalScale(xAxisProperties.scale);
                var xLabelOuterPadding = 0;
                if (xAxisProperties.outerPadding !== undefined) {
                    xLabelOuterPadding = xAxisProperties.outerPadding;
                }
                else if (xAxisProperties.xLabelMaxWidth !== undefined) {
                    xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
                }
                if (getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0
                    || getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {
                    var rotation = void 0;
                    if (scrollbarVisible)
                        rotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        rotation = LabelLayoutStrategy.DefaultRotation;
                    if (renderY1Axis) {
                        for (var i = 0, len = y1Labels.length; i < len; i++) {
                            properties.text = y1Labels[i];
                            maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(properties));
                        }
                    }
                    if (y2AxisProperties && renderY2Axis) {
                        var y2Labels = y2AxisProperties.values;
                        for (var i = 0, len = y2Labels.length; i < len; i++) {
                            properties.text = y2Labels[i];
                            maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(properties));
                        }
                    }
                    var textHeight = textHeightMeasurer(properties);
                    var maxNumLines = Math.floor(bottomMarginLimit / textHeight);
                    var xScale = xAxisProperties.scale;
                    var xDomain = xScale.domain();
                    if (renderXAxis && xLabels.length > 0) {
                        for (var i = 0, len = xLabels.length; i < len; i++) {
                            // find the max height of the x-labels, perhaps rotated or wrapped
                            var height = void 0;
                            properties.text = xLabels[i];
                            var width = textWidthMeasurer(properties);
                            if (xAxisProperties.willLabelsWordBreak) {
                                // Split label and count rows
                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(properties.text, properties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                height = wordBreaks.length * textHeight;
                                // word wrapping will truncate at xLabelMaxWidth
                                width = xAxisProperties.xLabelMaxWidth;
                            }
                            else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {
                                height = width * rotation.sine;
                                width = width * rotation.cosine;
                            }
                            else {
                                height = TextHeightConstant;
                            }
                            // calculate left and right overflow due to wide X labels
                            // (Note: no right overflow when rotated)
                            if (i === 0) {
                                if (scaleIsOrdinal) {
                                    if (!xAxisProperties.willLabelsFit /*rotated text*/)
                                        leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;
                                    else
                                        leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[0]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    leftOverflow = (width / 2) - xPos;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                            }
                            else if (i === len - 1) {
                                if (scaleIsOrdinal) {
                                    // if we are rotating text (!willLabelsFit) there won't be any right overflow
                                    if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {
                                        // assume this label is placed near the edge
                                        rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                        rightOverflow = Math.max(rightOverflow, 0);
                                    }
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[1]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    rightOverflow = (width / 2) - (viewport.width - xPos);
                                    rightOverflow = Math.max(rightOverflow, 0);
                                }
                            }
                            xMax = Math.max(xMax, height);
                        }
                        // trim any actual overflow to the limit
                        leftOverflow = Math.min(leftOverflow, XLabelMaxAllowedOverflow);
                        rightOverflow = Math.min(rightOverflow, XLabelMaxAllowedOverflow);
                    }
                }
                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                if (showOnRight) {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);
                }
                else {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);
                }
                return {
                    xMax: Math.ceil(bottomMargin),
                    yLeft: Math.ceil(leftMargin),
                    yRight: Math.ceil(rightMargin),
                };
            }
            AxisHelper.getTickLabelMargins = getTickLabelMargins;
            function columnDataTypeHasValue(dataType) {
                return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
            }
            AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue;
            function createOrdinalType() {
                return powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.createOrdinalType = createOrdinalType;
            function isOrdinal(type) {
                return !!(type && (type.text || type.bool));
            }
            AxisHelper.isOrdinal = isOrdinal;
            function isOrdinalScale(scale) {
                return typeof scale.invert === 'undefined';
            }
            AxisHelper.isOrdinalScale = isOrdinalScale;
            function isDateTime(type) {
                return !!(type && type.dateTime);
            }
            AxisHelper.isDateTime = isDateTime;
            function invertScale(scale, x) {
                if (isOrdinalScale(scale)) {
                    return invertOrdinalScale(scale, x);
                }
                return scale.invert(x);
            }
            AxisHelper.invertScale = invertScale;
            function extent(scale) {
                if (isOrdinalScale(scale)) {
                    return scale.rangeExtent();
                }
                return scale.range();
            }
            AxisHelper.extent = extent;
            function invertOrdinalScale(scale, x) {
                var leftEdges = scale.range();
                if (leftEdges.length < 2)
                    return 0;
                var width = scale.rangeBand();
                var halfInnerPadding = (leftEdges[1] - leftEdges[0] - width) / 2;
                var j;
                for (j = 0; x > (leftEdges[j] + width + halfInnerPadding) && j < (leftEdges.length - 1); j++)
                    ;
                return scale.domain()[j];
            }
            AxisHelper.invertOrdinalScale = invertOrdinalScale;
            function findClosestXAxisIndex(categoryValue, categoryAxisValues) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                for (var i in categoryAxisValues) {
                    var distance = Math.abs(categoryValue - categoryAxisValues[i].categoryValue);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = parseInt(i, 10);
                    }
                }
                return closestValueIndex;
            }
            AxisHelper.findClosestXAxisIndex = findClosestXAxisIndex;
            function lookupOrdinalIndex(scale, pixelValue) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                var domain = scale.domain();
                if (domain.length < 2)
                    return 0;
                var halfWidth = (scale(1) - scale(0)) / 2;
                for (var idx in domain) {
                    var leftEdgeInPixels = scale(idx);
                    var midPoint = leftEdgeInPixels + halfWidth;
                    var distance = Math.abs(pixelValue - midPoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = parseInt(idx, 10);
                    }
                }
                return closestValueIndex;
            }
            AxisHelper.lookupOrdinalIndex = lookupOrdinalIndex;
            /** scale(value1) - scale(value2) with zero checking and min(+/-1, result) */
            function diffScaled(scale, value1, value2) {
                debug.assertValue(scale, 'scale');
                var value = scale(value1) - scale(value2);
                if (value === 0)
                    return 0;
                if (value < 0)
                    return Math.min(value, -1);
                return Math.max(value, 1);
            }
            AxisHelper.diffScaled = diffScaled;
            function createDomain(data, axisType, isScalar, forcedScalarDomain, ensureDomain) {
                if (isScalar && !isOrdinal(axisType)) {
                    var userMin = void 0, userMax = void 0;
                    if (forcedScalarDomain && forcedScalarDomain.length === 2) {
                        userMin = forcedScalarDomain[0];
                        userMax = forcedScalarDomain[1];
                    }
                    return createScalarDomain(data, userMin, userMax, axisType, ensureDomain);
                }
                return createOrdinalDomain(data);
            }
            AxisHelper.createDomain = createDomain;
            function ensureValuesInRange(values, min, max) {
                debug.assert(min <= max, "min must be less or equal to max");
                var filteredValues = values.filter(function (v) { return v >= min && v <= max; });
                if (filteredValues.length < 2)
                    filteredValues = [min, max];
                return filteredValues;
            }
            AxisHelper.ensureValuesInRange = ensureValuesInRange;
            /**
             * Gets the ValueType of a category column, defaults to Text if the type is not present.
             */
            function getCategoryValueType(metadataColumn, isScalar) {
                if (metadataColumn && columnDataTypeHasValue(metadataColumn.type))
                    return metadataColumn.type;
                if (isScalar) {
                    return powerbi.ValueType.fromDescriptor({ numeric: true });
                }
                return powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.getCategoryValueType = getCategoryValueType;
            /**
             * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
             * @param options The properties used to create the axis.
             */
            function createAxis(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
                getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct;
                var dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
                // Create the Scale
                var scaleResult = AxisHelper.createScale(options);
                var scale = scaleResult.scale;
                var bestTickCount = scaleResult.bestTickCount;
                var scaleDomain = scale.domain();
                var isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);
                // fix categoryThickness if scalar and the domain was adjusted when making the scale "nice"
                if (categoryThickness && isScalar && dataDomain && dataDomain.length === 2) {
                    var oldSpan = dataDomain[1] - dataDomain[0];
                    var newSpan = scaleDomain[1] - scaleDomain[0];
                    if (oldSpan > 0 && newSpan > 0) {
                        categoryThickness = categoryThickness * oldSpan / newSpan;
                    }
                }
                // Prepare Tick Values for formatting
                var tickValues;
                if (isScalar && bestTickCount === 1) {
                    tickValues = [dataDomain[0]];
                }
                else {
                    var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : undefined;
                    tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
                }
                if (options.scaleType && options.scaleType === visuals.axisScale.log && isLogScaleAllowed) {
                    tickValues = tickValues.filter(function (d) { return AxisHelper.powerOfTen(d); });
                }
                var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision);
                // sets default orientation only, cartesianChart will fix y2 for comboChart
                // tickSize(pixelSpan) is used to create gridLines
                var axis = d3.svg.axis()
                    .scale(scale)
                    .tickSize(6, 0)
                    .orient(isVertical ? 'left' : 'bottom')
                    .ticks(bestTickCount)
                    .tickValues(tickValues);
                var formattedTickValues = [];
                if (metaDataColumn)
                    formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn);
                var xLabelMaxWidth;
                // Use category layout of labels if specified, otherwise use scalar layout of labels
                if (!isScalar && categoryThickness) {
                    xLabelMaxWidth = Math.max(1, categoryThickness - visuals.CartesianChart.TickLabelPadding * 2);
                }
                else {
                    // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan       
                    xLabelMaxWidth = tickValues.length > 1 ? getScalarLabelMaxWidth(scale, tickValues) : pixelSpan;
                    xLabelMaxWidth = xLabelMaxWidth - ScalarTickLabelPadding * 2;
                }
                return {
                    scale: scale,
                    axis: axis,
                    formatter: formatter,
                    values: formattedTickValues,
                    axisType: dataType,
                    axisLabel: null,
                    isCategoryAxis: isCategoryAxis,
                    xLabelMaxWidth: xLabelMaxWidth,
                    categoryThickness: categoryThickness,
                    outerPadding: outerPadding,
                    usingDefaultDomain: scaleResult.usingDefaultDomain,
                    isLogScaleAllowed: isLogScaleAllowed,
                    dataDomain: dataDomain,
                };
            }
            AxisHelper.createAxis = createAxis;
            function getScalarLabelMaxWidth(scale, tickValues) {
                debug.assertValue(scale, "scale");
                debug.assertNonEmpty(tickValues, "tickValues");
                // find the distance between two ticks. scalar ticks can be anywhere, such as:
                // |---50----------100--------|
                if (scale && !_.isEmpty(tickValues)) {
                    return Math.abs(scale(tickValues[1]) - scale(tickValues[0]));
                }
                return 1;
            }
            function createScale(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp;
                var dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
                var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
                var scalarDomain = dataDomain ? dataDomain.slice() : null;
                var bestTickCount = maxTicks;
                var scale;
                var usingDefaultDomain = false;
                if (dataDomain == null || (dataDomain.length === 2 && dataDomain[0] == null && dataDomain[1] == null) || (dataDomain.length !== 2 && isScalar)) {
                    usingDefaultDomain = true;
                    if (dataType.dateTime || !isOrdinal(dataType))
                        dataDomain = visuals.emptyDomain;
                    else
                        dataDomain = [];
                    if (isOrdinal(dataType)) {
                        scale = createOrdinalScale(pixelSpan, dataDomain, categoryThickness ? outerPadding / categoryThickness : 0);
                    }
                    else {
                        scale = createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount);
                    }
                }
                else {
                    if (isScalar && dataDomain.length > 0) {
                        bestTickCount = forcedTickCount !== undefined
                            ? (maxTicks !== 0 ? forcedTickCount : 0)
                            : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [metaDataColumn], maxTicks, dataType.dateTime);
                        var normalizedRange = normalizeLinearDomain({ min: dataDomain[0], max: dataDomain[dataDomain.length - 1] });
                        scalarDomain = [normalizedRange.min, normalizedRange.max];
                    }
                    if (isScalar && dataType.numeric && !dataType.dateTime) {
                        scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, bestTickCount, shouldClamp);
                    }
                    else if (isScalar && dataType.dateTime) {
                        // Use of a linear scale, instead of a D3.time.scale, is intentional since we want
                        // to control the formatting of the time values, since d3's implementation isn't
                        // in accordance to our design.
                        //     scalarDomain: should already be in long-int time (via category.values[0].getTime())
                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp); // DO NOT PASS TICKCOUNT
                    }
                    else if (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) {
                        scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0);
                        bestTickCount = maxTicks === 0 ? 0
                            : Math.min(scalarDomain.length, (pixelSpan - outerPadding * 2) / visuals.CartesianChart.MinOrdinalRectThickness);
                    }
                    else {
                        debug.assertFail('unsupported dataType, something other than text or numeric');
                    }
                }
                // vertical ordinal axis (e.g. categorical bar chart) does not need to reverse
                if (isVertical && isScalar) {
                    scale.range(scale.range().reverse());
                }
                visuals.ColumnUtil.normalizeInfinityInScale(scale);
                return {
                    scale: scale,
                    bestTickCount: bestTickCount,
                    usingDefaultDomain: usingDefaultDomain,
                };
            }
            AxisHelper.createScale = createScale;
            function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
                if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
                var formatter;
                if (dataType.dateTime) {
                    if (isScalar) {
                        var value = new Date(scaleDomain[0]);
                        var value2 = new Date(scaleDomain[1]);
                        // datetime with only one value needs to pass the same value
                        // (from the original dataDomain value, not the adjusted scaleDomain)
                        // so formatting works correctly.
                        if (bestTickCount === 1)
                            value = value2 = new Date(dataDomain[0]);
                        // this will ignore the formatString and create one based on the smallest non-zero portion of the values supplied.
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: value,
                            value2: value2,
                            tickCount: bestTickCount,
                        });
                    }
                    else {
                        // Use the model formatString for ordinal datetime
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                else {
                    if (getValueFn == null && !isScalar) {
                        debug.assertFail('getValueFn must be supplied for ordinal tickValues');
                    }
                    if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                        var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0];
                        var options = {
                            format: formatString,
                            value: value1,
                            value2: 0,
                            allowFormatBeautification: true,
                        };
                        if (axisPrecision)
                            options.precision = axisPrecision;
                        else
                            options.detectAxisPrecision = true;
                        formatter = visuals.valueFormatter.create(options);
                    }
                    else {
                        // do not use display units, just the basic value formatter
                        // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                return formatter;
            }
            AxisHelper.createFormatter = createFormatter;
            /**
             * Format the linear tick labels or the category labels.
             */
            function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
                var formattedTickValues = [];
                if (!getValueFn)
                    getValueFn = function (data) { return data; };
                if (formatter) {
                    axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
                    formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
                }
                else {
                    formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
                }
                return formattedTickValues;
            }
            function getMinTickValueInterval(formatString, columnType, is100Pct) {
                var isCustomFormat = formatString && !powerbi.NumberFormat.isStandardFormat(formatString);
                if (isCustomFormat) {
                    var precision = powerbi.NumberFormat.getCustomFormatMetadata(formatString, true /*calculatePrecision*/).precision;
                    if (formatString.indexOf('%') > -1)
                        precision += 2; //percent values are multiplied by 100 during formatting
                    return Math.pow(10, -precision);
                }
                else if (is100Pct)
                    return 0.01;
                else if (columnType.integer)
                    return 1;
                return 0;
            }
            AxisHelper.getMinTickValueInterval = getMinTickValueInterval;
            function createScalarDomain(data, userMin, userMax, axisType, ensureDomain) {
                debug.assertValue(data, 'data');
                if (data.length === 0) {
                    return null;
                }
                var defaultMinX = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.categoryValue; }); });
                var defaultMaxX = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.categoryValue; }); });
                return combineDomain([userMin, userMax], [defaultMinX, defaultMaxX], ensureDomain);
            }
            /**
             * Creates a [min,max] from your Cartiesian data values.
             *
             * @param data The series array of CartesianDataPoints.
             * @param includeZero Columns and bars includeZero, line and scatter do not.
             */
            function createValueDomain(data, includeZero) {
                debug.assertValue(data, 'data');
                if (data.length === 0)
                    return null;
                var minY = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.value; }); });
                var maxY = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.value; }); });
                if (includeZero)
                    return [Math.min(minY, 0), Math.max(maxY, 0)];
                return [minY, maxY];
            }
            AxisHelper.createValueDomain = createValueDomain;
            function createOrdinalDomain(data) {
                if (_.isEmpty(data))
                    return [];
                // each series shares the same categories for oridinal axes (even if a series has some nulls)
                var domain = [];
                var firstSeries = data[0];
                for (var _i = 0, _a = firstSeries.data; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    if (!dp.highlight)
                        domain.push(dp.categoryIndex);
                }
                return domain;
            }
            var LabelLayoutStrategy;
            (function (LabelLayoutStrategy) {
                function willLabelsFit(axisProperties, availableWidth, textMeasurer, properties) {
                    var labels = axisProperties.values;
                    if (labels.length === 0)
                        return false;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
                        ? axisProperties.xLabelMaxWidth
                        : availableWidth / labels.length;
                    return !labels.some(function (d) {
                        properties.text = d;
                        return textMeasurer(properties) > labelMaxWidth;
                    });
                }
                LabelLayoutStrategy.willLabelsFit = willLabelsFit;
                function willLabelsWordBreak(axisProperties, margin, availableWidth, textWidthMeasurer, textHeightMeasurer, textTruncator, properties) {
                    var labels = axisProperties.values;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
                        ? axisProperties.xLabelMaxWidth
                        : availableWidth / labels.length;
                    var maxRotatedLength = margin.bottom / LabelLayoutStrategy.DefaultRotation.sine;
                    var height = textHeightMeasurer(properties);
                    var maxNumLines = Math.max(1, Math.floor(margin.bottom / height)); // TODO: not taking axis label into account
                    if (labels.length === 0)
                        return false;
                    // If no break character and exceeds max width, word breaking will not work, return false
                    var mustRotate = labels.some(function (label) {
                        // Detect must rotate and return immediately
                        properties.text = label;
                        return !jsCommon.WordBreaker.hasBreakers(label) && textWidthMeasurer(properties) > labelMaxWidth;
                    });
                    if (mustRotate)
                        return false;
                    var moreWordBreakChars = labels.filter(function (label, index) {
                        // ...otherwise compare rotation versus word breaking
                        var allowedLengthProjectedOnXAxis = 
                        // Left margin is the width of Y axis.
                        margin.left
                            + axisProperties.outerPadding
                            + axisProperties.categoryThickness * (index + 0.5)
                            - LeftPadding;
                        var allowedLength = allowedLengthProjectedOnXAxis / LabelLayoutStrategy.DefaultRotation.cosine;
                        var rotatedLength = Math.min(allowedLength, maxRotatedLength);
                        // Which shows more characters? Rotated or maxNumLines truncated to labelMaxWidth?
                        var wordBreakChars = jsCommon.WordBreaker.splitByWidth(label, properties, textWidthMeasurer, labelMaxWidth, maxNumLines, textTruncator).join(' ');
                        properties.text = label;
                        var rotateChars = textTruncator(properties, rotatedLength);
                        // prefer word break (>=) as it takes up less plot area
                        return visuals.TextUtil.removeEllipses(wordBreakChars).length >= visuals.TextUtil.removeEllipses(rotateChars).length;
                    });
                    // prefer word break (>=) as it takes up less plot area
                    return moreWordBreakChars.length >= Math.floor(labels.length / 2);
                }
                LabelLayoutStrategy.willLabelsWordBreak = willLabelsWordBreak;
                LabelLayoutStrategy.DefaultRotation = {
                    sine: Math.sin(Math.PI * (35 / 180)),
                    cosine: Math.cos(Math.PI * (35 / 180)),
                    tangent: Math.tan(Math.PI * (35 / 180)),
                    transform: 'rotate(-35)',
                    dy: '-0.5em',
                };
                LabelLayoutStrategy.DefaultRotationWithScrollbar = {
                    sine: Math.sin(Math.PI * (90 / 180)),
                    cosine: Math.cos(Math.PI * (90 / 180)),
                    tangent: Math.tan(Math.PI * (90 / 180)),
                    transform: 'rotate(-90)',
                    dy: '-0.8em',
                };
                function rotate(text, maxBottomMargin, svgEllipsis, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
                    var rotatedLength;
                    var defaultRotation;
                    if (scrollbarVisible)
                        defaultRotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        defaultRotation = LabelLayoutStrategy.DefaultRotation;
                    if (needRotate) {
                        rotatedLength = maxBottomMargin / defaultRotation.sine;
                    }
                    text.each(function () {
                        var text = d3.select(this);
                        if (needRotate) {
                            var textContentIndex = axisProperties.values.indexOf(this.textContent);
                            var allowedLengthProjectedOnXAxis = 
                            // Left margin is the width of Y axis.
                            margin.left
                                + axisProperties.outerPadding
                                + axisProperties.categoryThickness * (textContentIndex + 0.5);
                            // Subtracting the left padding space from the allowed length.
                            if (!scrollbarVisible)
                                allowedLengthProjectedOnXAxis -= LeftPadding;
                            // Truncate if scrollbar is visible or rotatedLength exceeds allowedLength
                            var allowedLength = allowedLengthProjectedOnXAxis / defaultRotation.cosine;
                            if (scrollbarVisible || needEllipsis || (allowedLength < rotatedLength)) {
                                svgEllipsis(text[0][0], Math.min(allowedLength, rotatedLength));
                            }
                            text.style('text-anchor', 'end')
                                .attr({
                                'dx': '-0.5em',
                                'dy': defaultRotation.dy,
                                'transform': defaultRotation.transform
                            });
                        }
                        else {
                            svgEllipsis(text[0][0], axisProperties.xLabelMaxWidth);
                            text.style('text-anchor', 'middle')
                                .attr({
                                'dx': '0em',
                                'dy': '1em',
                                'transform': 'rotate(0)'
                            });
                        }
                    });
                }
                LabelLayoutStrategy.rotate = rotate;
                function wordBreak(text, axisProperties, maxHeight) {
                    var allowedLength = axisProperties.xLabelMaxWidth;
                    text.each(function () {
                        var node = d3.select(this);
                        // Reset style of text node
                        node
                            .style('text-anchor', 'middle')
                            .attr({
                            'dx': '0em',
                            'dy': '1em',
                            'transform': 'rotate(0)'
                        });
                        powerbi.TextMeasurementService.wordBreak(this, allowedLength, maxHeight);
                    });
                }
                LabelLayoutStrategy.wordBreak = wordBreak;
                function clip(text, availableWidth, svgEllipsis) {
                    if (text.size() === 0)
                        return;
                    text.each(function () {
                        var text = d3.select(this);
                        svgEllipsis(text[0][0], availableWidth);
                    });
                }
                LabelLayoutStrategy.clip = clip;
            })(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {}));
            function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio) {
                if (outerPaddingRatio === void 0) { outerPaddingRatio = 0; }
                debug.assert(outerPaddingRatio >= 0 && outerPaddingRatio < 4, 'outerPaddingRatio should be a value between zero and four');
                var scale = d3.scale.ordinal()
                    .rangeBands([0, pixelSpan], visuals.CartesianChart.InnerPaddingRatio, outerPaddingRatio)
                    .domain(dataDomain);
                return scale;
            }
            AxisHelper.createOrdinalScale = createOrdinalScale;
            function isLogScalePossible(domain, axisType) {
                if (domain == null)
                    return false;
                if (isDateTime(axisType))
                    return false;
                return (domain[0] > 0 && domain[1] > 0) || (domain[0] < 0 && domain[1] < 0); //doman must exclude 0
            }
            AxisHelper.isLogScalePossible = isLogScalePossible;
            //this function can return different scales e.g. log, linear
            // NOTE: export only for testing, do not access directly
            function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
                if (outerPadding === void 0) { outerPadding = 0; }
                if (axisScaleType === visuals.axisScale.log && isLogScalePossible(dataDomain, dataType)) {
                    return createLogScale(pixelSpan, dataDomain, outerPadding, niceCount);
                }
                else {
                    return createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
                }
            }
            AxisHelper.createNumericalScale = createNumericalScale;
            function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                if (outerPadding === void 0) { outerPadding = 0; }
                debug.assert(isLogScalePossible(dataDomain), "dataDomain cannot include 0");
                var scale = d3.scale.log()
                    .range([outerPadding, pixelSpan - outerPadding])
                    .domain([dataDomain[0], dataDomain[1]])
                    .clamp(true);
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            // NOTE: export only for testing, do not access directly
            function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
                if (outerPadding === void 0) { outerPadding = 0; }
                var scale = d3.scale.linear()
                    .range([outerPadding, pixelSpan - outerPadding])
                    .domain([dataDomain[0], dataDomain[1]])
                    .clamp(shouldClamp);
                // .nice(undefined) still modifies the scale boundaries, and for datetime this messes things up.
                // we use millisecond ticks since epoch for datetime, so we don't want any "nice" with numbers like 17398203392.
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            AxisHelper.createLinearScale = createLinearScale;
            function getRangeForColumn(sizeColumn) {
                var result = {};
                if (sizeColumn) {
                    result.min = sizeColumn.min == null
                        ? sizeColumn.minLocal == null ? d3.min(sizeColumn.values) : sizeColumn.minLocal
                        : sizeColumn.min;
                    result.max = sizeColumn.max == null
                        ? sizeColumn.maxLocal == null ? d3.max(sizeColumn.values) : sizeColumn.maxLocal
                        : sizeColumn.max;
                }
                return result;
            }
            AxisHelper.getRangeForColumn = getRangeForColumn;
            /**
             * Set customized domain, but don't change when nothing is set
             */
            function applyCustomizedDomain(customizedDomain, forcedDomain) {
                var domain = [undefined, undefined];
                if (forcedDomain && forcedDomain.length === 2) {
                    domain = [forcedDomain[0], forcedDomain[1]];
                }
                if (customizedDomain && customizedDomain.length === 2) {
                    if (customizedDomain[0] != null) {
                        domain[0] = customizedDomain[0];
                    }
                    if (customizedDomain[1] != null) {
                        domain[1] = customizedDomain[1];
                    }
                }
                if (domain[0] == null && domain[1] == null) {
                    return forcedDomain; //return untouched object
                }
                //do extra check to see if the user input was valid with the merged axis values.
                if (domain[0] != null && domain[1] != null) {
                    if (domain[0] > domain[1]) {
                        return forcedDomain;
                    }
                }
                return domain;
            }
            AxisHelper.applyCustomizedDomain = applyCustomizedDomain;
            /**
             * Combine the forced domain with the actual domain if one of the values was set.
             * The forcedDomain is in 1st priority. Extends the domain if the any reference point requires it.
             */
            function combineDomain(forcedDomain, domain, ensureDomain) {
                var combinedDomain = domain ? [domain[0], domain[1]] : [];
                if (ensureDomain) {
                    if (combinedDomain[0] == null || ensureDomain.min < combinedDomain[0])
                        combinedDomain[0] = ensureDomain.min;
                    if (combinedDomain[1] == null || ensureDomain.max > combinedDomain[1])
                        combinedDomain[1] = ensureDomain.max;
                }
                var domainBeforeForced = [combinedDomain[0], combinedDomain[1]];
                if (forcedDomain && forcedDomain.length === 2) {
                    if (forcedDomain[0] != null) {
                        combinedDomain[0] = forcedDomain[0];
                    }
                    if (forcedDomain[1] != null) {
                        combinedDomain[1] = forcedDomain[1];
                    }
                    if (combinedDomain[0] > combinedDomain[1]) {
                        combinedDomain = domainBeforeForced; //this is invalid, so take the original domain considering the values and the reference line
                    }
                }
                return combinedDomain;
            }
            AxisHelper.combineDomain = combineDomain;
            function createAxisLabel(properties, label, unitType, y2) {
                if (y2 === void 0) { y2 = false; }
                var propertyName = y2 ? 'secAxisStyle' : 'axisStyle';
                if (!properties || !properties[propertyName]) {
                    return label;
                }
                var modifiedLabel;
                if (properties[propertyName] === visuals.axisStyle.showBoth) {
                    modifiedLabel = label + ' (' + unitType + ')'; //todo: localize
                }
                else if (properties[propertyName] === visuals.axisStyle.showUnitOnly) {
                    modifiedLabel = unitType;
                }
                else {
                    modifiedLabel = label;
                }
                return modifiedLabel;
            }
            AxisHelper.createAxisLabel = createAxisLabel;
            function scaleShouldClamp(combinedDomain, domain) {
                if (!combinedDomain || !domain || combinedDomain.length < 2 || domain.length < 2)
                    return false;
                //when the start or end is different, clamp it
                return combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1];
            }
            AxisHelper.scaleShouldClamp = scaleShouldClamp;
            function normalizeNonFiniteNumber(value) {
                if (isNaN(value))
                    return null;
                else if (value === Number.POSITIVE_INFINITY)
                    return Number.MAX_VALUE;
                else if (value === Number.NEGATIVE_INFINITY)
                    return -Number.MAX_VALUE;
                return value;
            }
            AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber;
            function powerOfTen(d) {
                return d / Math.pow(10, Math.ceil(Math.log(d) / Math.LN10 - 1e-12)) === 1;
            }
            AxisHelper.powerOfTen = powerOfTen;
        })(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ShapeFactory;
        (function (ShapeFactory) {
            var ShapeFactoryConsts;
            (function (ShapeFactoryConsts) {
                ShapeFactoryConsts.PaddingConstRatio = 0.01;
                ShapeFactoryConsts.TrianglePaddingConstRatio = 0.15;
                ShapeFactoryConsts.TriangleEndPaddingConstRatio = 0.85;
                ShapeFactoryConsts.ShapeConstRatio = 1.0 - (ShapeFactoryConsts.PaddingConstRatio * 2);
                ShapeFactoryConsts.SmallPaddingConstValue = 10;
                ShapeFactoryConsts.OvalRadiusConst = 2;
                ShapeFactoryConsts.OvalRadiusConstPadding = 0.2;
                ShapeFactoryConsts.ArrowLeftHeadPoint = { x: 0.05, y: 0.42 };
                ShapeFactoryConsts.ArrowMiddleHeadPoint = { x: 0.5, y: 0.016 };
                ShapeFactoryConsts.ArrowRightHeadPoint = { x: 0.95, y: 0.42 };
                ShapeFactoryConsts.ArrowRightMiddleHeadPoint = { x: 0.764, y: 0.42 };
                ShapeFactoryConsts.ArrowBottomRightPoint = { x: 0.764, y: 0.993 };
                ShapeFactoryConsts.ArrowBottomLeftPoint = { x: 0.246, y: 0.993 };
                ShapeFactoryConsts.ArrowLeftMiddleHeadPoint = { x: 0.246, y: 0.42 };
            })(ShapeFactoryConsts = ShapeFactory.ShapeFactoryConsts || (ShapeFactory.ShapeFactoryConsts = {}));
            /** this function creates a rectangle svg   */
            function createRectangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var x = (viewportWidth * ShapeFactoryConsts.PaddingConstRatio) + (data.lineWeight / 2);
                var y = (viewportHeight * ShapeFactoryConsts.PaddingConstRatio) + (data.lineWeight / 2);
                var width = (viewportWidth * ShapeFactoryConsts.ShapeConstRatio) - (data.lineWeight);
                var height = (viewportHeight * ShapeFactoryConsts.ShapeConstRatio) - (data.lineWeight);
                var attrs = { x: x, y: y, width: width, height: height, rx: data.roundEdge, ry: data.roundEdge };
                var scale = getScale(width, height, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'rect', attrs);
            }
            ShapeFactory.createRectangle = createRectangle;
            /** this function creates a oval svg   */
            function createOval(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var widthForCircle = (viewportWidth / ShapeFactoryConsts.OvalRadiusConst).toString();
                var heightForCircle = (viewportHeight / ShapeFactoryConsts.OvalRadiusConst).toString();
                var radiusXForCircle = ((viewportWidth / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding)) - data.lineWeight);
                var radiusYForCircle = ((viewportHeight / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding)) - data.lineWeight);
                var attrs = { cx: widthForCircle, cy: heightForCircle, rx: radiusXForCircle, ry: radiusYForCircle };
                var scale = getScale(viewportWidth, viewportHeight, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'ellipse', attrs);
            }
            ShapeFactory.createOval = createOval;
            /** this function creates a line svg   */
            function createLine(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var x1, y1, x2, y2;
                var width = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - ShapeFactoryConsts.SmallPaddingConstValue;
                var height = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - ShapeFactoryConsts.SmallPaddingConstValue;
                var ratio;
                if (degrees <= 45) {
                    ratio = degrees / 90;
                    x1 = viewportWidth / 2 + width * ratio;
                    y1 = ShapeFactoryConsts.SmallPaddingConstValue;
                    x2 = viewportWidth / 2 - width * ratio;
                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
                }
                else if (degrees <= 135) {
                    ratio = (degrees - 45) / 90;
                    x1 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue);
                    y1 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio;
                    x2 = ShapeFactoryConsts.SmallPaddingConstValue;
                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - height * ratio;
                }
                else if (degrees <= 225) {
                    ratio = (degrees - 135) / 90;
                    x1 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - width * ratio;
                    y1 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
                    x2 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio;
                    y2 = ShapeFactoryConsts.SmallPaddingConstValue;
                }
                else if (degrees <= 315) {
                    ratio = (degrees - 225) / 90;
                    x1 = ShapeFactoryConsts.SmallPaddingConstValue;
                    y1 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - height * ratio;
                    x2 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue);
                    y2 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio;
                }
                else if (degrees <= 360) {
                    ratio = (degrees - 315) / 90;
                    x1 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio;
                    y1 = ShapeFactoryConsts.SmallPaddingConstValue;
                    x2 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - width * ratio;
                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
                }
                // create the inner path with the wanted shape
                selectedElement
                    .append('svg')
                    .attr({
                    width: viewportWidth,
                    height: viewportHeight
                })
                    .append('line')
                    .attr({
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                })
                    .style({
                    'vector-effect': 'non-scaling-stroke',
                    'stroke-width': data.lineWeight + 'px',
                    'stroke-opacity': (100 - data.lineTransparency) / 100,
                    'stroke': data.lineColor
                });
            }
            ShapeFactory.createLine = createLine;
            /** this function creates a arrow svg   */
            function createUpArrow(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var lineWeight = data.lineWeight;
                var viewportHeightWeight = viewportHeight - lineWeight;
                var viewportWidthWeight = viewportWidth - lineWeight;
                var arrowPoints = [
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowRightHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowRightHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomRightPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomRightPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.y).toString() },
                ];
                // create the inner path with the wanted shape
                createPathFromArray(data, arrowPoints, selectedElement, viewportHeight, viewportWidth, degrees);
            }
            ShapeFactory.createUpArrow = createUpArrow;
            /** this function creates a triangle svg   */
            function createTriangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var lineWeight = data.lineWeight;
                // remove the basic line weight
                if (lineWeight > 3) {
                    lineWeight -= 3;
                }
                var firstPointX = ((viewportWidth + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio);
                var firstPointY = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight) < 0 ?
                    (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight);
                var secondPointY = ((viewportHeight + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio);
                var thirdPointX = ((viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio) < 0 ?
                    (viewportWidth * ShapeFactoryConsts.TriangleEndPaddingConstRatio) : ((viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio);
                var thirdPointY = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight) < 0 ?
                    (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : (viewportHeight - lineWeight - ShapeFactoryConsts.SmallPaddingConstValue);
                var secondPointX = ((firstPointX + thirdPointX) / 2);
                if (firstPointX < 10) {
                    firstPointX = ShapeFactoryConsts.SmallPaddingConstValue;
                }
                if (secondPointY < 10) {
                    secondPointY = ShapeFactoryConsts.SmallPaddingConstValue;
                }
                var trianglePoints = [
                    { 'x': firstPointX, 'y': firstPointY },
                    { 'x': secondPointX, 'y': secondPointY },
                    { 'x': thirdPointX, 'y': thirdPointY },
                ];
                createPathFromArray(data, trianglePoints, selectedElement, viewportHeight, viewportWidth, degrees);
            }
            ShapeFactory.createTriangle = createTriangle;
            /** this funcion adds a path to an svg element from an array of points (x,y) */
            function createPathFromArray(data, points, selectedElement, viewportHeight, viewportWidth, degrees) {
                var lineFunction = d3.svg.line()
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; })
                    .interpolate('linear');
                var attrs = { d: lineFunction(points) + ' Z' };
                var scale = getScale(viewportWidth, viewportHeight, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'path', attrs);
            }
            function createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, shapeType, shapeAttrs) {
                selectedElement
                    .append('div')
                    .style({
                    'transform': 'rotate(' + degrees + 'deg) scale(' + scale + ')',
                    'transform-origin': 'center',
                    // for testing with phantomjs we need the webkit prefix
                    '-webkit-transform': 'rotate(' + degrees + 'deg) scale(' + scale + ')',
                    '-webkit-transform-origin': 'center',
                    'width': viewportWidth + 'px',
                    'height': viewportHeight + 'px'
                })
                    .append('svg')
                    .attr({
                    width: viewportWidth,
                    height: viewportHeight
                })
                    .append(shapeType)
                    .attr(shapeAttrs)
                    .style({
                    'vector-effect': 'non-scaling-stroke',
                    'stroke-width': data.lineWeight + 'px',
                    'stroke': data.lineColor,
                    'stroke-opacity': (100 - data.lineTransparency) / 100,
                    'fill': data.fillColor,
                    'fill-opacity': data.showFill === true ? ((100 - data.shapeTransparency) / 100) : 0
                });
            }
            // this function return the scale to add to the shape. 
            // it calculate it by the ratio of the original shape's diagonal and the shape's diagonal after rotate (the maximum diagonal that still fit to the container).
            // it calculate the shape's diagonal by the rotate angle.
            function getScale(width, height, degrees) {
                var originalWidth = width;
                var originalHeight = height;
                var offsetAngle = Math.atan2(height, width);
                var originalFactor = Math.sqrt(Math.pow(height, 2) + Math.pow(width, 2));
                var radians = (degrees / 180) * Math.PI;
                if (width >= height) {
                    if (degrees < 90) {
                        radians += offsetAngle;
                    }
                    else if (degrees < 180) {
                        radians -= offsetAngle;
                    }
                    else if (degrees < 270) {
                        radians += offsetAngle;
                    }
                    else {
                        radians -= offsetAngle;
                    }
                    return (originalHeight / Math.abs(Math.sin(radians))) / originalFactor;
                }
                else {
                    if (degrees < 90) {
                        radians -= offsetAngle;
                    }
                    else if (degrees < 180) {
                        radians += offsetAngle;
                    }
                    else if (degrees < 270) {
                        radians -= offsetAngle;
                    }
                    else {
                        radians += offsetAngle;
                    }
                    return (originalWidth / Math.abs(Math.cos(radians))) / originalFactor;
                }
            }
        })(ShapeFactory = visuals.ShapeFactory || (visuals.ShapeFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CartesianHelper;
        (function (CartesianHelper) {
            function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var categoryAxisObject = objects['categoryAxis'];
                    if (categoryAxisObject) {
                        toReturn = {
                            show: categoryAxisObject['show'],
                            axisType: categoryAxisObject['axisType'],
                            axisScale: categoryAxisObject['axisScale'],
                            start: categoryAxisObject['start'],
                            end: categoryAxisObject['end'],
                            showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
                            axisStyle: categoryAxisObject['axisStyle'],
                            labelColor: categoryAxisObject['labelColor'],
                            labelDisplayUnits: categoryAxisObject['labelDisplayUnits'],
                            labelPrecision: categoryAxisObject['labelPrecision'],
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties;
            function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var valueAxisObject = objects['valueAxis'];
                    if (valueAxisObject) {
                        toReturn = {
                            show: valueAxisObject['show'],
                            position: valueAxisObject['position'],
                            axisScale: valueAxisObject['axisScale'],
                            start: valueAxisObject['start'],
                            end: valueAxisObject['end'],
                            showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
                            axisStyle: valueAxisObject['axisStyle'],
                            labelColor: valueAxisObject['labelColor'],
                            labelDisplayUnits: valueAxisObject['labelDisplayUnits'],
                            labelPrecision: valueAxisObject['labelPrecision'],
                            secShow: valueAxisObject['secShow'],
                            secPosition: valueAxisObject['secPosition'],
                            secAxisScale: valueAxisObject['secAxisScale'],
                            secStart: valueAxisObject['secStart'],
                            secEnd: valueAxisObject['secEnd'],
                            secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
                            secAxisStyle: valueAxisObject['secAxisStyle'],
                            secLabelColor: valueAxisObject['secLabelColor'],
                            secLabelDisplayUnits: valueAxisObject['secLabelDisplayUnits'],
                            secLabelPrecision: valueAxisObject['secLabelPrecision'],
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getValueAxisProperties = getValueAxisProperties;
            function isScalar(isScalar, xAxisCardProperties) {
                if (isScalar) {
                    //now check what the user wants
                    isScalar = xAxisCardProperties && xAxisCardProperties['axisType'] ? xAxisCardProperties['axisType'] === visuals.axisType.scalar : true;
                }
                return isScalar;
            }
            CartesianHelper.isScalar = isScalar;
            function getPrecision(precision) {
                if (precision != null) {
                    if (precision < 0) {
                        return 0;
                    }
                    return precision;
                }
                return null;
            }
            CartesianHelper.getPrecision = getPrecision;
            function lookupXValue(data, index, type, isScalar) {
                debug.assertValue(data, 'data');
                debug.assertValue(type, 'type');
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isScalar) {
                    if (isDateTime)
                        return new Date(index);
                    // index is the numeric value
                    return index;
                }
                if (type.text) {
                    debug.assert(index < data.categories.length, 'category index out of range');
                    return data.categories[index];
                }
                if (data && data.series && data.series.length > 0) {
                    var firstSeries = data.series[0];
                    if (firstSeries) {
                        var seriesValues = firstSeries.data;
                        if (seriesValues) {
                            if (data.hasHighlights)
                                index = index * 2;
                            var dataAtIndex = seriesValues[index];
                            if (dataAtIndex) {
                                if (isDateTime && dataAtIndex.categoryValue != null)
                                    return new Date(dataAtIndex.categoryValue);
                                return dataAtIndex.categoryValue;
                            }
                        }
                    }
                }
                return index;
            }
            CartesianHelper.lookupXValue = lookupXValue;
            function findMaxCategoryIndex(series) {
                if (_.isEmpty(series)) {
                    return 0;
                }
                var maxCategoryIndex = 0;
                for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
                    var singleSeries = series_1[_i];
                    if (!_.isEmpty(singleSeries.data)) {
                        var lastIndex = singleSeries.data[singleSeries.data.length - 1].categoryIndex;
                        maxCategoryIndex = Math.max(lastIndex, maxCategoryIndex);
                    }
                }
                return maxCategoryIndex;
            }
            CartesianHelper.findMaxCategoryIndex = findMaxCategoryIndex;
        })(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
        var ColorHelper = (function () {
            function ColorHelper(colors, fillProp, defaultDataPointColor) {
                this.colors = colors;
                this.fillProp = fillProp;
                this.defaultDataPointColor = defaultDataPointColor;
                this.defaultColorScale = colors.getNewColorScale();
            }
            /**
             * Gets the color for the given series value.
             * If no explicit color or default color has been set then the color is
             * allocated from the color scale for this series.
             */
            ColorHelper.prototype.getColorForSeriesValue = function (objects, fieldIds, value) {
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
                    || this.defaultDataPointColor
                    || this.getColorScaleForSeries(fieldIds).getColor(value).value;
            };
            /**
             * Gets the color scale for the given series.
             */
            ColorHelper.prototype.getColorScaleForSeries = function (fieldIds) {
                return this.colors.getColorScaleByKey(SQExprShortSerializer.serializeArray(fieldIds || []));
            };
            /**
             * Gets the color for the given measure.
             */
            ColorHelper.prototype.getColorForMeasure = function (objects, measureKey) {
                // Note, this allocates the color from the scale regardless of if we use it or not which helps keep colors stable.
                var scaleColor = this.defaultColorScale.getColor(measureKey).value;
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
                    || this.defaultDataPointColor
                    || scaleColor;
            };
            ColorHelper.normalizeSelector = function (selector, isSingleSeries) {
                debug.assertAnyValue(selector, 'selector');
                // For dynamic series charts, colors are set per category.  So, exclude any measure (metadata repetition) from the selector.
                if (selector && (isSingleSeries || selector.data))
                    return { data: selector.data };
                return selector;
            };
            return ColorHelper;
        }());
        visuals.ColorHelper = ColorHelper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var rectName = 'rect';
        var ColumnUtil;
        (function (ColumnUtil) {
            ColumnUtil.DimmedOpacity = 0.4;
            ColumnUtil.DefaultOpacity = 1.0;
            function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
                if (isScalar) {
                    var min = xAxisCardProperties['start'];
                    var max = xAxisCardProperties['end'];
                    return ColumnUtil.transformDomain(dataView, min, max);
                }
                return dataView;
            }
            ColumnUtil.applyUserMinMax = applyUserMinMax;
            function transformDomain(dataView, min, max) {
                if (!dataView.categories || !dataView.values || dataView.categories.length === 0 || dataView.values.length === 0)
                    return dataView; // no need to do something when there are no categories  
                if (typeof min !== "number" && typeof max !== "number")
                    return dataView; //user did not set min max, nothing to do here        
                var category = dataView.categories[0]; //at the moment we only support one category
                var categoryValues = category.values;
                var categoryObjects = category.objects;
                if (!categoryValues || !categoryObjects)
                    return dataView;
                var newcategoryValues = [];
                var newValues = [];
                var newObjects = [];
                //get new min max
                if (typeof min !== "number") {
                    min = categoryValues[0];
                }
                if (typeof max !== "number") {
                    max = categoryValues[categoryValues.length - 1];
                }
                //don't allow this
                if (min > max)
                    return dataView;
                //build measure array
                for (var j = 0, len = dataView.values.length; j < len; j++) {
                    newValues.push([]);
                }
                for (var t = 0, len = categoryValues.length; t < len; t++) {
                    if (categoryValues[t] >= min && categoryValues[t] <= max) {
                        newcategoryValues.push(categoryValues[t]);
                        if (categoryObjects) {
                            newObjects.push(categoryObjects[t]);
                        }
                        //on each measure set the new range
                        if (dataView.values) {
                            for (var k = 0; k < dataView.values.length; k++) {
                                newValues[k].push(dataView.values[k].values[t]);
                            }
                        }
                    }
                }
                //don't write directly to dataview
                var resultDataView = powerbi.Prototype.inherit(dataView);
                var resultDataViewValues = resultDataView.values = powerbi.Prototype.inherit(resultDataView.values);
                var resultDataViewCategories = resultDataView.categories = powerbi.Prototype.inherit(dataView.categories);
                var resultDataViewCategories0 = resultDataView.categories[0] = powerbi.Prototype.inherit(resultDataViewCategories[0]);
                resultDataViewCategories0.values = newcategoryValues;
                //only if we had objects, then you set the new objects
                if (resultDataViewCategories0.objects) {
                    resultDataViewCategories0.objects = newObjects;
                }
                //update measure array
                for (var t = 0, len = dataView.values.length; t < len; t++) {
                    var measureArray = resultDataViewValues[t] = powerbi.Prototype.inherit(resultDataViewValues[t]);
                    measureArray.values = newValues[t];
                }
                return resultDataView;
            }
            ColumnUtil.transformDomain = transformDomain;
            function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var categoryThickness = layout.categoryThickness;
                var isScalar = layout.isScalar;
                var outerPaddingRatio = layout.outerPaddingRatio;
                var domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({ text: true }), isScalar, [forcedXMin, forcedXMax], ensureXDomain);
                var axisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: size,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, visuals.columnChartProps.general.formatString),
                    outerPadding: categoryThickness * outerPaddingRatio,
                    isCategoryAxis: true,
                    isScalar: isScalar,
                    isVertical: isVertical,
                    categoryThickness: categoryThickness,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function (index, type) { return visuals.CartesianHelper.lookupXValue(data, index, type, isScalar); },
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision
                });
                // intentionally updating the input layout by ref
                layout.categoryThickness = axisProperties.categoryThickness;
                return axisProperties;
            }
            ColumnUtil.getCategoryAxis = getCategoryAxis;
            function applyInteractivity(columns, onDragStart) {
                debug.assertValue(columns, 'columns');
                if (onDragStart) {
                    columns
                        .attr('draggable', 'true')
                        .on('dragstart', onDragStart);
                }
            }
            ColumnUtil.applyInteractivity = applyInteractivity;
            function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
                    return ColumnUtil.DimmedOpacity;
                return ColumnUtil.DefaultOpacity;
            }
            ColumnUtil.getFillOpacity = getFillOpacity;
            function getClosestColumnIndex(coordinate, columnsCenters) {
                var currentIndex = 0;
                var distance = Number.MAX_VALUE;
                for (var i = 0, ilen = columnsCenters.length; i < ilen; i++) {
                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                    if (currentDistance < distance) {
                        distance = currentDistance;
                        currentIndex = i;
                    }
                }
                return currentIndex;
            }
            ColumnUtil.getClosestColumnIndex = getClosestColumnIndex;
            function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
                var series = mainGraphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var lastColumnUndefined = typeof lastColumnIndex === 'undefined';
                // find all columns that do not belong to the selected column and set a dimmed opacity with a smooth animation to those columns
                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
                    return (d.categoryIndex !== selectedColumnIndex) && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
                }).transition().style('fill-opacity', ColumnUtil.DimmedOpacity);
                // set the default opacity for the selected column
                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
                    return d.categoryIndex === selectedColumnIndex;
                }).style('fill-opacity', ColumnUtil.DefaultOpacity);
            }
            ColumnUtil.setChosenColumnOpacity = setChosenColumnOpacity;
            function drawSeries(data, graphicsContext, axisOptions) {
                var colGroupSelection = graphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var series = colGroupSelection.data(data.series, function (d) { return d.key; });
                series
                    .enter()
                    .append('g')
                    .classed(visuals.ColumnChart.SeriesClasses.class, true);
                series
                    .style({
                    fill: function (d) { return d.color; },
                });
                series
                    .exit()
                    .remove();
                return series;
            }
            ColumnUtil.drawSeries = drawSeries;
            function drawDefaultShapes(data, series, layout, itemCS, filterZeros, hasSelection) {
                // We filter out invisible (0, null, etc.) values from the dataset
                // based on whether animations are enabled or not, Dashboard and
                // Exploration mode, respectively.
                var dataSelector;
                if (filterZeros) {
                    dataSelector = function (d) {
                        var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });
                        return filteredData;
                    };
                }
                else {
                    dataSelector = function (d) { return d.data; };
                }
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });
                shapes.enter()
                    .append(rectName)
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes
                    .style("fill-opacity", function (d) { return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); })
                    .style("fill", function (d) { return d.color !== data.series[d.seriesIndex].color ? d.color : null; }) // PERF: Only set the fill color if it is different than series.
                    .attr(layout.shapeLayout);
                shapes
                    .exit()
                    .remove();
                return shapes;
            }
            ColumnUtil.drawDefaultShapes = drawDefaultShapes;
            function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                if (series) {
                    var seriesData = series.data();
                    var dataPoints = [];
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        Array.prototype.push.apply(dataPoints, seriesData[i].data);
                    }
                    return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(context);
                }
            }
            ColumnUtil.drawDefaultLabels = drawDefaultLabels;
            function normalizeInfinityInScale(scale) {
                // When large values (eg Number.MAX_VALUE) are involved, a call to scale.nice occasionally
                // results in infinite values being included in the domain. To correct for that, we need to
                // re-normalize the domain now to not include infinities.
                var scaledDomain = scale.domain();
                for (var i = 0, len = scaledDomain.length; i < len; ++i) {
                    if (scaledDomain[i] === Number.POSITIVE_INFINITY)
                        scaledDomain[i] = Number.MAX_VALUE;
                    else if (scaledDomain[i] === Number.NEGATIVE_INFINITY)
                        scaledDomain[i] = -Number.MAX_VALUE;
                }
                scale.domain(scaledDomain);
            }
            ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale;
            function calculatePosition(d, axisOptions) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var scaledY0 = yScale(0);
                var scaledX0 = xScale(0);
                switch (d.chartType) {
                    case visuals.ColumnChartType.stackedBar:
                    case visuals.ColumnChartType.hundredPercentStackedBar:
                        return scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.valueAbsolute)) +
                            visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case visuals.ColumnChartType.clusteredBar:
                        return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case visuals.ColumnChartType.stackedColumn:
                    case visuals.ColumnChartType.hundredPercentStackedColumn:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case visuals.ColumnChartType.clusteredColumn:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                }
            }
            ColumnUtil.calculatePosition = calculatePosition;
        })(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
        var ClusteredUtil;
        (function (ClusteredUtil) {
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var cols = mainGraphicsContext.selectAll(itemCS.selector)
                    .data([]);
                cols.exit().remove();
            }
            ClusteredUtil.clearColumns = clearColumns;
        })(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
        var StackedUtil;
        (function (StackedUtil) {
            var PctRoundingError = 0.0001;
            function getSize(scale, size, zeroVal) {
                if (zeroVal === void 0) { zeroVal = 0; }
                return visuals.AxisHelper.diffScaled(scale, zeroVal, size);
            }
            StackedUtil.getSize = getSize;
            function calcValueDomain(data, is100pct) {
                var defaultNumberRange = {
                    min: 0,
                    max: 10
                };
                if (data.length === 0)
                    return defaultNumberRange;
                // Can't use AxisHelper because Stacked layout has a slightly different calc, (position - valueAbs)
                var min = d3.min(data, function (d) { return d3.min(d.data, function (e) { return e.position - e.valueAbsolute; }); });
                var max = d3.max(data, function (d) { return d3.max(d.data, function (e) { return e.position; }); });
                if (is100pct) {
                    min = powerbi.Double.roundToPrecision(min, PctRoundingError);
                    max = powerbi.Double.roundToPrecision(max, PctRoundingError);
                }
                return {
                    min: min,
                    max: max,
                };
            }
            StackedUtil.calcValueDomain = calcValueDomain;
            function getStackedMultiplier(dataView, rowIdx, seriesCount, categoryCount, converterStrategy) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(rowIdx, 'rowIdx');
                var pos = 0, neg = 0;
                for (var i = 0; i < seriesCount; i++) {
                    var value = converterStrategy.getValueBySeriesAndCategory(i, rowIdx);
                    value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
                    if (value > 0)
                        pos += value;
                    else if (value < 0)
                        neg -= value;
                }
                var absTotal = pos + neg;
                return {
                    pos: pos ? (pos / absTotal) / pos : 1,
                    neg: neg ? (neg / absTotal) / neg : 1,
                };
            }
            StackedUtil.getStackedMultiplier = getStackedMultiplier;
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var bars = mainGraphicsContext.selectAll(itemCS.selector)
                    .data([]);
                bars.exit().remove();
            }
            StackedUtil.clearColumns = clearColumns;
        })(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var converterHelper;
        (function (converterHelper) {
            function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
                if (dataView.categories && dataView.categories.length > 0) {
                    // Need to pivot data if our category soure is a series role
                    var category = dataView.categories[0];
                    return category.source &&
                        DataRoleHelper.hasRole(category.source, seriesRoleName) &&
                        DataRoleHelper.hasRole(category.source, categoryRoleName);
                }
                return false;
            }
            converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;
            function getPivotedCategories(dataView, formatStringProp) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = dataView.categories[0];
                    var categoryValues = category.values;
                    return category.values.length > 0
                        ? {
                            categories: categoryValues,
                            categoryFormatter: visuals.valueFormatter.create({
                                format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
                                value: categoryValues[0],
                                value2: categoryValues[categoryValues.length - 1],
                                // Do not use display units such as K/M/bn etc. on the x-axis.
                                // PowerView does not use units either as large ranges will make the x-axis indecipherable.
                                displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose,
                            }),
                            categoryIdentities: category.identity,
                            categoryObjects: category.objects,
                        }
                        : {
                            categories: [],
                            categoryFormatter: { format: visuals.valueFormatter.format },
                        };
                }
                // For cases where the category source is just a series role, we are pivoting the data on the role which means we
                // will have no categories.
                return defaultCategories();
            }
            converterHelper.getPivotedCategories = getPivotedCategories;
            function getSeriesName(source) {
                debug.assertValue(source, 'source');
                return (source.groupName !== undefined)
                    ? source.groupName
                    : source.queryName;
            }
            converterHelper.getSeriesName = getSeriesName;
            function getFormattedLegendLabel(source, values, formatStringProp) {
                debug.assertValue(source, 'source');
                debug.assertValue(values, 'values');
                var sourceForFormat = source;
                var nameForFormat = source.displayName;
                if (source.groupName !== undefined) {
                    sourceForFormat = values.source;
                    nameForFormat = source.groupName;
                }
                return visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
            }
            converterHelper.getFormattedLegendLabel = getFormattedLegendLabel;
            function defaultCategories() {
                return {
                    categories: [null],
                    categoryFormatter: { format: visuals.valueFormatter.format },
                };
            }
            function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
                var xAxisLabel = null;
                var yAxisLabel = null;
                if (categoryAxisProperties) {
                    // Take the value only if it's there
                    if (category && category.displayName) {
                        xAxisLabel = category.displayName;
                    }
                }
                if (valueAxisProperties) {
                    var valuesNames = [];
                    if (values) {
                        // Take the name from the values, and make it unique because there are sometimes duplications
                        valuesNames = values.map(function (v) { return v ? v.displayName : ''; }).filter(function (value, index, self) { return value !== '' && self.indexOf(value) === index; });
                        yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames);
                    }
                }
                return { xAxisLabel: xAxisLabel, yAxisLabel: yAxisLabel };
            }
            converterHelper.createAxesLabels = createAxesLabels;
            function isImageUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return misc != null && misc.imageUrl === true;
            }
            converterHelper.isImageUrlColumn = isImageUrlColumn;
            function isWebUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return misc != null && misc.webUrl === true;
            }
            converterHelper.isWebUrlColumn = isWebUrlColumn;
            function getMiscellaneousTypeDescriptor(column) {
                return column
                    && column.type
                    && column.type.misc;
            }
            function hasImageUrlColumn(dataView) {
                if (!dataView || !dataView.metadata || _.isEmpty(dataView.metadata.columns))
                    return false;
                return _.any(dataView.metadata.columns, function (column) { return isImageUrlColumn(column) === true; });
            }
            converterHelper.hasImageUrlColumn = hasImageUrlColumn;
            function formatFromMetadataColumn(value, column, formatStringProp) {
                debug.assertValue(column, 'column should exist');
                var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
                formatString = formatString || column ? column.format : undefined;
                return visuals.valueFormatter.format(value, formatString);
            }
            converterHelper.formatFromMetadataColumn = formatFromMetadataColumn;
        })(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var LabelStyle = visuals.labelStyle;
        var dataLabelUtils;
        (function (dataLabelUtils) {
            dataLabelUtils.minLabelFontSize = 8;
            dataLabelUtils.labelMargin = 8;
            dataLabelUtils.maxLabelWidth = 50;
            dataLabelUtils.defaultColumnLabelMargin = 5;
            dataLabelUtils.defaultColumnHalfLabelHeight = 4;
            dataLabelUtils.DefaultDy = '-0.15em';
            dataLabelUtils.DefaultFontSizeInPt = 9;
            dataLabelUtils.StandardFontFamily = 'wf_segoe-ui_normal';
            dataLabelUtils.LabelTextProperties = {
                fontFamily: 'wf_standard-font',
                fontSize: PixelConverter.fromPoint(dataLabelUtils.DefaultFontSizeInPt),
                fontWeight: 'normal',
            };
            dataLabelUtils.defaultLabelColor = "#777777";
            dataLabelUtils.defaultInsideLabelColor = "#ffffff";
            dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %";
            dataLabelUtils.defaultLabelPrecision = undefined;
            var defaultCountLabelPrecision = 0;
            var labelGraphicsContextClass = createClassAndSelector('labels');
            var linesGraphicsContextClass = createClassAndSelector('lines');
            var labelsClass = createClassAndSelector('data-labels');
            var lineClass = createClassAndSelector('line-label');
            function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                if (labelsObj) {
                    if (labelsObj.show !== undefined)
                        labelSettings.show = labelsObj.show;
                    if (labelsObj.showSeries !== undefined)
                        labelSettings.show = labelsObj.showSeries;
                    if (labelsObj.color !== undefined)
                        labelSettings.labelColor = labelsObj.color.solid.color;
                    if (labelsObj.labelDisplayUnits !== undefined)
                        labelSettings.displayUnits = labelsObj.labelDisplayUnits;
                    if (labelsObj.labelPrecision !== undefined)
                        labelSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : dataLabelUtils.defaultLabelPrecision;
                    if (labelsObj.fontSize !== undefined)
                        labelSettings.fontSize = labelsObj.fontSize;
                    if (labelsObj.showAll !== undefined)
                        labelSettings.showLabelPerSeries = labelsObj.showAll;
                    if (labelsObj.labelStyle !== undefined)
                        labelSettings.labelStyle = labelsObj.labelStyle;
                }
            }
            dataLabelUtils.updateLabelSettingsFromLabelsObject = updateLabelSettingsFromLabelsObject;
            function updateLineChartLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                if (labelsObj && labelsObj.labelDensity !== undefined)
                    labelSettings.labelDensity = labelsObj.labelDensity;
            }
            dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject = updateLineChartLabelSettingsFromLabelsObject;
            function getDefaultLabelSettings(show, labelColor, fontSize) {
                if (show === void 0) { show = false; }
                return {
                    show: show,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: fontSize || dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings;
            function getDefaultCardLabelSettings(labelColor, categoryLabelColor, fontSize) {
                var labelSettings = getDefaultLabelSettings(true, labelColor, fontSize);
                labelSettings.showCategory = true;
                labelSettings.categoryLabelColor = categoryLabelColor;
                return labelSettings;
            }
            dataLabelUtils.getDefaultCardLabelSettings = getDefaultCardLabelSettings;
            function getDefaultTreemapLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    showCategory: true,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings;
            function getDefaultSunburstLabelSettings() {
                return {
                    show: false,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    showCategory: true,
                };
            }
            dataLabelUtils.getDefaultSunburstLabelSettings = getDefaultSunburstLabelSettings;
            function getDefaultColumnLabelSettings(isLabelPositionInside) {
                var labelSettings = getDefaultLabelSettings(false, undefined);
                labelSettings.position = null;
                labelSettings.labelColor = undefined;
                return labelSettings;
            }
            dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings;
            function getDefaultPointLabelSettings() {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings;
            function getDefaultLineChartLabelSettings(isComboChart) {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    labelDensity: isComboChart ? visuals.NewDataLabelUtils.LabelDensityMax : visuals.NewDataLabelUtils.LabelDensityMin,
                };
            }
            dataLabelUtils.getDefaultLineChartLabelSettings = getDefaultLineChartLabelSettings;
            function getDefaultMapLabelSettings() {
                return {
                    show: false,
                    showCategory: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultMapLabelSettings = getDefaultMapLabelSettings;
            function getDefaultDonutLabelSettings() {
                var labelSettings = dataLabelUtils.getDefaultLabelSettings(true, dataLabelUtils.defaultLabelColor, dataLabelUtils.DefaultFontSizeInPt);
                labelSettings.labelStyle = LabelStyle.category;
                return labelSettings;
            }
            dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings;
            function getDefaultGaugeLabelSettings() {
                return {
                    show: true,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: null,
                    position: null,
                    fontSize: dataLabelUtils.minLabelFontSize,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultGaugeLabelSettings = getDefaultGaugeLabelSettings;
            function getDefaultFunnelLabelSettings() {
                return {
                    show: true,
                    position: powerbi.visuals.labelPosition.insideCenter,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultFunnelLabelSettings = getDefaultFunnelLabelSettings;
            function getDefaultKpiLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    position: null,
                    showCategory: true,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultKpiLabelSettings = getDefaultKpiLabelSettings;
            function getLabelPrecision(precision, format) {
                debug.assertAnyValue(format, 'format');
                if (precision !== dataLabelUtils.defaultLabelPrecision)
                    return precision;
                if (format === 'g' || format === 'G')
                    return;
                if (format) {
                    // Calculate precision from positive format by default
                    var positiveFormat = format.split(";")[0];
                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
                    if (formatMetadata.hasDots) {
                        return formatMetadata.precision;
                    }
                }
                // For count fields we do not want a precision by default
                return defaultCountLabelPrecision;
            }
            dataLabelUtils.getLabelPrecision = getLabelPrecision;
            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection) {
                if (isAnimator === void 0) { isAnimator = false; }
                debug.assertValue(data, 'data cannot be null or undefined');
                // Hide and reposition labels that overlap
                var dataLabelManager = new powerbi.DataLabelManager();
                var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout);
                var hasAnimation = isAnimator && !!animationDuration;
                var labels = selectLabels(filteredData, context, false, hasAnimation);
                if (!labels)
                    return;
                if (hasAnimation) {
                    labels
                        .text(function (d) { return d.labeltext; })
                        .transition()
                        .duration(animationDuration)
                        .style(layout.style)
                        .style('opacity', hasSelection ? function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); } : 1)
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } });
                    labels
                        .exit()
                        .transition()
                        .duration(animationDuration)
                        .style('opacity', 0) //fade out labels that are removed
                        .remove();
                }
                else {
                    labels
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } })
                        .text(function (d) { return d.labeltext; })
                        .style(layout.style);
                    labels
                        .exit()
                        .remove();
                }
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart;
            /**
             * Note: Funnel chart uses animation and does not use collision detection.
             */
            function drawDefaultLabelsForFunnelChart(data, context, layout, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                debug.assertValue(data, 'data could not be null or undefined');
                var filteredData = data.filter(layout.filter);
                var labels = selectLabels(filteredData, context);
                if (!labels)
                    return;
                labels
                    .attr(layout.labelLayout)
                    .text(layout.labelText)
                    .style(layout.style);
                if (isAnimator && animationDuration) {
                    labels.transition().duration(animationDuration);
                }
                labels
                    .exit()
                    .remove();
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForFunnelChart = drawDefaultLabelsForFunnelChart;
            function selectLabels(filteredData, context, isDonut, forAnimation) {
                if (isDonut === void 0) { isDonut = false; }
                if (forAnimation === void 0) { forAnimation = false; }
                // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'
                if (filteredData.length === 0) {
                    cleanDataLabels(context, true);
                    return null;
                }
                if (context.select(labelGraphicsContextClass.selector).empty())
                    context.append('g').classed(labelGraphicsContextClass.class, true);
                // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity
                var hasKey = filteredData[0].key != null;
                var hasDataPointIdentity = filteredData[0].identity != null;
                var getIdentifier = hasKey ?
                    function (d) { return d.key; }
                    : hasDataPointIdentity ?
                        function (d) { return d.identity.getKey(); }
                        : undefined;
                var labels = isDonut ?
                    context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, function (d) { return d.data.identity.getKey(); })
                    : getIdentifier != null ?
                        context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, getIdentifier)
                        : context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData);
                var newLabels = labels.enter()
                    .append('text')
                    .classed(labelsClass.class, true);
                if (forAnimation)
                    newLabels.style('opacity', 0);
                return labels;
            }
            function cleanDataLabels(context, removeLines) {
                if (removeLines === void 0) { removeLines = false; }
                var empty = [];
                var labels = context.selectAll(labelsClass.selector).data(empty);
                labels.exit().remove();
                context.selectAll(labelGraphicsContextClass.selector).remove();
                if (removeLines) {
                    var lines = context.selectAll(lineClass.selector).data(empty);
                    lines.exit().remove();
                    context.selectAll(linesGraphicsContextClass.selector).remove();
                }
            }
            dataLabelUtils.cleanDataLabels = cleanDataLabels;
            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                context.selectAll(labelsClass.selector).style("fill-opacity", function (d) {
                    var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
                    return labelOpacity;
                });
            }
            dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity;
            function getLabelFormattedText(options) {
                var properties = {
                    text: options.formatter
                        ? options.formatter.format(options.label)
                        : powerbi.formattingService.formatValue(options.label, options.format),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: PixelConverter.fromPoint(options.fontSize),
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, options.maxWidth ? options.maxWidth : dataLabelUtils.maxLabelWidth);
            }
            dataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
                return {
                    x: function (d) { return xAxisProperties.scale(d.categoryIndex) + (categoryWidth / 2); },
                    y: function (d) { return getWaterfallLabelYPosition(yAxisProperties.scale, d, dataDomain); }
                };
            }
            dataLabelUtils.getLabelLayoutXYForWaterfall = getLabelLayoutXYForWaterfall;
            function getWaterfallLabelYPosition(scale, d, dataDomain) {
                var yValue = scale(0) - scale(Math.abs(d.value));
                var yPos = scale(d.position);
                var scaleMinDomain = scale(dataDomain[0]);
                var endPosition = scale(d.position + d.value);
                if (d.value < 0) {
                    var properties = {
                        text: d.labeltext,
                        fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    var outsideBelowPosition = yPos + yValue + powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                    if (scaleMinDomain > outsideBelowPosition) {
                        return outsideBelowPosition;
                    }
                }
                else {
                    var outsideAbovePosition = yPos - yValue - dataLabelUtils.labelMargin;
                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                    if (outsideAbovePosition > 0) {
                        return outsideAbovePosition;
                    }
                }
                d.isLabelInside = true;
                return getWaterfallInsideLabelYPosition(yPos, endPosition, scaleMinDomain);
            }
            function getWaterfallInsideLabelYPosition(startPosition, endPosition, scaleMinDomain) {
                // Get the start and end position of the column
                // If the start or end is outside of the visual because of clipping - adjust the position
                startPosition = startPosition < 0 ? 0 : startPosition;
                startPosition = startPosition > scaleMinDomain ? scaleMinDomain : startPosition;
                endPosition = endPosition < 0 ? 0 : endPosition;
                endPosition = endPosition > scaleMinDomain ? scaleMinDomain : endPosition;
                return (Math.abs(endPosition - startPosition) / 2) + Math.min(startPosition, endPosition);
            }
            function doesDataLabelFitInShape(d, yAxisProperties, layout) {
                if (d == null || d.value === null)
                    return false;
                var properties = {
                    text: layout.labelText(d),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                var outsidePosition = visuals.WaterfallChart.getRectTop(yAxisProperties.scale, d.position, d.value) - dataLabelUtils.labelMargin;
                // The shape is fit to be outside
                if (outsidePosition > 0)
                    return true;
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var shapeWidth = layout.categoryWidth;
                var shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yAxisProperties.scale, Math.max(0, Math.abs(d.value)), 0));
                //checking that labels aren't greater than shape
                if ((textWidth > shapeWidth) || (textHeight > shapeHeight))
                    return false;
                return true;
            }
            dataLabelUtils.doesDataLabelFitInShape = doesDataLabelFitInShape;
            function getMapLabelLayout(labelSettings) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText({
                            label: d.labeltext,
                            fontSize: labelSettings.fontSize
                        });
                    },
                    labelLayout: {
                        x: function (d) { return d.x; },
                        y: function (d) {
                            var margin = d.radius + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? d.y - margin : d.y + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.labeltext != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'font-size': PixelConverter.fromPoint(labelSettings.fontSize),
                    },
                };
            }
            dataLabelUtils.getMapLabelLayout = getMapLabelLayout;
            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth) {
                var formatOverride = (isHundredPercent) ? dataLabelUtils.hundredPercentFormat : null;
                var formattersCache = createColumnFormatterCacheManager();
                var hasSelection = interactivityService ? interactivityService.hasSelection() : false;
                return {
                    labelText: function (d) {
                        var formatString = (formatOverride != null) ? formatOverride : d.labelFormatString;
                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
                        var formatter = formattersCache.getOrCreate(formatString, d.labelSettings, value2);
                        return getLabelFormattedText({
                            label: formatter.format(d.value),
                            maxWidth: dataLabelUtils.maxLabelWidth
                        });
                    },
                    labelLayout: labelLayoutXY,
                    filter: function (d) { return dataLabelUtils.getColumnChartLabelFilter(d, hasSelection, data.hasHighlights, axisOptions, visualWidth); },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'text-anchor': isColumn ? 'middle' : 'start',
                    },
                };
            }
            dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout;
            /**
             * Valide for stacked column/bar chart and 100% stacked column/bar chart,
             * that labels that should to be inside the shape aren't bigger then shapes.
             */
            function validateLabelsSize(d, axisOptions, visualWidth) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var columnWidth = axisOptions.columnWidth;
                var properties = {
                    text: d.labeltext,
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var shapeWidth, shapeHeight;
                var inside = false;
                var outsidePosition = visuals.ColumnUtil.calculatePosition(d, axisOptions);
                switch (d.chartType) {
                    case visuals.ColumnChartType.stackedBar:
                    case visuals.ColumnChartType.hundredPercentStackedBar:
                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
                        if (!d.lastSeries || (outsidePosition + textWidth > visualWidth) || d.chartType === visuals.ColumnChartType.hundredPercentStackedBar) {
                            shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                            shapeHeight = columnWidth;
                            inside = true;
                        }
                        break;
                    case visuals.ColumnChartType.clusteredBar:
                        // if the label doesn't fit where specified, then it should be inside 
                        if ((outsidePosition + textWidth) > visualWidth) {
                            shapeWidth = Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value));
                            shapeHeight = columnWidth;
                            inside = true;
                        }
                        break;
                    case visuals.ColumnChartType.stackedColumn:
                    case visuals.ColumnChartType.hundredPercentStackedColumn:
                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
                        if (!d.lastSeries || outsidePosition <= 0 || d.chartType === visuals.ColumnChartType.hundredPercentStackedColumn) {
                            shapeWidth = columnWidth;
                            shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                            inside = true;
                        }
                        break;
                    case visuals.ColumnChartType.clusteredColumn:
                        // if the label doesn't fit where specified, then it should be inside 
                        if (outsidePosition <= 0) {
                            shapeWidth = columnWidth;
                            shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value));
                            inside = true;
                        }
                        break;
                    default:
                        return true;
                }
                //checking that labels aren't greater than shape
                if (inside && ((textWidth > shapeWidth) || textHeight > shapeHeight))
                    return false;
                return true;
            }
            function getColumnChartLabelFilter(d, hasSelection, hasHighlights, axisOptions, visualWidth) {
                //labels of dimmed are hidden
                var shapesOpacity = hasSelection ? visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) :
                    visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                return (d != null && d.value != null && validateLabelsSize(d, axisOptions, visualWidth) && shapesOpacity === 1);
            }
            dataLabelUtils.getColumnChartLabelFilter = getColumnChartLabelFilter;
            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText({
                            label: d.formattedCategory.getValue(),
                            maxWidth: dataLabelUtils.maxLabelWidth * 2.0
                        });
                    },
                    labelLayout: {
                        x: function (d) { return xScale(d.x); },
                        y: function (d) {
                            var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.formattedCategory.getValue() != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                    },
                };
            }
            dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout;
            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar, axisFormatter) {
                var formattersCache = createColumnFormatterCacheManager();
                return {
                    labelText: function (d) {
                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
                        var formatter = formattersCache.getOrCreate(d.labelFormatString, d.labelSettings, value2);
                        return getLabelFormattedText({ label: formatter.format(d.value) });
                    },
                    labelLayout: {
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex); },
                        y: function (d) { return labelSettings.position === 0 /* Above */ ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin; },
                    },
                    filter: function (d) {
                        return (d != null && d.value != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'font-size': function (d) { return PixelConverter.fromPoint(d.labelSettings.fontSize); },
                    },
                };
            }
            dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout;
            function getFunnelChartLabelLayout(data, axisOptions, textMinimumPadding, labelSettings, currentViewport) {
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var marginLeft = axisOptions.margin.left;
                var innerTextHeightRate = 0.7;
                var rangeBand = axisOptions.xScale.rangeBand();
                //the bars are tranform, verticalRange mean horizontal range, xScale is y, yscale is x
                var pixelSpan = axisOptions.verticalRange / 2;
                var formatString = visuals.valueFormatter.getFormatString(data.valuesMetadata[0], visuals.funnelChartProps.general.formatString);
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                var value2 = null;
                if (labelSettings.displayUnits === 0) {
                    var minY = d3.min(data.slices, function (d) { return d.value; });
                    var maxY = d3.max(data.slices, function (d) { return d.value; });
                    value2 = Math.max(Math.abs(minY), Math.abs(maxY));
                }
                var formattersCache = createColumnFormatterCacheManager();
                return {
                    labelText: function (d) {
                        var barWidth = Math.abs(yScale(d.value) - yScale(0));
                        var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - (textMinimumPadding * 2);
                        var outsideAvailableSpace = pixelSpan - (barWidth / 2) - textMinimumPadding;
                        var labelFormatString = (formatString != null) ? formatString : d.labelFormatString;
                        var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                        var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings, value2);
                        var labelText = formatter.format(visuals.FunnelChart.getFunnelSliceValue(d, true /* asOriginal */));
                        return getLabelFormattedText({
                            label: labelText,
                            maxWidth: maximumTextSize,
                            fontSize: labelSettings.fontSize
                        });
                    },
                    labelLayout: {
                        y: function (d, i) {
                            var properties = {
                                text: d.labeltext,
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            //in order to make it center aligned we should 'correct' the height to not calculate text margin
                            var labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                            return xScale(i) + (rangeBand / 2) + (labelHeight / 2);
                        },
                        x: function (d) {
                            var barWidth = Math.abs(yScale(d.value) - yScale(0));
                            var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - (textMinimumPadding * 2);
                            var outsideAvailableSpace = pixelSpan - (barWidth / 2) - textMinimumPadding;
                            var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                            var labelFormatString = (formatString != null) ? formatString : d.labelFormatString;
                            var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings, value2);
                            var labelText = formatter.format(visuals.FunnelChart.getFunnelSliceValue(d, true /* asOriginal */));
                            var properties = {
                                text: getLabelFormattedText({
                                    label: labelText,
                                    maxWidth: maximumTextSize
                                }),
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            var textLength = textMeasurer(properties);
                            // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                            var labelPositionValue = labelSettings.position;
                            if ((labelPositionValue === visuals.labelPosition.outsideEnd && outsideAvailableSpace < textLength) || d.value === 0)
                                labelPositionValue = visuals.labelPosition.insideCenter;
                            else if (labelPositionValue === visuals.labelPosition.insideCenter && insideAvailableSpace < textLength) {
                                labelPositionValue = visuals.labelPosition.outsideEnd;
                            }
                            switch (labelPositionValue) {
                                case visuals.labelPosition.outsideEnd:
                                    return marginLeft + pixelSpan + (barWidth / 2) + textMinimumPadding + (textLength / 2);
                                default:
                                    // Inside position, change color to white unless value is 0
                                    d.labelFill = d.value !== 0 ? dataLabelUtils.defaultInsideLabelColor : d.labelFill;
                                    return marginLeft + pixelSpan;
                            }
                        },
                        dy: '-0.15em',
                    },
                    filter: function (d) {
                        if (!(d != null && d.value != null && data.hasHighlights === !!d.highlight))
                            return false;
                        var properties = {
                            text: d.labeltext,
                            fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                            fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties) * innerTextHeightRate;
                        return labelHeight < rangeBand;
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'fill-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, false, false); },
                        'font-size': function (d) { return PixelConverter.fromPoint(labelSettings.fontSize); },
                    },
                };
            }
            dataLabelUtils.getFunnelChartLabelLayout = getFunnelChartLabelLayout;
            function enumerateDataLabels(options) {
                debug.assertValue(options, 'options');
                debug.assertValue(options.enumeration, 'enumeration');
                if (!options.dataLabelsSettings)
                    return;
                var instance = {
                    objectName: 'labels',
                    selector: options.selector,
                    properties: {},
                };
                if (options.show && options.selector) {
                    instance.properties['showSeries'] = options.dataLabelsSettings.show;
                }
                else if (options.show) {
                    instance.properties['show'] = options.dataLabelsSettings.show;
                }
                instance.properties['color'] = options.dataLabelsSettings.labelColor || dataLabelUtils.defaultLabelColor;
                if (options.displayUnits) {
                    instance.properties['labelDisplayUnits'] = options.dataLabelsSettings.displayUnits;
                }
                if (options.precision) {
                    var precision = options.dataLabelsSettings.precision;
                    instance.properties['labelPrecision'] = precision === dataLabelUtils.defaultLabelPrecision ? null : precision;
                }
                if (options.position) {
                    instance.properties['labelPosition'] = options.dataLabelsSettings.position;
                    if (options.positionObject) {
                        debug.assert(!instance.validValues, '!instance.validValues');
                        instance.validValues = { 'labelPosition': options.positionObject };
                    }
                }
                if (options.labelStyle)
                    instance.properties['labelStyle'] = options.dataLabelsSettings.labelStyle;
                if (options.fontSize)
                    instance.properties['fontSize'] = options.dataLabelsSettings.fontSize;
                if (options.labelDensity) {
                    var lineChartSettings = options.dataLabelsSettings;
                    if (lineChartSettings)
                        instance.properties['labelDensity'] = lineChartSettings.labelDensity;
                }
                //Keep show all as the last property of the instance.
                if (options.showAll)
                    instance.properties['showAll'] = options.dataLabelsSettings.showLabelPerSeries;
                return options.enumeration.pushInstance(instance);
            }
            dataLabelUtils.enumerateDataLabels = enumerateDataLabels;
            function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory, fontSize) {
                if (isShowCategory === void 0) { isShowCategory = false; }
                var labelSettings = (dataLabelsSettings)
                    ? dataLabelsSettings
                    : getDefaultPointLabelSettings();
                var instance = {
                    objectName: 'categoryLabels',
                    selector: null,
                    properties: {
                        show: isShowCategory
                            ? labelSettings.showCategory
                            : labelSettings.show,
                        fontSize: dataLabelsSettings ? dataLabelsSettings.fontSize : dataLabelUtils.DefaultFontSizeInPt,
                    },
                };
                if (withFill) {
                    instance.properties['color'] = labelSettings.categoryLabelColor
                        ? labelSettings.categoryLabelColor
                        : labelSettings.labelColor;
                }
                if (fontSize) {
                    instance.properties['fontSize'] = fontSize;
                }
                enumeration.pushInstance(instance);
            }
            dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels;
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
                    return axisFormatter.displayUnit.value;
                return null;
            }
            function createColumnFormatterCacheManager() {
                return {
                    cache: { defaultFormatter: null, },
                    getOrCreate: function (formatString, labelSetting, value2) {
                        if (formatString) {
                            var cacheKeyObject = {
                                formatString: formatString,
                                displayUnits: labelSetting.displayUnits,
                                precision: getLabelPrecision(labelSetting.precision, formatString),
                                value2: value2
                            };
                            var cacheKey = JSON.stringify(cacheKeyObject);
                            if (!this.cache[cacheKey])
                                this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                            return this.cache[cacheKey];
                        }
                        if (!this.cache.defaultFormatter) {
                            this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision));
                        }
                        return this.cache.defaultFormatter;
                    }
                };
            }
            dataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            dataLabelUtils.getOptionsForLabelFormatter = getOptionsForLabelFormatter;
            function isTextWidthOverflows(textWidth, maxTextWidth) {
                return textWidth > maxTextWidth;
            }
            dataLabelUtils.isTextWidthOverflows = isTextWidthOverflows;
            ;
            function isTextHeightOverflows(textHeight, innerChordLength) {
                return textHeight > innerChordLength;
            }
            dataLabelUtils.isTextHeightOverflows = isTextHeightOverflows;
            ;
        })(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DonutLabelUtils;
        (function (DonutLabelUtils) {
            DonutLabelUtils.LineStrokeWidth = 1;
            DonutLabelUtils.DiagonalLineIndex = 0;
            DonutLabelUtils.HorizontalLineIndex = 1;
            function getLabelLeaderLineForDonutChart(donutArcDescriptor, donutProperties, parentPoint, sliceArc) {
                if (sliceArc === void 0) { sliceArc = 0; }
                var innerLinePointMultiplier = 2.05;
                var textPoint;
                var midPoint;
                var chartPoint;
                // Label position has changed
                if (sliceArc) {
                    var arc = sliceArc;
                    var outerRadius = donutProperties.radius * donutProperties.outerArcRadiusRatio;
                    var innerRadius = (donutProperties.radius / 2) * donutProperties.innerArcRadiusRatio;
                    midPoint = [Math.cos(arc) * outerRadius, Math.sin(arc) * outerRadius];
                    chartPoint = [Math.cos(arc) * innerRadius, Math.sin(arc) * innerRadius];
                }
                else {
                    midPoint = donutProperties.outerArc.centroid(donutArcDescriptor);
                    chartPoint = donutProperties.arc.centroid(donutArcDescriptor);
                }
                var textPointX = parentPoint.x;
                var lineMargin = visuals.NewDataLabelUtils.maxLabelOffset / 2;
                textPointX += textPointX < 0 ? -lineMargin : lineMargin;
                textPoint = [textPointX, parentPoint.y];
                chartPoint[0] *= innerLinePointMultiplier;
                chartPoint[1] *= innerLinePointMultiplier;
                return [chartPoint, midPoint, textPoint];
            }
            DonutLabelUtils.getLabelLeaderLineForDonutChart = getLabelLeaderLineForDonutChart;
            /** We calculate the rectangles of the leader lines for collision detection
              *width: x2 - x1; height: y2 - y1 */
            function getLabelLeaderLinesSizeForDonutChart(leaderLinePoints) {
                if (leaderLinePoints && leaderLinePoints.length > 2) {
                    var diagonalLineSize = {
                        width: Math.abs(leaderLinePoints[1][0] - leaderLinePoints[0][0]),
                        height: Math.abs(leaderLinePoints[1][1] - leaderLinePoints[0][1]),
                    };
                    // For horizontal line we set 1 in the height
                    var horizontalLineSize = {
                        width: Math.abs(leaderLinePoints[2][0] - leaderLinePoints[1][0]),
                        height: DonutLabelUtils.LineStrokeWidth,
                    };
                    return [diagonalLineSize, horizontalLineSize];
                }
                return null;
            }
            DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart = getLabelLeaderLinesSizeForDonutChart;
            function getXPositionForDonutLabel(textPointX) {
                var margin = textPointX < 0 ? -visuals.NewDataLabelUtils.maxLabelOffset : visuals.NewDataLabelUtils.maxLabelOffset;
                return textPointX += margin;
            }
            DonutLabelUtils.getXPositionForDonutLabel = getXPositionForDonutLabel;
            function getSpaceAvailableForDonutLabels(labelXPos, viewport) {
                return viewport.width / 2 - Math.abs(labelXPos) - visuals.NewDataLabelUtils.maxLabelOffset;
            }
            DonutLabelUtils.getSpaceAvailableForDonutLabels = getSpaceAvailableForDonutLabels;
        })(DonutLabelUtils = visuals.DonutLabelUtils || (visuals.DonutLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var NewDataLabelUtils;
        (function (NewDataLabelUtils) {
            NewDataLabelUtils.DefaultLabelFontSizeInPt = 9;
            NewDataLabelUtils.MapPolylineOpacity = 0.5;
            NewDataLabelUtils.LabelDensityBufferFactor = 3;
            NewDataLabelUtils.LabelDensityPadding = 6;
            NewDataLabelUtils.LabelDensityMin = 0;
            NewDataLabelUtils.LabelDensityMax = 6;
            NewDataLabelUtils.startingLabelOffset = 8;
            NewDataLabelUtils.maxLabelOffset = 8;
            NewDataLabelUtils.maxLabelWidth = 50;
            NewDataLabelUtils.hundredPercentFormat = '0.00 %;-0.00 %;0.00 %';
            NewDataLabelUtils.LabelTextProperties = {
                fontFamily: 'wf_standard-font',
                fontSize: PixelConverter.fromPoint(NewDataLabelUtils.DefaultLabelFontSizeInPt),
                fontWeight: 'normal',
            };
            NewDataLabelUtils.defaultLabelColor = "#777777";
            NewDataLabelUtils.defaultInsideLabelColor = "#ffffff"; //white
            NewDataLabelUtils.horizontalLabelBackgroundPadding = 4;
            NewDataLabelUtils.verticalLabelBackgroundPadding = 2;
            var labelBackgroundRounding = 4;
            var defaultLabelPrecision = undefined;
            var defaultCountLabelPrecision = 0;
            NewDataLabelUtils.labelGraphicsContextClass = createClassAndSelector('labelGraphicsContext');
            NewDataLabelUtils.labelBackgroundGraphicsContextClass = createClassAndSelector('labelBackgroundGraphicsContext');
            var labelsClass = createClassAndSelector('label');
            var secondLineLabelClass = createClassAndSelector('label-second-line');
            var linesGraphicsContextClass = createClassAndSelector('leader-lines');
            var lineClass = createClassAndSelector('line-label');
            function drawDefaultLabels(context, dataLabels, numeric, twoRows, hasTooltip) {
                if (numeric === void 0) { numeric = false; }
                if (twoRows === void 0) { twoRows = false; }
                if (hasTooltip === void 0) { hasTooltip = false; }
                var filteredDataLabels = _.filter(dataLabels, function (d) { return d.isVisible; });
                var labels = context.selectAll(labelsClass.selector)
                    .data(filteredDataLabels, labelKeyFunction);
                labels.enter()
                    .append("text")
                    .classed(labelsClass.class, true);
                var labelAttr = {
                    x: function (d) {
                        return (d.boundingBox.left + (d.boundingBox.width / 2));
                    },
                    y: function (d) {
                        if (d.hasBackground)
                            return d.boundingBox.top + d.boundingBox.height - NewDataLabelUtils.verticalLabelBackgroundPadding;
                        else
                            return d.boundingBox.top + d.boundingBox.height;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                labels
                    .text(function (d) { return d.text; })
                    .attr(labelAttr)
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                    'text-anchor': function (d) { return d.textAnchor; },
                });
                labels.exit()
                    .remove();
                var filteredCategoryLabels = _.filter(twoRows ? dataLabels : [], function (d) { return d.isVisible && !_.isEmpty(d.secondRowText); });
                var secondLineLabels = context.selectAll(secondLineLabelClass.selector)
                    .data(filteredCategoryLabels, function (d, index) { return d.identity ? d.identity.getKeyWithoutHighlight() : index; });
                secondLineLabels.enter()
                    .append("text")
                    .classed(secondLineLabelClass.class, true);
                labelAttr = {
                    x: function (d) {
                        return (d.boundingBox.left + (d.boundingBox.width / 2));
                    },
                    y: function (d) {
                        var boundingBoxHeight = (d.text !== undefined) ? d.boundingBox.height / 2 : d.boundingBox.height;
                        if (d.hasBackground)
                            return d.boundingBox.top + boundingBoxHeight - NewDataLabelUtils.verticalLabelBackgroundPadding;
                        else
                            return d.boundingBox.top + boundingBoxHeight;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                secondLineLabels
                    .text(function (d) { return d.secondRowText; })
                    .attr(labelAttr)
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                    'text-anchor': function (d) { return d.textAnchor; },
                });
                secondLineLabels.exit()
                    .remove();
                if (hasTooltip) {
                    labels.append('title').text(function (d) { return d.tooltip; });
                    secondLineLabels.append('title').text(function (d) { return d.tooltip; });
                    labels.style("pointer-events", "all");
                    secondLineLabels.style("pointer-events", "all");
                }
                return labels;
            }
            NewDataLabelUtils.drawDefaultLabels = drawDefaultLabels;
            function animateDefaultLabels(context, dataLabels, duration, numeric, easeType) {
                if (numeric === void 0) { numeric = false; }
                if (easeType === void 0) { easeType = 'cubic-in-out'; }
                var labels = context.selectAll(labelsClass.selector)
                    .data(_.filter(dataLabels, function (d) { return d.isVisible; }), labelKeyFunction);
                labels.enter()
                    .append("text")
                    .classed(labelsClass.class, true)
                    .style('opacity', 0);
                var labelAttr = {
                    x: function (d) {
                        return (d.boundingBox.left + (d.boundingBox.width / 2));
                    },
                    y: function (d) {
                        return d.boundingBox.top + d.boundingBox.height;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                labels.text(function (d) { return d.text; })
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                })
                    .transition()
                    .ease(easeType)
                    .duration(duration)
                    .attr(labelAttr)
                    .style('opacity', 1);
                labels.exit()
                    .transition()
                    .duration(duration)
                    .style('opacity', 0)
                    .remove();
                return labels;
            }
            NewDataLabelUtils.animateDefaultLabels = animateDefaultLabels;
            /** Draws black rectangles based on the bounding bx of labels, to be used in debugging */
            function drawLabelBackground(context, dataLabels, fill, fillOpacity) {
                var labelRects = context.selectAll("rect")
                    .data(_.filter(dataLabels, function (d) { return d.isVisible; }), labelKeyFunction);
                labelRects.enter()
                    .append("rect");
                labelRects
                    .attr({
                    x: function (d) {
                        return d.boundingBox.left - NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    y: function (d) {
                        return d.boundingBox.top - NewDataLabelUtils.verticalLabelBackgroundPadding;
                    },
                    rx: labelBackgroundRounding,
                    ry: labelBackgroundRounding,
                    width: function (d) {
                        return d.boundingBox.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    height: function (d) {
                        if (d.text === undefined && d.secondRowText === undefined) {
                            return 0;
                        }
                        return d.boundingBox.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding;
                    },
                })
                    .style("fill", fill ? fill : "#000000")
                    .style("fill-opacity", fillOpacity != null ? fillOpacity : 1);
                labelRects.exit()
                    .remove();
                return labelRects;
            }
            NewDataLabelUtils.drawLabelBackground = drawLabelBackground;
            function drawLabelLeaderLines(context, filteredDataLabels, key, leaderLineColor) {
                if (context.select(linesGraphicsContextClass.selector).empty())
                    context.append('g').classed(linesGraphicsContextClass.class, true);
                var lines = context.select(linesGraphicsContextClass.selector).selectAll('polyline')
                    .data(filteredDataLabels, key);
                lines.enter()
                    .append('polyline')
                    .classed(lineClass.class, true);
                lines
                    .attr('points', function (d) {
                    return d.leaderLinePoints;
                }).
                    style({
                    'stroke': function (d) { return leaderLineColor ? leaderLineColor : d.fill; },
                    'stroke-width': visuals.DonutLabelUtils.LineStrokeWidth,
                });
                lines
                    .exit()
                    .remove();
            }
            NewDataLabelUtils.drawLabelLeaderLines = drawLabelLeaderLines;
            function getLabelFormattedText(label, format, formatter) {
                return formatter ? formatter.format(label) : powerbi.formattingService.formatValue(label, format);
            }
            NewDataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
                    return axisFormatter.displayUnit.value;
                return null;
            }
            NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter;
            function getLabelPrecision(precision, format) {
                debug.assertAnyValue(format, 'format');
                if (precision !== defaultLabelPrecision)
                    return precision;
                if (format) {
                    // Calculate precision from positive format by default
                    var positiveFormat = format.split(";")[0];
                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
                    if (formatMetadata.hasDots) {
                        return formatMetadata.precision;
                    }
                }
                // For count fields we do not want a precision by default
                return defaultCountLabelPrecision;
            }
            function createColumnFormatterCacheManager() {
                return {
                    cache: { defaultFormatter: null, },
                    getOrCreate: function (formatString, labelSetting, value2) {
                        if (formatString) {
                            var cacheKeyObject = {
                                formatString: formatString,
                                displayUnits: labelSetting.displayUnits,
                                precision: getLabelPrecision(labelSetting.precision, formatString),
                                value2: value2
                            };
                            var cacheKey = JSON.stringify(cacheKeyObject);
                            if (!this.cache[cacheKey])
                                this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                            return this.cache[cacheKey];
                        }
                        if (!this.cache.defaultFormatter) {
                            this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision));
                        }
                        return this.cache.defaultFormatter;
                    }
                };
            }
            NewDataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            function removeDuplicates(labelDataPoints) {
                var uniqueLabelDataPoints = [];
                var labelDataPointMap = {};
                var sameParentIsInArray = function (newValue, array, parentIsRect) {
                    return array.some(function (arrayValue) {
                        if (parentIsRect) {
                            return visuals.shapes.Rect.equals(newValue.parentShape.rect, arrayValue.rect);
                        }
                        else {
                            return visuals.shapes.Point.equals(newValue.parentShape.point, arrayValue.point);
                        }
                    });
                };
                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                    var dataPoint = labelDataPoints_1[_i];
                    var parentIsRect = dataPoint.parentType === 1 /* Rectangle */;
                    var resultsFromMap = labelDataPointMap[dataPoint.text];
                    if (!resultsFromMap) {
                        uniqueLabelDataPoints.push(dataPoint);
                        labelDataPointMap[dataPoint.text] = [dataPoint.parentShape];
                    }
                    else {
                        if (!sameParentIsInArray(dataPoint, resultsFromMap, parentIsRect)) {
                            uniqueLabelDataPoints.push(dataPoint);
                            resultsFromMap.push(dataPoint.parentShape);
                        }
                    }
                }
                return uniqueLabelDataPoints;
            }
            NewDataLabelUtils.removeDuplicates = removeDuplicates;
            function getDataLabelLayoutOptions(type) {
                switch (type) {
                    case 9 /* Scatter */:
                        return {
                            maximumOffset: visuals.ScatterChart.dataLabelLayoutMaximumOffset,
                            startingOffset: visuals.ScatterChart.dataLabelLayoutStartingOffset,
                            offsetIterationDelta: visuals.ScatterChart.dataLabelLayoutOffsetIterationDelta,
                            allowLeaderLines: true,
                            attemptToMoveLabelsIntoViewport: true,
                        };
                    default:
                        return {
                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
                            startingOffset: NewDataLabelUtils.startingLabelOffset,
                            attemptToMoveLabelsIntoViewport: true,
                        };
                }
            }
            NewDataLabelUtils.getDataLabelLayoutOptions = getDataLabelLayoutOptions;
            function getTextSize(text, fontSize) {
                var labelTextProperties = NewDataLabelUtils.LabelTextProperties;
                var properties = {
                    text: text,
                    fontFamily: labelTextProperties.fontFamily,
                    fontSize: jsCommon.PixelConverter.fromPoint(fontSize),
                    fontWeight: labelTextProperties.fontWeight,
                };
                return {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
                };
            }
            NewDataLabelUtils.getTextSize = getTextSize;
            /**
             * Obtains the key from the label.  Index is required to use as a backup in cases
             * where labels have no key or identity.
             */
            function labelKeyFunction(label, index) {
                if (label.key) {
                    return label.key;
                }
                if (label.identity) {
                    return label.identity.getKeyWithoutHighlight();
                }
                return index;
            }
        })(NewDataLabelUtils = visuals.NewDataLabelUtils || (visuals.NewDataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var KpiUtil;
        (function (KpiUtil) {
            var KPIImageClassName = 'powervisuals-glyph';
            var BigImageClassName = 'big-kpi';
            var RYGStatusIconClassNames = ['kpi-red', 'kpi-yellow', 'kpi-green'];
            var threeLights = {
                kpiIconClass: 'circle',
                statusValues: RYGStatusIconClassNames,
            };
            var roadSigns = {
                kpiIconClass: '',
                statusValues: ['circle-x kpi-red', 'circle-exclamation kpi-yellow', 'circle-checkmark kpi-green'],
            };
            var trafficLight = {
                kpiIconClass: 'traffic-light',
                statusValues: RYGStatusIconClassNames,
            };
            var shapes = {
                kpiIconClass: '',
                statusValues: ['rhombus kpi-red', 'triangle kpi-yellow', 'circle kpi-green'],
            };
            var gauge = {
                kpiIconClass: '',
                statusValues: ['circle-empty', 'circle-one-quarter', 'circle-half', 'circle-three-quarters', 'circle-full'],
            };
            var statusGraphicFormatStrings = {
                'THREE CIRCLES COLORED': threeLights,
                'TRAFFIC LIGHT - SINGLE': threeLights,
                'THREE FLAGS COLORED': {
                    kpiIconClass: 'flag',
                    statusValues: RYGStatusIconClassNames,
                },
                'ROAD SIGNS': roadSigns,
                'THREE SYMBOLS CIRCLED COLORED': roadSigns,
                'TRAFFIC LIGHT': trafficLight,
                'THREE TRAFFIC LIGHTS RIMMED COLORED': trafficLight,
                'THREE SYMBOLS UNCIRCLED COLORED': {
                    kpiIconClass: '',
                    statusValues: ['x kpi-red', 'exclamation kpi-yellow', 'checkmark kpi-green'],
                },
                'SHAPES': shapes,
                'SMILEY FACE': shapes,
                'THERMOMETER': shapes,
                'CYLINDER': shapes,
                'THREE SIGNS COLORED': shapes,
                'THREE STARS COLORED': {
                    kpiIconClass: 'star-stacked',
                    statusValues: ['star-empty', 'star-half-full', 'star-full'],
                },
                'FIVE BARS COLORED': {
                    kpiIconClass: 'bars-stacked',
                    statusValues: ['bars-zero', 'bars-one', 'bars-two', 'bars-three', 'bars-four'],
                },
                'FIVE BOXES COLORED': {
                    kpiIconClass: 'boxes-stacked',
                    statusValues: ['boxes-zero', 'boxes-one', 'boxes-two', 'boxes-three', 'boxes-four'],
                },
                'FIVE QUARTERS COLORED': gauge,
                'GAUGE - ASCENDING': gauge,
                'GAUGE - DESCENDING': {
                    kpiIconClass: '',
                    statusValues: ['circle-full', 'circle-three-quarters', 'circle-half', 'circle-one-quarter', 'circle-empty'],
                },
                'STANDARD ARROW': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down', 'arrow-right-down', 'arrow-right', 'arrow-right-up', 'arrow-up'],
                },
                'VARIANCE ARROW': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down kpi-red', 'arrow-right kpi-yellow', 'arrow-up kpi-green'],
                },
                'STATUS ARROW - ASCENDING': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down kpi-red', 'arrow-right-down kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-up kpi-yellow', 'arrow-up kpi-green'],
                },
                'STATUS ARROW - DESCENDING': {
                    kpiIconClass: '',
                    statusValues: ['arrow-up kpi-green', 'arrow-right-up kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-down kpi-yellow', 'arrow-down kpi-red'],
                },
            };
            function getKpiIcon(kpi, value) {
                var numValue = parseFloat(value);
                if (!kpi)
                    return;
                var statusGraphicFormat = statusGraphicFormatStrings[kpi.graphic.toUpperCase()];
                if (!statusGraphicFormat || isNaN(numValue))
                    return undefined;
                var statusValues = statusGraphicFormat.statusValues;
                // Normalize range of (-1, -0.5, 0, 0.5, 1) to (-2, -1, 0, 1, 2)
                if (kpi.normalizedFiveStateKpiRange && statusValues.length === 5)
                    numValue = numValue * 2;
                // Convert values from the range of (-n/2, ..., 0, ..., n/2) to (0, 1, ..., n-1)
                var num = numValue + Math.floor(statusValues.length / 2);
                return [statusGraphicFormat.kpiIconClass, statusValues[num]].join(' ').trim();
            }
            function getKpiIconClassName(kpiIcon, kpiImageSize) {
                if (!kpiIcon)
                    return undefined;
                if (kpiImageSize === 1 /* Big */)
                    return [KPIImageClassName, BigImageClassName, kpiIcon].join(' ');
                else
                    return [KPIImageClassName, kpiIcon].join(' ');
            }
            function getClassForKpi(kpi, value, kpiImageSize) {
                debug.assertValue(kpi, 'kpi');
                debug.assertValue(value, 'value');
                var kpiIcon = getKpiIcon(kpi, value);
                return getKpiIconClassName(kpiIcon, kpiImageSize);
            }
            KpiUtil.getClassForKpi = getClassForKpi;
            function getKpiImageMetadata(metaDataColumn, value, kpiImageSize) {
                var kpi = metaDataColumn && metaDataColumn.kpi;
                if (kpi) {
                    var kpiIcon = getKpiIcon(kpi, value);
                    if (kpiIcon) {
                        return {
                            caption: kpiIcon,
                            statusGraphic: kpi.graphic,
                            class: getKpiIconClassName(kpiIcon, kpiImageSize),
                        };
                    }
                }
            }
            KpiUtil.getKpiImageMetadata = getKpiImageMetadata;
        })(KpiUtil = visuals.KpiUtil || (visuals.KpiUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ReferenceLineHelper;
        (function (ReferenceLineHelper) {
            ReferenceLineHelper.referenceLineProps = {
                show: 'show',
                lineColor: 'lineColor',
                transparency: 'transparency',
                value: 'value',
                style: 'style',
                position: 'position',
                dataLabelShow: 'dataLabelShow',
                dataLabelColor: 'dataLabelColor',
                dataLabelDecimalPoints: 'dataLabelDecimalPoints',
                dataLabelHorizontalPosition: 'dataLabelHorizontalPosition',
                dataLabelVerticalPosition: 'dataLabelVerticalPosition',
                dataLabelDisplayUnits: 'dataLabelDisplayUnits',
            };
            function enumerateObjectInstances(enumeration, referenceLines, defaultColor, objectName) {
                debug.assertValue(enumeration, 'enumeration');
                if (_.isEmpty(referenceLines)) {
                    // NOTE: We do not currently have support for object maps in the property pane. For now we will generate a single reference line 
                    // object that the format pane can handle.In the future we will need property pane support for multiple reference lines. Also, we're
                    // assuming that the user-defined IDs will be numeric strings, this may change in the future and will likley be controlled by the property pane.
                    var instance = {
                        selector: {
                            id: '0'
                        },
                        properties: {
                            show: false,
                            value: '',
                            lineColor: { solid: { color: defaultColor } },
                            transparency: 50,
                            style: visuals.lineStyle.dashed,
                            position: visuals.referenceLinePosition.back,
                            dataLabelShow: false,
                        },
                        objectName: objectName
                    };
                    enumeration.pushInstance(instance);
                    return;
                }
                for (var _i = 0, referenceLines_1 = referenceLines; _i < referenceLines_1.length; _i++) {
                    var referenceLine = referenceLines_1[_i];
                    var referenceLineProperties = referenceLine.object;
                    var show = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, false);
                    var value = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value);
                    var lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, { solid: { color: defaultColor } });
                    var transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency, 50);
                    var style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed);
                    var position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back);
                    var dataLabelShow = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelShow, false);
                    var instance = {
                        selector: {
                            id: referenceLine.id
                        },
                        properties: {
                            show: show,
                            value: value,
                            lineColor: lineColor,
                            transparency: transparency,
                            style: style,
                            position: position,
                            dataLabelShow: dataLabelShow,
                        },
                        objectName: objectName
                    };
                    // Show the data label properties only if the user chose to show the data label
                    if (dataLabelShow) {
                        var dataLabelColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, { solid: { color: defaultColor } });
                        var dataLabelHorizontalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition, visuals.referenceLineDataLabelHorizontalPosition.left);
                        var dataLabelVerticalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition, visuals.referenceLineDataLabelVerticalPosition.above);
                        var dataLabelDecimalPoints = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, undefined) < 0
                            ? undefined
                            : powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, undefined);
                        var dataLabelDisplayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelColor] = dataLabelColor;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] = dataLabelHorizontalPosition;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] = dataLabelVerticalPosition;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] = dataLabelDecimalPoints;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits] = dataLabelDisplayUnits;
                    }
                    enumeration.pushInstance(instance);
                }
            }
            ReferenceLineHelper.enumerateObjectInstances = enumerateObjectInstances;
            function render(options) {
                var graphicContext = options.graphicContext;
                var axes = options.axes;
                var referenceLineProperties = options.referenceLineProperties;
                var isHorizontal = options.isHorizontal;
                var viewport = options.viewport;
                var classAndSelector = options.classAndSelector;
                var xScale = axes.x.scale;
                var yScale = axes.y1.scale;
                var refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0);
                var lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, { solid: { color: options.defaultColor } });
                var transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency);
                var style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed);
                var position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back);
                var refLine = graphicContext.select(classAndSelector.selector);
                var index = $(refLine[0]).index();
                var currentPosition = index > 1 ? visuals.referenceLinePosition.front : visuals.referenceLinePosition.back;
                var isRefLineExists = index !== -1;
                var isPositionChanged = currentPosition !== position;
                if (isRefLineExists && isPositionChanged)
                    refLine.remove();
                if (!isRefLineExists || isPositionChanged)
                    refLine = (position === visuals.referenceLinePosition.back) ? graphicContext.insert('line', ":first-child") : graphicContext.append('line');
                var refLineX1 = isHorizontal ? 0 : xScale(refValue);
                var refLineY1 = isHorizontal ? yScale(refValue) : 0;
                var refLineX2 = isHorizontal ? viewport.width : xScale(refValue);
                var refLineY2 = isHorizontal ? yScale(refValue) : viewport.height;
                refLine.attr({
                    'class': classAndSelector.class,
                    x1: refLineX1,
                    y1: refLineY1,
                    x2: refLineX2,
                    y2: refLineY2,
                })
                    .style({
                    'stroke': lineColor.solid.color,
                });
                if (transparency != null)
                    refLine.style('stroke-opacity', ((100 - transparency) / 100));
                if (style === visuals.lineStyle.dashed) {
                    refLine.style('stroke-dasharray', ("5, 5"));
                }
                else if (style === visuals.lineStyle.dotted) {
                    refLine.style({
                        'stroke-dasharray': ("1, 5"),
                        'stroke-linecap': "round"
                    });
                }
                else if (style === visuals.lineStyle.solid) {
                    refLine.style({
                        'stroke-dasharray': null,
                        'stroke-linecap': null
                    });
                }
            }
            ReferenceLineHelper.render = render;
            function createLabelDataPoint(options) {
                var offsetRefLine = 5;
                var axes = options.axes;
                var referenceLineProperties = options.referenceLineProperties;
                var isHorizontal = options.isHorizontal;
                var viewport = options.viewport;
                var xScale = axes.x.scale;
                var yScale = axes.y1.scale;
                // Get the data label properties                
                var refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0);
                var color = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, { solid: { color: options.defaultColor } });
                var decimalPoints = (referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] < 0 ? undefined : referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints]);
                var horizontalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] || visuals.referenceLineDataLabelHorizontalPosition.left;
                var verticalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] || visuals.referenceLineDataLabelVerticalPosition.above;
                var displayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
                // Format the reference line data label text according to the matching axis formatter
                // When options is null default formatter is used either boolean, numeric, or text
                var axisFormatter = isHorizontal ? axes.y1.formatter : axes.x.formatter;
                var formatterForReferenceLineDataLabel = axisFormatter;
                if (axisFormatter.options != null) {
                    var formatterOptions = powerbi.Prototype.inherit(axisFormatter.options);
                    formatterOptions.precision = decimalPoints;
                    formatterOptions.value = displayUnits;
                    formatterForReferenceLineDataLabel = visuals.valueFormatter.create(formatterOptions);
                }
                var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatterForReferenceLineDataLabel.format(refValue));
                var properties = {
                    text: text,
                    fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                };
                // Get the height and with of the text element that will be created in order to place it correctly
                var rectWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var rectHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var dataLabelX;
                var dataLabelY;
                var x1 = isHorizontal ? 0 : xScale(refValue);
                var y1 = isHorizontal ? yScale(refValue) : 0;
                var x2 = isHorizontal ? viewport.width : xScale(refValue);
                var y2 = isHorizontal ? yScale(refValue) : viewport.height;
                var validPositions = [1 /* Above */];
                if (isHorizontal) {
                    // Horizontal line. y1 = y2
                    dataLabelX = (horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? x1 + offsetRefLine : x2 - (rectWidth / 2) - offsetRefLine;
                    dataLabelY = y1;
                    validPositions = (verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? [1 /* Above */] : [2 /* Below */];
                }
                else {
                    // Vertical line. x1 = x2 
                    dataLabelX = x1;
                    dataLabelY = (verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? y1 + (rectHeight / 2) + offsetRefLine : y2 - (rectHeight / 2) - offsetRefLine;
                    validPositions = (horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? [4 /* Left */] : [8 /* Right */];
                }
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                var parentShape;
                parentShape = {
                    point: {
                        x: dataLabelX,
                        y: dataLabelY,
                    },
                    radius: 0,
                    validPositions: validPositions,
                };
                return {
                    isPreferred: true,
                    text: text,
                    textSize: {
                        width: textWidth,
                        height: textHeight,
                    },
                    outsideFill: color.solid.color,
                    insideFill: null,
                    parentShape: parentShape,
                    parentType: 0 /* Point */,
                    fontSize: 9,
                    identity: null,
                    secondRowText: null,
                    key: options.key,
                };
            }
            ReferenceLineHelper.createLabelDataPoint = createLabelDataPoint;
            function extractReferenceLineValue(referenceLineProperties) {
                var referenceLineValue = null;
                if (referenceLineProperties && powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, false))
                    referenceLineValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, null);
                return referenceLineValue;
            }
            ReferenceLineHelper.extractReferenceLineValue = extractReferenceLineValue;
        })(ReferenceLineHelper = visuals.ReferenceLineHelper || (visuals.ReferenceLineHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var InteractivityUtils;
        (function (InteractivityUtils) {
            function getPositionOfLastInputEvent() {
                return {
                    x: d3.event.clientX,
                    y: d3.event.clientY
                };
            }
            InteractivityUtils.getPositionOfLastInputEvent = getPositionOfLastInputEvent;
            function registerStandardInteractivityHandlers(selection, selectionHandler) {
                registerStandardSelectionHandler(selection, selectionHandler);
                registerStandardContextMenuHandler(selection, selectionHandler);
            }
            InteractivityUtils.registerStandardInteractivityHandlers = registerStandardInteractivityHandlers;
            function registerStandardSelectionHandler(selection, selectionHandler) {
                selection.on('click', function (d) { return handleSelection(d, selectionHandler); });
            }
            InteractivityUtils.registerStandardSelectionHandler = registerStandardSelectionHandler;
            function registerStandardContextMenuHandler(selection, selectionHandler) {
                selection.on('contextmenu', function (d) { return handleContextMenu(d, selectionHandler); });
            }
            InteractivityUtils.registerStandardContextMenuHandler = registerStandardContextMenuHandler;
            function registerGroupInteractivityHandlers(group, selectionHandler) {
                registerGroupSelectionHandler(group, selectionHandler);
                registerGroupContextMenuHandler(group, selectionHandler);
            }
            InteractivityUtils.registerGroupInteractivityHandlers = registerGroupInteractivityHandlers;
            function registerGroupSelectionHandler(group, selectionHandler) {
                group.on('click', function () {
                    var target = d3.event.target;
                    var d = d3.select(target).datum();
                    handleSelection(d, selectionHandler);
                });
            }
            InteractivityUtils.registerGroupSelectionHandler = registerGroupSelectionHandler;
            function registerGroupContextMenuHandler(group, selectionHandler) {
                group.on('contextmenu', function () {
                    var target = d3.event.target;
                    var d = d3.select(target).datum();
                    handleContextMenu(d, selectionHandler);
                });
            }
            InteractivityUtils.registerGroupContextMenuHandler = registerGroupContextMenuHandler;
            function handleContextMenu(d, selectionHandler) {
                if (d3.event.ctrlKey)
                    return;
                d3.event.preventDefault();
                var position = InteractivityUtils.getPositionOfLastInputEvent();
                selectionHandler.handleContextMenu(d, position);
            }
            function handleSelection(d, selectionHandler) {
                selectionHandler.handleSelection(d, d3.event.ctrlKey);
            }
        })(InteractivityUtils = visuals.InteractivityUtils || (visuals.InteractivityUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
            var checker = new InvalidDataValuesChecker(supportsNaN /*supportsNaN*/, supportsNegativeInfinity /*supportsNegativeInfinity*/, supportsPositiveInfinity /*supportsPositiveInfinity*/);
            // Show a warning if necessary.
            return checker.getWarningMessages(dataViews);
        }
        visuals.getInvalidValueWarnings = getInvalidValueWarnings;
        var InvalidDataValuesChecker = (function () {
            function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
                this.supportsNaN = supportsNaN;
                this.supportsNegativeInfinity = supportsNegativeInfinity;
                this.supportsPositiveInfinity = supportsPositiveInfinity;
            }
            InvalidDataValuesChecker.prototype.getWarningMessages = function (dataViews) {
                this.loadWarningStatus(dataViews);
                var warnings = [];
                if (this.hasNaN && !this.supportsNaN) {
                    warnings.push(new visuals.NaNNotSupportedWarning());
                }
                if ((this.hasNegativeInfinity && !this.supportsNegativeInfinity)
                    || (this.hasPositiveInfinity && !this.supportsPositiveInfinity)) {
                    warnings.push(new visuals.InfinityValuesNotSupportedWarning());
                }
                if (this.hasOutOfRange) {
                    warnings.push(new visuals.ValuesOutOfRangeWarning());
                }
                return warnings;
            };
            InvalidDataValuesChecker.prototype.loadWarningStatus = function (dataViews) {
                this.hasNaN = false;
                this.hasNegativeInfinity = false;
                this.hasOutOfRange = false;
                this.hasPositiveInfinity = false;
                for (var k = 0; k < dataViews.length; k++) {
                    var dataView = dataViews[k];
                    var values = dataView && dataView.categorical && dataView.categorical.values
                        ? dataView.categorical.values
                        : null;
                    if (!values)
                        return;
                    var valueLength = values.length;
                    for (var i = 0; i < valueLength; i++) {
                        var value = values[i];
                        if (value.values) {
                            var valueValueLength = value.values.length;
                            for (var j = 0; j < valueValueLength; j++) {
                                var v = value.values[j];
                                if (isNaN(v))
                                    this.hasNaN = true;
                                else if (v === Number.POSITIVE_INFINITY)
                                    this.hasPositiveInfinity = true;
                                else if (v === Number.NEGATIVE_INFINITY)
                                    this.hasNegativeInfinity = true;
                                else if (v < -1e300 || v > 1e300)
                                    this.hasOutOfRange = true;
                            }
                        }
                    }
                }
            };
            return InvalidDataValuesChecker;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ListViewFactory;
        (function (ListViewFactory) {
            function createListView(options) {
                return new ListView(options);
            }
            ListViewFactory.createListView = createListView;
        })(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
        /**
         * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
         * It can create lists containing either HTML or SVG elements.
         */
        var ListView = (function () {
            function ListView(options) {
                var _this = this;
                // make a copy of options so that it is not modified later by caller
                this.options = $.extend(true, {}, options);
                this.scrollbarInner = options.baseContainer
                    .append('div')
                    .classed('scrollbar-inner', true)
                    .on('scroll', function () { return _this.renderImpl(_this.options.rowHeight); });
                this.scrollContainer = this.scrollbarInner
                    .append('div')
                    .classed('scrollRegion', true)
                    .on('touchstart', function () { return _this.stopTouchProp(); })
                    .on('touchmove', function () { return _this.stopTouchProp(); });
                this.visibleGroupContainer = this.scrollContainer
                    .append('div')
                    .classed('visibleGroup', true);
                $(options.baseContainer.node()).find('.scroll-element').attr('drag-resize-disabled', 'true');
                ListView.SetDefaultOptions(options);
            }
            ListView.SetDefaultOptions = function (options) {
                options.rowHeight = options.rowHeight || ListView.defaultRowHeight;
            };
            ListView.prototype.rowHeight = function (rowHeight) {
                this.options.rowHeight = Math.ceil(rowHeight);
                return this;
            };
            ListView.prototype.data = function (data, getDatumIndex, dataReset) {
                if (dataReset === void 0) { dataReset = false; }
                this._data = data;
                this.getDatumIndex = getDatumIndex;
                this.setTotalRows();
                if (dataReset)
                    $(this.scrollbarInner.node()).scrollTop(0);
                this.render();
                return this;
            };
            ListView.prototype.viewport = function (viewport) {
                this.options.viewport = viewport;
                this.render();
                return this;
            };
            ListView.prototype.empty = function () {
                this._data = [];
                this.render();
            };
            ListView.prototype.render = function () {
                var _this = this;
                if (this.renderTimeoutId)
                    window.clearTimeout(this.renderTimeoutId);
                this.renderTimeoutId = window.setTimeout(function () {
                    _this.getRowHeight().then(function (rowHeight) {
                        _this.renderImpl(rowHeight);
                    });
                    _this.renderTimeoutId = undefined;
                }, 0);
            };
            ListView.prototype.renderImpl = function (rowHeight) {
                var totalHeight = this.options.scrollEnabled ? Math.max(0, (this._totalRows * rowHeight)) : this.options.viewport.height;
                this.scrollContainer
                    .style('height', totalHeight + "px")
                    .attr('height', totalHeight);
                this.scrollToFrame(true /*loadMoreData*/);
            };
            /*
             *  This method is called in order to prevent a bug found in the Interact.js.
             *  The bug is caused when finishing a scroll outside the scroll area.
             *  In that case the Interact doesn't process a touchcancel event and thinks a touch point still exists.
             *  since the Interact listens on the visualContainer, by stoping the propagation we prevent the bug from taking place.
             */
            ListView.prototype.stopTouchProp = function () {
                //Stop the propagation only in read mode so the drag won't be affected.
                if (this.options.isReadMode()) {
                    if (d3.event.type === "touchstart") {
                        var event = d3.event;
                        //If there is another touch point outside this visual than the event should be propagated.
                        //This way the pinch to zoom will not be affected.
                        if (event.touches && event.touches.length === 1) {
                            d3.event.stopPropagation();
                        }
                    }
                    if (d3.event.type === "touchmove") {
                        d3.event.stopPropagation();
                    }
                }
            };
            ListView.prototype.scrollToFrame = function (loadMoreData) {
                var options = this.options;
                var visibleGroupContainer = this.visibleGroupContainer;
                var totalRows = this._totalRows;
                var rowHeight = options.rowHeight || ListView.defaultRowHeight;
                var visibleRows = this.getVisibleRows() || 1;
                var scrollTop = this.scrollbarInner.node().scrollTop;
                var scrollPosition = (scrollTop === 0) ? 0 : Math.floor(scrollTop / rowHeight);
                var transformAttr = visuals.SVGUtil.translateWithPixels(0, scrollPosition * rowHeight);
                visibleGroupContainer.style({
                    //order matters for proper overriding
                    'transform': function (d) { return transformAttr; },
                    '-webkit-transform': transformAttr
                });
                var position0 = Math.max(0, Math.min(scrollPosition, totalRows - visibleRows + 1)), position1 = position0 + visibleRows;
                var rowSelection = visibleGroupContainer.selectAll(".row")
                    .data(this._data.slice(position0, Math.min(position1, totalRows)), this.getDatumIndex);
                rowSelection
                    .enter()
                    .append('div')
                    .classed('row', true)
                    .call(function (d) { return options.enter(d); });
                rowSelection.order();
                var rowUpdateSelection = visibleGroupContainer.selectAll('.row:not(.transitioning)');
                rowUpdateSelection.call(function (d) { return options.update(d); });
                rowSelection
                    .exit()
                    .call(function (d) { return options.exit(d); })
                    .remove();
                if (loadMoreData && visibleRows !== totalRows && position1 >= totalRows * ListView.loadMoreDataThreshold)
                    options.loadMoreData();
            };
            ListView.prototype.setTotalRows = function () {
                var data = this._data;
                this._totalRows = data ? data.length : 0;
            };
            ListView.prototype.getVisibleRows = function () {
                var minimumVisibleRows = 1;
                var rowHeight = this.options.rowHeight;
                var viewportHeight = this.options.viewport.height;
                if (!rowHeight || rowHeight < 1)
                    return minimumVisibleRows;
                if (this.options.scrollEnabled)
                    return Math.min(Math.ceil(viewportHeight / rowHeight), this._totalRows) || minimumVisibleRows;
                return Math.min(Math.floor(viewportHeight / rowHeight), this._totalRows) || minimumVisibleRows;
            };
            ListView.prototype.getRowHeight = function () {
                var deferred = $.Deferred();
                var listView = this;
                var options = listView.options;
                if (this.cancelMeasurePass)
                    this.cancelMeasurePass();
                // if there is no data, resolve and return
                if (!(this._data && this._data.length && options)) {
                    listView.rowHeight(ListView.defaultRowHeight);
                    return deferred.resolve(options.rowHeight).promise();
                }
                //render the first item to calculate the row height
                this.scrollToFrame(false /*loadMoreData*/);
                var requestAnimationFrameId = window.requestAnimationFrame(function () {
                    //measure row height
                    var rows = listView.visibleGroupContainer.select(".row");
                    if (rows.length > 0) {
                        var firstRow = rows.node().firstChild;
                        var rowHeight = $(firstRow).outerHeight(true);
                        listView.rowHeight(rowHeight);
                        deferred.resolve(rowHeight);
                    }
                    listView.cancelMeasurePass = undefined;
                    window.cancelAnimationFrame(requestAnimationFrameId);
                });
                this.cancelMeasurePass = function () {
                    window.cancelAnimationFrame(requestAnimationFrameId);
                    deferred.reject();
                };
                return deferred.promise();
            };
            /**
             * The value indicates the percentage of data already shown
             * in the list view that triggers a loadMoreData call.
             */
            ListView.loadMoreDataThreshold = 0.8;
            ListView.defaultRowHeight = 1;
            return ListView;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var defaultLevelOfDetail = 11;
        var MapUtil;
        (function (MapUtil) {
            MapUtil.Settings = {
                /** Maximum Bing requests at once. The Bing have limit how many request at once you can do per socket. */
                MaxBingRequest: 6,
                /** Maximum cache size of cached geocode data. */
                MaxCacheSize: 3000,
                /** Maximum cache overflow of cached geocode data to kick the cache reducing. */
                MaxCacheSizeOverflow: 100,
                // Bing Keys and URL
                BingKey: "insert your key",
                BingUrl: "https://dev.virtualearth.net/REST/v1/Locations?",
                BingUrlGeodata: "https://platform.bing.com/geo/spatial/v1/public/Geodata?",
                /** Switch the data result for geodata polygons to by double array instead locations array */
                UseDoubleArrayGeodataResult: true,
                UseDoubleArrayDequeueTimeout: 0,
            };
            // Bing map min/max boundaries
            MapUtil.MinAllowedLatitude = -85.05112878;
            MapUtil.MaxAllowedLatitude = 85.05112878;
            MapUtil.MinAllowedLongitude = -180;
            MapUtil.MaxAllowedLongitude = 180;
            MapUtil.TileSize = 256;
            MapUtil.MaxLevelOfDetail = 23;
            MapUtil.MinLevelOfDetail = 1;
            MapUtil.MaxAutoZoomLevel = 5;
            MapUtil.DefaultLevelOfDetail = 11;
            MapUtil.WorkerErrorName = "___error___";
            MapUtil.CategoryTypes = {
                Address: "Address",
                City: "City",
                Continent: "Continent",
                CountryRegion: "Country",
                County: "County",
                Longitude: "Longitude",
                Latitude: "Latitude",
                Place: "Place",
                PostalCode: "PostalCode",
                StateOrProvince: "StateOrProvince"
            };
            var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
            function clip(n, minValue, maxValue) {
                return Math.min(Math.max(n, minValue), maxValue);
            }
            MapUtil.clip = clip;
            function getMapSize(levelOfDetail) {
                if (levelOfDetail === 23)
                    return 2147483648; //256 << 23 overflow the integer and return a negative value
                if (Math.floor(levelOfDetail) === levelOfDetail)
                    return 256 << levelOfDetail;
                return 256 * Math.pow(2, levelOfDetail);
            }
            MapUtil.getMapSize = getMapSize;
            /**
             * @param latLongArray - is a Float64Array as [lt0, lon0, lat1, long1, lat2, long2,....]
             * @returns Float64Array as [x0, y0, x1, y1, x2, y2,....]
             */
            function latLongToPixelXYArray(latLongArray, levelOfDetail) {
                var result = new Float64Array(latLongArray.length);
                for (var i = 0; i < latLongArray.length; i += 2) {
                    var latitude = clip(latLongArray[i], MapUtil.MinAllowedLatitude, MapUtil.MaxAllowedLatitude);
                    var longitude = clip(latLongArray[i + 1], MapUtil.MinAllowedLongitude, MapUtil.MaxAllowedLongitude);
                    var x = (longitude + 180) / 360;
                    var sinLatitude = Math.sin(latitude * Math.PI / 180);
                    var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
                    var mapSize = getMapSize(levelOfDetail);
                    result[i] = clip(x * mapSize + 0.5, 0.0, mapSize - 1);
                    result[i + 1] = clip(y * mapSize + 0.5, 0.0, mapSize - 1);
                }
                return result;
            }
            MapUtil.latLongToPixelXYArray = latLongToPixelXYArray;
            function pointArrayToString(array) {
                var maxLength = 80000;
                if (array.length > maxLength) {
                    var result = "";
                    for (var i = 0; i < array.length; i += maxLength) {
                        var array1 = Array.apply([], array.subarray(i, i + maxLength));
                        result += array1.join(" ") + " ";
                    }
                    return result;
                }
                return Array.apply([], array).join(" ");
            }
            MapUtil.pointArrayToString = pointArrayToString;
            function pointArrayToArray(array) {
                var maxLength = 80000;
                var result = [];
                if (array.length > maxLength) {
                    for (var i = 0; i < array.length; i += maxLength) {
                        var array1 = Array.apply([], array.subarray(i, i + maxLength));
                        result.concat(array1);
                    }
                    return result;
                }
                return Array.apply([], array);
            }
            MapUtil.pointArrayToArray = pointArrayToArray;
            function getLocationBoundaries(latLongArray) {
                var northWest = {
                    latitude: -90, longitude: 180
                };
                var southEast = {
                    latitude: 90, longitude: -180
                };
                for (var i = 0; i < latLongArray.length; i += 2) {
                    northWest.latitude = Math.max(latLongArray[i], northWest.latitude);
                    northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude);
                    southEast.latitude = Math.min(latLongArray[i], southEast.latitude);
                    southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
                }
                northWest.longitude = clip(northWest.longitude, -180, 180);
                southEast.longitude = clip(southEast.longitude, -180, 180);
                return Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
            }
            MapUtil.getLocationBoundaries = getLocationBoundaries;
            /**
             * Note: this code is taken from Bing.
             *  see Point Compression Algorithm http://msdn.microsoft.com/en-us/library/jj158958.aspx
             *  see Decompression Algorithm in http://msdn.microsoft.com/en-us/library/dn306801.aspx
             */
            function parseEncodedSpatialValueArray(value) {
                var list = [];
                var index = 0;
                var xsum = 0;
                var ysum = 0;
                var max = 4294967296;
                while (index < value.length) {
                    var n = 0;
                    var k = 0;
                    while (1) {
                        if (index >= value.length) {
                            return null;
                        }
                        var b = safeCharacters.indexOf(value.charAt(index++));
                        if (b === -1) {
                            return null;
                        }
                        var tmp = ((b & 31) * (Math.pow(2, k)));
                        var ht = tmp / max;
                        var lt = tmp % max;
                        var hn = n / max;
                        var ln = n % max;
                        var nl = (lt | ln) >>> 0;
                        n = (ht | hn) * max + nl;
                        k += 5;
                        if (b < 32)
                            break;
                    }
                    var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
                    n -= diagonal * (diagonal + 1) / 2;
                    var ny = Math.floor(n);
                    var nx = diagonal - ny;
                    nx = (nx >> 1) ^ -(nx & 1);
                    ny = (ny >> 1) ^ -(ny & 1);
                    xsum += nx;
                    ysum += ny;
                    var lat = ysum * 0.00001;
                    var lon = xsum * 0.00001;
                    list.push(lat);
                    list.push(lon);
                }
                return new Float64Array(list);
            }
            MapUtil.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray;
            function calcGeoData(data) {
                var locations = data.locations;
                for (var i = 0; i < locations.length; i++) {
                    var location_1 = locations[i];
                    if (!location_1.geographic) {
                        location_1.geographic = MapUtil.parseEncodedSpatialValueArray(location_1.nativeBing);
                    }
                    var polygon = location_1.geographic;
                    if (polygon) {
                        if (!location_1.absolute) {
                            location_1.absolute = MapUtil.latLongToPixelXYArray(polygon, MapUtil.DefaultLevelOfDetail);
                            location_1.absoluteString = MapUtil.pointArrayToString(location_1.absolute);
                            var geographicBounds = MapUtil.getLocationBoundaries(polygon);
                            location_1.absoluteBounds = MapUtil.locationRectToRectXY(geographicBounds, MapUtil.DefaultLevelOfDetail);
                        }
                    }
                }
            }
            MapUtil.calcGeoData = calcGeoData;
            function locationToPixelXY(location, levelOfDetail) {
                return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
            }
            MapUtil.locationToPixelXY = locationToPixelXY;
            function locationRectToRectXY(locationRect, levelOfDetail) {
                var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail);
                var bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
                return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
            }
            MapUtil.locationRectToRectXY = locationRectToRectXY;
            function latLongToPixelXY(latitude, longitude, levelOfDetail) {
                var array = latLongToPixelXYArray(new Float64Array([latitude, longitude]), levelOfDetail);
                return new powerbi.visuals.Point(array[0], array[1]);
            }
            MapUtil.latLongToPixelXY = latLongToPixelXY;
            function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
                var mapSize = getMapSize(levelOfDetail);
                var x = (clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
                var y = 0.5 - (clip(pixelY, 0, mapSize - 1) / mapSize);
                var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
                var longitude = 360 * x;
                return new Microsoft.Maps.Location(latitude, longitude);
            }
            MapUtil.pixelXYToLocation = pixelXYToLocation;
            var CurrentLocation;
            (function (CurrentLocation) {
                function createPushpin(location) {
                    var template = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">'
                        + '<circle fill="#FF5F00" cx="12" cy="12" r="6"/>'
                        + '<circle fill="none" stroke="#FF5F00" stroke-width="2" cx="12" cy="12" r="10"/>'
                        + '</svg>';
                    var options = {
                        draggable: false,
                        htmlContent: template,
                        height: 24,
                        width: 24
                    };
                    return new Microsoft.Maps.Pushpin(location, options);
                }
                CurrentLocation.createPushpin = createPushpin;
            })(CurrentLocation = MapUtil.CurrentLocation || (MapUtil.CurrentLocation = {}));
        })(MapUtil = visuals.MapUtil || (visuals.MapUtil = {}));
        var MapPolygonInfo = (function () {
            function MapPolygonInfo() {
                this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
            }
            MapPolygonInfo.prototype.reCalc = function (mapControl, width, height) {
                var baseLocations = [this._locationRect.getNorthwest(), this._locationRect.getSoutheast()];
                width = width / 2.00;
                height = height / 2.00;
                if (!this._baseRect) {
                    var l0 = MapUtil.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail);
                    var l1 = MapUtil.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
                    this._baseRect = new visuals.Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
                }
                var l = mapControl.tryLocationToPixel(baseLocations);
                this._currentRect = new visuals.Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
            };
            Object.defineProperty(MapPolygonInfo.prototype, "scale", {
                get: function () {
                    if (this._baseRect) {
                        return this._currentRect.width / this._baseRect.width;
                    }
                    return 1.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "transform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    transform.translate(current.left, current.top);
                    transform.scale((current.width / base.width), (current.height / base.height));
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    transform.translate(current.left, current.top);
                    var scale = Math.sqrt(current.width / base.width);
                    transform.scale(scale, scale);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.setViewBox = function (svg) {
                var rect = svg.getBoundingClientRect();
                var current = this._currentRect;
                svg.setAttribute("viewBox", [-current.left, -current.top, rect.width, rect.height].join(" "));
            };
            Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    var scale = current.width / base.width;
                    transform.scale(scale, scale);
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.transformToString = function (transform) {
                var m = transform.matrix;
                return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
            };
            return MapPolygonInfo;
        }());
        visuals.MapPolygonInfo = MapPolygonInfo;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var utility;
        (function (utility) {
            ;
            var SelectionManager = (function () {
                function SelectionManager(options) {
                    this.hostServices = options.hostServices;
                    this.selectedIds = [];
                }
                SelectionManager.prototype.select = function (selectionId, multiSelect) {
                    if (multiSelect === void 0) { multiSelect = false; }
                    var defered = $.Deferred();
                    if (this.hostServices.shouldRetainSelection()) {
                        this.sendSelectionToHost([selectionId]);
                    }
                    else {
                        this.selectInternal(selectionId, multiSelect);
                        this.sendSelectionToHost(this.selectedIds);
                    }
                    defered.resolve(this.selectedIds);
                    return defered;
                };
                SelectionManager.prototype.hasSelection = function () {
                    return this.selectedIds.length > 0;
                };
                SelectionManager.prototype.clear = function () {
                    var defered = $.Deferred();
                    this.selectedIds = [];
                    this.sendSelectionToHost([]);
                    defered.resolve();
                    return defered;
                };
                SelectionManager.prototype.getSelectionIds = function () {
                    return this.selectedIds;
                };
                SelectionManager.prototype.sendSelectionToHost = function (ids) {
                    var selectArgs = {
                        data: ids
                            .filter(function (value) { return value.hasIdentity(); })
                            .map(function (value) { return value.getSelector(); })
                    };
                    var data2 = ids
                        .filter(function (value) { return value.getSelectorsByColumn() && value.hasIdentity(); })
                        .map(function (value) { return value.getSelectorsByColumn(); });
                    if (data2 && data2.length > 0)
                        selectArgs.data2 = data2;
                    this.hostServices.onSelect(selectArgs);
                };
                SelectionManager.prototype.selectInternal = function (selectionId, multiSelect) {
                    if (SelectionManager.containsSelection(this.selectedIds, selectionId)) {
                        this.selectedIds = multiSelect
                            ? this.selectedIds.filter(function (d) { return !powerbi.data.Selector.equals(d, selectionId); })
                            : this.selectedIds.length > 1
                                ? [selectionId] : [];
                    }
                    else {
                        if (multiSelect)
                            this.selectedIds.push(selectionId);
                        else
                            this.selectedIds = [selectionId];
                    }
                };
                SelectionManager.containsSelection = function (list, id) {
                    return list.some(function (d) { return powerbi.data.Selector.equals(d.getSelector(), id.getSelector()); });
                };
                return SelectionManager;
            }());
            utility.SelectionManager = SelectionManager;
        })(utility = visuals.utility || (visuals.utility = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        "use strict";
        var shapes;
        (function (shapes) {
            var Utility = jsCommon.Utility;
            var Polygon = (function () {
                function Polygon(absolutePoints) {
                    this.polygonPoints = this.convertArrayPathToPoints(absolutePoints);
                }
                Polygon.prototype.absoluteCentroid = function () {
                    if (this._absoluteCentroid == null) {
                        this._absoluteCentroid = this.calculatePolygonCentroid();
                    }
                    return this._absoluteCentroid;
                };
                Polygon.prototype.absoluteBoundingRect = function () {
                    if (this._absoluteBoundingRect == null) {
                        this._absoluteBoundingRect = this.calculateBoundingRect();
                    }
                    return this._absoluteBoundingRect;
                };
                /**
                 * Check if label text contain in polygon shape.
                 *
                 * @return true/false is the label fit in polygon.
                 * measure if rects points are inside the polygon shape
                 * return true if there is at least 3 point inside the polygon
                 */
                Polygon.prototype.contains = function (rect) {
                    var topLeft = { x: rect.left, y: rect.top };
                    var topRight = { x: rect.left + rect.width, y: rect.top };
                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
                    return (this.inside(topLeft)
                        && this.inside(topRight)
                        && this.inside(bottomLeft)
                        && this.inside(bottomRight));
                };
                /**
                * Check if label text is outside of polygon shape.
                * It checks 8 points in the label. TopLeft, TopCenter, TopRight, MiddleLeft, MiddleRight, BottomLeft, BottomMiddle, BottomRight
                * @return true/false is there is any conflict (at least one point inside the shape).
                */
                Polygon.prototype.conflicts = function (rect) {
                    if (!this.isConflictWithBoundingBox(rect)) {
                        return false;
                    }
                    var topLeft = { x: rect.left, y: rect.top };
                    var topCenter = { x: rect.left + rect.width / 2, y: rect.top };
                    var topRight = { x: rect.left + rect.width, y: rect.top };
                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
                    var bottomCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height };
                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
                    var middleLeft = { x: rect.left, y: rect.top + rect.height / 2 };
                    var middleRight = { x: rect.left + rect.width, y: rect.top + rect.height / 2 };
                    return (this.inside(topLeft)
                        || this.inside(topCenter)
                        || this.inside(topRight)
                        || this.inside(bottomLeft)
                        || this.inside(bottomCenter)
                        || this.inside(bottomRight)
                        || this.inside(middleLeft)
                        || this.inside(middleRight));
                };
                /**
                * returns intersection point of a line (depicted by two points) and a polygon.
                *
                * @return the point of intersection or null if there is no intersection.
                */
                Polygon.prototype.lineIntersectionPoint = function (p0, p1) {
                    for (var i = 0; i < this.polygonPoints.length; i++) {
                        var p2 = this.polygonPoints[i];
                        var p3 = (i === this.polygonPoints.length - 1 ? this.polygonPoints[0] : this.polygonPoints[i + 1]);
                        var intersection = this.getLineIntersection(p0, p1, p2, p3);
                        if (intersection !== null) {
                            return intersection;
                        }
                    }
                    return null;
                };
                /**
                 * calculate Polygon Area.
                 *
                 * @return the area of the polygon (as number).
                 */
                Polygon.calculateAbsolutePolygonArea = function (polygonPoints) {
                    var i, j = 1;
                    var area = 0.0;
                    for (i = 0; i < polygonPoints.length; i++) {
                        area += polygonPoints[i].x * polygonPoints[j].y - polygonPoints[j].x * polygonPoints[i].y;
                        j = (j + 1) % polygonPoints.length;
                    }
                    area *= 0.5;
                    return area;
                };
                /**
                * Check if label text is outside of polygon bounding box.
                *
                * @return true/false is there is any conflict (at least one point inside the shape).
                */
                Polygon.prototype.isConflictWithBoundingBox = function (rect) {
                    return Rect.isIntersecting(this.absoluteBoundingRect(), rect);
                };
                /**
                 * Calculate Polygon Centroid.
                 *
                 * @return 'center' point of the polygon.
                 * calculate the polygon area
                 * calculate the average points of the polygon by x & y axis.
                 * divided the average point by the area
                 */
                Polygon.prototype.calculatePolygonCentroid = function () {
                    var area, tempPoint, cx, cy, i, j;
                    /* First calculate the polygon's signed area A */
                    area = Polygon.calculateAbsolutePolygonArea(this.polygonPoints);
                    /* Now calculate the centroid coordinates Cx and Cy */
                    cx = cy = 0.0;
                    j = 1;
                    for (i = 0; i < this.polygonPoints.length; i++) {
                        tempPoint = this.polygonPoints[i].x * this.polygonPoints[j].y - this.polygonPoints[j].x * this.polygonPoints[i].y;
                        cx += (this.polygonPoints[i].x + this.polygonPoints[j].x) * tempPoint;
                        cy += (this.polygonPoints[i].y + this.polygonPoints[j].y) * tempPoint;
                        j = (j + 1) % this.polygonPoints.length;
                    }
                    cx = cx / (6.0 * area);
                    cy = cy / (6.0 * area);
                    return {
                        x: cx,
                        y: cy,
                    };
                };
                Polygon.prototype.calculateBoundingRect = function () {
                    var minX = Number.POSITIVE_INFINITY;
                    var minY = Number.POSITIVE_INFINITY;
                    var maxX = Number.NEGATIVE_INFINITY;
                    var maxY = Number.NEGATIVE_INFINITY;
                    for (var i = 0; i < this.polygonPoints.length; i++) {
                        if (this.polygonPoints[i].x < minX) {
                            minX = this.polygonPoints[i].x;
                        }
                        else if (this.polygonPoints[i].x > maxX) {
                            maxX = this.polygonPoints[i].x;
                        }
                        if (this.polygonPoints[i].y < minY) {
                            minY = this.polygonPoints[i].y;
                        }
                        else if (this.polygonPoints[i].y > maxY) {
                            maxY = this.polygonPoints[i].y;
                        }
                    }
                    return {
                        left: minX,
                        top: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                };
                /**
                 * Check if point exist inside polygon shape.
                 *
                 * @return true/false if point exist inside shape.
                 * ray-casting algorithm based on:
                 * http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                 */
                Polygon.prototype.inside = function (point) {
                    var x = point.x, y = point.y;
                    var insideVar = false;
                    for (var i = 0, j = this.polygonPoints.length - 1; i < this.polygonPoints.length; j = i++) {
                        var xi = this.polygonPoints[i].x, yi = this.polygonPoints[i].y;
                        var xj = this.polygonPoints[j].x, yj = this.polygonPoints[j].y;
                        var intersect = ((yi > y) !== (yj > y))
                            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                        if (intersect) {
                            insideVar = !insideVar;
                        }
                    }
                    return insideVar;
                };
                ;
                /**
                 * Checks if a line (presented as two points) intersects with a another line
                 */
                Polygon.prototype.getLineIntersection = function (line0p1, line0p2, line1p1, line1p2) {
                    var p0_x = line0p1.x;
                    var p0_y = line0p1.y;
                    var p1_x = line0p2.x;
                    var p1_y = line0p2.y;
                    var p2_x = line1p1.x;
                    var p2_y = line1p1.y;
                    var p3_x = line1p2.x;
                    var p3_y = line1p2.y;
                    var s1_x = p1_x - p0_x;
                    var s1_y = p1_y - p0_y;
                    var s2_x = p3_x - p2_x;
                    var s2_y = p3_y - p2_y;
                    //Calculating collisions using cross products
                    var s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
                    var t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
                    // 0<=s<=1 and 0<=t<=1 ensures that the collision is part of the original line
                    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                        // Collision detected
                        return { x: (p0_x + (t * s1_x)), y: (p0_y + (t * s1_y)) };
                    }
                    return null; // No collision
                };
                Polygon.prototype.convertArrayPathToPoints = function (path) {
                    var pointsRes = [];
                    for (var i = 0; i < path.length; i += 2) {
                        var x = path[i];
                        var y = path[i + 1];
                        var newPoint = {
                            x: x,
                            y: y,
                        };
                        pointsRes.push(newPoint);
                    }
                    return pointsRes;
                };
                return Polygon;
            }());
            shapes.Polygon = Polygon;
            var Point;
            (function (Point) {
                function offset(point, offsetX, offsetY) {
                    var newPointX = ((point.x + offsetX) >= 0) ? (point.x + offsetX) : 0;
                    var newPointY = ((point.y + offsetY) >= 0) ? (point.y + offsetY) : 0;
                    return { x: newPointX, y: newPointY };
                }
                Point.offset = offset;
                function equals(point, other) {
                    return point !== undefined && point !== null && other !== undefined && other !== null && point.x === other.x && point.y === other.y;
                }
                Point.equals = equals;
                function clone(point) {
                    return (point !== null) ? { x: point.x, y: point.y } : null;
                }
                Point.clone = clone;
                function toString(point) {
                    return "{x:" + point.x + ", y:" + point.y + "}";
                }
                Point.toString = toString;
                function serialize(point) {
                    return point.x + "," + point.y;
                }
                Point.serialize = serialize;
                function getDistance(point, other) {
                    if ((point === null) || (other) === null) {
                        return null;
                    }
                    var diffX = other.x - point.x;
                    var diffY = other.y - point.y;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
                }
                Point.getDistance = getDistance;
                function equalWithPrecision(point1, point2) {
                    return point1 === point2 ||
                        (point1 !== undefined && point2 !== undefined && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y));
                }
                Point.equalWithPrecision = equalWithPrecision;
                function parsePoint(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { x: Utility.parseNumber(value[0]), y: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { x: Utility.parseNumber(parts[0]), y: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { x: Utility.parseNumber(value.x), y: Utility.parseNumber(value.y) };
                        }
                    }
                }
                Point.parsePoint = parsePoint;
            })(Point = shapes.Point || (shapes.Point = {}));
            var Size;
            (function (Size) {
                function isEmpty(size) {
                    return size.width === 0 && size.height === 0;
                }
                Size.isEmpty = isEmpty;
                function equals(size, other) {
                    return size !== undefined && size !== null && other !== undefined && other !== null && size.width === other.width && size.height === other.height;
                }
                Size.equals = equals;
                function clone(size) {
                    return (size !== null) ? { width: size.width, height: size.height } : null;
                }
                Size.clone = clone;
                function inflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Size.inflate = inflate;
                function deflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width = result.width - padding.left - padding.right;
                        if (result.width < 0) {
                            result.width = 0;
                        }
                        result.height = result.height - padding.top - padding.bottom;
                        if (result.height < 0) {
                            result.height = 0;
                        }
                    }
                    return result;
                }
                Size.deflate = deflate;
                function combine(size, other) {
                    if (other) {
                        size.width = Math.max(size.width, other.width);
                        size.height = Math.max(size.height, other.height);
                    }
                    return size;
                }
                Size.combine = combine;
                function toRect(size) {
                    return { left: 0, top: 0, width: size.width, height: size.height };
                }
                Size.toRect = toRect;
                function toString(size) {
                    return "{width:" + size.width + ", height:" + size.height + "}";
                }
                Size.toString = toString;
                function equal(size1, size2) {
                    return size1 === size2 ||
                        (size1 !== undefined && size2 !== undefined && size1.width === size2.width && size1.height === size2.height);
                }
                Size.equal = equal;
                function equalWithPrecision(size1, size2) {
                    return size1 === size2 ||
                        (size1 !== undefined && size2 !== undefined && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height));
                }
                Size.equalWithPrecision = equalWithPrecision;
                function parseSize(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { width: Utility.parseNumber(value[0]), height: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { width: Utility.parseNumber(parts[0]), height: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Size.parseSize = parseSize;
            })(Size = shapes.Size || (shapes.Size = {}));
            var Rect;
            (function (Rect) {
                function getOffset(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.getOffset = getOffset;
                function getSize(rect) {
                    return { width: rect.width, height: rect.height };
                }
                Rect.getSize = getSize;
                function setSize(rect, value) {
                    rect.width = value.width;
                    rect.height = value.height;
                }
                Rect.setSize = setSize;
                function right(rect) {
                    return rect.left + rect.width;
                }
                Rect.right = right;
                function bottom(rect) {
                    return rect.top + rect.height;
                }
                Rect.bottom = bottom;
                function topLeft(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.topLeft = topLeft;
                function topRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top };
                }
                Rect.topRight = topRight;
                function bottomLeft(rect) {
                    return { x: rect.left, y: rect.top + rect.height };
                }
                Rect.bottomLeft = bottomLeft;
                function bottomRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top + rect.height };
                }
                Rect.bottomRight = bottomRight;
                function equals(rect, other) {
                    return other !== undefined && other !== null &&
                        rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
                }
                Rect.equals = equals;
                function clone(rect) {
                    return (rect !== null) ? { left: rect.left, top: rect.top, width: rect.width, height: rect.height } : null;
                }
                Rect.clone = clone;
                function toString(rect) {
                    return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
                }
                Rect.toString = toString;
                function offset(rect, offsetX, offsetY) {
                    var newLeft = ((rect.left + offsetX) >= 0) ? rect.left + offsetX : 0;
                    var newTop = ((rect.top + offsetY) >= 0) ? rect.top + offsetY : 0;
                    return { left: newLeft, top: newTop, width: rect.width, height: rect.height };
                }
                Rect.offset = offset;
                function inflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left -= padding.left;
                        result.top -= padding.top;
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.inflate = inflate;
                function deflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left += padding.left;
                        result.top += padding.top;
                        result.width -= padding.left + padding.right;
                        result.height -= padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.deflate = deflate;
                function inflateBy(rect, padding) {
                    return { left: rect.left - padding, top: rect.top - padding, width: rect.width + padding + padding, height: rect.height + padding + padding };
                }
                Rect.inflateBy = inflateBy;
                function deflateBy(rect, padding) {
                    return { left: rect.left + padding, top: rect.top + padding, width: rect.width - padding - padding, height: rect.height - padding - padding };
                }
                Rect.deflateBy = deflateBy;
                /**
                 * Get closest point.
                 *
                 * @return the closest point on the rect to the (x,y) point given.
                 * In case the (x,y) given is inside the rect, (x,y) will be returned.
                 * Otherwise, a point on a border will be returned.
                 */
                function getClosestPoint(rect, x, y) {
                    return {
                        x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
                        y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
                    };
                }
                Rect.getClosestPoint = getClosestPoint;
                function equal(rect1, rect2) {
                    return rect1 === rect2 ||
                        (rect1 !== undefined && rect2 !== undefined && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height);
                }
                Rect.equal = equal;
                function equalWithPrecision(rect1, rect2) {
                    return rect1 === rect2 ||
                        (rect1 !== undefined && rect2 !== undefined &&
                            powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) &&
                            powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height));
                }
                Rect.equalWithPrecision = equalWithPrecision;
                function isEmpty(rect) {
                    return rect === undefined || rect === null || (rect.width === 0 && rect.height === 0);
                }
                Rect.isEmpty = isEmpty;
                function containsPoint(rect, point) {
                    if ((rect === null) || (point === null)) {
                        return false;
                    }
                    return powerbi.Double.lessOrEqualWithPrecision(rect.left, point.x) &&
                        powerbi.Double.lessOrEqualWithPrecision(point.x, rect.left + rect.width) &&
                        powerbi.Double.lessOrEqualWithPrecision(rect.top, point.y) &&
                        powerbi.Double.lessOrEqualWithPrecision(point.y, rect.top + rect.height);
                }
                Rect.containsPoint = containsPoint;
                function isIntersecting(rect1, rect2) {
                    if (!rect1 || !rect2) {
                        return false;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    if (left > right) {
                        return false;
                    }
                    var top = Math.max(rect1.top, rect2.top);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    return top <= bottom;
                }
                Rect.isIntersecting = isIntersecting;
                function intersect(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var top = Math.max(rect1.top, rect2.top);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    if (left <= right && top <= bottom) {
                        return { left: left, top: top, width: right - left, height: bottom - top };
                    }
                    else {
                        return { left: 0, top: 0, width: 0, height: 0 };
                    }
                }
                Rect.intersect = intersect;
                function combine(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.min(rect1.left, rect2.left);
                    var top = Math.min(rect1.top, rect2.top);
                    var right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
                    return { left: left, top: top, width: right - left, height: bottom - top };
                }
                Rect.combine = combine;
                function parseRect(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), width: Utility.parseNumber(value[2]), height: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return {
                                left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), width: Utility.parseNumber(parts[2]), height: Utility.parseNumber(parts[3])
                            };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Rect.parseRect = parseRect;
            })(Rect = shapes.Rect || (shapes.Rect = {}));
            var Thickness;
            (function (Thickness) {
                function inflate(thickness, other) {
                    var result = clone(thickness);
                    if (other) {
                        result.left = thickness.left + other.left;
                        result.right = thickness.right + other.right;
                        result.bottom = thickness.bottom + other.bottom;
                        result.top = thickness.top + other.top;
                    }
                    return result;
                }
                Thickness.inflate = inflate;
                function getWidth(thickness) {
                    return thickness.left + thickness.right;
                }
                Thickness.getWidth = getWidth;
                function getHeight(thickness) {
                    return thickness.top + thickness.bottom;
                }
                Thickness.getHeight = getHeight;
                function clone(thickness) {
                    return (thickness !== null) ? { left: thickness.left, top: thickness.top, right: thickness.right, bottom: thickness.bottom } : null;
                }
                Thickness.clone = clone;
                function equals(thickness, other) {
                    return thickness !== undefined && thickness !== null && other !== undefined && other !== null && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
                }
                Thickness.equals = equals;
                function flipHorizontal(thickness) {
                    var temp = thickness.right;
                    thickness.right = thickness.left;
                    thickness.left = temp;
                }
                Thickness.flipHorizontal = flipHorizontal;
                function flipVertical(thickness) {
                    var top = thickness.top;
                    thickness.top = thickness.bottom;
                    thickness.bottom = top;
                }
                Thickness.flipVertical = flipVertical;
                function toString(thickness) {
                    return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
                }
                Thickness.toString = toString;
                function toCssString(thickness) {
                    return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
                }
                Thickness.toCssString = toCssString;
                function isEmpty(thickness) {
                    return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;
                }
                Thickness.isEmpty = isEmpty;
                function equal(thickness1, thickness2) {
                    return thickness1 === thickness2 ||
                        (thickness1 !== undefined && thickness2 !== undefined && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom);
                }
                Thickness.equal = equal;
                function equalWithPrecision(thickness1, thickness2) {
                    return thickness1 === thickness2 ||
                        (thickness1 !== undefined && thickness2 !== undefined &&
                            powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) &&
                            powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom));
                }
                Thickness.equalWithPrecision = equalWithPrecision;
                function parseThickness(value, defaultValue, resetValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), right: Utility.parseNumber(value[2]), bottom: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), right: Utility.parseNumber(parts[2]), bottom: Utility.parseNumber(parts[3]) };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), right: Utility.parseNumber(value.right), bottom: Utility.parseNumber(value.bottom) };
                        }
                    }
                }
                Thickness.parseThickness = parseThickness;
            })(Thickness = shapes.Thickness || (shapes.Thickness = {}));
            var Vector;
            (function (Vector) {
                function isEmpty(vector) {
                    return vector.x === 0 && vector.y === 0;
                }
                Vector.isEmpty = isEmpty;
                function equals(vector, other) {
                    return vector !== undefined && vector !== null && other !== undefined && other !== null && vector.x === other.x && vector.y === other.y;
                }
                Vector.equals = equals;
                function clone(vector) {
                    return (vector !== null) ? { x: vector.x, y: vector.y } : null;
                }
                Vector.clone = clone;
                function toString(vector) {
                    return "{x:" + vector.x + ", y:" + vector.y + "}";
                }
                Vector.toString = toString;
                function getLength(vector) {
                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                }
                Vector.getLength = getLength;
                function getLengthSqr(vector) {
                    return vector.x * vector.x + vector.y * vector.y;
                }
                Vector.getLengthSqr = getLengthSqr;
                function scale(vector, scalar) {
                    return { x: vector.x * scalar, y: vector.y * scalar };
                }
                Vector.scale = scale;
                function normalize(vector) {
                    return !isEmpty(vector) ? scale(vector, 1 / getLength(vector)) : vector;
                }
                Vector.normalize = normalize;
                function rotate90DegCW(vector) {
                    return { x: vector.y, y: -vector.x };
                }
                Vector.rotate90DegCW = rotate90DegCW;
                function rotate90DegCCW(vector) {
                    return { x: -vector.y, y: vector.x };
                }
                Vector.rotate90DegCCW = rotate90DegCCW;
                function rotate(vector, angle) {
                    var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle);
                    var newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
                    return { x: newX, y: newY };
                }
                Vector.rotate = rotate;
                function equal(vector1, vector2) {
                    return vector1 === vector2 ||
                        (vector1 !== undefined && vector2 !== undefined && vector1.x === vector2.x && vector1.y === vector2.y);
                }
                Vector.equal = equal;
                function equalWithPrecision(vector1, vector2) {
                    return vector1 === vector2 ||
                        (vector1 !== undefined && vector2 !== undefined && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y));
                }
                Vector.equalWithPrecision = equalWithPrecision;
                function add(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x + vect2.x, y: vect1.y + vect2.y };
                }
                Vector.add = add;
                function subtract(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x - vect2.x, y: vect1.y - vect2.y };
                }
                Vector.subtract = subtract;
                function dotProduct(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return vect1.x * vect2.x + vect1.y * vect2.y;
                }
                Vector.dotProduct = dotProduct;
                function getDeltaVector(p0, p1) {
                    if (!p0 || !p1) {
                        return undefined;
                    }
                    return { x: p1.x - p0.x, y: p1.y - p0.y };
                }
                Vector.getDeltaVector = getDeltaVector;
            })(Vector = shapes.Vector || (shapes.Vector = {}));
        })(shapes = visuals.shapes || (visuals.shapes = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        /** Utility class for slicer*/
        var SlicerUtil;
        (function (SlicerUtil) {
            /** CSS selectors for slicer elements. */
            var Selectors;
            (function (Selectors) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                Selectors.HeaderContainer = createClassAndSelector('headerContainer');
                Selectors.Header = createClassAndSelector('slicerHeader');
                Selectors.HeaderText = createClassAndSelector('headerText');
                Selectors.Body = createClassAndSelector('slicerBody');
                Selectors.Label = createClassAndSelector('slicerLabel');
                Selectors.LabelText = createClassAndSelector('slicerText');
                Selectors.LabelImage = createClassAndSelector('slicerImage');
                Selectors.CountText = createClassAndSelector('slicerCountText');
                Selectors.Clear = createClassAndSelector('clear');
                Selectors.MultiSelectEnabled = createClassAndSelector('isMultiSelectEnabled');
            })(Selectors = SlicerUtil.Selectors || (SlicerUtil.Selectors = {}));
            /** Const declarations*/
            var DisplayNameKeys;
            (function (DisplayNameKeys) {
                DisplayNameKeys.Clear = 'Slicer_Clear';
                DisplayNameKeys.SelectAll = 'Slicer_SelectAll';
            })(DisplayNameKeys = SlicerUtil.DisplayNameKeys || (SlicerUtil.DisplayNameKeys = {}));
            /** Helper class for slicer settings  */
            var SettingsHelper;
            (function (SettingsHelper) {
                function areSettingsDefined(data) {
                    return data != null && data.slicerSettings != null;
                }
                SettingsHelper.areSettingsDefined = areSettingsDefined;
            })(SettingsHelper = SlicerUtil.SettingsHelper || (SlicerUtil.SettingsHelper = {}));
            /** Helper class for handling slicer default value  */
            var DefaultValueHandler;
            (function (DefaultValueHandler) {
                function getIdentityFields(dataView) {
                    if (!dataView)
                        return;
                    var dataViewCategorical = dataView.categorical;
                    if (!dataViewCategorical || _.isEmpty(dataViewCategorical.categories))
                        return;
                    return dataViewCategorical.categories[0].identityFields;
                }
                DefaultValueHandler.getIdentityFields = getIdentityFields;
            })(DefaultValueHandler = SlicerUtil.DefaultValueHandler || (SlicerUtil.DefaultValueHandler = {}));
            // Compare the sqExpr of the scopeId with sqExprs of the retained values. 
            // If match found, remove the item from the retainedValues list, and return true, 
            // otherwise return false.
            function tryRemoveValueFromRetainedList(value, selectedScopeIds, caseInsensitive) {
                if (!value || _.isEmpty(selectedScopeIds))
                    return false;
                for (var i = 0, len = selectedScopeIds.length; i < len; i++) {
                    var retainedValueScopeId = selectedScopeIds[i];
                    if (powerbi.DataViewScopeIdentity.equals(value, retainedValueScopeId, caseInsensitive)) {
                        selectedScopeIds.splice(i, 1);
                        return true;
                    }
                }
                return false;
            }
            SlicerUtil.tryRemoveValueFromRetainedList = tryRemoveValueFromRetainedList;
            /** Helper class for creating and measuring slicer DOM elements  */
            var DOMHelper = (function () {
                function DOMHelper() {
                }
                DOMHelper.prototype.createSlicerHeader = function (hostServices) {
                    var slicerHeaderDiv = document.createElement('div');
                    slicerHeaderDiv.className = Selectors.Header.class;
                    var slicerHeader = d3.select(slicerHeaderDiv);
                    slicerHeader.append('span')
                        .classed(Selectors.Clear.class, true)
                        .attr('title', hostServices.getLocalizedString(DisplayNameKeys.Clear));
                    slicerHeader.append('div').classed(Selectors.HeaderText.class, true);
                    return slicerHeaderDiv;
                };
                DOMHelper.prototype.getHeaderTextProperties = function (settings) {
                    var headerTextProperties = {
                        fontFamily: 'wf_segoe-ui_normal',
                        fontSize: '10px'
                    };
                    if (settings.header.show) {
                        headerTextProperties.fontSize = PixelConverter.fromPoint(settings.header.textSize);
                    }
                    return headerTextProperties;
                };
                DOMHelper.prototype.getSlicerBodyViewport = function (currentViewport, settings, headerTextProperties) {
                    var headerHeight = (settings.header.show) ? this.getHeaderHeight(settings, headerTextProperties) : 0;
                    var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                    return {
                        height: slicerBodyHeight,
                        width: currentViewport.width
                    };
                };
                DOMHelper.prototype.updateSlicerBodyDimensions = function (currentViewport, slicerBody, settings) {
                    var slicerViewport = this.getSlicerBodyViewport(currentViewport, settings, this.getHeaderTextProperties(settings));
                    slicerBody.style({
                        'height': PixelConverter.toString(slicerViewport.height),
                        'width': PixelConverter.toString(slicerViewport.width),
                    });
                };
                DOMHelper.prototype.getHeaderHeight = function (settings, textProperties) {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.header.textSize, textProperties)) + settings.general.outlineWeight;
                };
                DOMHelper.prototype.getRowHeight = function (settings, textProperties) {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.slicerText.textSize, textProperties)) + this.getRowsOutlineWidth(settings.slicerText.outline, settings.general.outlineWeight);
                };
                DOMHelper.prototype.styleSlicerHeader = function (slicerHeader, settings, headerText) {
                    if (settings.header.show) {
                        slicerHeader.style('display', 'block');
                        var headerTextElement = slicerHeader.select(Selectors.HeaderText.selector)
                            .text(headerText);
                        this.setSlicerHeaderTextStyle(headerTextElement, settings);
                    }
                    else {
                        slicerHeader.style('display', 'none');
                    }
                };
                DOMHelper.prototype.setSlicerTextStyle = function (slicerText, settings) {
                    slicerText
                        .style({
                        'color': settings.slicerText.color,
                        'background-color': settings.slicerText.background,
                        'border-style': 'solid',
                        'border-color': settings.general.outlineColor,
                        'border-width': visuals.VisualBorderUtil.getBorderWidth(settings.slicerText.outline, settings.general.outlineWeight),
                        'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
                    });
                };
                DOMHelper.prototype.getRowsOutlineWidth = function (outlineElement, outlineWeight) {
                    switch (outlineElement) {
                        case visuals.outline.none:
                        case visuals.outline.leftRight:
                            return 0;
                        case visuals.outline.bottomOnly:
                        case visuals.outline.topOnly:
                            return outlineWeight;
                        case visuals.outline.topBottom:
                        case visuals.outline.frame:
                            return outlineWeight * 2;
                        default:
                            return 0;
                    }
                };
                DOMHelper.prototype.setSlicerHeaderTextStyle = function (slicerHeader, settings) {
                    slicerHeader
                        .style({
                        'border-style': 'solid',
                        'border-color': settings.general.outlineColor,
                        'border-width': visuals.VisualBorderUtil.getBorderWidth(settings.header.outline, settings.general.outlineWeight),
                        'color': settings.header.fontColor,
                        'background-color': settings.header.background,
                        'font-size': PixelConverter.fromPoint(settings.header.textSize),
                    });
                };
                DOMHelper.prototype.getTextProperties = function (textSize, textProperties) {
                    textProperties.fontSize = PixelConverter.fromPoint(textSize);
                    return textProperties;
                };
                return DOMHelper;
            }());
            SlicerUtil.DOMHelper = DOMHelper;
        })(SlicerUtil = visuals.SlicerUtil || (visuals.SlicerUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in adding tooltips.
         */
        var tooltipUtils;
        (function (tooltipUtils) {
            function tooltipUpdate(selection, tooltips) {
                if (tooltips.length === 0)
                    return;
                debug.assert(selection.length === tooltips.length || selection[0].length === tooltips.length, 'data length should match dom element count');
                var titles = selection.selectAll('title');
                var titlesUpdate = titles.data(function (d, i) { return [tooltips[i]]; });
                titlesUpdate.enter().append('title');
                titlesUpdate.exit().remove();
                titlesUpdate.text(function (d) { return d; });
            }
            tooltipUtils.tooltipUpdate = tooltipUpdate;
        })(tooltipUtils = visuals.tooltipUtils || (visuals.tooltipUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in SVG manupilation.
         */
        var SVGUtil;
        (function (SVGUtil) {
            /**
             * Very small values, when stringified, may be converted to scientific notation and cause a temporarily
             * invalid attribute or style property value.
             * For example, the number 0.0000001 is converted to the string "1e-7".
             * This is particularly noticeable when interpolating opacity values.
             * To avoid scientific notation, start or end the transition at 1e-6,
             * which is the smallest value that is not stringified in exponential notation.
             */
            SVGUtil.AlmostZero = 1e-6;
            /**
             * Creates a translate string for use with the SVG transform call.
             */
            function translate(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + ',' + y + ')';
            }
            SVGUtil.translate = translate;
            /**
             * Creates a translateX string for use with the SVG transform call.
             */
            function translateXWithPixels(x) {
                debug.assertValue(x, 'x');
                return 'translateX(' + x + 'px)';
            }
            SVGUtil.translateXWithPixels = translateXWithPixels;
            function translateWithPixels(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + 'px,' + y + 'px)';
            }
            SVGUtil.translateWithPixels = translateWithPixels;
            /**
             * Creates a translate + rotate string for use with the SVG transform call.
             */
            function translateAndRotate(x, y, px, py, angle) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                debug.assertValue(px, 'px');
                debug.assertValue(py, 'py');
                debug.assertValue(angle, 'angle');
                return 'transform', "translate("
                    + x + "," + y + ")"
                    + " rotate(" + angle + "," + px + "," + py + ")";
            }
            SVGUtil.translateAndRotate = translateAndRotate;
            /**
             * Creates a scale string for use in a CSS transform property.
             */
            function scale(scale) {
                debug.assertValue(scale, 'scale');
                return "scale(" + scale + ")";
            }
            SVGUtil.scale = scale;
            /**
             * Creates a translate + scale string for use with the SVG transform call.
             */
            function translateAndScale(x, y, ratio) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                debug.assertValue(ratio, 'ratio');
                return 'transform', "translate("
                    + x + "," + y + ")"
                    + " scale(" + ratio + ")";
            }
            SVGUtil.translateAndScale = translateAndScale;
            /**
             * Creates a transform origin string for use in a CSS transform-origin property.
             */
            function transformOrigin(xOffset, yOffset) {
                debug.assertValue(xOffset, 'xOffset');
                debug.assertValue(yOffset, 'yOffset');
                return xOffset + " " + yOffset;
            }
            SVGUtil.transformOrigin = transformOrigin;
            /**
             * Forces all D3 transitions to complete.
             * Normally, zero-delay transitions are executed after an instantaneous delay (<10ms).
             * This can cause a brief flicker if the browser renders the page twice: once at the end of the first event loop,
             * then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop,
             * you can run any zero-delay transitions immediately and avoid the flicker.
             *
             * These flickers are noticable on IE, and with a large number of webviews(not recommend you ever do this) on iOS.
             */
            function flushAllD3Transitions() {
                var now = Date.now;
                Date.now = function () { return Infinity; };
                d3.timer.flush();
                Date.now = now;
            }
            SVGUtil.flushAllD3Transitions = flushAllD3Transitions;
            /**
             * Wrapper for flushAllD3Transitions.
             */
            function flushAllD3TransitionsIfNeeded(options) {
                if (!options)
                    return;
                var animationOptions = options;
                var asVisualInitOptions = options;
                if (asVisualInitOptions.animation)
                    animationOptions = asVisualInitOptions.animation;
                if (animationOptions && animationOptions.transitionImmediate) {
                    flushAllD3Transitions();
                }
            }
            SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded;
            /**
             * There is a known bug in IE10 that causes cryptic crashes for SVG elements with a null 'd' attribute:
             * https://github.com/mbostock/d3/issues/1737
             */
            function ensureDAttribute(pathElement) {
                if (!pathElement.getAttribute('d')) {
                    pathElement.setAttribute('d', '');
                }
            }
            SVGUtil.ensureDAttribute = ensureDAttribute;
            /**
             * In IE10, it is possible to return SVGPoints with NaN members.
             */
            function ensureValidSVGPoint(point) {
                if (isNaN(point.x)) {
                    point.x = 0;
                }
                if (isNaN(point.y)) {
                    point.y = 0;
                }
            }
            SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint;
            /**
             * Parse the Transform string with value 'translate(x,y)'.
             * In Chrome for the translate(position) string the delimiter
             * is a comma and in IE it is a spaceso checking for both.
             */
            function parseTranslateTransform(input) {
                if (!input || input.length === 0) {
                    return {
                        x: "0",
                        y: "0",
                    };
                }
                var translateCoordinates = input.split(/[\s,]+/);
                debug.assertValue(translateCoordinates, 'translateCoordinates');
                debug.assert(translateCoordinates.length > 0, 'translate array must atleast have one value');
                var yValue = '0';
                var xValue;
                var xCoord = translateCoordinates[0];
                // Y coordinate is ommited in I.E if it is 0, so need to check against that
                if (translateCoordinates.length === 1) {
                    // 10 refers to the length of 'translate('
                    xValue = xCoord.substring(10, xCoord.length - 1);
                }
                else {
                    var yCoord = translateCoordinates[1];
                    yValue = yCoord.substring(0, yCoord.length - 1);
                    // 10 refers to the length of 'translate('
                    xValue = xCoord.substring(10, xCoord.length);
                }
                return {
                    x: xValue,
                    y: yValue
                };
            }
            SVGUtil.parseTranslateTransform = parseTranslateTransform;
            /**
             * Create an arrow.
             */
            function createArrow(width, height, rotate) {
                var transform = "rotate(" + rotate + " " + width / 2 + " " + height / 2 + ")";
                var path = "M0 0";
                path += "L0 " + height;
                path += "L" + width + " " + height / 2 + " Z";
                return {
                    path: path,
                    transform: transform
                };
            }
            SVGUtil.createArrow = createArrow;
            /**
             * Use the ratio of the scaled bounding rect and the SVG DOM bounding box to get the x and y transform scale values
             */
            function getTransformScaleRatios(svgElement) {
                if (svgElement != null) {
                    var scaledRect = svgElement.getBoundingClientRect();
                    var domRect = svgElement.getBBox();
                    if (domRect.height > 0 && domRect.width > 0) {
                        return {
                            x: scaledRect.width / domRect.width,
                            y: scaledRect.height / domRect.height
                        };
                    }
                }
                return { x: 1, y: 1 };
            }
            SVGUtil.getTransformScaleRatios = getTransformScaleRatios;
        })(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in text manupilation.
         */
        var TextUtil;
        (function (TextUtil) {
            /**
             * Remove breaking spaces from given string and replace by none breaking space (&nbsp).
             */
            function removeBreakingSpaces(str) {
                return str.toString().replace(new RegExp(' ', 'g'), '&nbsp');
            }
            TextUtil.removeBreakingSpaces = removeBreakingSpaces;
            /**
             * Remove ellipses from a given string
             */
            function removeEllipses(str) {
                return str.replace(//g, '');
            }
            TextUtil.removeEllipses = removeEllipses;
            /**
            * Replace every whitespace (0x20) with Non-Breaking Space (0xA0)
             * @param {string} txt String to replace White spaces
             * @returns Text after replcing white spaces
             */
            function replaceSpaceWithNBSP(txt) {
                if (txt != null)
                    return txt.replace(/ /g, "\xA0");
            }
            TextUtil.replaceSpaceWithNBSP = replaceSpaceWithNBSP;
        })(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        ;
        var GradientUtils;
        (function (GradientUtils) {
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var DefaultMidColor = "#ffffff";
            var DataPointPropertyIdentifier = "dataPoint";
            var FillRulePropertyIdentifier = "fillRule";
            function getFillRuleRole(objectDescs) {
                if (!objectDescs)
                    return;
                for (var objectName in objectDescs) {
                    var objectDesc = objectDescs[objectName];
                    for (var propertyName in objectDesc.properties) {
                        var propertyDesc = objectDesc.properties[propertyName];
                        if (propertyDesc.type && propertyDesc.type[FillRulePropertyIdentifier]) {
                            return propertyDesc.rule.inputRole;
                        }
                    }
                }
            }
            GradientUtils.getFillRuleRole = getFillRuleRole;
            function shouldShowGradient(visualConfig) {
                var isShowGradienCard = visualConfig && visualConfig.query && visualConfig.query.projections && visualConfig.query.projections['Gradient'] ? true : false;
                return isShowGradienCard;
            }
            GradientUtils.shouldShowGradient = shouldShowGradient;
            function getUpdatedGradientSettings(gradientObject) {
                var gradientSettings;
                if (gradientObject && !$.isEmptyObject(gradientObject)) {
                    gradientSettings = getDefaultGradientSettings();
                    for (var propertyName in gradientSettings) {
                        var hasProperty = gradientObject.hasOwnProperty(propertyName);
                        if (hasProperty) {
                            var value = gradientObject[propertyName];
                            if (value && value.solid && value.solid.color) {
                                value = value.solid.color;
                            }
                            gradientSettings[propertyName] = value;
                        }
                    }
                }
                return gradientSettings;
            }
            GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings;
            function getGradientMeasureIndex(dataViewCategorical) {
                if (dataViewCategorical && dataViewCategorical.values && dataViewCategorical.values.grouped) {
                    var grouped = dataViewCategorical.values.grouped();
                    return DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');
                }
                return -1;
            }
            GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex;
            function getGradientValueColumn(dataViewCategorical) {
                if (dataViewCategorical == null)
                    return null;
                // check for gradient measure index 
                var gradientMeasureIndex = GradientUtils.getGradientMeasureIndex(dataViewCategorical);
                var gradientValueColumn = gradientMeasureIndex === -1 ? null : dataViewCategorical.values[gradientMeasureIndex];
                return gradientValueColumn;
            }
            GradientUtils.getGradientValueColumn = getGradientValueColumn;
            function hasGradientRole(dataViewCategorical) {
                var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
                return gradientMeasureIndex >= 0;
            }
            GradientUtils.hasGradientRole = hasGradientRole;
            function getDefaultGradientSettings() {
                var colors = getDefaultColors();
                var gradientSettings = {
                    diverging: false,
                    minColor: colors.minColor,
                    midColor: DefaultMidColor,
                    maxColor: colors.maxColor,
                    minValue: undefined,
                    midValue: undefined,
                    maxValue: undefined,
                };
                return gradientSettings;
            }
            GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings;
            function getDefaultFillRuleDefinition() {
                return getLinearGradien2FillRuleDefinition();
            }
            GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition;
            function updateFillRule(propertyName, propertyValue, definitions) {
                var dataPointObjectDefinition = powerbi.data.DataViewObjectDefinitions.ensure(definitions, DataPointPropertyIdentifier, null);
                var fillRule = getFillRule(definitions);
                var numericValueExpr;
                var colorValueExpr;
                if (!fillRule) {
                    return;
                }
                if ($.isNumeric(propertyValue)) {
                    numericValueExpr = propertyValue !== undefined ? SQExprBuilder.double(+propertyValue) : undefined;
                    ;
                }
                if (propertyName === "minColor" || propertyName === "midColor" || propertyName === "maxColor") {
                    colorValueExpr = getColorExpressionValue(fillRule, propertyName, propertyValue);
                }
                if (propertyName === "minColor") {
                    updateMinColor(fillRule, colorValueExpr);
                }
                else if (propertyName === "midColor") {
                    updateMidColor(fillRule, colorValueExpr);
                }
                else if (propertyName === "maxColor") {
                    updateMaxColor(fillRule, colorValueExpr);
                }
                else if (propertyName === "minValue") {
                    updateMinValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "midValue") {
                    updateMidValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "maxValue") {
                    updateMaxValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "diverging") {
                    if (propertyValue) {
                        fillRule = getLinearGradien3FillRuleDefinition(fillRule);
                    }
                    else {
                        fillRule = getLinearGradien2FillRuleDefinition(fillRule);
                    }
                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
                }
                else if (propertyName === "revertToDefault") {
                    fillRule = this.getDefaultFillRuleDefinition();
                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
                }
            }
            GradientUtils.updateFillRule = updateFillRule;
            function getGradientSettings(baseFillRule) {
                if (baseFillRule) {
                    return getGradientSettingsFromRule(baseFillRule);
                }
                else {
                    return getDefaultGradientSettings();
                }
            }
            GradientUtils.getGradientSettings = getGradientSettings;
            function getFillRule(objectDefinitions) {
                var fillRuleDefinition = powerbi.data.DataViewObjectDefinitions.getValue(objectDefinitions, { objectName: DataPointPropertyIdentifier, propertyName: FillRulePropertyIdentifier }, null);
                return fillRuleDefinition;
            }
            GradientUtils.getFillRule = getFillRule;
            function getDefaultColors() {
                var dataColors = new powerbi.visuals.DataColorPalette();
                var maxColorInfo = dataColors.getColorByIndex(0);
                var colors = d3.scale.linear()
                    .domain([0, 100])
                    .range(["#ffffff", maxColorInfo.value]);
                var maxColor = maxColorInfo.value;
                var minColor = colors(20);
                var midColor = DefaultMidColor;
                return {
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                };
            }
            function getGradientSettingsFromRule(fillRule) {
                var maxColor;
                var minColor;
                var midColor = DefaultMidColor;
                var maxValue;
                var midValue;
                var minValue;
                var diverging = fillRule.linearGradient3 !== undefined;
                if (fillRule.linearGradient2) {
                    var maxColorExpr = fillRule.linearGradient2.max.color;
                    var minColorExpr = fillRule.linearGradient2.min.color;
                    var maxValueExpr = fillRule.linearGradient2.max.value;
                    var minValueExpr = fillRule.linearGradient2.min.value;
                    maxColor = maxColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                }
                else if (fillRule.linearGradient3) {
                    var maxColorExpr = fillRule.linearGradient3.max.color;
                    var midColorExpr = fillRule.linearGradient3.mid.color;
                    var minColorExpr = fillRule.linearGradient3.min.color;
                    var maxValueExpr = fillRule.linearGradient3.max.value;
                    var midValueExpr = fillRule.linearGradient3.mid.value;
                    var minValueExpr = fillRule.linearGradient3.min.value;
                    maxColor = maxColorExpr.value;
                    midColor = midColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (midValueExpr) {
                        midValue = midValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                }
                return {
                    diverging: diverging,
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                    minValue: minValue,
                    midValue: midValue,
                    maxValue: maxValue,
                };
            }
            GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule;
            function getLinearGradien2FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient2: {
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                    }
                };
                return fillRuleDefinition;
            }
            function getLinearGradien3FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient3: {
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        mid: { color: SQExprBuilder.text(gradientSettings.midColor) },
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                    }
                };
                return fillRuleDefinition;
            }
            function getDefaultColorExpression(fillRule, propertyName) {
                var defaultColor;
                var defaultFillRule;
                if (fillRule.linearGradient3) {
                    defaultFillRule = getLinearGradien3FillRuleDefinition();
                    if (propertyName === "minColor") {
                        defaultColor = defaultFillRule.linearGradient3.min.color;
                    }
                    else if (propertyName === "midColor") {
                        defaultColor = defaultFillRule.linearGradient3.mid.color;
                    }
                    else if (propertyName === "maxColor") {
                        defaultColor = defaultFillRule.linearGradient3.max.color;
                    }
                }
                else if (fillRule.linearGradient2) {
                    defaultFillRule = getLinearGradien2FillRuleDefinition();
                    if (propertyName === "minColor") {
                        defaultColor = defaultFillRule.linearGradient2.min.color;
                    }
                    else if (propertyName === "maxColor") {
                        defaultColor = defaultFillRule.linearGradient2.max.color;
                    }
                }
                return defaultColor;
            }
            function getColorExpressionValue(fillRule, propertyName, propertyValue) {
                var colorExpressionValue;
                if (propertyValue) {
                    colorExpressionValue = SQExprBuilder.text(propertyValue);
                }
                else {
                    colorExpressionValue = getDefaultColorExpression(fillRule, propertyName);
                }
                return colorExpressionValue;
            }
            function updateMinColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.color = colorExpressionValue;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.color = colorExpressionValue;
                }
            }
            function updateMidColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.color = colorExpressionValue;
                }
            }
            function updateMaxColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.color = colorExpressionValue;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.color = colorExpressionValue;
                }
            }
            function updateMinValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.value = value;
                }
            }
            function updateMidValue(fillRule, value) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.value = value;
                }
            }
            function updateMaxValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.value = value;
                }
            }
        })(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
        ;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualBackgroundHelper;
        (function (visualBackgroundHelper) {
            function getDefaultColor() {
                return '#FFF';
            }
            visualBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultTransparency() {
                return 50;
            }
            visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency;
            function getDefaultShow() {
                return false;
            }
            visualBackgroundHelper.getDefaultShow = getDefaultShow;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                    transparency: getDefaultTransparency(),
                    show: getDefaultShow()
                };
            }
            visualBackgroundHelper.getDefaultValues = getDefaultValues;
            function enumeratePlot(enumeration, background) {
                var transparency = (background && background.transparency);
                if (transparency == null)
                    transparency = getDefaultTransparency();
                var backgroundObject = {
                    selector: null,
                    properties: {
                        transparency: transparency,
                        image: (background && background.image)
                    },
                    objectName: 'plotArea',
                };
                enumeration.pushInstance(backgroundObject);
            }
            visualBackgroundHelper.enumeratePlot = enumeratePlot;
            function renderBackgroundImage(background, visualElement, layout) {
                var image = background && background.image;
                var imageUrl = image && image.url;
                var imageFit = image && image.scaling;
                var imageTransparency = background && background.transparency;
                var backgroundImage = visualElement.children('.background-image');
                // If there were image and it was removed
                if (!imageUrl) {
                    if (backgroundImage.length !== 0)
                        backgroundImage.remove();
                    return;
                }
                // If this is the first edit of the image
                if (backgroundImage.length === 0) {
                    // Place the div only if the image exists in order to keep the html as clean as possible
                    visualElement.prepend('<div class="background-image"></div>');
                    backgroundImage = visualElement.children('.background-image');
                    // the div should be positioned absolute in order to get on top of the sibling svg
                    backgroundImage.css('position', 'absolute');
                }
                // Get the size and margins from the visual for the div will placed inside the plot area
                backgroundImage.css({
                    'width': layout.width,
                    'height': layout.height,
                    'margin-left': layout.left,
                    'margin-top': layout.top,
                });
                // Background properties
                backgroundImage.css({
                    'background-image': 'url(' + imageUrl + ')',
                    'background-repeat': 'no-repeat',
                    'opacity': (100 - imageTransparency) / 100,
                });
                switch (imageFit) {
                    // The image will be centered in its initial size
                    case visuals.imageScalingType.normal: {
                        backgroundImage.css({
                            'background-size': '',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                    // The image will be streched all over the background
                    case visuals.imageScalingType.fit: {
                        backgroundImage.css({
                            'background-size': '100% 100%',
                            'background-position': '',
                        });
                        break;
                    }
                    // The image will stretch on the width and the height will scale accordingly
                    case visuals.imageScalingType.fill: {
                        backgroundImage.css({
                            'background-size': '100%',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                    default: {
                        backgroundImage.css({
                            'background-size': '',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                }
            }
            visualBackgroundHelper.renderBackgroundImage = renderBackgroundImage;
        })(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Selector = powerbi.data.Selector;
        /**
         * A helper class for building a VisualObjectInstanceEnumerationObject:
         * - Allows call chaining (e.g., builder.pushInstance({...}).pushInstance({...})
         * - Allows creating of containers (via pushContainer/popContainer)
         */
        var ObjectEnumerationBuilder = (function () {
            function ObjectEnumerationBuilder() {
            }
            ObjectEnumerationBuilder.prototype.pushInstance = function (instance) {
                debug.assertValue(instance, 'instance');
                var instances = this.instances;
                if (!instances) {
                    instances = this.instances = [];
                }
                var containerIdx = this.containerIdx;
                if (containerIdx != null) {
                    instance.containerIdx = containerIdx;
                }
                // Attempt to merge with an existing item if possible.
                for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
                    var existingInstance = instances_1[_i];
                    if (this.canMerge(existingInstance, instance)) {
                        this.extend(existingInstance, instance, 'properties');
                        this.extend(existingInstance, instance, 'validValues');
                        return this;
                    }
                }
                instances.push(instance);
                return this;
            };
            ObjectEnumerationBuilder.prototype.pushContainer = function (container) {
                debug.assertValue(container, 'container');
                var containers = this.containers;
                if (!containers) {
                    containers = this.containers = [];
                }
                var updatedLen = containers.push(container);
                this.containerIdx = updatedLen - 1;
                return this;
            };
            ObjectEnumerationBuilder.prototype.popContainer = function () {
                this.containerIdx = undefined;
                return this;
            };
            ObjectEnumerationBuilder.prototype.complete = function () {
                if (!this.instances)
                    return;
                var result = {
                    instances: this.instances,
                };
                var containers = this.containers;
                if (containers) {
                    result.containers = containers;
                }
                return result;
            };
            ObjectEnumerationBuilder.prototype.canMerge = function (x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return x.objectName === y.objectName &&
                    x.containerIdx === y.containerIdx &&
                    Selector.equals(x.selector, y.selector);
            };
            ObjectEnumerationBuilder.prototype.extend = function (target, source, propertyName) {
                debug.assertValue(target, 'target');
                debug.assertValue(source, 'source');
                debug.assertValue(propertyName, 'propertyName');
                var sourceValues = source[propertyName];
                if (!sourceValues)
                    return;
                var targetValues = target[propertyName];
                if (!targetValues)
                    targetValues = target[propertyName] = {};
                for (var valuePropertyName in sourceValues) {
                    if (targetValues[valuePropertyName]) {
                        // Properties have first-writer-wins semantics.
                        continue;
                    }
                    targetValues[valuePropertyName] = sourceValues[valuePropertyName];
                }
            };
            ObjectEnumerationBuilder.merge = function (x, y) {
                var xNormalized = ObjectEnumerationBuilder.normalize(x);
                var yNormalized = ObjectEnumerationBuilder.normalize(y);
                if (!xNormalized || !yNormalized)
                    return xNormalized || yNormalized;
                debug.assertValue(xNormalized, 'xNormalized');
                debug.assertValue(yNormalized, 'yNormalized');
                var xCategoryCount = xNormalized.containers ? xNormalized.containers.length : 0;
                for (var _i = 0, _a = yNormalized.instances; _i < _a.length; _i++) {
                    var yInstance = _a[_i];
                    xNormalized.instances.push(yInstance);
                    if (yInstance.containerIdx != null)
                        yInstance.containerIdx += xCategoryCount;
                }
                var yContainers = yNormalized.containers;
                if (!_.isEmpty(yContainers)) {
                    if (xNormalized.containers)
                        Array.prototype.push.apply(xNormalized.containers, yContainers);
                    else
                        xNormalized.containers = yContainers;
                }
                return xNormalized;
            };
            ObjectEnumerationBuilder.normalize = function (x) {
                debug.assertAnyValue(x, 'x');
                if (_.isArray(x)) {
                    return { instances: x };
                }
                return x;
            };
            ObjectEnumerationBuilder.getContainerForInstance = function (enumeration, instance) {
                debug.assertValue(enumeration, "enumeration");
                debug.assertValue(instance, "instance");
                debug.assertValue(enumeration.containers, "containers");
                debug.assert(enumeration.containers.length > instance.containerIdx, "no container found in containers collection");
                return enumeration.containers[instance.containerIdx];
            };
            return ObjectEnumerationBuilder;
        }());
        visuals.ObjectEnumerationBuilder = ObjectEnumerationBuilder;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Helper class for Visual border styles */
        var VisualBorderUtil;
        (function (VisualBorderUtil) {
            /**
             * Gets The Boder Width string (e.g. 0px 1px 2px 3px)
             * @param {OutlineType} string Type of the Outline, one of Visuals.outline.<XX> const strings
             * @param {number} outlineWeight Weight of the outline in pixels
             * @returns String representing the Border Width
             */
            function getBorderWidth(outlineType, outlineWeight) {
                switch (outlineType) {
                    case visuals.outline.none:
                        return '0px';
                    case visuals.outline.bottomOnly:
                        return '0px 0px ' + outlineWeight + 'px 0px';
                    case visuals.outline.topOnly:
                        return outlineWeight + 'px 0px 0px 0px';
                    case visuals.outline.leftOnly:
                        return '0px 0px 0px ' + outlineWeight + 'px';
                    case visuals.outline.rightOnly:
                        return '0px ' + outlineWeight + 'px 0px 0px';
                    case visuals.outline.topBottom:
                        return outlineWeight + 'px 0px';
                    case visuals.outline.leftRight:
                        return '0px ' + outlineWeight + 'px';
                    case visuals.outline.frame:
                        return outlineWeight + 'px';
                    default:
                        debug.assertFail('Unexpected OutlineType value: ' + outlineType);
                        return '0px';
                }
            }
            VisualBorderUtil.getBorderWidth = getBorderWidth;
        })(VisualBorderUtil = visuals.VisualBorderUtil || (visuals.VisualBorderUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Transformation matrix math wrapper */
        var Transform = (function () {
            // Constructor
            function Transform(m) {
                this.matrix = m || {
                    m00: 1, m01: 0, m02: 0,
                    m10: 0, m11: 1, m12: 0,
                };
            }
            // Methods
            Transform.prototype.applyToPoint = function (point) {
                if (!point) {
                    return point;
                }
                var m = this.matrix;
                return {
                    x: m.m00 * point.x + m.m01 * point.y + m.m02,
                    y: m.m10 * point.x + m.m11 * point.y + m.m12,
                };
            };
            Transform.prototype.applyToRect = function (rect) {
                if (!rect) {
                    return rect;
                }
                var x0 = rect.left;
                var y0 = rect.top;
                var m = this.matrix;
                var isScaled = m.m00 !== 1 || m.m11 !== 1;
                var isRotated = m.m01 !== 0 || m.m10 !== 0;
                if (!isRotated && !isScaled) {
                    // Optimize for the translation only case
                    return { left: x0 + m.m02, top: y0 + m.m12, width: rect.width, height: rect.height };
                }
                var x1 = rect.left + rect.width;
                var y1 = rect.top + rect.height;
                var minX;
                var maxX;
                var minY;
                var maxY;
                if (isRotated) {
                    var p0x = m.m00 * x0 + m.m01 * y0 + m.m02;
                    var p0y = m.m10 * x0 + m.m11 * y0 + m.m12;
                    var p1x = m.m00 * x0 + m.m01 * y1 + m.m02;
                    var p1y = m.m10 * x0 + m.m11 * y1 + m.m12;
                    var p2x = m.m00 * x1 + m.m01 * y0 + m.m02;
                    var p2y = m.m10 * x1 + m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m01 * y1 + m.m02;
                    var p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p1x, p2x, p3x);
                    maxX = Math.max(p0x, p1x, p2x, p3x);
                    minY = Math.min(p0y, p1y, p2y, p3y);
                    maxY = Math.max(p0y, p1y, p2y, p3y);
                }
                else {
                    var p0x = m.m00 * x0 + m.m02;
                    var p0y = m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m02;
                    var p3y = m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p3x);
                    maxX = Math.max(p0x, p3x);
                    minY = Math.min(p0y, p3y);
                    maxY = Math.max(p0y, p3y);
                }
                return { left: minX, top: minY, width: maxX - minX, height: maxY - minY };
            };
            Transform.prototype.translate = function (xOffset, yOffset) {
                if (xOffset !== 0 || yOffset !== 0) {
                    var m = createTranslateMatrix(xOffset, yOffset);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.scale = function (xScale, yScale) {
                if (xScale !== 1 || yScale !== 1) {
                    var m = createScaleMatrix(xScale, yScale);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.rotate = function (angleInRadians) {
                if (angleInRadians !== 0) {
                    var m = createRotationMatrix(angleInRadians);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.add = function (other) {
                if (other) {
                    this.matrix = multiplyMatrices(this.matrix, other.matrix);
                    this._inverse = null;
                }
            };
            Transform.prototype.getInverse = function () {
                if (!this._inverse) {
                    this._inverse = new Transform(createInverseMatrix(this.matrix));
                }
                return this._inverse;
            };
            return Transform;
        }());
        visuals.Transform = Transform;
        function createTranslateMatrix(xOffset, yOffset) {
            return {
                m00: 1, m01: 0, m02: xOffset,
                m10: 0, m11: 1, m12: yOffset,
            };
        }
        visuals.createTranslateMatrix = createTranslateMatrix;
        function createScaleMatrix(xScale, yScale) {
            return {
                m00: xScale, m01: 0, m02: 0,
                m10: 0, m11: yScale, m12: 0
            };
        }
        visuals.createScaleMatrix = createScaleMatrix;
        function createRotationMatrix(angleInRads) {
            var a = angleInRads;
            var sinA = Math.sin(a);
            var cosA = Math.cos(a);
            return {
                m00: cosA, m01: -sinA, m02: 0,
                m10: sinA, m11: cosA, m12: 0,
            };
        }
        visuals.createRotationMatrix = createRotationMatrix;
        function createInverseMatrix(m) {
            var determinant = m.m00 * m.m11 - m.m01 * m.m10;
            var invdet = 1 / determinant;
            return {
                m00: m.m11 * invdet,
                m01: -m.m01 * invdet,
                m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
                m10: -m.m10 * invdet,
                m11: m.m00 * invdet,
                m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
            };
        }
        visuals.createInverseMatrix = createInverseMatrix;
        function multiplyMatrices(a, b) {
            return {
                m00: a.m00 * b.m00 + a.m01 * b.m10,
                m01: a.m00 * b.m01 + a.m01 * b.m11,
                m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
                m10: a.m10 * b.m00 + a.m11 * b.m10,
                m11: a.m10 * b.m01 + a.m11 * b.m11,
                m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12,
            };
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TrendLineHelper;
        (function (TrendLineHelper) {
            var trendLinePropertyNames = {
                show: 'show',
                lineColor: 'lineColor',
                transparency: 'transparency',
                style: 'style',
            };
            var trendObjectName = 'trend';
            TrendLineHelper.defaults = {
                color: { solid: { color: '#000' } },
                lineStyle: visuals.lineStyle.solid,
                transparency: 0,
            };
            var TrendLineClassSelector = jsCommon.CssConstants.createClassAndSelector('trend-line');
            function enumerateObjectInstances(enumeration, trendLine) {
                debug.assertValue(enumeration, 'enumeration');
                if (trendLine == null) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: false,
                        },
                        objectName: trendObjectName,
                    });
                    return;
                }
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: trendLine.show,
                        lineColor: trendLine.lineColor,
                        transparency: trendLine.transparency,
                        style: trendLine.style,
                    },
                    objectName: trendObjectName,
                });
            }
            TrendLineHelper.enumerateObjectInstances = enumerateObjectInstances;
            function readDataView(dataView) {
                if (!dataView || !dataView.categorical)
                    return;
                var categorical = dataView.categorical;
                if (_.isEmpty(categorical.categories) || _.isEmpty(categorical.values))
                    return;
                var categories = categorical.categories[0].values;
                var values = categorical.values[0].values;
                if (!categories || !values)
                    return;
                var points = [];
                for (var i = 0; i < categories.length; i++) {
                    var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]);
                    var y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
                    if (x != null && y != null) {
                        points.push({
                            x: x,
                            y: y,
                        });
                    }
                }
                var trendProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, trendObjectName, {});
                var show = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.show, false);
                var lineColor = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.lineColor, TrendLineHelper.defaults.color);
                var transparency = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.transparency, TrendLineHelper.defaults.transparency);
                var style = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.style, TrendLineHelper.defaults.lineStyle);
                // Trend lines generated by Insights will be putting line color here, we should convert the Insights code to create
                // "trend" objects like above and write the upgrade code to handle pinned tiles with trend lines before removing any feature switch.
                var legacyColor = powerbi.DataViewObjects.getValue(categorical.values[0].source.objects, visuals.lineChartProps.dataPoint.fill);
                if (legacyColor)
                    lineColor = legacyColor;
                return {
                    points: points,
                    show: show,
                    lineColor: lineColor,
                    transparency: transparency,
                    style: style,
                };
            }
            TrendLineHelper.readDataView = readDataView;
            function render(trendLine, graphicsContext, axes, viewport) {
                var xScale = axes.x.scale;
                var yScale = axes.y1.scale;
                var lines = graphicsContext.selectAll(TrendLineClassSelector.selector).data(trendLine ? [trendLine] : []);
                lines.enter().append('path').classed(TrendLineClassSelector.class, true);
                var pathGen = d3.svg.line()
                    .x(function (point) { return xScale(point.x); })
                    .y(function (point) { return yScale(point.y); });
                lines
                    .attr('d', function (d) {
                    return pathGen(d.points);
                });
                lines.each(function (d) {
                    var line = d3.select(this);
                    var style = {};
                    style.stroke = d.lineColor.solid.color;
                    if (d.transparency != null) {
                        style['stroke-opacity'] = (100 - d.transparency) / 100;
                    }
                    if (d.style === visuals.lineStyle.dashed) {
                        style['stroke-dasharray'] = "5, 5";
                    }
                    else if (d.style === visuals.lineStyle.dotted) {
                        style['stroke-dasharray'] = "1, 5";
                        style['stroke-linecap'] = "round";
                    }
                    else if (d.style === visuals.lineStyle.solid) {
                        style['stroke-dasharray'] = null;
                        style['stroke-linecap'] = null;
                    }
                    line.style(style);
                });
                lines.exit().remove();
            }
            TrendLineHelper.render = render;
        })(TrendLineHelper = visuals.TrendLineHelper || (visuals.TrendLineHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visibilityHelper;
        (function (visibilityHelper) {
            /**  Helper method that uses jQuery :visible selector to determine if visual is visible.
                Elements are considered visible if they consume space in the document. Visible elements have a width or height that is greater than zero.
                Elements with visibility: hidden or opacity: 0 are considered visible, since they still consume space in the layout.
            */
            function partiallyVisible(element) {
                return element.is(":visible");
            }
            visibilityHelper.partiallyVisible = partiallyVisible;
        })(visibilityHelper = visuals.visibilityHelper || (visuals.visibilityHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SemanticFilter = powerbi.data.SemanticFilter;
        var UrlUtils = jsCommon.UrlUtils;
        /** Helper module for converting a DataView into SlicerData. */
        var DataConversion;
        (function (DataConversion) {
            function convert(dataView, localizedSelectAllText, interactivityService, hostServices) {
                debug.assertValue(hostServices, 'hostServices');
                if (!dataView || !dataView.categorical || _.isEmpty(dataView.categorical.categories))
                    return;
                var identityFields = dataView.categorical.categories[0].identityFields;
                if (!identityFields)
                    return;
                var filter = (dataView.metadata &&
                    dataView.metadata.objects &&
                    powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.slicerProps.filterPropertyIdentifier));
                var analyzer = hostServices.analyzeFilter({
                    dataView: dataView,
                    defaultValuePropertyId: visuals.slicerProps.defaultValue,
                    filter: filter,
                    fieldSQExprs: identityFields
                });
                if (!analyzer)
                    return;
                var analyzedSemanticFilter = analyzer.filter;
                if (analyzedSemanticFilter && !SemanticFilter.isSameFilter(analyzedSemanticFilter, filter)) {
                    interactivityService.handleClearSelection();
                    var filterPropertyIdentifier = visuals.slicerProps.filterPropertyIdentifier;
                    var properties = {};
                    properties[filterPropertyIdentifier.propertyName] = analyzer.filter;
                    var instance = {
                        objectName: filterPropertyIdentifier.objectName,
                        selector: undefined,
                        properties: properties
                    };
                    var changes = {
                        merge: [instance]
                    };
                    hostServices.persistProperties(changes);
                }
                var slicerData = getSlicerData(analyzer, dataView.metadata, dataView.categorical, localizedSelectAllText, interactivityService, hostServices);
                return slicerData;
            }
            DataConversion.convert = convert;
            function getSlicerData(analyzer, dataViewMetadata, categorical, localizedSelectAllText, interactivityService, hostServices) {
                var isInvertedSelectionMode = interactivityService && interactivityService.isSelectionModeInverted();
                var selectedScopeIds = analyzer.selectedIdentities;
                var hasSelectionOverride = !_.isEmpty(selectedScopeIds) || isInvertedSelectionMode === true;
                if (!isInvertedSelectionMode && analyzer.filter)
                    isInvertedSelectionMode = analyzer.isNotFilter;
                if (interactivityService) {
                    // To indicate whether the selection is Not selected items
                    interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
                    // defaultValueMode will be used when determine show/hide clear button.
                    interactivityService.setDefaultValueMode(SemanticFilter.isDefaultFilter(analyzer.filter));
                }
                var category = categorical.categories[0];
                var categoryValuesLen = category && category.values ? category.values.length : 0;
                var slicerDataPoints = [];
                var formatString = visuals.valueFormatter.getFormatString(category.source, visuals.slicerProps.formatString);
                var numOfSelected = 0;
                var valueCounts = categorical.values && categorical.values[0] && categorical.values[0].values;
                if (valueCounts && _.isEmpty(valueCounts))
                    valueCounts = undefined;
                debug.assert(!valueCounts || valueCounts.length === categoryValuesLen, "valueCounts doesn't match values");
                var isImageData = dataViewMetadata &&
                    !_.isEmpty(dataViewMetadata.columns) && visuals.converterHelper.isImageUrlColumn(dataViewMetadata.columns[0]);
                var displayNameIdentityPairs = [];
                for (var i = 0; i < categoryValuesLen; i++) {
                    var scopeId = category.identity && category.identity[i];
                    var value = category.values && category.values[i];
                    var count = valueCounts && valueCounts[i];
                    var isRetained = hasSelectionOverride ? visuals.SlicerUtil.tryRemoveValueFromRetainedList(scopeId, selectedScopeIds) : false;
                    var label = visuals.valueFormatter.format(value, formatString);
                    var isImage = isImageData === true && UrlUtils.isValidImageUrl(label);
                    var slicerData_1 = {
                        value: label,
                        tooltip: label,
                        identity: visuals.SelectionId.createWithId(scopeId),
                        selected: isRetained,
                        count: count,
                        isImage: isImage,
                    };
                    if (isRetained) {
                        var displayNameIdentityPair = {
                            displayName: label,
                            identity: scopeId
                        };
                        displayNameIdentityPairs.push(displayNameIdentityPair);
                    }
                    slicerDataPoints.push(slicerData_1);
                    if (slicerData_1.selected)
                        numOfSelected++;
                }
                if (!_.isEmpty(displayNameIdentityPairs))
                    hostServices.setIdentityDisplayNames(displayNameIdentityPairs);
                // Add retained values that are not in the returned dataview to the value list.
                if (hasSelectionOverride && !_.isEmpty(selectedScopeIds)) {
                    var displayNamesIdentityPairs = hostServices.getIdentityDisplayNames(selectedScopeIds);
                    if (!_.isEmpty(displayNamesIdentityPairs)) {
                        for (var _i = 0, displayNamesIdentityPairs_1 = displayNamesIdentityPairs; _i < displayNamesIdentityPairs_1.length; _i++) {
                            var pair = displayNamesIdentityPairs_1[_i];
                            // When there is no valueCounts, set count to be undefined, otherwise use 0 as the count for retained values
                            var slicerData_2 = {
                                value: pair.displayName,
                                tooltip: pair.displayName,
                                identity: visuals.SelectionId.createWithId(pair.identity),
                                selected: true,
                                count: valueCounts != null ? 0 : undefined,
                            };
                            slicerDataPoints.push(slicerData_2);
                            numOfSelected++;
                        }
                    }
                }
                var defaultSettings = createDefaultSettings(dataViewMetadata);
                if (defaultSettings.selection.selectAllCheckboxEnabled) {
                    //If selectAllCheckboxEnabled, and all the items are selected and there is no more data to request, then unselect all and toggle the invertedSelectionMode
                    if (numOfSelected > 0 && !dataViewMetadata.segment && numOfSelected === slicerDataPoints.length) {
                        isInvertedSelectionMode = !isInvertedSelectionMode;
                        interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
                        for (var _a = 0, slicerDataPoints_1 = slicerDataPoints; _a < slicerDataPoints_1.length; _a++) {
                            var item = slicerDataPoints_1[_a];
                            item.selected = false;
                        }
                        hasSelectionOverride = false;
                        numOfSelected = 0;
                    }
                    slicerDataPoints.unshift({
                        value: localizedSelectAllText,
                        tooltip: localizedSelectAllText,
                        identity: visuals.SelectionId.createWithMeasure(localizedSelectAllText),
                        selected: !!isInvertedSelectionMode && numOfSelected === 0,
                        isSelectAllDataPoint: true,
                        count: undefined,
                    });
                }
                var slicerData = {
                    categorySourceName: category.source.displayName,
                    slicerSettings: defaultSettings,
                    slicerDataPoints: slicerDataPoints,
                    hasSelectionOverride: hasSelectionOverride,
                    defaultValue: analyzer.defaultValue,
                };
                return slicerData;
            }
            function createDefaultSettings(dataViewMetadata) {
                var defaultSettings = visuals.Slicer.DefaultStyleProperties();
                var objects = dataViewMetadata.objects;
                var forceSingleSelect = dataViewMetadata.columns && _.some(dataViewMetadata.columns, function (column) { return column.discourageAggregationAcrossGroups; });
                if (objects) {
                    defaultSettings.general.outlineColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.general.outlineColor, defaultSettings.general.outlineColor);
                    defaultSettings.general.outlineWeight = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.outlineWeight, defaultSettings.general.outlineWeight);
                    defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.orientation, defaultSettings.general.orientation);
                    defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.show, defaultSettings.header.show);
                    defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.fontColor, defaultSettings.header.fontColor);
                    var headerBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.background);
                    if (headerBackground)
                        defaultSettings.header.background = headerBackground;
                    defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.outline, defaultSettings.header.outline);
                    defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.textSize, defaultSettings.header.textSize);
                    defaultSettings.slicerText.color = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.fontColor, defaultSettings.slicerText.color);
                    var textBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.background);
                    if (textBackground)
                        defaultSettings.slicerText.background = textBackground;
                    defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.outline, defaultSettings.slicerText.outline);
                    defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.textSize, defaultSettings.slicerText.textSize);
                    defaultSettings.selection.selectAllCheckboxEnabled = !forceSingleSelect && powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.selectAllCheckboxEnabled, defaultSettings.selection.selectAllCheckboxEnabled);
                    defaultSettings.selection.singleSelect = forceSingleSelect || powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.singleSelect, defaultSettings.selection.singleSelect);
                }
                return defaultSettings;
            }
        })(DataConversion = visuals.DataConversion || (visuals.DataConversion = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var shapes = powerbi.visuals.shapes;
    /**
    * Rectangle orientation. Rectangle orientation is used to define vertical or horizontal orientation
    * and starting/ending side of the rectangle.
    */
    (function (RectOrientation) {
        /** Rectangle with no specific orientation. */
        RectOrientation[RectOrientation["None"] = 0] = "None";
        /** Vertical rectangle with base at the bottom. */
        RectOrientation[RectOrientation["VerticalBottomTop"] = 1] = "VerticalBottomTop";
        /** Vertical rectangle with base at the top. */
        RectOrientation[RectOrientation["VerticalTopBottom"] = 2] = "VerticalTopBottom";
        /** Horizontal rectangle with base at the left. */
        RectOrientation[RectOrientation["HorizontalLeftRight"] = 3] = "HorizontalLeftRight";
        /** Horizontal rectangle with base at the right. */
        RectOrientation[RectOrientation["HorizontalRightLeft"] = 4] = "HorizontalRightLeft";
    })(powerbi.RectOrientation || (powerbi.RectOrientation = {}));
    var RectOrientation = powerbi.RectOrientation;
    /**
    * Defines if panel elements are allowed to be positioned
    * outside of the panel boundaries.
    */
    (function (OutsidePlacement) {
        /** Elements can be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Allowed"] = 0] = "Allowed";
        /** Elements can not be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Disallowed"] = 1] = "Disallowed";
        /** Elements can be partially outside of the panel. */
        OutsidePlacement[OutsidePlacement["Partial"] = 2] = "Partial";
    })(powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
    var OutsidePlacement = powerbi.OutsidePlacement;
    /**
    * Arranges label elements using the anchor point or rectangle. Collisions
    * between elements can be automatically detected and as a result elements
    * can be repositioned or get hidden.
    */
    var DataLabelManager = (function () {
        function DataLabelManager() {
            this.movingStep = 3;
            this.hideOverlapped = true;
            // The global settings for all labels. 
            // They can be oweridden by each label we add into the panel, because contains same properties.
            this.defaultDataLabelSettings = {
                anchorMargin: DataLabelManager.DefaultAnchorMargin,
                anchorRectOrientation: RectOrientation.None,
                contentPosition: 128 /* BottomCenter */,
                outsidePlacement: OutsidePlacement.Disallowed,
                maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
                minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
                validContentPositions: 128 /* BottomCenter */,
                opacity: 1
            };
        }
        Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
            get: function () {
                return this.defaultDataLabelSettings;
            },
            enumerable: true,
            configurable: true
        });
        /** Arranges the lables position and visibility*/
        DataLabelManager.prototype.hideCollidedLabels = function (viewport, data, layout, addTransform) {
            if (addTransform === void 0) { addTransform = false; }
            // Split size into a grid
            var arrangeGrid = new DataLabelArrangeGrid(viewport, data, layout);
            var filteredData = [];
            var transform = { x: 0, y: 0 };
            if (addTransform) {
                transform.x = viewport.width / 2;
                transform.y = viewport.height / 2;
            }
            for (var i = 0, len = data.length; i < len; i++) {
                // Filter unwanted data points
                if (!layout.filter(data[i]))
                    continue;
                // Set default values where properties values are undefined
                var info = this.getLabelInfo(data[i]);
                info.anchorPoint = {
                    x: layout.labelLayout.x(data[i]) + transform.x,
                    y: layout.labelLayout.y(data[i]) + transform.y,
                };
                var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
                if (DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, viewport)) {
                    data[i].labelX = position.left - transform.x;
                    data[i].labelY = position.top - transform.y;
                    // Keep track of all panel elements positions.
                    arrangeGrid.add(info, position);
                    // Save all data points to display
                    filteredData.push(data[i]);
                }
            }
            return filteredData;
        };
        /**
         * Merges the label element info with the panel element info and returns correct label info.
         * @param source The label info.
         */
        DataLabelManager.prototype.getLabelInfo = function (source) {
            var settings = this.defaultDataLabelSettings;
            source.anchorMargin = source.anchorMargin !== undefined ? source.anchorMargin : settings.anchorMargin;
            source.anchorRectOrientation = source.anchorRectOrientation !== undefined ? source.anchorRectOrientation : settings.anchorRectOrientation;
            source.contentPosition = source.contentPosition !== undefined ? source.contentPosition : settings.contentPosition;
            source.maximumMovingDistance = source.maximumMovingDistance !== undefined ? source.maximumMovingDistance : settings.maximumMovingDistance;
            source.minimumMovingDistance = source.minimumMovingDistance !== undefined ? source.minimumMovingDistance : settings.minimumMovingDistance;
            source.outsidePlacement = source.outsidePlacement !== undefined ? source.outsidePlacement : settings.outsidePlacement;
            source.validContentPositions = source.validContentPositions !== undefined ? source.validContentPositions : settings.validContentPositions;
            source.opacity = source.opacity !== undefined ? source.opacity : settings.opacity;
            source.maximumMovingDistance += source.anchorMargin;
            return source;
        };
        /**
        * (Private) Calculates element position using anchor point..
        */
        DataLabelManager.prototype.calculateContentPositionFromPoint = function (anchorPoint, contentPosition, contentSize, offset) {
            var position = { x: 0, y: 0 };
            if (anchorPoint) {
                if (anchorPoint.x !== undefined && isFinite(anchorPoint.x)) {
                    position.x = anchorPoint.x;
                    switch (contentPosition) {
                        // D3 positions the label in the middle by default.
                        // The algorithem asumed the label was positioned in right so this is why we add/substract half width
                        case 1 /* TopLeft */:
                        case 8 /* MiddleLeft */:
                        case 64 /* BottomLeft */:
                            position.x -= contentSize.width / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 32 /* MiddleRight */:
                        case 256 /* BottomRight */:
                            position.x += contentSize.width / 2.0;
                            break;
                    }
                }
                if (anchorPoint.y !== undefined && isFinite(anchorPoint.y)) {
                    position.y = anchorPoint.y;
                    switch (contentPosition) {
                        case 8 /* MiddleLeft */:
                        case 16 /* MiddleCenter */:
                        case 32 /* MiddleRight */:
                            position.y -= contentSize.height / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 1 /* TopLeft */:
                        case 2 /* TopCenter */:
                            position.y -= contentSize.height;
                            break;
                    }
                }
                if (offset !== undefined && isFinite(offset)) {
                    switch (contentPosition) {
                        case 1 /* TopLeft */:
                            position.x -= offset;
                            position.y -= offset;
                            break;
                        case 8 /* MiddleLeft */:
                            position.x -= offset;
                            break;
                        case 64 /* BottomLeft */:
                            position.x -= offset;
                            position.y += offset;
                            break;
                        case 2 /* TopCenter */:
                            position.y -= offset;
                            break;
                        case 16 /* MiddleCenter */:
                            // Offset is not applied
                            break;
                        case 128 /* BottomCenter */:
                            position.y += offset;
                            break;
                        case 4 /* TopRight */:
                            position.x += offset;
                            position.y -= offset;
                            break;
                        case 32 /* MiddleRight */:
                            position.x += offset;
                            break;
                        case 256 /* BottomRight */:
                            position.x += offset;
                            position.y += offset;
                            break;
                        default:
                            debug.assertFail("Unsupported content position.");
                            break;
                    }
                }
            }
            return { left: position.x, top: position.y, width: contentSize.width, height: contentSize.height };
        };
        /** (Private) Calculates element position using anchor rect. */
        DataLabelManager.prototype.calculateContentPositionFromRect = function (anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
            switch (contentPosition) {
                case 512 /* InsideCenter */:
                    return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 2048 /* InsideEnd */:
                    return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 1024 /* InsideBase */:
                    return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 8192 /* OutsideEnd */:
                    return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 4096 /* OutsideBase */:
                    return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                default:
                    debug.assertFail("Unsupported ContentPosition.");
            }
            return { left: 0, top: 0, width: -1, height: -1 };
        };
        /** (Private) Calculates element inside center position using anchor rect. */
        DataLabelManager.prototype.handleInsideCenterPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.middleVertical(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                case RectOrientation.HorizontalRightLeft:
                default:
                    return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside end position using anchor rect. */
        DataLabelManager.prototype.handleInsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside base position using anchor rect. */
        DataLabelManager.prototype.handleInsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside end position using anchor rect. */
        DataLabelManager.prototype.handleOutsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside base position using anchor rect. */
        DataLabelManager.prototype.handleOutsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
            }
        };
        /**  (Private) Calculates element position. */
        DataLabelManager.prototype.calculateContentPosition = function (anchoredElementInfo, contentPosition, contentSize, offset) {
            if (contentPosition !== 2048 /* InsideEnd */ &&
                contentPosition !== 512 /* InsideCenter */ &&
                contentPosition !== 1024 /* InsideBase */ &&
                contentPosition !== 4096 /* OutsideBase */ &&
                contentPosition !== 8192 /* OutsideEnd */) {
                // Determine position using anchor point.
                return this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset);
            }
            // Determine position using anchor rectangle.
            return this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
        };
        /** (Private) Check for collisions. */
        DataLabelManager.prototype.hasCollisions = function (arrangeGrid, info, position, size) {
            var rect = shapes.Rect;
            if (arrangeGrid.hasConflict(position)) {
                return true;
            }
            // Since we divide the height by 2 we add it back to the top of the view port so labels won't be cut off
            var intersection = { left: 0, top: position.height / 2, width: size.width, height: size.height };
            intersection = rect.inflate(intersection, { left: DataLabelManager.InflateAmount, top: 0, right: DataLabelManager.InflateAmount, bottom: 0 });
            intersection = rect.intersect(intersection, position);
            if (rect.isEmpty(intersection))
                // Empty rectangle means there is a collision
                return true;
            var lessWithPrecision = powerbi.Double.lessWithPrecision;
            switch (info.outsidePlacement) {
                // D3 positions the label in the middle by default.
                // The algorithem asumed the label was positioned in right so this is why we devide by 2 or 4
                case OutsidePlacement.Disallowed:
                    return lessWithPrecision(intersection.width, position.width) ||
                        lessWithPrecision(intersection.height, position.height / 2);
                case OutsidePlacement.Partial:
                    return lessWithPrecision(intersection.width, position.width / 2) ||
                        lessWithPrecision(intersection.height, position.height / 4);
            }
            return false;
        };
        DataLabelManager.isValid = function (rect) {
            return !shapes.Rect.isEmpty(rect) && (rect.width > 0 && rect.height > 0);
        };
        DataLabelManager.DefaultAnchorMargin = 0; // For future use
        DataLabelManager.DefaultMaximumMovingDistance = 12;
        DataLabelManager.DefaultMinimumMovingDistance = 3;
        DataLabelManager.InflateAmount = 5;
        return DataLabelManager;
    }());
    powerbi.DataLabelManager = DataLabelManager;
    /**
    * Utility class to speed up the conflict detection by collecting the arranged items in the DataLabelsPanel.
    */
    var DataLabelArrangeGrid = (function () {
        /**
         * Creates new ArrangeGrid.
         * @param size The available size
         */
        function DataLabelArrangeGrid(size, elements, layout) {
            this.grid = [];
            if (size.width === 0 || size.height === 0) {
                this.cellSize = size;
                this.rowCount = this.colCount = 0;
            }
            var baseProperties = {
                fontFamily: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                fontSize: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize,
                fontWeight: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontWeight,
            };
            //sets the cell size to be twice of the Max with and Max height of the elements 
            this.cellSize = { width: 0, height: 0 };
            for (var i = 0, len = elements.length; i < len; i++) {
                var child = elements[i];
                // Fill label field
                child.labeltext = layout.labelText(child);
                var properties = powerbi.Prototype.inherit(baseProperties);
                properties.text = child.labeltext;
                properties.fontSize = (child.data) ? child.data.labelFontSize :
                    child.labelFontSize ? child.labelFontSize : powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize;
                child.size = {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
                };
                var w = child.size.width * 2;
                var h = child.size.height * 2;
                if (w > this.cellSize.width)
                    this.cellSize.width = w;
                if (h > this.cellSize.height)
                    this.cellSize.height = h;
            }
            if (this.cellSize.width === 0)
                this.cellSize.width = size.width;
            if (this.cellSize.height === 0)
                this.cellSize.height = size.height;
            this.colCount = this.getGridRowColCount(this.cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this.rowCount = this.getGridRowColCount(this.cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this.cellSize.width = size.width / this.colCount;
            this.cellSize.height = size.height / this.rowCount;
            var grid = this.grid;
            for (var x = 0; x < this.colCount; x++) {
                grid[x] = [];
                for (var y = 0; y < this.rowCount; y++) {
                    grid[x][y] = [];
                }
            }
        }
        /**
         * Register a new label element.
         * @param element The label element to register.
         * @param rect The label element position rectangle.
         */
        DataLabelArrangeGrid.prototype.add = function (element, rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this.grid;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    grid[x][y].push({ element: element, rect: rect });
                }
            }
        };
        /**
         * Checks for conflict of given rectangle in registered elements.
         * @param rect The rectengle to check.
         * @return True if conflict is detected.
         */
        DataLabelArrangeGrid.prototype.hasConflict = function (rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this.grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    for (var z = 0; z < grid[x][y].length; z++) {
                        var item = grid[x][y][z];
                        if (isIntersecting(item.rect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
         * Calculates the number of rows or columns in a grid
         * @param step is the largest label size (width or height)
         * @param length is the grid size (width or height)
         * @param minCount is the minimum allowed size
         * @param maxCount is the maximum allowed size
         * @return the number of grid rows or columns
         */
        DataLabelArrangeGrid.prototype.getGridRowColCount = function (step, length, minCount, maxCount) {
            return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
        };
        /**
         * Returns the grid index of a given recangle
         * @param rect The rectengle to check.
         * @return grid index as a thickness object.
         */
        DataLabelArrangeGrid.prototype.getGridIndexRect = function (rect) {
            var restrict = function (n, min, max) { return Math.min(Math.max(n, min), max); };
            return {
                left: restrict(Math.floor(rect.left / this.cellSize.width), 0, this.colCount),
                top: restrict(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                right: restrict(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.colCount),
                bottom: restrict(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
            };
        };
        DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1;
        DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100;
        return DataLabelArrangeGrid;
    }());
    powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
    /**
    * (Private) Contains methods for calculating the top-left coordinate of rectangle based on content size and anchor rect.
    */
    var LocationConverter;
    (function (LocationConverter) {
        function topInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topInside = topInside;
        function bottomInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomInside = bottomInside;
        function rightInside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightInside = rightInside;
        function leftInside(size, rect, offset) {
            return {
                left: rect.left + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftInside = leftInside;
        function topOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topOutside = topOutside;
        function bottomOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomOutside = bottomOutside;
        function rightOutside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightOutside = rightOutside;
        function leftOutside(size, rect, offset) {
            return {
                left: rect.left - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftOutside = leftOutside;
        function middleHorizontal(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0 + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleHorizontal = middleHorizontal;
        function middleVertical(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + rect.height / 2.0 - size.height / 2.0 + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleVertical = middleVertical;
    })(LocationConverter || (LocationConverter = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var shapes = powerbi.visuals.shapes;
    var Rect = powerbi.visuals.shapes.Rect;
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
    var LabelArrangeGrid = (function () {
        function LabelArrangeGrid(labelDataPointsGroups, viewport) {
            this.viewport = viewport;
            var maxLabelWidth = 0;
            var maxLabelHeight = 0;
            for (var _i = 0, labelDataPointsGroups_1 = labelDataPointsGroups; _i < labelDataPointsGroups_1.length; _i++) {
                var labelDataPointsGroup = labelDataPointsGroups_1[_i];
                for (var _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                    var labelDataPoint = _b[_a];
                    if (labelDataPoint.isPreferred) {
                        var dataLabelSize = labelDataPoint.labelSize;
                        if (dataLabelSize.width > maxLabelWidth) {
                            maxLabelWidth = dataLabelSize.width;
                        }
                        if (dataLabelSize.height > maxLabelHeight) {
                            maxLabelHeight = dataLabelSize.height;
                        }
                    }
                }
            }
            if (maxLabelWidth === 0) {
                maxLabelWidth = viewport.width;
            }
            if (maxLabelHeight === 0) {
                maxLabelHeight = viewport.height;
            }
            var cellSize = this.cellSize = { width: maxLabelWidth * LabelArrangeGrid.cellSizeMultiplier, height: maxLabelHeight * LabelArrangeGrid.cellSizeMultiplier };
            this.columnCount = LabelArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
            this.rowCount = LabelArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            var grid = [];
            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
                    grid[i][j] = [];
                }
            }
            this.grid = grid;
        }
        /**
         * Add a rectangle to check collision against
         */
        LabelArrangeGrid.prototype.add = function (rect) {
            var containingIndexRect = this.getContainingGridSubsection(rect);
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    this.grid[x][y].push(rect);
                }
            }
        };
        /**
         * Check whether the rect conflicts with the grid, either bleeding outside the
         * viewport or colliding with another rect added to the grid.
         */
        LabelArrangeGrid.prototype.hasConflict = function (rect) {
            if (!this.isWithinGridViewport(rect)) {
                return true;
            }
            return this.hasCollision(rect);
        };
        /**
         * Attempt to position the given rect within the viewport.  Returns
         * the adjusted rectangle or null if the rectangle couldn't fit,
         * conflicts with the viewport, or is too far outside the viewport
         */
        LabelArrangeGrid.prototype.tryPositionInViewport = function (rect) {
            // If it's too far outside the viewport, return null
            if (!this.isCloseToGridViewport(rect)) {
                return;
            }
            if (!this.isWithinGridViewport(rect)) {
                rect = this.tryMoveInsideViewport(rect);
            }
            if (rect && !this.hasCollision(rect)) {
                return rect;
            }
        };
        /**
         * Checks for a collision between the given rect and others in the grid.
         * Returns true if there is a collision.
         */
        LabelArrangeGrid.prototype.hasCollision = function (rect) {
            var containingIndexRect = this.getContainingGridSubsection(rect);
            var grid = this.grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                        var currentGridRect = _a[_i];
                        if (isIntersecting(currentGridRect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
         * Check to see if the given rect is inside the grid's viewport
         */
        LabelArrangeGrid.prototype.isWithinGridViewport = function (rect) {
            return rect.left >= 0 &&
                rect.top >= 0 &&
                rect.left + rect.width <= this.viewport.width &&
                rect.top + rect.height <= this.viewport.height;
        };
        /**
         * Checks to see if the rect is close enough to the viewport to be moved inside.
         * "Close" here is determined by the distance between the edge of the viewport
         * and the closest edge of the rect; if that distance is less than the appropriate
         * dimension of the rect, we will reposition the rect.
         */
        LabelArrangeGrid.prototype.isCloseToGridViewport = function (rect) {
            return rect.left + rect.width >= 0 - rect.width &&
                rect.top + rect.height >= -rect.height &&
                rect.left <= this.viewport.width + rect.width &&
                rect.top <= this.viewport.height + rect.height;
        };
        /**
         * Attempt to move the rect inside the grid's viewport.  Returns the resulting
         * rectangle with the same width/height adjusted to be inside the viewport or
         * null if it couldn't fit regardless.
         */
        LabelArrangeGrid.prototype.tryMoveInsideViewport = function (rect) {
            var result = Rect.clone(rect);
            var viewport = this.viewport;
            // Return null if it's too big to fit regardless of positioning
            if (rect.width > viewport.width || rect.height > viewport.height) {
                return;
            }
            // Only one movement should be made in each direction, because we are only moving it inside enough for it to fit; there should be no overshooting.
            // Outside to the left
            if (rect.left < 0) {
                result.left = 0;
            }
            else if (rect.left + rect.width > viewport.width) {
                result.left -= (rect.left + rect.width) - viewport.width;
            }
            // Outside above
            if (rect.top < 0) {
                result.top = 0;
            }
            else if (rect.top + rect.height > viewport.height) {
                result.top -= (rect.top + rect.height) - viewport.height;
            }
            return result;
        };
        LabelArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
            return {
                xMin: LabelArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
            };
        };
        LabelArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
            return LabelArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        };
        LabelArrangeGrid.bound = function (value, min, max) {
            return Math.max(Math.min(value, max), min);
        };
        /**
         * A multiplier applied to the largest width height to attempt to balance # of
         * labels in each cell and number of cells each label belongs to
         */
        LabelArrangeGrid.cellSizeMultiplier = 2;
        return LabelArrangeGrid;
    }());
    powerbi.LabelArrangeGrid = LabelArrangeGrid;
    var LabelLayout = (function () {
        function LabelLayout(options) {
            this.startingOffset = options.startingOffset;
            this.maximumOffset = options.maximumOffset;
            if (options.offsetIterationDelta != null) {
                debug.assert(options.offsetIterationDelta > 0, "label offset delta must be greater than 0");
                this.offsetIterationDelta = options.offsetIterationDelta;
            }
            else {
                this.offsetIterationDelta = LabelLayout.defaultOffsetIterationDelta;
            }
            if (options.horizontalPadding != null) {
                this.horizontalPadding = options.horizontalPadding;
            }
            else {
                this.horizontalPadding = LabelLayout.defaultHorizontalPadding;
            }
            if (options.verticalPadding != null) {
                this.verticalPadding = options.verticalPadding;
            }
            else {
                this.verticalPadding = LabelLayout.defaultVerticalPadding;
            }
            this.allowLeaderLines = !!options.allowLeaderLines;
            this.attemptToMoveLabelsIntoViewport = !!options.attemptToMoveLabelsIntoViewport;
        }
        /**
         * Arrange takes a set of data labels and lays them out in order, assuming that
         * the given array has already been sorted with the most preferred labels at the
         * front, taking into considiration a maximum number of labels that are alowed
         * to display.
         *
         * Details:
         * - We iterate over offsets from the target position, increasing from 0 while
         *      verifiying the maximum number of labels to display hasn't been reached
         * - For each offset, we iterate over each data label
         * - For each data label, we iterate over each position that is valid for
         *     both the specific label and this layout
         * - When a valid position is found, we position the label there and no longer
         *     reposition it.
         * - This prioritizes the earlier labels to be positioned closer to their
         *     target points in the position they prefer.
         * - This prioritizes putting data labels close to a valid position over
         *     placing them at their preferred position (it will place it at a less
         *     preferred position if it will be a smaller offset)
         */
        LabelLayout.prototype.layout = function (labelDataPointsGroups, viewport) {
            // Clear data labels for a new layout
            for (var _i = 0, labelDataPointsGroups_2 = labelDataPointsGroups; _i < labelDataPointsGroups_2.length; _i++) {
                var labelDataPointsGroup = labelDataPointsGroups_2[_i];
                for (var _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                    var labelPoint = _b[_a];
                    labelPoint.hasBeenRendered = false;
                    if (labelPoint.hasBackground) {
                        labelPoint.labelSize = {
                            width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                            height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding,
                        };
                    }
                    else {
                        labelPoint.labelSize = labelPoint.textSize;
                    }
                }
            }
            var resultingDataLabels = [];
            var grid = new LabelArrangeGrid(labelDataPointsGroups, viewport);
            // Iterates on every series
            for (var _c = 0, labelDataPointsGroups_3 = labelDataPointsGroups; _c < labelDataPointsGroups_3.length; _c++) {
                var labelDataPointsGroup = labelDataPointsGroups_3[_c];
                var maxLabelsToRender = labelDataPointsGroup.maxNumberOfLabels;
                // NOTE: we create a copy and modify the copy to keep track of preferred vs. non-preferred labels.
                var labelDataPoints = _.clone(labelDataPointsGroup.labelDataPoints);
                var preferredLabels = [];
                // Exclude preferred labels
                for (var j = labelDataPoints.length - 1, localMax = maxLabelsToRender; j >= 0 && localMax > 0; j--) {
                    var labelPoint = labelDataPoints[j];
                    if (labelPoint.isPreferred) {
                        preferredLabels.unshift(labelDataPoints.splice(j, 1)[0]);
                        localMax--;
                    }
                }
                // First iterate all the preferred labels
                if (preferredLabels.length > 0) {
                    var positionedLabels = this.positionDataLabels(preferredLabels, viewport, grid, maxLabelsToRender);
                    maxLabelsToRender -= positionedLabels.length;
                    resultingDataLabels = resultingDataLabels.concat(positionedLabels);
                }
                // While there are invisible not preferred labels and label distance is less than the max
                // allowed distance
                if (labelDataPoints.length > 0) {
                    var labels = this.positionDataLabels(labelDataPoints, viewport, grid, maxLabelsToRender);
                    resultingDataLabels = resultingDataLabels.concat(labels);
                }
            }
            return resultingDataLabels;
        };
        LabelLayout.prototype.positionDataLabels = function (labelDataPoints, viewport, grid, maxLabelsToRender) {
            var resultingDataLabels = [];
            var offsetDelta = this.offsetIterationDelta;
            var currentOffset = this.startingOffset;
            var currentCenteredOffset = 0;
            var drawLeaderLinesOnIteration;
            while (currentOffset <= this.maximumOffset && maxLabelsToRender > 0) {
                drawLeaderLinesOnIteration = this.allowLeaderLines && currentOffset > this.startingOffset;
                for (var _i = 0, labelDataPoints_2 = labelDataPoints; _i < labelDataPoints_2.length; _i++) {
                    var labelPoint = labelDataPoints_2[_i];
                    // Check if maximum number of labels to display has been reached
                    if (maxLabelsToRender === 0)
                        break;
                    if (labelPoint.hasBeenRendered) {
                        continue;
                    }
                    var dataLabel = void 0;
                    if (labelPoint.parentType === 1 /* Rectangle */) {
                        dataLabel = this.tryPositionForRectPositions(labelPoint, grid, currentOffset, currentCenteredOffset);
                    }
                    else {
                        dataLabel = this.tryPositionForPointPositions(labelPoint, grid, currentOffset, drawLeaderLinesOnIteration);
                    }
                    if (dataLabel) {
                        resultingDataLabels.push(dataLabel);
                        maxLabelsToRender--;
                    }
                }
                currentOffset += offsetDelta;
                currentCenteredOffset += offsetDelta;
            }
            return resultingDataLabels;
        };
        LabelLayout.prototype.tryPositionForRectPositions = function (labelPoint, grid, currentLabelOffset, currentCenteredLabelOffset) {
            var _this = this;
            // Function declared and reused to reduce code duplication
            var tryPosition = function (position, adjustForViewport) {
                var isPositionInside = position & 7 /* InsideAll */;
                if (isPositionInside && !DataLabelRectPositioner.canFitWithinParent(labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
                    return;
                }
                var resultingBoundingBox = LabelLayout.tryPositionRect(grid, position, labelPoint, currentLabelOffset, currentCenteredLabelOffset, adjustForViewport);
                if (resultingBoundingBox) {
                    if (isPositionInside && !DataLabelRectPositioner.isLabelWithinParent(resultingBoundingBox, labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
                        return;
                    }
                    grid.add(resultingBoundingBox);
                    labelPoint.hasBeenRendered = true;
                    return {
                        boundingBox: resultingBoundingBox,
                        text: labelPoint.text,
                        tooltip: labelPoint.tooltip,
                        isVisible: true,
                        fill: isPositionInside ? labelPoint.insideFill : labelPoint.outsideFill,
                        identity: labelPoint.identity,
                        key: labelPoint.key,
                        fontSize: labelPoint.fontSize,
                        selected: false,
                        hasBackground: !!labelPoint.hasBackground,
                    };
                }
            };
            // Iterate over all positions that are valid for the data point
            for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                var position = _a[_i];
                var label = tryPosition(position, false /* adjustForViewport */);
                if (label)
                    return label;
            }
            // If no position has been found and the option is enabled, try any outside positions while moving the label inside the viewport
            if (this.attemptToMoveLabelsIntoViewport) {
                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b];
                    var label = tryPosition(position, true /* adjustForViewport */);
                    if (label)
                        return label;
                }
            }
            return null;
        };
        /**
         * Tests a particular position/offset combination for the given data label.
         * If the label can be placed, returns the resulting bounding box for the data
         * label.  If not, returns null.
         */
        LabelLayout.tryPositionRect = function (grid, position, labelDataPoint, offset, centerOffset, adjustForViewport) {
            var offsetForPosition = offset;
            if (position & 1 /* InsideCenter */) {
                offsetForPosition = centerOffset;
            }
            var labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, offsetForPosition);
            if (position !== 1 /* InsideCenter */ || labelDataPoint.parentShape.orientation === 0 /* None */) {
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
                if (adjustForViewport) {
                    return grid.tryPositionInViewport(labelRect);
                }
            }
            else {
                // If the position is centered, attempt to offset in both a positive and negative direction
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
                labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, -offsetForPosition);
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
            }
            return null;
        };
        LabelLayout.prototype.tryPositionForPointPositions = function (labelPoint, grid, currentLabelOffset, drawLeaderLines) {
            // Function declared and reused to reduce code duplication
            var tryPosition = function (position, parentShape, adjustForViewport) {
                var resultingBoundingBox = LabelLayout.tryPositionPoint(grid, position, labelPoint, currentLabelOffset, adjustForViewport);
                if (resultingBoundingBox) {
                    grid.add(resultingBoundingBox);
                    labelPoint.hasBeenRendered = true;
                    return {
                        boundingBox: resultingBoundingBox,
                        text: labelPoint.text,
                        tooltip: labelPoint.tooltip,
                        isVisible: true,
                        fill: position === 256 /* Center */ ? labelPoint.insideFill : labelPoint.outsideFill,
                        isInsideParent: position === 256 /* Center */,
                        identity: labelPoint.identity,
                        key: labelPoint.key,
                        fontSize: labelPoint.fontSize,
                        selected: false,
                        leaderLinePoints: drawLeaderLines ? DataLabelPointPositioner.getLabelLeaderLineEndingPoint(resultingBoundingBox, position, parentShape) : null,
                        hasBackground: !!labelPoint.hasBackground,
                    };
                }
            };
            // Iterate over all positions that are valid for the data point
            var parentShape = labelPoint.parentShape;
            var validPositions = parentShape.validPositions;
            for (var _i = 0, validPositions_1 = validPositions; _i < validPositions_1.length; _i++) {
                var position = validPositions_1[_i];
                var label = tryPosition(position, parentShape, false /* adjustForViewport */);
                if (label)
                    return label;
            }
            // Attempt to position at the most preferred position by simply moving it inside the viewport
            if (this.attemptToMoveLabelsIntoViewport && !_.isEmpty(validPositions)) {
                var label = tryPosition(validPositions[0], parentShape, true /* adjustForViewport */);
                if (label)
                    return label;
            }
            return null;
        };
        LabelLayout.tryPositionPoint = function (grid, position, labelDataPoint, offset, adjustForViewport) {
            var labelRect = DataLabelPointPositioner.getLabelRect(labelDataPoint.labelSize, labelDataPoint.parentShape, position, offset);
            if (!grid.hasConflict(labelRect)) {
                return labelRect;
            }
            if (adjustForViewport) {
                return grid.tryPositionInViewport(labelRect);
            }
            return null;
        };
        // Default values
        LabelLayout.defaultOffsetIterationDelta = 2;
        LabelLayout.defaultHorizontalPadding = 2;
        LabelLayout.defaultVerticalPadding = 2;
        return LabelLayout;
    }());
    powerbi.LabelLayout = LabelLayout;
    /**
     * (Private) Contains methods for calculating the bounding box of a data label
     */
    var DataLabelRectPositioner;
    (function (DataLabelRectPositioner) {
        function getLabelRect(labelDataPoint, position, offset) {
            var parentRect = labelDataPoint.parentShape;
            if (parentRect != null) {
                // Each combination of position and orientation results in a different actual positioning, which is then called.
                switch (position) {
                    case 1 /* InsideCenter */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.middleVertical(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.middleHorizontal(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 2 /* InsideBase */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 4 /* InsideEnd */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 8 /* OutsideBase */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 16 /* OutsideEnd */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    default:
                        debug.assertFail("Unsupported label position");
                }
            }
            else {
            }
            return null;
        }
        DataLabelRectPositioner.getLabelRect = getLabelRect;
        function canFitWithinParent(labelDataPoint, horizontalPadding, verticalPadding) {
            return (labelDataPoint.labelSize.width + 2 * horizontalPadding < labelDataPoint.parentShape.rect.width) ||
                (labelDataPoint.labelSize.height + 2 * verticalPadding < labelDataPoint.parentShape.rect.height);
        }
        DataLabelRectPositioner.canFitWithinParent = canFitWithinParent;
        function isLabelWithinParent(labelRect, labelPoint, horizontalPadding, verticalPadding) {
            var parentRect = labelPoint.parentShape.rect;
            var labelRectWithPadding = shapes.Rect.inflate(labelRect, { left: horizontalPadding, right: horizontalPadding, top: verticalPadding, bottom: verticalPadding });
            return shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left,
                y: labelRectWithPadding.top,
            }) && shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left + labelRectWithPadding.width,
                y: labelRectWithPadding.top + labelRectWithPadding.height,
            });
        }
        DataLabelRectPositioner.isLabelWithinParent = isLabelWithinParent;
        function topInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.topInside = topInside;
        function bottomInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: (parentRect.top + parentRect.height) - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.bottomInside = bottomInside;
        function rightInside(labelSize, parentRect, offset) {
            return {
                left: (parentRect.left + parentRect.width) - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.rightInside = rightInside;
        function leftInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.leftInside = leftInside;
        function topOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top - labelSize.height - offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.topOutside = topOutside;
        function bottomOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: (parentRect.top + parentRect.height) + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.bottomOutside = bottomOutside;
        function rightOutside(labelSize, parentRect, offset) {
            return {
                left: (parentRect.left + parentRect.width) + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.rightOutside = rightOutside;
        function leftOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.leftOutside = leftOutside;
        function middleHorizontal(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0 + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.middleHorizontal = middleHorizontal;
        function middleVertical(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0 + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.middleVertical = middleVertical;
    })(DataLabelRectPositioner = powerbi.DataLabelRectPositioner || (powerbi.DataLabelRectPositioner = {}));
    var DataLabelPointPositioner;
    (function (DataLabelPointPositioner) {
        DataLabelPointPositioner.cos45 = Math.cos(45);
        DataLabelPointPositioner.sin45 = Math.sin(45);
        function getLabelRect(labelSize, parentPoint, position, offset) {
            switch (position) {
                case 1 /* Above */: {
                    return DataLabelPointPositioner.above(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 2 /* Below */: {
                    return DataLabelPointPositioner.below(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 4 /* Left */: {
                    return DataLabelPointPositioner.left(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 8 /* Right */: {
                    return DataLabelPointPositioner.right(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 32 /* BelowLeft */: {
                    return DataLabelPointPositioner.belowLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 16 /* BelowRight */: {
                    return DataLabelPointPositioner.belowRight(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 128 /* AboveLeft */: {
                    return DataLabelPointPositioner.aboveLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 64 /* AboveRight */: {
                    return DataLabelPointPositioner.aboveRight(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 256 /* Center */: {
                    return DataLabelPointPositioner.center(labelSize, parentPoint.point);
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return null;
        }
        DataLabelPointPositioner.getLabelRect = getLabelRect;
        function above(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.above = above;
        function below(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.below = below;
        function left(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - offset - labelSize.width,
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.left = left;
        function right(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + offset,
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.right = right;
        function belowLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.belowLeft = belowLeft;
        function belowRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.belowRight = belowRight;
        function aboveLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.aboveLeft = aboveLeft;
        function aboveRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.aboveRight = aboveRight;
        function center(labelSize, parentPoint) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.center = center;
        function getLabelLeaderLineEndingPoint(boundingBox, position, parentShape) {
            var x = boundingBox.left;
            var y = boundingBox.top;
            switch (position) {
                case 1 /* Above */:
                    x += (boundingBox.width / 2);
                    y += boundingBox.height;
                    break;
                case 2 /* Below */:
                    x += (boundingBox.width / 2);
                    break;
                case 4 /* Left */:
                    x += boundingBox.width;
                    y += ((boundingBox.height * 2) / 3);
                    break;
                case 8 /* Right */:
                    y += ((boundingBox.height * 2) / 3);
                    break;
                case 32 /* BelowLeft */:
                    x += boundingBox.width;
                    y += (boundingBox.height / 2);
                    break;
                case 16 /* BelowRight */:
                    y += (boundingBox.height / 2);
                    break;
                case 128 /* AboveLeft */:
                    x += boundingBox.width;
                    y += boundingBox.height;
                    break;
                case 64 /* AboveRight */:
                    y += boundingBox.height;
                    break;
            }
            return [[parentShape.point.x, parentShape.point.y], [x, y]];
        }
        DataLabelPointPositioner.getLabelLeaderLineEndingPoint = getLabelLeaderLineEndingPoint;
    })(DataLabelPointPositioner = powerbi.DataLabelPointPositioner || (powerbi.DataLabelPointPositioner = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** Repreasents the sequence of the dates/times */
    var DateTimeSequence = (function () {
        // Constructors
        /** Creates new instance of the DateTimeSequence */
        function DateTimeSequence(unit) {
            this.unit = unit;
            this.sequence = [];
            this.min = new Date("9999-12-31T23:59:59.999");
            this.max = new Date("0001-01-01T00:00:00.000");
        }
        // Methods
        /**
         * Add a new Date to a sequence.
         * @param date - date to add
         */
        DateTimeSequence.prototype.add = function (date) {
            if (date < this.min) {
                this.min = date;
            }
            if (date > this.max) {
                this.max = date;
            }
            this.sequence.push(date);
        };
        // Methods
        /**
         * Extends the sequence to cover new date range
         * @param min - new min to be covered by sequence
         * @param max - new max to be covered by sequence
         */
        DateTimeSequence.prototype.extendToCover = function (min, max) {
            var x = this.min;
            while (min < x) {
                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);
                this.sequence.splice(0, 0, x);
            }
            this.min = x;
            x = this.max;
            while (x < max) {
                x = DateTimeSequence.addInterval(x, this.interval, this.unit);
                this.sequence.push(x);
            }
            this.max = x;
        };
        /**
         * Move the sequence to cover new date range
         * @param min - new min to be covered by sequence
         * @param max - new max to be covered by sequence
         */
        DateTimeSequence.prototype.moveToCover = function (min, max) {
            var delta = DateTimeSequence.getDelta(min, max, this.unit);
            var count = Math.floor(delta / this.interval);
            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);
            this.sequence = [];
            this.sequence.push(this.min);
            this.max = this.min;
            while (this.max < max) {
                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);
                this.sequence.push(this.max);
            }
        };
        // Static
        /**
         * Calculate a new DateTimeSequence
         * @param dataMin - Date representing min of the data range
         * @param dataMax - Date representing max of the data range
         * @param expectedCount - expected number of intervals in the sequence
         * @param unit - of the intervals in the sequence
         */
        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {
            if (!unit) {
                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);
            }
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Month:
                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Week:
                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Day:
                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Hour:
                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Minute:
                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Second:
                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Millisecond:
                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);
                default:
                    debug.assertFail("Unsupported DateTimeUnit");
            }
        };
        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "Expected count is out of range");
            // Calculate range and sequence
            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);
            // Calculate year sequence
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);
            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;
            var date = new Date(newMinYear, 0, 1);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);
            return result;
        };
        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var minYear = dataMin.getFullYear();
            var maxYear = dataMax.getFullYear();
            var minMonth = dataMin.getMonth();
            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();
            var date = new Date(minYear, 0, 1);
            // Calculate month sequence
            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);
            return result;
        };
        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            var firstDayOfWeek = 0;
            var minDayOfWeek = dataMin.getDay();
            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;
            var minDay = dataMin.getDate() - dayOffset;
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));
            // Calculate week sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);
            return result;
        };
        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));
            // Calculate day sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);
            return result;
        };
        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));
            // Calculate hour sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);
            return result;
        };
        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);
            return result;
        };
        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);
            return result;
        };
        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());
            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);
            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);
            // Calculate milliseconds numeric sequence
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);
            return result;
        };
        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {
            var result = new DateTimeSequence(unit);
            for (var i = 0; i < sequence.sequence.length; i++) {
                var x = sequence.sequence[i];
                var d = DateTimeSequence.addInterval(date, x, unit);
                result.add(d);
            }
            result.interval = sequence.interval;
            result.intervalOffset = sequence.intervalOffset;
            return result;
        };
        DateTimeSequence.addInterval = function (value, interval, unit) {
            interval = Math.round(interval);
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    return DateUtils.addYears(value, interval);
                case powerbi.DateTimeUnit.Month:
                    return DateUtils.addMonths(value, interval);
                case powerbi.DateTimeUnit.Week:
                    return DateUtils.addWeeks(value, interval);
                case powerbi.DateTimeUnit.Day:
                    return DateUtils.addDays(value, interval);
                case powerbi.DateTimeUnit.Hour:
                    return DateUtils.addHours(value, interval);
                case powerbi.DateTimeUnit.Minute:
                    return DateUtils.addMinutes(value, interval);
                case powerbi.DateTimeUnit.Second:
                    return DateUtils.addSeconds(value, interval);
                case powerbi.DateTimeUnit.Millisecond:
                    return DateUtils.addMilliseconds(value, interval);
            }
        };
        DateTimeSequence.getDelta = function (min, max, unit) {
            var delta = 0;
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    delta = max.getFullYear() - min.getFullYear();
                    break;
                case powerbi.DateTimeUnit.Month:
                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();
                    break;
                case powerbi.DateTimeUnit.Week:
                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);
                    break;
                case powerbi.DateTimeUnit.Day:
                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);
                    break;
                case powerbi.DateTimeUnit.Hour:
                    delta = (max.getTime() - min.getTime()) / 3600000;
                    break;
                case powerbi.DateTimeUnit.Minute:
                    delta = (max.getTime() - min.getTime()) / 60000;
                    break;
                case powerbi.DateTimeUnit.Second:
                    delta = (max.getTime() - min.getTime()) / 1000;
                    break;
                case powerbi.DateTimeUnit.Millisecond:
                    delta = max.getTime() - min.getTime();
                    break;
            }
            return delta;
        };
        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {
            maxCount = Math.max(maxCount, 2);
            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);
            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)
                return powerbi.DateTimeUnit.Year;
            if (totalDays > 60 && totalDays > 7 * maxCount)
                return powerbi.DateTimeUnit.Month;
            if (totalDays > 14 && totalDays > 2 * maxCount)
                return powerbi.DateTimeUnit.Week;
            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);
            if (totalDays > 2 && totalHours > 12 * maxCount)
                return powerbi.DateTimeUnit.Day;
            if (totalHours >= 24 && totalHours >= maxCount)
                return powerbi.DateTimeUnit.Hour;
            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);
            if (totalMinutes > 2 && totalMinutes >= maxCount)
                return powerbi.DateTimeUnit.Minute;
            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);
            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)
                return powerbi.DateTimeUnit.Second;
            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);
            if (totalMilliseconds > 0)
                return powerbi.DateTimeUnit.Millisecond;
            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds
            var date = min;
            if (date.getMilliseconds() !== 0)
                return powerbi.DateTimeUnit.Millisecond;
            if (date.getSeconds() !== 0)
                return powerbi.DateTimeUnit.Second;
            if (date.getMinutes() !== 0)
                return powerbi.DateTimeUnit.Minute;
            if (date.getHours() !== 0)
                return powerbi.DateTimeUnit.Hour;
            if (date.getDate() !== 1)
                return powerbi.DateTimeUnit.Day;
            if (date.getMonth() !== 0)
                return powerbi.DateTimeUnit.Month;
            return powerbi.DateTimeUnit.Year;
        };
        // Constants
        DateTimeSequence.MIN_COUNT = 1;
        DateTimeSequence.MAX_COUNT = 1000;
        return DateTimeSequence;
    }());
    powerbi.DateTimeSequence = DateTimeSequence;
    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */
    var DateUtils;
    (function (DateUtils) {
        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        /**
         * Returns bool indicating weither the provided year is a leap year.
         * @param year - year value
         */
        function isLeap(year) {
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
        }
        /**
         * Returns number of days in the provided year/month.
         * @param year - year value
         * @param month - month value
         */
        function getMonthDays(year, month) {
            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];
        }
        /**
         * Adds a specified number of years to the provided date.
         * @param date - date value
         * @param yearDelta - number of years to add
         */
        function addYears(date, yearDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var isLeapDay = month === 2 && day === 29;
            var result = new Date(date.getTime());
            year = year + yearDelta;
            if (isLeapDay && !isLeap(year)) {
                day = 28;
            }
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addYears = addYears;
        /**
         * Adds a specified number of months to the provided date.
         * @param date - date value
         * @param monthDelta - number of months to add
         */
        function addMonths(date, monthDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            year += (monthDelta - (monthDelta % 12)) / 12;
            month += monthDelta % 12;
            // VSTS 1325771: Certain column charts don't display any data
            // Wrap arround the month if is after december (value 11)
            if (month > 11) {
                month = month % 12;
                year++;
            }
            day = Math.min(day, getMonthDays(year, month));
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addMonths = addMonths;
        /**
         * Adds a specified number of weeks to the provided date.
         * @param date - date value
         * @param weeks - number of weeks to add
         */
        function addWeeks(date, weeks) {
            return addDays(date, weeks * 7);
        }
        DateUtils.addWeeks = addWeeks;
        /**
         * Adds a specified number of days to the provided date.
         * @param date - date value
         * @param days - number of days to add
         */
        function addDays(date, days) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            result.setFullYear(year, month, day + days);
            return result;
        }
        DateUtils.addDays = addDays;
        /**
         * Adds a specified number of hours to the provided date.
         * @param date - date value
         * @param hours - number of hours to add
         */
        function addHours(date, hours) {
            return new Date(date.getTime() + hours * 3600000);
        }
        DateUtils.addHours = addHours;
        /**
         * Adds a specified number of minutes to the provided date.
         * @param date - date value
         * @param minutes - number of minutes to add
         */
        function addMinutes(date, minutes) {
            return new Date(date.getTime() + minutes * 60000);
        }
        DateUtils.addMinutes = addMinutes;
        /**
         * Adds a specified number of seconds to the provided date.
         * @param date - date value
         * @param seconds - number of seconds to add
         */
        function addSeconds(date, seconds) {
            return new Date(date.getTime() + seconds * 1000);
        }
        DateUtils.addSeconds = addSeconds;
        /**
         * Adds a specified number of milliseconds to the provided date.
         * @param date - date value
         * @param milliseconds - number of milliseconds to add
         */
        function addMilliseconds(date, milliseconds) {
            return new Date(date.getTime() + milliseconds);
        }
        DateUtils.addMilliseconds = addMilliseconds;
    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    // Constants
    var maxExponent = 24;
    var defaultScientificBigNumbersBoundary = 1E15;
    var scientificSmallNumbersBoundary = 1E-4;
    var PERCENTAGE_FORMAT = '%';
    var SCIENTIFIC_FORMAT = 'E+0';
    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;
    // Regular expressions
    /**
     * This regex looks for strings that match one of the following conditions:
     *   - Optionally contain "0", "#", followed by a period, followed by at least one "0" or "#" (Ex. ###,000.###)
     *   - Contains at least one of "0", "#", or "," (Ex. ###,000)
     *   - Contain a "g" (indicates to use the general .NET numeric format string)
     * The entire string (start to end) must match, and the match is not case-sensitive.
     */
    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\#,]*\.[0\#]+|[0\#,]+|g)$/i;
    var DisplayUnit = (function () {
        function DisplayUnit() {
        }
        // Methods
        DisplayUnit.prototype.project = function (value) {
            if (this.value) {
                return powerbi.Double.removeDecimalNoise(value / this.value);
            }
            else {
                return value;
            }
        };
        DisplayUnit.prototype.reverseProject = function (value) {
            if (this.value) {
                return value * this.value;
            }
            else {
                return value;
            }
        };
        DisplayUnit.prototype.isApplicableTo = function (value) {
            value = Math.abs(value);
            var precision = powerbi.Double.getPrecision(value, 3);
            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);
        };
        DisplayUnit.prototype.isScaling = function () {
            return this.value > 1;
        };
        return DisplayUnit;
    }());
    powerbi.DisplayUnit = DisplayUnit;
    var DisplayUnitSystem = (function () {
        // Constructor
        function DisplayUnitSystem(units) {
            this.units = units ? units : [];
        }
        Object.defineProperty(DisplayUnitSystem.prototype, "title", {
            // Properties
            get: function () {
                return this.displayUnit ? this.displayUnit.title : undefined;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        DisplayUnitSystem.prototype.update = function (value) {
            if (value === undefined)
                return;
            this.unitBaseValue = value;
            this.displayUnit = this.findApplicableDisplayUnit(value);
        };
        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {
            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {
                var unit = _a[_i];
                if (unit.isApplicableTo(value))
                    return unit;
            }
            return undefined;
        };
        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {
            if (this.isFormatSupported(format)) {
                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);
                if (this.hasScientitifcFormat(format)) {
                    return this.formatHelper(value, '', format, decimals, trailingZeros);
                }
                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {
                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);
                }
                if (decimals != null) {
                    return this.formatHelper(value, '', format, decimals, trailingZeros);
                }
            }
            return powerbi.formattingService.formatValue(value, format);
        };
        DisplayUnitSystem.prototype.isFormatSupported = function (format) {
            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        };
        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {
            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;
        };
        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {
            return !this.isPercentageFormat(format);
        };
        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {
            return decimals;
        };
        DisplayUnitSystem.prototype.isScalingUnit = function () {
            return this.displayUnit && this.displayUnit.isScaling();
        };
        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {
            // If the format is "general" and we want to override the number of decimal places then use the default numeric format string.
            if ((format === 'g' || format === 'G') && decimals != null)
                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;
            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);
            if (format && !powerbi.formattingService.isStandardNumberFormat(format))
                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);
            if (!format)
                format = 'G';
            if (!nonScientificFormat)
                nonScientificFormat = '{0}';
            var text = powerbi.formattingService.formatValue(value, format);
            return powerbi.formattingService.format(nonScientificFormat, [text]);
        };
        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */
        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {
            // Change unit base to a value appropriate for this value
            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);
            return this.format(value, format, decimals, trailingZeros);
        };
        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {
            if (this.units.length === 0)
                return true;
            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).
            var applicableRangeMin = 0;
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].isScaling()) {
                    applicableRangeMin = this.units[i].applicableRangeMin;
                    break;
                }
            }
            return Math.abs(value) < applicableRangeMin;
        };
        DisplayUnitSystem.prototype.isScientific = function (value) {
            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||
                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);
        };
        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {
            return format && format.toUpperCase().indexOf("E") !== -1;
        };
        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {
            if (format)
                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);
            return true;
        };
        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {
            return !this.hasScientitifcFormat(format)
                && this.supportsScientificFormat(format)
                && this.isScientific(value);
        };
        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {
            // Use scientific format outside of the range
            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {
                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);
                if (decimals)
                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);
                if (numericFormat)
                    return numericFormat + SCIENTIFIC_FORMAT;
                else
                    return DEFAULT_SCIENTIFIC_FORMAT;
            }
            return format;
        };
        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\d*)|(.*\%)|(e\d*)$/i;
        return DisplayUnitSystem;
    }());
    powerbi.DisplayUnitSystem = DisplayUnitSystem;
    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */
    var NoDisplayUnitSystem = (function (_super) {
        __extends(NoDisplayUnitSystem, _super);
        // Constructor
        function NoDisplayUnitSystem() {
            _super.call(this, []);
        }
        return NoDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where
        we are showing values (chart axes) and as such it is the default unit system. */
    var DefaultDisplayUnitSystem = (function (_super) {
        __extends(DefaultDisplayUnitSystem, _super);
        // Constructor
        function DefaultDisplayUnitSystem(unitLookup) {
            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));
        }
        // Methods
        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        DefaultDisplayUnitSystem.reset = function () {
            DefaultDisplayUnitSystem.units = null;
        };
        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!DefaultDisplayUnitSystem.units) {
                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {
                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc
                    if (value - previousUnitValue >= 1000) {
                        return value / 10;
                    }
                    return min;
                });
                // Ensure last unit has max of infinity
                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return DefaultDisplayUnitSystem.units;
        };
        return DefaultDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least
        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles
        where we have restricted space but do not want to show partial units. */
    var WholeUnitsDisplayUnitSystem = (function (_super) {
        __extends(WholeUnitsDisplayUnitSystem, _super);
        // Constructor
        function WholeUnitsDisplayUnitSystem(unitLookup) {
            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));
        }
        WholeUnitsDisplayUnitSystem.reset = function () {
            WholeUnitsDisplayUnitSystem.units = null;
        };
        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!WholeUnitsDisplayUnitSystem.units) {
                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);
                // Ensure last unit has max of infinity
                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return WholeUnitsDisplayUnitSystem.units;
        };
        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        return WholeUnitsDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;
    var DataLabelsDisplayUnitSystem = (function (_super) {
        __extends(DataLabelsDisplayUnitSystem, _super);
        function DataLabelsDisplayUnitSystem(unitLookup) {
            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));
        }
        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {
            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        };
        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!DataLabelsDisplayUnitSystem.units) {
                var units = [];
                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {
                    // Never returns true, we are always ignoring
                    // We do not early switch (e.g. 100K instead of 0.1M)
                    // Intended? If so, remove this function, otherwise, remove if statement
                    if (value === -1)
                        if (value - previousUnitValue >= 1000) {
                            return value / 10;
                        }
                    return min;
                };
                // Add Auto & None
                var names = unitLookup(-1);
                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);
                names = unitLookup(0);
                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);
                // Add normal units
                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));
                // Ensure last unit has max of infinity
                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return DataLabelsDisplayUnitSystem.units;
        };
        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        // Constants
        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;
        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;
        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\d*)$/i;
        return DataLabelsDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;
    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {
        var units = [];
        for (var i = 3; i < maxExponent; i++) {
            var names = unitLookup(i);
            if (names)
                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);
        }
        return units;
    }
    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {
        if (title || labelFormat) {
            var min = value;
            if (units.length > 0) {
                var previousUnit = units[units.length - 1];
                if (adjustMinBasedOnPreviousUnit)
                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);
                previousUnit.applicableRangeMax = min;
            }
            var unit = new DisplayUnit();
            unit.value = value;
            unit.applicableRangeMin = min;
            unit.applicableRangeMax = min * 1000;
            unit.title = title;
            unit.labelFormat = labelFormat;
            units.push(unit);
        }
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequence = (function () {
        function NumericSequence() {
        }
        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {
            debug.assertValue(range, "range");
            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), "expectedCount");
            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), "minPower");
            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), "maxAllowedMargin");
            var result = new NumericSequence();
            if (expectedCount === undefined)
                expectedCount = 10;
            else
                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (minPower === undefined)
                minPower = powerbi.Double.MIN_EXP;
            if (useZeroRefPoint === undefined)
                useZeroRefPoint = false;
            if (maxAllowedMargin === undefined)
                maxAllowedMargin = 1;
            if (steps === undefined)
                steps = [1, 2, 5];
            // Handle single stop case
            if (range.forcedSingleStop) {
                result.interval = range.getSize();
                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);
                result.min = range.min;
                result.max = range.max;
                result.sequence = [range.forcedSingleStop];
                return result;
            }
            var interval = 0;
            var min = 0;
            var max = 9;
            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;
            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;
            var size = range.getSize();
            var exp = powerbi.Double.log10(size);
            // Account for Exp of steps
            var stepExp = powerbi.Double.log10(steps[0]);
            exp = exp - stepExp;
            // Account for MaxCount
            var expectedCountExp = powerbi.Double.log10(expectedCount);
            exp = exp - expectedCountExp;
            // Account for MinPower
            exp = Math.max(exp, minPower - stepExp + 1);
            var count = undefined;
            // Create array of "good looking" numbers
            if (interval !== 0) {
                // If explicit interval is defined - use it instead of the steps array.
                var power = powerbi.Double.pow10(exp);
                var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);
                roundRange.shrinkByStep(range, interval);
                min = roundRange.min;
                max = roundRange.max;
                count = Math.floor(roundRange.getSize() / interval);
            }
            else {
                // No interval defined -> find optimal interval
                var dexp = void 0;
                for (dexp = 0; dexp < 3; dexp++) {
                    var e = exp + dexp;
                    var power = powerbi.Double.pow10(e);
                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                    // Go throught the steps array looking for the smallest step that produces the right interval count.
                    var stepsCount = steps.length;
                    var stepPower = powerbi.Double.pow10(e - 1);
                    for (var i = 0; i < stepsCount; i++) {
                        var step = steps[i] * stepPower;
                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);
                        roundRange.shrinkByStep(range, step);
                        // If the range is based on Data we might need to extend it to provide nice data margins.
                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)
                            roundRange.min -= step;
                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)
                            roundRange.max += step;
                        // Count the intervals
                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);
                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {
                            interval = step;
                            min = roundRange.min;
                            max = roundRange.max;
                            break;
                        }
                    }
                    // Increase the scale power until the interval is found
                    if (interval !== 0)
                        break;
                }
            }
            // Avoid extreme count cases (>1000 ticks)
            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {
                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);
                interval = (max - min) / count;
            }
            result.min = min;
            result.max = max;
            result.interval = interval;
            result.intervalOffset = min - range.min;
            result.maxAllowedMargin = maxAllowedMargin;
            result.canExtendMin = canExtendMin;
            result.canExtendMax = canExtendMax;
            // Fill in the Sequence
            var precision = powerbi.Double.getPrecision(interval, 0);
            result.precision = precision;
            var sequence = [];
            var x = powerbi.Double.roundToPrecision(min, precision);
            sequence.push(x);
            for (var i = 0; i < count; i++) {
                x = powerbi.Double.roundToPrecision(x + interval, precision);
                sequence.push(x);
            }
            result.sequence = sequence;
            result.trimMinMax(range.min, range.max);
            return result;
        };
        /**
         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.
         * @min - The minimum of the range.
         * @max - The maximum of the range.
         * @maxCount - The max count of intervals.
         * @steps - array of intervals.
         */
        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {
            // Initialization actions
            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (min === max) {
                max = min + 1;
            }
            var stepCount = 0;
            var step = 0;
            // Calculate step
            for (var i = 0; i < steps.length; i++) {
                step = steps[i];
                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);
                var minStepCount = powerbi.Double.floorWithPrecision(min / step);
                stepCount = maxStepCount - minStepCount;
                if (stepCount <= maxCount) {
                    break;
                }
            }
            // Calculate the offset
            var offset = -min;
            offset = offset % step;
            // Create sequence
            var result = new NumericSequence();
            result.sequence = [];
            for (var x = min + offset;; x += step) {
                result.sequence.push(x);
                if (x >= max)
                    break;
            }
            result.interval = step;
            result.intervalOffset = offset;
            result.min = result.sequence[0];
            result.max = result.sequence[result.sequence.length - 1];
            return result;
        };
        NumericSequence.prototype.trimMinMax = function (min, max) {
            var minMargin = (min - this.min) / this.interval;
            var maxMargin = (this.max - max) / this.interval;
            var marginPrecision = 0.001;
            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {
                this.min = min;
            }
            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {
                this.max = max;
            }
        };
        NumericSequence.MIN_COUNT = 1;
        NumericSequence.MAX_COUNT = 1000;
        return NumericSequence;
    }());
    powerbi.NumericSequence = NumericSequence;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequenceRange = (function () {
        function NumericSequenceRange() {
        }
        NumericSequenceRange.prototype._ensureIncludeZero = function () {
            if (this.includeZero) {
                // fixed min and max has higher priority than includeZero
                if (this.min > 0 && !this.hasFixedMin) {
                    this.min = 0;
                }
                if (this.max < 0 && !this.hasFixedMax) {
                    this.max = 0;
                }
            }
        };
        NumericSequenceRange.prototype._ensureNotEmpty = function () {
            if (this.min === this.max) {
                if (!this.min) {
                    this.min = 0;
                    this.max = NumericSequenceRange.DEFAULT_MAX;
                    this.hasFixedMin = true;
                    this.hasFixedMax = true;
                }
                else {
                    // We are dealing with a single data value (includeZero is not set)
                    // In order to fix the range we need to extend it in both directions by half of the interval.
                    // Interval is calculated based on the number:
                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006
                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.
                    var value = this.min;
                    var exp = powerbi.Double.log10(Math.abs(value));
                    var step = void 0;
                    if (exp >= 0 && exp < 4) {
                        step = 0.5;
                        this.forcedSingleStop = value;
                    }
                    else {
                        step = powerbi.Double.pow10(exp) / 2;
                        this.forcedSingleStop = null;
                    }
                    this.min = value - step;
                    this.max = value + step;
                }
            }
        };
        NumericSequenceRange.prototype._ensureDirection = function () {
            if (this.min > this.max) {
                var temp = this.min;
                this.min = this.max;
                this.max = temp;
            }
        };
        NumericSequenceRange.prototype.getSize = function () {
            return this.max - this.min;
        };
        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {
            debug.assertValue(range, "range");
            debug.assert(step > 0, "step");
            var oldCount = this.min / step;
            var newCount = range.min / step;
            var deltaCount = Math.floor(newCount - oldCount);
            this.min += deltaCount * step;
            oldCount = this.max / step;
            newCount = range.max / step;
            deltaCount = Math.ceil(newCount - oldCount);
            this.max += deltaCount * step;
        };
        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {
            debug.assert(dataMin <= dataMax, "dataMin should be less or equal to dataMax.");
            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, "fixedMin should be less or equal to fixedMax.");
            var result = new NumericSequenceRange();
            result.includeZero = includeZero ? true : false;
            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);
            result.hasFixedMin = ValueUtil.hasValue(fixedMin);
            result.hasFixedMax = ValueUtil.hasValue(fixedMax);
            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            // Calculate the range using the min, max, dataRange
            if (result.hasFixedMin && result.hasFixedMax) {
                result.min = fixedMin;
                result.max = fixedMax;
            }
            else if (result.hasFixedMin) {
                result.min = fixedMin;
                result.max = dataMax > fixedMin ? dataMax : fixedMin;
            }
            else if (result.hasFixedMax) {
                result.min = dataMin < fixedMax ? dataMin : fixedMax;
                result.max = fixedMax;
            }
            else if (result.hasDataRange) {
                result.min = dataMin;
                result.max = dataMax;
            }
            else {
                result.min = 0;
                result.max = 0;
            }
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            if (result.min === 0) {
                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range
            }
            else if (result.max === 0) {
                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range
            }
            return result;
        };
        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {
            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {
                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);
            }
            else {
                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);
            }
        };
        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {
            debug.assertValue(fixedMin, "fixedMin");
            debug.assertValue(fixedMax, "fixedMax");
            var result = new NumericSequenceRange();
            result.hasDataRange = false;
            result.includeZero = includeZero;
            result.min = fixedMin;
            result.max = fixedMax;
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            result.hasFixedMin = true;
            result.hasFixedMax = true;
            return result;
        };
        NumericSequenceRange.DEFAULT_MAX = 10;
        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;
        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;
        return NumericSequenceRange;
    }());
    powerbi.NumericSequenceRange = NumericSequenceRange;
    /** Note: Exported for testability */
    var ValueUtil;
    (function (ValueUtil) {
        function hasValue(value) {
            return value !== undefined && value !== null;
        }
        ValueUtil.hasValue = hasValue;
    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var valueFormatter;
        (function (valueFormatter) {
            var StringExtensions = jsCommon.StringExtensions;
            var BeautifiedFormat = {
                '0.00 %;-0.00 %;0.00 %': 'Percentage',
                '0.0 %;-0.0 %;0.0 %': 'Percentage1',
            };
            valueFormatter.DefaultIntegerFormat = 'g';
            valueFormatter.DefaultNumericFormat = '#,0.00';
            valueFormatter.DefaultDateFormat = 'd';
            var defaultLocalizedStrings = {
                'NullValue': '(Blank)',
                'BooleanTrue': 'True',
                'BooleanFalse': 'False',
                'NaNValue': 'NaN',
                'InfinityValue': '+Infinity',
                'NegativeInfinityValue': '-Infinity',
                'RestatementComma': '{0}, {1}',
                'RestatementCompoundAnd': '{0} and {1}',
                'RestatementCompoundOr': '{0} or {1}',
                'DisplayUnitSystem_EAuto_Title': 'Auto',
                'DisplayUnitSystem_E0_Title': 'None',
                'DisplayUnitSystem_E3_LabelFormat': '{0}K',
                'DisplayUnitSystem_E3_Title': 'Thousands',
                'DisplayUnitSystem_E6_LabelFormat': '{0}M',
                'DisplayUnitSystem_E6_Title': 'Millions',
                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
                'DisplayUnitSystem_E9_Title': 'Billions',
                'DisplayUnitSystem_E12_LabelFormat': '{0}T',
                'DisplayUnitSystem_E12_Title': 'Trillions',
                'Percentage': '#,0.##%',
                'Percentage1': '#,0.#%',
                'TableTotalLabel': 'Total',
                'Tooltip_HighlightedValueDisplayName': 'Highlighted',
                'Funnel_PercentOfFirst': 'Percent of first',
                'Funnel_PercentOfPrevious': 'Percent of previous',
                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',
                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',
                // Geotagging strings
                'GeotaggingString_Continent': 'continent',
                'GeotaggingString_Continents': 'continents',
                'GeotaggingString_Country': 'country',
                'GeotaggingString_Countries': 'countries',
                'GeotaggingString_State': 'state',
                'GeotaggingString_States': 'states',
                'GeotaggingString_City': 'city',
                'GeotaggingString_Cities': 'cities',
                'GeotaggingString_Town': 'town',
                'GeotaggingString_Towns': 'towns',
                'GeotaggingString_Province': 'province',
                'GeotaggingString_Provinces': 'provinces',
                'GeotaggingString_County': 'county',
                'GeotaggingString_Counties': 'counties',
                'GeotaggingString_Village': 'village',
                'GeotaggingString_Villages': 'villages',
                'GeotaggingString_Post': 'post',
                'GeotaggingString_Zip': 'zip',
                'GeotaggingString_Code': 'code',
                'GeotaggingString_Place': 'place',
                'GeotaggingString_Places': 'places',
                'GeotaggingString_Address': 'address',
                'GeotaggingString_Addresses': 'addresses',
                'GeotaggingString_Street': 'street',
                'GeotaggingString_Streets': 'streets',
                'GeotaggingString_Longitude': 'longitude',
                'GeotaggingString_Longitude_Short': 'lon',
                'GeotaggingString_Latitude': 'latitude',
                'GeotaggingString_Latitude_Short': 'lat',
                'GeotaggingString_PostalCode': 'postal code',
                'GeotaggingString_PostalCodes': 'postal codes',
                'GeotaggingString_ZipCode': 'zip code',
                'GeotaggingString_ZipCodes': 'zip codes',
                'GeotaggingString_Territory': 'territory',
                'GeotaggingString_Territories': 'territories',
            };
            function beautify(format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            }
            function describeUnit(exponent) {
                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"];
                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            }
            function getLocalizedString(stringId) {
                return defaultLocalizedStrings[stringId];
            }
            valueFormatter.getLocalizedString = getLocalizedString;
            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.
            var locale = {
                null: defaultLocalizedStrings['NullValue'],
                true: defaultLocalizedStrings['BooleanTrue'],
                false: defaultLocalizedStrings['BooleanFalse'],
                NaN: defaultLocalizedStrings['NaNValue'],
                infinity: defaultLocalizedStrings['InfinityValue'],
                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                beautify: function (format) { return beautify(format); },
                describe: function (exponent) { return describeUnit(exponent); },
                restatementComma: defaultLocalizedStrings['RestatementComma'],
                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],
                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],
            };
            var MaxScaledDecimalPlaces = 2;
            var MaxValueForDisplayUnitRounding = 1000;
            var MinIntegerValueForDisplayUnits = 10000;
            var MinPrecisionForDisplayUnits = 2;
            var DateTimeMetadataColumn = {
                displayName: '',
                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime),
            };
            function getFormatMetadata(format) {
                return powerbi.NumberFormat.getCustomFormatMetadata(format);
            }
            valueFormatter.getFormatMetadata = getFormatMetadata;
            function setLocaleOptions(options) {
                debug.assertValue(options, 'options');
                locale = options;
                powerbi.DefaultDisplayUnitSystem.reset();
                powerbi.WholeUnitsDisplayUnitSystem.reset();
            }
            valueFormatter.setLocaleOptions = setLocaleOptions;
            function createDefaultFormatter(formatString, allowFormatBeautification) {
                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }
                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;
                return {
                    format: function (value) {
                        if (value == null)
                            return locale.null;
                        return formatCore(value, formatBeaut);
                    }
                };
            }
            valueFormatter.createDefaultFormatter = createDefaultFormatter;
            /** Creates an IValueFormatter to be used for a range of values. */
            function create(options) {
                debug.assertValue(options, 'options');
                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;
                if (shouldUseNumericDisplayUnits(options)) {
                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);
                    var singleValueFormattingMode_1 = !!options.formatSingleValues;
                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));
                    var forcePrecision_1 = options.precision != null;
                    var decimals_1;
                    if (forcePrecision_1)
                        decimals_1 = -options.precision;
                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)
                        decimals_1 = -MaxScaledDecimalPlaces;
                    // Detect axis precision
                    if (options.detectAxisPrecision) {
                        // Trailing zeroes
                        forcePrecision_1 = true;
                        var axisValue = options.value;
                        if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0)
                            axisValue = axisValue / displayUnitSystem_1.displayUnit.value;
                        if (powerbi.Double.isInteger(axisValue))
                            decimals_1 = 0;
                        else
                            decimals_1 = powerbi.Double.log10(axisValue);
                    }
                    return {
                        format: function (value) {
                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);
                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                                return formattedValue;
                            // Round to Double.DEFAULT_PRECISION
                            if (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1)
                                value = powerbi.Double.roundToPrecision(value);
                            return singleValueFormattingMode_1 ?
                                displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) :
                                displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1);
                        },
                        displayUnit: displayUnitSystem_1.displayUnit,
                        options: options
                    };
                }
                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {
                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);
                    return {
                        format: function (value) {
                            if (value == null)
                                return locale.null;
                            var formatString = powerbi.formattingService.dateFormatString(unit_1);
                            return formatCore(value, formatString);
                        },
                        options: options
                    };
                }
                return createDefaultFormatter(format);
            }
            valueFormatter.create = create;
            function format(value, format, allowFormatBeautification) {
                if (value == null)
                    return locale.null;
                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);
            }
            valueFormatter.format = format;
            function getValueFormat(value, columnType) {
                // If column type not defined or is not datetime
                // ...and the value is of time datetime,
                // then use the default date format string
                if ((!columnType || !columnType.dateTime) && value instanceof Date)
                    return getFormatString(DateTimeMetadataColumn, null, false);
            }
            function formatValueColumn(value, column, formatStringProp) {
                var valueFormat = getValueFormat(value, column.type);
                if (valueFormat)
                    return formatCore(value, valueFormat);
                else
                    return formatCore(value, getFormatString(column, formatStringProp));
            }
            valueFormatter.formatValueColumn = formatValueColumn;
            function createDisplayUnitSystem(displayUnitSystemType) {
                if (displayUnitSystemType == null)
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                switch (displayUnitSystemType) {
                    case powerbi.DisplayUnitSystemType.Default:
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                    case powerbi.DisplayUnitSystemType.WholeUnits:
                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);
                    case powerbi.DisplayUnitSystemType.Verbose:
                        return new powerbi.NoDisplayUnitSystem();
                    case powerbi.DisplayUnitSystemType.DataLabels:
                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);
                    default:
                        debug.assertFail('Unknown display unit system type');
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                }
            }
            function shouldUseNumericDisplayUnits(options) {
                var value = options.value;
                var value2 = options.value2;
                var format = options.format;
                // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units
                if (options.formatSingleValues && format) {
                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {
                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);
                        if (isCustomFormat) {
                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;
                            if (precision < MinPrecisionForDisplayUnits)
                                return false;
                        }
                        else if (powerbi.Double.isInteger(value))
                            return false;
                    }
                }
                if ((typeof value === 'number') || (typeof value2 === 'number')) {
                    return true;
                }
            }
            function shouldUseDateUnits(value, value2, tickCount) {
                // must check both value and value2 because we'll need to get an interval for date units
                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);
            }
            /*
             * Get the column format. Order of precendence is:
             *  1. Column format
             *  2. Default PowerView policy for column type
             */
            function getFormatString(column, formatStringProperty, suppressTypeFallback) {
                if (column) {
                    if (formatStringProperty) {
                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);
                        if (propertyValue)
                            return propertyValue;
                    }
                    if (!suppressTypeFallback) {
                        var columnType = column.type;
                        if (columnType) {
                            if (columnType.dateTime)
                                return valueFormatter.DefaultDateFormat;
                            if (columnType.integer)
                                return valueFormatter.DefaultIntegerFormat;
                            if (columnType.numeric)
                                return valueFormatter.DefaultNumericFormat;
                        }
                    }
                }
            }
            valueFormatter.getFormatString = getFormatString;
            function formatListCompound(strings, conjunction) {
                var result;
                if (!strings) {
                    return null;
                }
                var length = strings.length;
                if (length > 0) {
                    result = strings[0];
                    var lastIndex = length - 1;
                    for (var i = 1, len = lastIndex; i < len; i++) {
                        var value = strings[i];
                        result = StringExtensions.format(locale.restatementComma, result, value);
                    }
                    if (length > 1) {
                        var value = strings[lastIndex];
                        result = StringExtensions.format(conjunction, result, value);
                    }
                }
                else {
                    result = null;
                }
                return result;
            }
            /** The returned string will look like 'A, B, ..., and C'  */
            function formatListAnd(strings) {
                return formatListCompound(strings, locale.restatementCompoundAnd);
            }
            valueFormatter.formatListAnd = formatListAnd;
            /** The returned string will look like 'A, B, ..., or C' */
            function formatListOr(strings) {
                return formatListCompound(strings, locale.restatementCompoundOr);
            }
            valueFormatter.formatListOr = formatListOr;
            function formatCore(value, format) {
                var formattedValue = getStringFormat(value, false /*nullsAreBlank*/);
                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                    return formattedValue;
                return powerbi.formattingService.formatValue(value, format);
            }
            function getStringFormat(value, nullsAreBlank) {
                if (value == null && nullsAreBlank)
                    return locale.null;
                if (value === true)
                    return locale.true;
                if (value === false)
                    return locale.false;
                if (typeof value === 'number' && isNaN(value))
                    return locale.NaN;
                if (value === Number.NEGATIVE_INFINITY)
                    return locale.negativeInfinity;
                if (value === Number.POSITIVE_INFINITY)
                    return locale.infinity;
                return '';
            }
            function getDisplayUnits(displayUnitSystemType) {
                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);
                return displayUnitSystem.units;
            }
            valueFormatter.getDisplayUnits = getDisplayUnits;
        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
    var labelStyle = powerbi.visuals.labelStyle;
    var DonutLabelUtils = powerbi.visuals.DonutLabelUtils;
    var DonutLabelLayout = (function () {
        function DonutLabelLayout(options, donutChartProperties) {
            this.startingOffset = options.startingOffset;
            this.maximumOffset = options.maximumOffset;
            if (options.offsetIterationDelta != null) {
                debug.assert(options.offsetIterationDelta > 0, "label offset delta must be greater than 0");
                this.offsetIterationDelta = options.offsetIterationDelta;
            }
            this.donutChartProperties = donutChartProperties;
            this.center = {
                x: donutChartProperties.viewport.width / 2,
                y: donutChartProperties.viewport.height / 2,
            };
            this.outerRadius = this.donutChartProperties.radius * this.donutChartProperties.outerArcRadiusRatio;
            this.innerRadius = (this.donutChartProperties.radius / 2) * this.donutChartProperties.innerArcRadiusRatio;
            this.additionalCharsWidth = powerbi.TextMeasurementService.measureSvgTextWidth({
                text: " ()",
                fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                fontSize: jsCommon.PixelConverter.fromPoint(donutChartProperties.dataLabelsSettings.fontSize),
                fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,
            });
        }
        /**
         * Arrange takes a set of data labels and lays them out them in order, assuming that
         * the given array has already been sorted with the most preferred labels at the
         * front.
         *
         * Details:
         * - We iterate over offsets from the target position, increasing from 0
         * - For each offset, we iterate over each data label
         * - For each data label, we iterate over each position that is valid for
         *     both the specific label and this layout
         * - When a valid position is found, we position the label there and no longer
         *     reposition it.
         * - This prioritizes the earlier labels to be positioned closer to their
         *     target points in the position they prefer.
         * - This prioritizes putting data labels close to a valid position over
         *     placing them at their preferred position (it will place it at a less
         *     preferred position if it will be a smaller offset)
         */
        DonutLabelLayout.prototype.layout = function (labelDataPoints) {
            // Clear data labels for a new layout
            for (var _i = 0, labelDataPoints_3 = labelDataPoints; _i < labelDataPoints_3.length; _i++) {
                var donutLabel = labelDataPoints_3[_i];
                donutLabel.hasBeenRendered = false;
                donutLabel.labelSize = donutLabel.textSize;
            }
            var resultingLabels = [];
            var preferredLabels = [];
            var viewport = this.donutChartProperties.viewport;
            var labelDataPointsGroup = {
                labelDataPoints: labelDataPoints,
                maxNumberOfLabels: labelDataPoints.length
            };
            var grid = new powerbi.LabelArrangeGrid([labelDataPointsGroup], viewport);
            for (var i = labelDataPoints.length - 1; i >= 0; i--) {
                var labelPoint = labelDataPoints[i];
                if (labelPoint.isPreferred) {
                    var label = labelDataPoints.splice(i, 1);
                    preferredLabels = label.concat(preferredLabels);
                }
            }
            // first iterate all the preferred labels
            if (preferredLabels.length > 0)
                resultingLabels = this.positionLabels(preferredLabels, grid);
            // While there are invisible not preferred labels and label distance is less than the max
            // allowed distance
            if (labelDataPoints.length > 0) {
                var labels = this.positionLabels(labelDataPoints, grid);
                resultingLabels = resultingLabels.concat(labels);
            }
            return resultingLabels;
        };
        DonutLabelLayout.prototype.positionLabels = function (labelDataPoints, grid) {
            var resultingLabels = [];
            var offsetDelta = this.offsetIterationDelta;
            var currentOffset = this.startingOffset;
            var currentCenteredOffset = 0;
            while (currentOffset <= this.maximumOffset) {
                for (var _i = 0, labelDataPoints_4 = labelDataPoints; _i < labelDataPoints_4.length; _i++) {
                    var labelPoint = labelDataPoints_4[_i];
                    if (labelPoint.hasBeenRendered)
                        continue;
                    var label = this.tryPositionForDonut(labelPoint, grid, currentOffset);
                    if (label)
                        resultingLabels.push(label);
                }
                currentOffset += offsetDelta;
                currentCenteredOffset += offsetDelta;
            }
            return resultingLabels;
        };
        /**
         * We try to move the label 25% up/down if the label is truncated or it collides with other labels.
         * after we moved it once we check that the new position doesn't failed (collides with other labels).
         */
        DonutLabelLayout.prototype.tryPositionForDonut = function (labelPoint, grid, currentLabelOffset) {
            var parentShape = labelPoint.parentShape;
            if (_.isEmpty(parentShape.validPositions) || parentShape.validPositions[0] === 0 /* None */)
                return;
            var defaultPosition = parentShape.validPositions[0];
            var bestCandidate = this.tryAllPositions(labelPoint, grid, defaultPosition, currentLabelOffset);
            if (bestCandidate && bestCandidate.score === 0) {
                return this.buildLabel(bestCandidate, grid);
            }
            // If we haven't found a non-truncated label, try to split into 2 lines.
            if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both) {
                // Try to split the label to two lines if both data and category label are on
                var splitLabelDataPoint = this.splitDonutDataPoint(labelPoint);
                var bestSplitCandidate = this.tryAllPositions(splitLabelDataPoint, grid, defaultPosition, currentLabelOffset);
                // If the best candidate with a split line is better than the best candidate with a single line, return the former.
                if (bestSplitCandidate && (!bestCandidate || (bestSplitCandidate.score < bestCandidate.score))) {
                    return this.buildLabel(bestSplitCandidate, grid);
                }
            }
            // We didn't find a better candidate by splitting the label lines, so return our best single-line candidate.
            if (bestCandidate) {
                return this.buildLabel(bestCandidate, grid);
            }
        };
        DonutLabelLayout.prototype.generateCandidate = function (labelDataPoint, candidatePosition, grid, currentLabelOffset) {
            var angle = this.generateCandidateAngleForPosition(labelDataPoint.donutArcDescriptor, candidatePosition);
            var parentShape = this.getPointPositionForAngle(angle);
            var parentPoint = parentShape.point;
            var score = this.score(labelDataPoint, parentPoint);
            var leaderLinePoints = DonutLabelUtils.getLabelLeaderLineForDonutChart(labelDataPoint.donutArcDescriptor, this.donutChartProperties, parentPoint, angle);
            var leaderLinesSize = DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
            var newLabelDataPoint = _.clone(labelDataPoint);
            newLabelDataPoint.angle = angle;
            newLabelDataPoint.parentShape = parentShape;
            newLabelDataPoint.leaderLinePoints = leaderLinePoints;
            newLabelDataPoint.linesSize = leaderLinesSize;
            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, parentShape.validPositions[0], newLabelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
            return {
                angle: angle,
                point: parentShape,
                score: score,
                labelRects: boundingBoxs,
                labelDataPoint: newLabelDataPoint,
            };
        };
        DonutLabelLayout.prototype.tryAllPositions = function (labelDataPoint, grid, defaultPosition, currentLabelOffset) {
            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, defaultPosition, labelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
            var originalPoint = labelDataPoint.parentShape;
            var originalCandidate = {
                point: originalPoint,
                angle: labelDataPoint.angle,
                score: this.score(labelDataPoint, originalPoint.point),
                labelRects: boundingBoxs,
                labelDataPoint: labelDataPoint,
            };
            if (boundingBoxs && boundingBoxs.textRect && originalCandidate.score === 0) {
                return originalCandidate;
            }
            var positions = [];
            var bestCandidate;
            if (boundingBoxs && boundingBoxs.textRect) {
                // We have a truncated label here, otherwised we would have returned already
                positions = this.getLabelPointPositions(labelDataPoint, /* isTruncated */ true);
                bestCandidate = originalCandidate;
            }
            else {
                positions = this.getLabelPointPositions(labelDataPoint, /* isTruncated */ false);
            }
            // Try to reposition the label if necessary
            for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                var position = positions_1[_i];
                var candidate = this.generateCandidate(labelDataPoint, position, grid, currentLabelOffset);
                if (candidate.labelRects && candidate.labelRects.textRect) {
                    if (bestCandidate == null || candidate.score < bestCandidate.score) {
                        bestCandidate = candidate;
                        if (bestCandidate.score === 0)
                            return bestCandidate;
                    }
                }
            }
            return bestCandidate;
        };
        DonutLabelLayout.prototype.buildLabel = function (labelLayout, grid) {
            var resultingBoundingBox = labelLayout.labelRects.textRect;
            var labelPoint = labelLayout.labelDataPoint;
            grid.add(resultingBoundingBox);
            grid.add(labelLayout.labelRects.horizontalLineRect);
            grid.add(labelLayout.labelRects.diagonalLineRect);
            labelPoint.hasBeenRendered = true;
            var left = resultingBoundingBox.left - this.center.x;
            //We need to add or subtract half resultingBoundingBox.width because Donut chart labels get text anchor start/end
            if (left < 0)
                left += resultingBoundingBox.width / 2;
            else
                left -= resultingBoundingBox.width / 2;
            var textAnchor = labelPoint.parentShape.validPositions[0] === 8 /* Right */ ? 'start' : 'end';
            var boundingBox = {
                left: left,
                top: resultingBoundingBox.top - this.center.y,
                height: resultingBoundingBox.height,
                width: resultingBoundingBox.width,
            };
            // After repositioning the label we need to recalculate its size and format it according to the current available space
            var labelSettingsStyle = this.donutChartProperties.dataLabelsSettings.labelStyle;
            var spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(labelPoint.parentShape.point.x, this.donutChartProperties.viewport);
            var formattedDataLabel;
            var formattedCategoryLabel;
            var text;
            var getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText;
            var fontSize = labelPoint.fontSize;
            var hasOneLabelRow = labelSettingsStyle === labelStyle.both && labelPoint.secondRowText == null;
            // Giving 50/50 space when both category and measure are on
            if (hasOneLabelRow) {
                labelPoint.dataLabel = " (" + labelPoint.dataLabel + ")";
                spaceAvailableForLabels /= 2;
            }
            if (labelSettingsStyle === labelStyle.both || labelSettingsStyle === labelStyle.data) {
                formattedDataLabel = getLabelFormattedText({
                    label: labelPoint.dataLabel,
                    maxWidth: spaceAvailableForLabels,
                    fontSize: fontSize
                });
            }
            if (labelSettingsStyle === labelStyle.both || labelSettingsStyle === labelStyle.category) {
                formattedCategoryLabel = getLabelFormattedText({
                    label: labelPoint.categoryLabel,
                    maxWidth: spaceAvailableForLabels,
                    fontSize: fontSize
                });
            }
            switch (labelSettingsStyle) {
                case labelStyle.both:
                    if (labelPoint.secondRowText == null) {
                        text = formattedCategoryLabel + formattedDataLabel;
                    }
                    else {
                        text = formattedDataLabel;
                        labelPoint.secondRowText = formattedCategoryLabel;
                    }
                    break;
                case labelStyle.data:
                    text = formattedDataLabel;
                    break;
                case labelStyle.category:
                    text = formattedCategoryLabel;
                    break;
            }
            // Limit text size width for correct leader line calculation
            labelPoint.textSize.width = Math.min(labelPoint.textSize.width, hasOneLabelRow ? spaceAvailableForLabels * 2 : spaceAvailableForLabels);
            return {
                boundingBox: boundingBox,
                text: text,
                tooltip: labelPoint.tooltip,
                isVisible: true,
                fill: labelPoint.outsideFill,
                identity: labelPoint.identity,
                fontSize: fontSize,
                selected: false,
                textAnchor: textAnchor,
                leaderLinePoints: labelPoint.leaderLinePoints,
                hasBackground: false,
                secondRowText: labelPoint.secondRowText,
            };
        };
        DonutLabelLayout.tryPositionPoint = function (grid, position, labelDataPoint, offset, center, viewport) {
            var parentPoint = labelDataPoint.parentShape;
            // Limit label width to fit the availabe space for labels
            var textSize = _.clone(labelDataPoint.textSize);
            textSize.width = Math.min(textSize.width, DonutLabelUtils.getSpaceAvailableForDonutLabels(parentPoint.point.x, viewport));
            // Create label rectangle
            var labelRect = powerbi.DataLabelPointPositioner.getLabelRect(textSize, parentPoint, position, offset);
            // Create label diagonal line rectangle
            var diagonalLineParentPoint = {
                point: {
                    x: labelDataPoint.leaderLinePoints[0][0],
                    y: labelDataPoint.leaderLinePoints[0][1] < 0 ? labelDataPoint.leaderLinePoints[1][1] : labelDataPoint.leaderLinePoints[0][1]
                },
                radius: 0,
                validPositions: null
            };
            var diagonalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.DiagonalLineIndex], diagonalLineParentPoint, position, offset);
            // Create label horizontal line rectangle
            var horizontalLineParentPoint = {
                point: {
                    x: labelDataPoint.leaderLinePoints[1][0],
                    y: labelDataPoint.leaderLinePoints[1][1]
                },
                radius: 0,
                validPositions: null
            };
            var horizontalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.HorizontalLineIndex], horizontalLineParentPoint, position, offset);
            if (!labelRect || !diagonalLineRect || !horizontalLineRect)
                return;
            labelRect.left += center.x;
            labelRect.top += center.y;
            var centerForLinesWidth = center.x - labelRect.width / 2;
            diagonalLineRect.left += centerForLinesWidth;
            diagonalLineRect.top += center.y;
            horizontalLineRect.left += centerForLinesWidth;
            horizontalLineRect.top += center.y;
            if (!grid.hasConflict(labelRect) && !grid.hasConflict(diagonalLineRect) && !grid.hasConflict(horizontalLineRect))
                return { textRect: labelRect, diagonalLineRect: diagonalLineRect, horizontalLineRect: horizontalLineRect };
        };
        /**
         * Returns an array of valid positions for hidden and truncated labels.
         * For truncated labels will return positions with more available space.
         * For hidden labels will return all possible positions by the order we draw labels (clockwise)
         */
        DonutLabelLayout.prototype.getLabelPointPositions = function (labelPoint, isTruncated) {
            var parentShape = labelPoint.parentShape;
            var position = parentShape.validPositions[0];
            if (!isTruncated) {
                return position === 4 /* Left */
                    ? [128 /* AboveLeft */, 32 /* BelowLeft */]
                    : [16 /* BelowRight */, 64 /* AboveRight */];
            }
            if (parentShape.point.y < 0) {
                return position === 8 /* Right */
                    ? [64 /* AboveRight */]
                    : [128 /* AboveLeft */];
            }
            else {
                return position === 8 /* Right */
                    ? [16 /* BelowRight */]
                    : [32 /* BelowLeft */];
            }
        };
        /**
         * Returns a new DonutLabelDataPoint after splitting it into two lines
         */
        DonutLabelLayout.prototype.splitDonutDataPoint = function (labelPoint) {
            var textSize = {
                width: Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width),
                height: labelPoint.dataLabelSize.height * 2,
            };
            var newLabelPoint = _.clone(labelPoint);
            newLabelPoint.textSize = textSize;
            newLabelPoint.secondRowText = labelPoint.categoryLabel;
            return newLabelPoint;
        };
        DonutLabelLayout.prototype.generateCandidateAngleForPosition = function (d, position) {
            var midAngle = d.startAngle + ((d.endAngle - d.startAngle) / 2);
            switch (position) {
                case 64 /* AboveRight */:
                case 32 /* BelowLeft */:
                    return ((d.startAngle + midAngle) - Math.PI) / 2;
                case 128 /* AboveLeft */:
                case 16 /* BelowRight */:
                    return ((midAngle + d.endAngle) - Math.PI) / 2;
                default:
                    debug.assertFail("Unsupported label position");
            }
        };
        DonutLabelLayout.prototype.getPointPositionForAngle = function (angle) {
            // Calculate the new label coordinates
            var labelX = DonutLabelUtils.getXPositionForDonutLabel(Math.cos(angle) * this.outerRadius);
            var labelY = Math.sin(angle) * this.outerRadius;
            var newPosition = labelX < 0 ? 4 /* Left */ : 8 /* Right */;
            var pointPosition = {
                point: {
                    x: labelX,
                    y: labelY,
                },
                validPositions: [newPosition],
                radius: 0,
            };
            return pointPosition;
        };
        DonutLabelLayout.prototype.score = function (labelPoint, point) {
            var spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(point.x, this.donutChartProperties.viewport);
            var textWidth;
            // Check if we show category and data labels in one row
            if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both && labelPoint.secondRowText == null) {
                // Each of the labels gets half of the available space for labels so we take this into consideration in the score
                textWidth = Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width + this.additionalCharsWidth);
                spaceAvailableForLabels /= 2;
            }
            else {
                textWidth = labelPoint.textSize.width;
            }
            return Math.max(textWidth - spaceAvailableForLabels, 0);
        };
        return DonutLabelLayout;
    }());
    powerbi.DonutLabelLayout = DonutLabelLayout;
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
    var DefaultCentroidOffset = 5;
    var OffsetDelta = 10;
    var MaximumOffset = 60;
    var stemExtension = 5;
    var FilledMapLabelLayout = (function () {
        function FilledMapLabelLayout() {
        }
        FilledMapLabelLayout.prototype.layout = function (labelDataPoints, viewport, polygonInfoTransform, redrawDataLabels) {
            if (redrawDataLabels || this.labels === undefined) {
                var labelDataPointsGroup = {
                    labelDataPoints: labelDataPoints,
                    maxNumberOfLabels: labelDataPoints.length
                };
                for (var _i = 0, labelDataPoints_5 = labelDataPoints; _i < labelDataPoints_5.length; _i++) {
                    var labelPoint = labelDataPoints_5[_i];
                    labelPoint.labelSize = {
                        width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                        height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding,
                    };
                }
                var grid = new powerbi.LabelArrangeGrid([labelDataPointsGroup], viewport);
                var resultingDataLabels = [];
                var allPolygons = [];
                for (var _a = 0, labelDataPoints_6 = labelDataPoints; _a < labelDataPoints_6.length; _a++) {
                    var labelPoint = labelDataPoints_6[_a];
                    var polygon = labelPoint.parentShape.polygon;
                    allPolygons.push(polygon);
                    polygon.pixelBoundingRect = polygonInfoTransform.applyToRect(polygon.absoluteBoundingRect());
                }
                var shapesgrid = new LabelPolygonArrangeGrid(allPolygons, viewport);
                for (var _b = 0, labelDataPoints_7 = labelDataPoints; _b < labelDataPoints_7.length; _b++) {
                    var labelPoint = labelDataPoints_7[_b];
                    var dataLabel = this.getLabelByPolygonPositions(labelPoint, polygonInfoTransform, grid, shapesgrid);
                    if (dataLabel != null) {
                        resultingDataLabels.push(dataLabel);
                    }
                }
                this.labels = resultingDataLabels;
            }
            else {
                this.updateLabelOffsets(polygonInfoTransform);
            }
            return this.labels;
        };
        FilledMapLabelLayout.prototype.getLabelPolygon = function (mapDataPoint, position, pointPosition, offset) {
            var dataPointSize = {
                width: mapDataPoint.textSize.width,
                height: (mapDataPoint.textSize.height)
            };
            return this.getLabelBoundingBox(dataPointSize, position, pointPosition, offset);
        };
        FilledMapLabelLayout.prototype.getLabelBoundingBox = function (dataPointSize, position, pointPosition, offset) {
            switch (position) {
                case 1 /* Above */: {
                    return powerbi.DataLabelPointPositioner.above(dataPointSize, pointPosition, offset);
                }
                case 2 /* Below */: {
                    return powerbi.DataLabelPointPositioner.below(dataPointSize, pointPosition, offset);
                }
                case 4 /* Left */: {
                    return powerbi.DataLabelPointPositioner.left(dataPointSize, pointPosition, offset);
                }
                case 8 /* Right */: {
                    return powerbi.DataLabelPointPositioner.right(dataPointSize, pointPosition, offset);
                }
                case 128 /* AboveLeft */: {
                    return powerbi.DataLabelPointPositioner.aboveLeft(dataPointSize, pointPosition, offset);
                }
                case 64 /* AboveRight */: {
                    return powerbi.DataLabelPointPositioner.aboveRight(dataPointSize, pointPosition, offset);
                }
                case 32 /* BelowLeft */: {
                    return powerbi.DataLabelPointPositioner.belowLeft(dataPointSize, pointPosition, offset);
                }
                case 16 /* BelowRight */: {
                    return powerbi.DataLabelPointPositioner.belowRight(dataPointSize, pointPosition, offset);
                }
                case 256 /* Center */: {
                    return powerbi.DataLabelPointPositioner.center(dataPointSize, pointPosition);
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return null;
        };
        FilledMapLabelLayout.prototype.getLabelByPolygonPositions = function (labelPoint, polygonInfoTransform, grid, shapesGrid) {
            var offset = 0;
            var inverseTransorm = polygonInfoTransform.getInverse();
            for (var i = 0; i < 2; i++) {
                if (i === 1) {
                    offset = DefaultCentroidOffset;
                }
                for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                    var position = _a[_i];
                    var resultingAbsoluteBoundingBox = this.tryPositionForPolygonPosition(position, labelPoint, polygonInfoTransform, offset, inverseTransorm);
                    if (position === 256 /* Center */ && i !== 0) {
                        continue;
                    }
                    if (resultingAbsoluteBoundingBox) {
                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsoluteBoundingBox);
                        var dataLabel = {
                            text: labelPoint.text,
                            secondRowText: labelPoint.secondRowText,
                            boundingBox: resultingBoundingBox,
                            isVisible: true,
                            fill: labelPoint.insideFill,
                            identity: null,
                            selected: false,
                            hasBackground: true,
                            textAnchor: "middle",
                            originalPixelOffset: offset,
                            isPlacedInsidePolygon: true,
                            absoluteBoundingBoxCenter: {
                                x: resultingAbsoluteBoundingBox.left + resultingAbsoluteBoundingBox.width / 2,
                                y: resultingAbsoluteBoundingBox.top + resultingAbsoluteBoundingBox.height / 2
                            }
                        };
                        return dataLabel;
                    }
                }
            }
            var currentOffset = 6;
            while (currentOffset <= MaximumOffset) {
                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b];
                    if (position === 256 /* Center */) {
                        continue;
                    }
                    var polygon = labelPoint.parentShape.polygon;
                    var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
                    var resultingAbsolutBoundingBox = this.tryPlaceLabelOutsidePolygon(grid, position, labelPoint, currentOffset, pixelCentroid, shapesGrid, inverseTransorm);
                    if (resultingAbsolutBoundingBox) {
                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsolutBoundingBox);
                        var dataLabel = {
                            text: labelPoint.text,
                            secondRowText: labelPoint.secondRowText,
                            boundingBox: resultingBoundingBox,
                            isVisible: true,
                            fill: labelPoint.insideFill,
                            identity: null,
                            selected: false,
                            hasBackground: true,
                            isPlacedInsidePolygon: false,
                            textAnchor: "middle",
                            originalPixelOffset: currentOffset,
                            originalPosition: position,
                            originalAbsoluteCentroid: polygon.absoluteCentroid(),
                            absoluteBoundingBoxCenter: {
                                x: resultingAbsolutBoundingBox.left + resultingAbsolutBoundingBox.width / 2,
                                y: resultingAbsolutBoundingBox.top + resultingAbsolutBoundingBox.height / 2
                            }
                        };
                        var pixelStemSource = this.calculateStemSource(polygonInfoTransform, inverseTransorm, polygon, resultingBoundingBox, position, pixelCentroid);
                        dataLabel.leaderLinePoints = this.setLeaderLinePoints(pixelStemSource, this.calculateStemDestination(resultingBoundingBox, position));
                        dataLabel.absoluteStemSource = inverseTransorm.applyToPoint(pixelStemSource);
                        grid.add(resultingBoundingBox);
                        return dataLabel;
                    }
                }
                currentOffset += OffsetDelta;
            }
            return null;
        };
        FilledMapLabelLayout.prototype.setLeaderLinePoints = function (stemSource, stemDestination) {
            return [[stemSource.x, stemSource.y], [stemDestination.x, stemDestination.y]];
        };
        FilledMapLabelLayout.prototype.calculateStemSource = function (polygonInfoTransform, inverseTransorm, polygon, labelBoundingBox, position, pixelCentroid) {
            var absoluteStemSource = polygon.lineIntersectionPoint(polygon.absoluteCentroid(), inverseTransorm.applyToPoint({ x: labelBoundingBox.left + labelBoundingBox.width / 2, y: labelBoundingBox.top + labelBoundingBox.height / 2 }));
            if (absoluteStemSource == null) {
                return pixelCentroid;
            }
            var stemSource = polygonInfoTransform.applyToPoint(absoluteStemSource);
            switch (position) {
                case 1 /* Above */: {
                    stemSource.y += stemExtension;
                    break;
                }
                case 2 /* Below */: {
                    stemSource.y -= stemExtension;
                    break;
                }
                case 4 /* Left */: {
                    stemSource.x += stemExtension;
                    break;
                }
                case 8 /* Right */: {
                    stemSource.x -= stemExtension;
                    break;
                }
                case 128 /* AboveLeft */: {
                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 64 /* AboveRight */: {
                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 32 /* BelowLeft */: {
                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 16 /* BelowRight */: {
                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 256 /* Center */: {
                    break;
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return stemSource;
        };
        FilledMapLabelLayout.prototype.calculateStemDestination = function (labelBoundingBox, position) {
            var x;
            var y;
            switch (position) {
                case 1 /* Above */: {
                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 2 /* Below */: {
                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
                    y = labelBoundingBox.top;
                    break;
                }
                case 4 /* Left */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;
                }
                case 8 /* Right */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;
                }
                case 128 /* AboveLeft */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 64 /* AboveRight */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 32 /* BelowLeft */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top;
                    break;
                }
                case 16 /* BelowRight */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top;
                    break;
                }
                case 256 /* Center */: {
                    break;
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return { x: x, y: y };
        };
        FilledMapLabelLayout.prototype.tryPositionForPolygonPosition = function (position, labelDataPoint, polygonInfoTransform, offset, inverseTransorm) {
            var polygon = labelDataPoint.parentShape.polygon;
            var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offset);
            var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransorm, labelRect);
            return polygon.contains(absoluteLabelRect) ? absoluteLabelRect : null;
        };
        /**
        * Tests a particular position/offset combination for the given data label.
        * If the label can be placed, returns the resulting bounding box for the data
        * label.  If not, returns null.
        */
        FilledMapLabelLayout.prototype.tryPlaceLabelOutsidePolygon = function (grid, position, labelDataPoint, offset, pixelCentroid, shapesGrid, inverseTransform) {
            var offsetForPosition = offset;
            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offsetForPosition);
            var otherLabelsConflict = grid.hasConflict(labelRect);
            if (!otherLabelsConflict) {
                var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransform, labelRect);
                if (!shapesGrid.hasConflict(absoluteLabelRect, labelRect))
                    return absoluteLabelRect;
            }
            return null;
        };
        FilledMapLabelLayout.prototype.updateLabelOffsets = function (polygonInfoTransform) {
            for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
                var label = _a[_i];
                if (!label.isVisible)
                    continue;
                if (label.isPlacedInsidePolygon) {
                    var newOffset = polygonInfoTransform.applyToPoint(label.absoluteBoundingBoxCenter);
                    var xDelta = (label.boundingBox.left + label.boundingBox.width / 2) - newOffset.x;
                    var yDelta = (label.boundingBox.top + label.boundingBox.height / 2) - newOffset.y;
                    label.boundingBox.top -= yDelta;
                    label.boundingBox.left -= xDelta;
                }
                else {
                    var stemSourcePoint = polygonInfoTransform.applyToPoint(label.absoluteStemSource);
                    var pixelCentroid = polygonInfoTransform.applyToPoint(label.originalAbsoluteCentroid);
                    label.boundingBox = this.getLabelBoundingBox({ width: label.boundingBox.width, height: label.boundingBox.height }, label.originalPosition, pixelCentroid, label.originalPixelOffset);
                    if (label.leaderLinePoints !== undefined)
                        label.leaderLinePoints = this.setLeaderLinePoints(stemSourcePoint, this.calculateStemDestination(label.boundingBox, label.originalPosition));
                }
            }
        };
        FilledMapLabelLayout.prototype.getAbsoluteRectangle = function (inverseTransorm, rect) {
            return inverseTransorm.applyToRect(rect);
        };
        return FilledMapLabelLayout;
    }());
    powerbi.FilledMapLabelLayout = FilledMapLabelLayout;
    var LabelPolygonArrangeGrid = (function () {
        function LabelPolygonArrangeGrid(polygons, viewport) {
            this.viewport = viewport;
            var maxPolygonWidth = 0;
            var maxPolygonHeight = 0;
            for (var _i = 0, polygons_1 = polygons; _i < polygons_1.length; _i++) {
                var polygon = polygons_1[_i];
                var polygonSize = polygon.pixelBoundingRect;
                if (polygonSize.width > maxPolygonWidth) {
                    maxPolygonWidth = polygonSize.width;
                }
                if (polygonSize.height > maxPolygonHeight) {
                    maxPolygonHeight = polygonSize.height;
                }
            }
            if (maxPolygonWidth === 0) {
                maxPolygonWidth = viewport.width;
            }
            if (maxPolygonHeight === 0) {
                maxPolygonHeight = viewport.height;
            }
            var cellSize = this.cellSize = { width: maxPolygonWidth * LabelPolygonArrangeGrid.cellSizeMultiplier, height: maxPolygonHeight * LabelPolygonArrangeGrid.cellSizeMultiplier };
            this.columnCount = LabelPolygonArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
            this.rowCount = LabelPolygonArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            var grid = [];
            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
                    grid[i][j] = [];
                }
            }
            this.grid = grid;
            for (var _a = 0, polygons_2 = polygons; _a < polygons_2.length; _a++) {
                var polygon = polygons_2[_a];
                this.add(polygon);
            }
        }
        LabelPolygonArrangeGrid.prototype.hasConflict = function (absolutLabelRect, pixelLabelRect) {
            var containingIndexRect = this.getContainingGridSubsection(pixelLabelRect);
            var grid = this.grid;
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                        var currentPolygon = _a[_i];
                        if (currentPolygon.conflicts(absolutLabelRect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        LabelPolygonArrangeGrid.prototype.add = function (polygon) {
            var containingIndexRect = this.getContainingGridSubsection(polygon.pixelBoundingRect);
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    this.grid[x][y].push(polygon);
                }
            }
        };
        LabelPolygonArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
            return {
                xMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
            };
        };
        LabelPolygonArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
            return LabelPolygonArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        };
        LabelPolygonArrangeGrid.bound = function (value, min, max) {
            return Math.max(Math.min(value, max), min);
        };
        /**
         * A multiplier applied to the largest width height to attempt to balance # of
         * polygons in each cell and number of cells each polygon belongs to
         */
        LabelPolygonArrangeGrid.cellSizeMultiplier = 2;
        return LabelPolygonArrangeGrid;
    }());
    powerbi.LabelPolygonArrangeGrid = LabelPolygonArrangeGrid;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function createColorAllocatorFactory() {
            return new ColorAllocatorFactory();
        }
        visuals.createColorAllocatorFactory = createColorAllocatorFactory;
        var ColorAllocatorFactory = (function () {
            function ColorAllocatorFactory() {
            }
            ColorAllocatorFactory.prototype.linearGradient2 = function (options) {
                return new LinearGradient2Allocator(options);
            };
            ColorAllocatorFactory.prototype.linearGradient3 = function (options, splitScales) {
                if (splitScales)
                    return new LinearGradient3AllocatorWithSplittedScales(options);
                return new LinearGradient3Allocator(options);
            };
            return ColorAllocatorFactory;
        }());
        var LinearGradient2Allocator = (function () {
            function LinearGradient2Allocator(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, max = options.max;
                this.scale = d3.scale.linear()
                    .domain([min.value, max.value])
                    .range([min.color, max.color])
                    .clamp(true); // process a value outside of the domain - set to extremum values
            }
            LinearGradient2Allocator.prototype.color = function (value) {
                var min = this.options.min, max = this.options.max;
                if (min.value === max.value) {
                    if (value >= max.value)
                        return max.color;
                    return min.color;
                }
                return this.scale(value);
            };
            return LinearGradient2Allocator;
        }());
        var LinearGradient3Allocator = (function () {
            function LinearGradient3Allocator(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                this.scale = d3.scale.linear()
                    .domain([min.value, mid.value, max.value])
                    .range([min.color, mid.color, max.color])
                    .clamp(true); // process a value outside of the domain- set to extremum values
            }
            LinearGradient3Allocator.prototype.color = function (value) {
                var min = this.options.min, mid = this.options.mid, max = this.options.max;
                if (max.value === mid.value || mid.value === min.value || (max.value === mid.value && max.value === min.value)) {
                    if (value >= max.value)
                        return max.color;
                    else if (value >= mid.value)
                        return mid.color;
                    return min.color;
                }
                return this.scale(value);
            };
            return LinearGradient3Allocator;
        }());
        var LinearGradient3AllocatorWithSplittedScales = (function () {
            function LinearGradient3AllocatorWithSplittedScales(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                /*
                If the center value is overridden, but the max and min remain automatic,
                colors are then assigned on a scale between the overridden center value and the max/min values in the data.
                Each side of the center value is assigned separately, independent of the relative scales.
                */
                this.scale1 = d3.scale.linear()
                    .domain([min.value, mid.value])
                    .range([min.color, mid.color])
                    .clamp(true); // process a value outside of the domain- set to extremum values
                this.scale2 = d3.scale.linear()
                    .domain([mid.value, max.value])
                    .range([mid.color, max.color])
                    .clamp(true); // process a value outside of the domain- set to extremum values
            }
            LinearGradient3AllocatorWithSplittedScales.prototype.color = function (value) {
                var min = this.options.min, mid = this.options.mid, max = this.options.max;
                if (max.value === mid.value || mid.value === min.value || (max.value === mid.value && max.value === min.value)) {
                    if (value >= max.value)
                        return max.color;
                    else if (value >= mid.value)
                        return mid.color;
                    return min.color;
                }
                else if (value <= mid.value) {
                    return this.scale1(value);
                }
                return this.scale2(value);
            };
            return LinearGradient3AllocatorWithSplittedScales;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BeautifiedFormat = {
            '0.00 %;-0.00 %;0.00 %': 'Percentage',
            '0.0 %;-0.0 %;0.0 %': 'Percentage1',
        };
        var defaultLocalizedStrings = {
            'NullValue': '(Blank)',
            'BooleanTrue': 'True',
            'BooleanFalse': 'False',
            'NaNValue': 'NaN',
            'InfinityValue': '+Infinity',
            'NegativeInfinityValue': '-Infinity',
            'Restatement_Comma': '{0}, {1}',
            'Restatement_CompoundAnd': '{0} and {1}',
            'DisplayUnitSystem_EAuto_Title': 'Auto',
            'DisplayUnitSystem_E0_Title': 'None',
            'DisplayUnitSystem_E3_LabelFormat': '{0}K',
            'DisplayUnitSystem_E3_Title': 'Thousands',
            'DisplayUnitSystem_E6_LabelFormat': '{0}M',
            'DisplayUnitSystem_E6_Title': 'Millions',
            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
            'DisplayUnitSystem_E9_Title': 'Billions',
            'DisplayUnitSystem_E12_LabelFormat': '{0}T',
            'DisplayUnitSystem_E12_Title': 'Trillions',
            'Percentage': '#,0.##%',
            'Percentage1': '#,0.#%',
            'RichTextbox_Link_DefaultText': 'Link',
            'TableTotalLabel': 'Total',
            'Tooltip_HighlightedValueDisplayName': 'Highlighted',
            'Funnel_PercentOfFirst': 'Percent of first',
            'Funnel_PercentOfPrevious': 'Percent of previous',
            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',
            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',
            // Geotagging strings
            'GeotaggingString_Continent': 'continent',
            'GeotaggingString_Continents': 'continents',
            'GeotaggingString_Country': 'country',
            'GeotaggingString_Countries': 'countries',
            'GeotaggingString_State': 'state',
            'GeotaggingString_States': 'states',
            'GeotaggingString_City': 'city',
            'GeotaggingString_Cities': 'cities',
            'GeotaggingString_Town': 'town',
            'GeotaggingString_Towns': 'towns',
            'GeotaggingString_Province': 'province',
            'GeotaggingString_Provinces': 'provinces',
            'GeotaggingString_County': 'county',
            'GeotaggingString_Counties': 'counties',
            'GeotaggingString_Village': 'village',
            'GeotaggingString_Villages': 'villages',
            'GeotaggingString_Post': 'post',
            'GeotaggingString_Zip': 'zip',
            'GeotaggingString_Code': 'code',
            'GeotaggingString_Place': 'place',
            'GeotaggingString_Places': 'places',
            'GeotaggingString_Address': 'address',
            'GeotaggingString_Addresses': 'addresses',
            'GeotaggingString_Street': 'street',
            'GeotaggingString_Streets': 'streets',
            'GeotaggingString_Longitude': 'longitude',
            'GeotaggingString_Longitude_Short': 'lon',
            'GeotaggingString_Latitude': 'latitude',
            'GeotaggingString_Latitude_Short': 'lat',
            'GeotaggingString_PostalCode': 'postal code',
            'GeotaggingString_PostalCodes': 'postal codes',
            'GeotaggingString_ZipCode': 'zip code',
            'GeotaggingString_ZipCodes': 'zip codes',
            'GeotaggingString_Territory': 'territory',
            'GeotaggingString_Territories': 'territories',
            'Waterfall_IncreaseLabel': 'Increase',
            'Waterfall_DecreaseLabel': 'Decrease',
            'Waterfall_TotalLabel': 'Total',
            'Slicer_SelectAll': 'Select All',
        };
        var DefaultVisualHostServices = (function () {
            function DefaultVisualHostServices() {
            }
            // TODO: Add locale-awareness to this host service. Currently default/english functionality only.
            DefaultVisualHostServices.initialize = function () {
                visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions());
                visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
            };
            /**
             * Create locale options.
             *
             * Note: Public for testability.
             */
            DefaultVisualHostServices.createLocaleOptions = function () {
                return {
                    null: defaultLocalizedStrings['NullValue'],
                    true: defaultLocalizedStrings['BooleanTrue'],
                    false: defaultLocalizedStrings['BooleanFalse'],
                    NaN: defaultLocalizedStrings['NaNValue'],
                    infinity: defaultLocalizedStrings['InfinityValue'],
                    negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                    beautify: function (format) { return DefaultVisualHostServices.beautify(format); },
                    describe: function (exponent) { return DefaultVisualHostServices.describeUnit(exponent); },
                    restatementComma: defaultLocalizedStrings['Restatement_Comma'],
                    restatementCompoundAnd: defaultLocalizedStrings['Restatement_CompoundAnd'],
                    restatementCompoundOr: defaultLocalizedStrings['Restatement_CompoundOr']
                };
            };
            DefaultVisualHostServices.createTooltipLocaleOptions = function () {
                return {
                    highlightedValueDisplayName: defaultLocalizedStrings['Tooltip_HighlightedValueDisplayName']
                };
            };
            DefaultVisualHostServices.prototype.getLocalizedString = function (stringId) {
                return defaultLocalizedStrings[stringId];
            };
            // NO-OP IHostServices methods
            DefaultVisualHostServices.prototype.onDragStart = function () { };
            DefaultVisualHostServices.prototype.canSelect = function () { return false; };
            DefaultVisualHostServices.prototype.onSelect = function () { };
            DefaultVisualHostServices.prototype.onContextMenu = function () { };
            DefaultVisualHostServices.prototype.loadMoreData = function () { };
            DefaultVisualHostServices.prototype.persistProperties = function (changes) { };
            DefaultVisualHostServices.prototype.onCustomSort = function (args) { };
            DefaultVisualHostServices.prototype.getViewMode = function () { return 0 /* View */; };
            DefaultVisualHostServices.prototype.setWarnings = function (warnings) { };
            DefaultVisualHostServices.prototype.setToolbar = function ($toolbar) { };
            DefaultVisualHostServices.prototype.shouldRetainSelection = function () { return false; };
            DefaultVisualHostServices.prototype.geocoder = function () { return visuals.services.createGeocoder(); };
            DefaultVisualHostServices.prototype.geolocation = function () { return visuals.services.createGeolocation(); };
            DefaultVisualHostServices.prototype.promiseFactory = function () { return powerbi.createJQueryPromiseFactory(); };
            DefaultVisualHostServices.prototype.analyzeFilter = function (options) {
                return {
                    isNotFilter: false,
                    selectedIdentities: [],
                    filter: undefined,
                    defaultValue: undefined,
                };
            };
            DefaultVisualHostServices.prototype.getIdentityDisplayNames = function (dentities) { return; };
            DefaultVisualHostServices.prototype.setIdentityDisplayNames = function (displayNamesIdentityPairs) { };
            DefaultVisualHostServices.beautify = function (format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            };
            DefaultVisualHostServices.describeUnit = function (exponent) {
                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"];
                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            };
            return DefaultVisualHostServices;
        }());
        visuals.DefaultVisualHostServices = DefaultVisualHostServices;
        visuals.defaultVisualHostServices = new DefaultVisualHostServices();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /**
         * Factory method to create an IInteractivityService instance.
         */
        function createInteractivityService(hostServices) {
            return new InteractivityService(hostServices);
        }
        visuals.createInteractivityService = createInteractivityService;
        /**
         * Creates a clear an svg rect to catch clear clicks.
         */
        function appendClearCatcher(selection) {
            return selection
                .append("rect")
                .classed("clearCatcher", true)
                .attr({ width: "100%", height: "100%" });
        }
        visuals.appendClearCatcher = appendClearCatcher;
        function isCategoryColumnSelected(propertyId, categories, idx) {
            return categories.objects != null
                && categories.objects[idx]
                && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
        }
        visuals.isCategoryColumnSelected = isCategoryColumnSelected;
        function dataHasSelection(data) {
            for (var i = 0, ilen = data.length; i < ilen; i++) {
                if (data[i].selected)
                    return true;
            }
            return false;
        }
        visuals.dataHasSelection = dataHasSelection;
        var InteractivityService = (function () {
            function InteractivityService(hostServices) {
                this.renderSelectionInVisual = _.noop;
                this.renderSelectionInLegend = _.noop;
                this.renderSelectionInLabels = _.noop;
                // Selection state
                this.selectedIds = [];
                this.isInvertedSelectionMode = false;
                debug.assertValue(hostServices, 'hostServices');
                this.hostService = hostServices;
            }
            // IInteractivityService Implementation
            /** Binds the vsiual to the interactivityService */
            InteractivityService.prototype.bind = function (dataPoints, behavior, behaviorOptions, options) {
                var _this = this;
                // Bind the data
                if (options && options.overrideSelectionFromData) {
                    // Override selection state from data points if needed
                    this.takeSelectionStateFromDataPoints(dataPoints);
                }
                if (options) {
                    if (options.isLegend) {
                        // Bind to legend data instead of normal data if isLegend
                        this.selectableLegendDataPoints = dataPoints;
                        this.renderSelectionInLegend = function () { return behavior.renderSelection(_this.legendHasSelection()); };
                    }
                    else if (options.isLabels) {
                        //Bind to label data instead of normal data if isLabels
                        this.selectableLabelsDataPoints = dataPoints;
                        this.renderSelectionInLabels = function () { return behavior.renderSelection(_this.labelsHasSelection()); };
                    }
                    else {
                        this.selectableDataPoints = dataPoints;
                        this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
                    }
                    if (options.hasSelectionOverride != null) {
                        this.hasSelectionOverride = options.hasSelectionOverride;
                    }
                    if (options.slicerDefaultValueHandler) {
                        this.slicerDefaultValueHandler = options.slicerDefaultValueHandler;
                    }
                }
                else {
                    this.selectableDataPoints = dataPoints;
                    this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
                }
                // Bind to the behavior
                this.behavior = behavior;
                behavior.bindEvents(behaviorOptions, this);
                // Sync data points with current selection state
                this.syncSelectionState();
            };
            /**
             * Sets the selected state of all selectable data points to false and invokes the behavior's select command.
             */
            InteractivityService.prototype.clearSelection = function () {
                // if default value is already applied, don't clear the default selection
                if (this.slicerDefaultValueHandler && this.slicerDefaultValueHandler.getDefaultValue() && this.useDefaultValue) {
                    this.isInvertedSelectionMode = false;
                    return;
                }
                this.hasSelectionOverride = undefined;
                ArrayExtensions.clear(this.selectedIds);
                this.isInvertedSelectionMode = false;
                this.applyToAllSelectableDataPoints(function (dataPoint) { return dataPoint.selected = false; });
                this.renderAll();
            };
            InteractivityService.prototype.applySelectionStateToData = function (dataPoints) {
                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var dataPoint = dataPoints_1[_i];
                    dataPoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(dataPoint, this.selectedIds);
                }
                return this.hasSelection();
            };
            /**
             * Checks whether there is at least one item selected.
             */
            InteractivityService.prototype.hasSelection = function () {
                return this.selectedIds.length > 0;
            };
            InteractivityService.prototype.legendHasSelection = function () {
                return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : false;
            };
            InteractivityService.prototype.labelsHasSelection = function () {
                return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : false;
            };
            InteractivityService.prototype.isSelectionModeInverted = function () {
                return this.isInvertedSelectionMode;
            };
            InteractivityService.prototype.setSelectionModeInverted = function (inverted) {
                this.isInvertedSelectionMode = inverted;
            };
            // ISelectionHandler Implementation
            InteractivityService.prototype.handleSelection = function (dataPoint, multiSelect) {
                // defect 7067397: should not happen so assert but also don't continue as it's
                // causing a lot of error telemetry in desktop.
                debug.assertValue(dataPoint, 'dataPoint');
                if (!dataPoint)
                    return;
                this.useDefaultValue = false;
                this.select(dataPoint, multiSelect);
                this.sendSelectionToHost();
                this.renderAll();
            };
            InteractivityService.prototype.handleContextMenu = function (dataPoint, point) {
                this.sendContextMenuToHost(dataPoint, point);
            };
            InteractivityService.prototype.handleClearSelection = function () {
                this.useDefaultValue = true;
                this.clearSelection();
                this.sendSelectionToHost();
            };
            InteractivityService.prototype.toggleSelectionModeInversion = function () {
                this.useDefaultValue = false;
                this.isInvertedSelectionMode = !this.isInvertedSelectionMode;
                ArrayExtensions.clear(this.selectedIds);
                this.applyToAllSelectableDataPoints(function (dataPoint) { return dataPoint.selected = false; });
                this.sendSelectionToHost();
                this.isInvertedSelectionMode ? this.syncSelectionStateInverted() : this.syncSelectionState();
                this.renderAll();
                return this.isInvertedSelectionMode;
            };
            InteractivityService.prototype.persistSelectionFilter = function (filterPropertyIdentifier) {
                this.hostService.persistProperties(this.createChangeForFilterProperty(filterPropertyIdentifier));
            };
            InteractivityService.prototype.setDefaultValueMode = function (useDefaultValue) {
                this.useDefaultValue = useDefaultValue;
            };
            InteractivityService.prototype.isDefaultValueEnabled = function () {
                return this.useDefaultValue;
            };
            // Private utility methods
            InteractivityService.prototype.renderAll = function () {
                this.renderSelectionInVisual();
                this.renderSelectionInLegend();
                this.renderSelectionInLabels();
            };
            /** Marks a data point as selected and syncs selection with the host. */
            InteractivityService.prototype.select = function (d, multiSelect) {
                // If we're in inverted mode, use the invertedSelect instead
                if (this.isInvertedSelectionMode) {
                    return this.selectInverted(d, multiSelect);
                }
                // For highlight data points we actually want to select the non-highlight data point
                if (d.identity.highlight) {
                    d = _.find(this.selectableDataPoints, function (dp) { return !dp.identity.highlight && d.identity.includes(dp.identity, /* ignoreHighlight */ true); });
                    debug.assertValue(d, 'Expected to find a non-highlight data point');
                }
                var id = d.identity;
                if (!id)
                    return;
                var selected = !d.selected || (!multiSelect && this.selectedIds.length > 1);
                // If we have a multiselect flag, we attempt a multiselect
                if (multiSelect) {
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                    else {
                        d.selected = false;
                        this.removeId(id);
                    }
                }
                // We do a single select if we didn't do a multiselect or if we find out that the multiselect is invalid.
                if (!multiSelect || !this.hostService.canSelect({ data: this.selectedIds.map(function (value) { return value.getSelector(); }) })) {
                    this.clearSelection();
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                }
                this.syncSelectionState();
            };
            InteractivityService.prototype.selectInverted = function (d, multiSelect) {
                var wasSelected = d.selected;
                var id = d.identity;
                debug.assert(!!multiSelect, "inverted selections are only supported in multiselect mode");
                // the current datapoint state has to be inverted
                d.selected = !wasSelected;
                if (wasSelected)
                    this.removeId(id);
                else
                    this.selectedIds.push(id);
                this.syncSelectionStateInverted();
            };
            InteractivityService.prototype.removeId = function (toRemove) {
                var selectedIds = this.selectedIds;
                for (var i = selectedIds.length - 1; i > -1; i--) {
                    var currentId = selectedIds[i];
                    if (toRemove.includes(currentId))
                        selectedIds.splice(i, 1);
                }
            };
            /** Note: Public for UnitTesting */
            InteractivityService.prototype.createChangeForFilterProperty = function (filterPropertyIdentifier) {
                var properties = {};
                var selectors = [];
                if (this.selectedIds.length > 0) {
                    selectors = _.chain(this.selectedIds)
                        .filter(function (value) { return value.hasIdentity(); })
                        .map(function (value) { return value.getSelector(); })
                        .value();
                }
                var instance = {
                    objectName: filterPropertyIdentifier.objectName,
                    selector: undefined,
                    properties: properties
                };
                var filter = powerbi.data.Selector.filterFromSelector(selectors, this.isInvertedSelectionMode);
                if (this.slicerDefaultValueHandler && this.slicerDefaultValueHandler.getDefaultValue()) {
                    // we explicitly check for true/false because undefine means no default value
                    if (this.useDefaultValue === true)
                        filter = powerbi.data.SemanticFilter.getDefaultValueFilter(this.slicerDefaultValueHandler.getIdentityFields());
                    else if (_.isEmpty(selectors))
                        filter = powerbi.data.SemanticFilter.getAnyValueFilter(this.slicerDefaultValueHandler.getIdentityFields());
                }
                if (filter == null) {
                    properties[filterPropertyIdentifier.propertyName] = {};
                    return {
                        remove: [instance]
                    };
                }
                else {
                    properties[filterPropertyIdentifier.propertyName] = filter;
                    return {
                        merge: [instance]
                    };
                }
            };
            InteractivityService.prototype.sendContextMenuToHost = function (dataPoint, position) {
                var host = this.hostService;
                if (!host.onContextMenu)
                    return;
                var selectors = this.getSelectorsByColumn([dataPoint.identity]);
                if (_.isEmpty(selectors))
                    return;
                var args = {
                    data: selectors,
                    position: position
                };
                host.onContextMenu(args);
            };
            InteractivityService.prototype.sendSelectionToHost = function () {
                var host = this.hostService;
                if (host.onSelect) {
                    var selectArgs = {
                        data: this.selectedIds.filter(function (value) { return value.hasIdentity(); }).map(function (value) { return value.getSelector(); })
                    };
                    var data2 = this.getSelectorsByColumn(this.selectedIds);
                    if (!_.isEmpty(data2))
                        selectArgs.data2 = data2;
                    host.onSelect(selectArgs);
                }
            };
            InteractivityService.prototype.getSelectorsByColumn = function (selectionIds) {
                return _(selectionIds)
                    .filter(function (value) { return value.hasIdentity; })
                    .map(function (value) { return value.getSelectorsByColumn(); })
                    .compact()
                    .value();
            };
            InteractivityService.prototype.takeSelectionStateFromDataPoints = function (dataPoints) {
                debug.assertValue(dataPoints, "dataPoints");
                var selectedIds = this.selectedIds;
                // Replace the existing selectedIds rather than merging.
                ArrayExtensions.clear(selectedIds);
                for (var _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var dataPoint = dataPoints_2[_i];
                    if (dataPoint.selected)
                        selectedIds.push(dataPoint.identity);
                }
            };
            /**
             * Syncs the selection state for all data points that have the same category. Returns
             * true if the selection state was out of sync and corrections were made; false if
             * the data is already in sync with the service.
             *
             * If the data is not compatible with the current service's current selection state,
             * the state is cleared and the cleared selection is sent to the host.
             *
             * Ignores series for now, since we don't support series selection at the moment.
             */
            InteractivityService.prototype.syncSelectionState = function () {
                if (this.isInvertedSelectionMode) {
                    return this.syncSelectionStateInverted();
                }
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                var foundMatchingId = false; // Checked only against the visual's data points; it's possible to have stuff selected in the visual that's not in the legend, but not vice-verse
                if (!selectableDataPoints && !selectableLegendDataPoints)
                    return;
                if (selectableDataPoints) {
                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableDataPoints, selectedIds))
                        foundMatchingId = true;
                }
                if (selectableLegendDataPoints) {
                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableLegendDataPoints, selectedIds))
                        foundMatchingId = true;
                }
                if (selectableLabelsDataPoints) {
                    var labelsDataPoint_1;
                    for (var i = 0, ilen = selectableLabelsDataPoints.length; i < ilen; i++) {
                        labelsDataPoint_1 = selectableLabelsDataPoints[i];
                        if (selectedIds.some(function (value) { return value.includes(labelsDataPoint_1.identity); }))
                            labelsDataPoint_1.selected = true;
                        else
                            labelsDataPoint_1.selected = false;
                    }
                }
                if (!foundMatchingId && selectedIds.length > 0) {
                    this.clearSelection();
                    this.sendSelectionToHost();
                }
            };
            InteractivityService.prototype.syncSelectionStateInverted = function () {
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                if (!selectableDataPoints)
                    return;
                if (selectedIds.length === 0) {
                    for (var _i = 0, selectableDataPoints_1 = selectableDataPoints; _i < selectableDataPoints_1.length; _i++) {
                        var dataPoint_1 = selectableDataPoints_1[_i];
                        dataPoint_1.selected = false;
                    }
                }
                else {
                    for (var _a = 0, selectableDataPoints_2 = selectableDataPoints; _a < selectableDataPoints_2.length; _a++) {
                        var dataPoint = selectableDataPoints_2[_a];
                        if (selectedIds.some(function (value) { return value.includes(dataPoint.identity); }))
                            dataPoint.selected = true;
                        else if (dataPoint.selected)
                            dataPoint.selected = false;
                    }
                }
            };
            InteractivityService.prototype.applyToAllSelectableDataPoints = function (action) {
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                if (selectableDataPoints) {
                    for (var _i = 0, selectableDataPoints_3 = selectableDataPoints; _i < selectableDataPoints_3.length; _i++) {
                        var dataPoint = selectableDataPoints_3[_i];
                        action(dataPoint);
                    }
                }
                if (selectableLegendDataPoints) {
                    for (var _a = 0, selectableLegendDataPoints_1 = selectableLegendDataPoints; _a < selectableLegendDataPoints_1.length; _a++) {
                        var dataPoint = selectableLegendDataPoints_1[_a];
                        action(dataPoint);
                    }
                }
                if (selectableLabelsDataPoints) {
                    for (var _b = 0, selectableLabelsDataPoints_1 = selectableLabelsDataPoints; _b < selectableLabelsDataPoints_1.length; _b++) {
                        var dataPoint = selectableLabelsDataPoints_1[_b];
                        action(dataPoint);
                    }
                }
            };
            InteractivityService.updateSelectableDataPointsBySelectedIds = function (selectableDataPoints, selectedIds) {
                var foundMatchingId = false;
                for (var _i = 0, selectableDataPoints_4 = selectableDataPoints; _i < selectableDataPoints_4.length; _i++) {
                    var datapoint = selectableDataPoints_4[_i];
                    datapoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(datapoint, selectedIds);
                    if (datapoint.selected)
                        foundMatchingId = true;
                }
                return foundMatchingId;
            };
            InteractivityService.checkDatapointAgainstSelectedIds = function (datapoint, selectedIds) {
                return selectedIds.some(function (value) { return value.includes(datapoint.identity); });
            };
            return InteractivityService;
        }());
        visuals.InteractivityService = InteractivityService;
        ;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            var CategoryTypes = visuals.MapUtil.CategoryTypes;
            var Settings = visuals.MapUtil.Settings;
            function createGeocoder() {
                return {
                    geocode: geocode,
                    geocodeBoundary: geocodeBoundary,
                };
            }
            services.createGeocoder = createGeocoder;
            services.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
            /** Note: Used for test mockup */
            services.BingAjaxCall = $.ajax;
            services.CategoryTypeArray = [
                "Address",
                "City",
                "Continent",
                "Country",
                "County",
                "Longitude",
                "Latitude",
                "Place",
                "PostalCode",
                "StateOrProvince"
            ];
            function isCategoryType(value) {
                return services.CategoryTypeArray.indexOf(value) > -1;
            }
            services.isCategoryType = isCategoryType;
            services.BingEntities = {
                Continent: "Continent",
                Sovereign: "Sovereign",
                CountryRegion: "CountryRegion",
                AdminDivision1: "AdminDivision1",
                AdminDivision2: "AdminDivision2",
                PopulatedPlace: "PopulatedPlace",
                Postcode: "Postcode",
                Postcode1: "Postcode1",
                Neighborhood: "Neighborhood",
                Address: "Address",
            };
            // Static variables for caching, maps, etc
            var geocodeQueue;
            var activeRequests;
            var categoryToBingEntity;
            var categoryToBingEntityGeodata;
            var geocodingCache;
            var GeocodeQuery = (function () {
                function GeocodeQuery(query, category) {
                    this.query = query != null ? query : "";
                    this.category = category != null ? category : "";
                    this.key = (this.query + "/" + this.category).toLowerCase();
                    this.cacheHits = 0;
                    if (!geocodingCache) {
                        geocodingCache = services.createGeocodingCache(Settings.MaxCacheSize, Settings.MaxCacheSizeOverflow);
                    }
                }
                GeocodeQuery.prototype.incrementCacheHit = function () {
                    this.cacheHits++;
                };
                GeocodeQuery.prototype.getCacheHits = function () {
                    return this.cacheHits;
                };
                GeocodeQuery.prototype.getBingEntity = function () {
                    var category = this.category.toLowerCase();
                    if (!categoryToBingEntity) {
                        categoryToBingEntity = {};
                        categoryToBingEntity[CategoryTypes.Continent.toLowerCase()] = services.BingEntities.Continent;
                        categoryToBingEntity[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.Sovereign;
                        categoryToBingEntity[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
                        categoryToBingEntity[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
                        categoryToBingEntity[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
                        categoryToBingEntity[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode;
                        categoryToBingEntity[CategoryTypes.Address.toLowerCase()] = services.BingEntities.Address;
                    }
                    return categoryToBingEntity[category] || "";
                };
                GeocodeQuery.prototype.getUrl = function () {
                    var url = Settings.BingUrl + "key=" + Settings.BingKey;
                    var entityType = this.getBingEntity();
                    var queryAdded = false;
                    if (entityType) {
                        if (entityType === services.BingEntities.Postcode) {
                            url += "&includeEntityTypes=Postcode,Postcode1,Postcode2,Postcode3,Postcode4";
                        }
                        else if (this.query.indexOf(",") === -1 && (entityType === services.BingEntities.AdminDivision1 || entityType === services.BingEntities.AdminDivision2)) {
                            queryAdded = true;
                            try {
                                url += "&adminDistrict=" + decodeURIComponent(this.query);
                            }
                            catch (e) {
                                return null;
                            }
                        }
                        else {
                            url += "&includeEntityTypes=" + entityType;
                        }
                    }
                    if (!queryAdded) {
                        try {
                            url += "&q=" + decodeURIComponent(this.query);
                        }
                        catch (e) {
                            return null;
                        }
                    }
                    var cultureName = navigator.userLanguage || navigator["language"];
                    cultureName = mapLocalesForBing(cultureName);
                    if (cultureName) {
                        url += "&c=" + cultureName;
                    }
                    url += "&maxRes=20";
                    // If the query is of length 2, request the ISO 2-letter country code to be returned with the result to be compared against the query so that such results can be preferred.
                    if (this.query.length === 2 && this.category === CategoryTypes.CountryRegion) {
                        url += "&include=ciso2";
                    }
                    return url;
                };
                return GeocodeQuery;
            }());
            services.GeocodeQuery = GeocodeQuery;
            var GeocodeBoundaryQuery = (function (_super) {
                __extends(GeocodeBoundaryQuery, _super);
                function GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData) {
                    if (maxGeoData === void 0) { maxGeoData = 3; }
                    _super.call(this, [latitude, longitude, levelOfDetail, maxGeoData].join(","), category);
                    this.latitude = latitude;
                    this.longitude = longitude;
                    this.levelOfDetail = levelOfDetail;
                    this.maxGeoData = maxGeoData;
                }
                GeocodeBoundaryQuery.prototype.getBingEntity = function () {
                    var category = this.category.toLowerCase();
                    if (!categoryToBingEntityGeodata) {
                        categoryToBingEntityGeodata = {};
                        categoryToBingEntityGeodata[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.CountryRegion;
                        categoryToBingEntityGeodata[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
                        categoryToBingEntityGeodata[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
                        categoryToBingEntityGeodata[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
                        categoryToBingEntityGeodata[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode1;
                    }
                    return categoryToBingEntityGeodata[category] || "";
                };
                GeocodeBoundaryQuery.prototype.getUrl = function () {
                    var url = Settings.BingUrlGeodata + "key=" + Settings.BingKey + "&$format=json";
                    var entityType = this.getBingEntity();
                    if (!entityType) {
                        return null;
                    }
                    var cultureName = navigator.userLanguage || navigator["language"];
                    cultureName = mapLocalesForBing(cultureName);
                    var cultures = cultureName.split("-");
                    var data = [this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'"];
                    if (cultures.length > 1) {
                        data.push("'" + cultures[1] + "'");
                    }
                    return url + "&SpatialFilter=GetBoundary(" + data.join(", ") + ")";
                };
                return GeocodeBoundaryQuery;
            }(GeocodeQuery));
            services.GeocodeBoundaryQuery = GeocodeBoundaryQuery;
            /**
             * Map locales that cause failures to similar locales that work
             */
            function mapLocalesForBing(locale) {
                switch (locale.toLowerCase()) {
                    case 'fr':
                        return 'fr-FR';
                    default:
                        return locale;
                }
            }
            function geocodeCore(geocodeQuery) {
                var result = geocodingCache ? geocodingCache.getCoordinates(geocodeQuery) : undefined;
                var deferred = $.Deferred();
                if (result) {
                    deferred.resolve(result);
                }
                else {
                    geocodeQueue.push({ query: geocodeQuery, deferred: deferred });
                    dequeue();
                }
                return deferred;
            }
            services.geocodeCore = geocodeCore;
            function geocode(query, category) {
                if (category === void 0) { category = ""; }
                return geocodeCore(new GeocodeQuery(query, category));
            }
            services.geocode = geocode;
            function geocodeBoundary(latitude, longitude, category, levelOfDetail, maxGeoData) {
                if (category === void 0) { category = ""; }
                if (levelOfDetail === void 0) { levelOfDetail = 2; }
                if (maxGeoData === void 0) { maxGeoData = 3; }
                return geocodeCore(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData));
            }
            services.geocodeBoundary = geocodeBoundary;
            function dequeue(decrement) {
                if (decrement === void 0) { decrement = 0; }
                activeRequests -= decrement;
                while (activeRequests < Settings.MaxBingRequest) {
                    if (geocodeQueue.length === 0) {
                        break;
                    }
                    activeRequests++;
                    makeRequest(geocodeQueue.shift());
                }
            }
            function makeRequest(item) {
                // Check again if we already got the coordinate;
                var result = geocodingCache ? geocodingCache.getCoordinates(item.query) : undefined;
                if (result) {
                    setTimeout(function () { return dequeue(1); });
                    item.deferred.resolve(result);
                    return;
                }
                // Unfortunately the Bing service doesn't support CORS, only jsonp. This issue must be raised and revised.
                // VSTS: 1396088 - Tracking: Ask: Bing geocoding to support CORS
                var config = {
                    type: "GET",
                    dataType: "jsonp",
                    jsonp: "jsonp"
                };
                var url = item.query.getUrl();
                if (!url) {
                    completeRequest(item, new Error("Unsupported query. " + item.query.query));
                }
                services.BingAjaxCall(url, config).then(function (data) {
                    try {
                        if (item.query instanceof GeocodeBoundaryQuery) {
                            var result_1 = data;
                            if (result_1 && result_1.d && Array.isArray(result_1.d.results) && result_1.d.results.length > 0) {
                                var entity = result_1.d.results[0];
                                var primitives = entity.Primitives;
                                if (primitives && primitives.length > 0) {
                                    var coordinates = {
                                        latitude: item.query.latitude,
                                        longitude: item.query.longitude,
                                        locations: []
                                    };
                                    primitives.sort(function (a, b) {
                                        if (a.Shape.length < b.Shape.length) {
                                            return 1;
                                        }
                                        if (a.Shape.length > b.Shape.length) {
                                            return -1;
                                        }
                                        return 0;
                                    });
                                    var maxGeoData = Math.min(primitives.length, item.query.maxGeoData);
                                    for (var i = 0; i < maxGeoData; i++) {
                                        var ringStr = primitives[i].Shape;
                                        var ringArray = ringStr.split(",");
                                        for (var j = 1; j < ringArray.length; j++) {
                                            coordinates.locations.push({ nativeBing: ringArray[j] });
                                        }
                                    }
                                    completeRequest(item, null, coordinates);
                                }
                                else {
                                    completeRequest(item, new Error("Geocode result is empty."));
                                }
                            }
                            else {
                                completeRequest(item, new Error("Geocode result is empty."));
                            }
                        }
                        else {
                            var resources = data.resourceSets[0].resources;
                            if (Array.isArray(resources) && resources.length > 0) {
                                var index = getBestResultIndex(resources, item.query);
                                var pointData = resources[index].point.coordinates;
                                var coordinates = {
                                    latitude: parseFloat(pointData[0]),
                                    longitude: parseFloat(pointData[1])
                                };
                                completeRequest(item, null, coordinates);
                            }
                            else {
                                completeRequest(item, new Error("Geocode result is empty."));
                            }
                        }
                    }
                    catch (error) {
                        completeRequest(item, error);
                    }
                }, function (error) {
                    completeRequest(item, error);
                });
            }
            var dequeueTimeoutId;
            function completeRequest(item, error, coordinate) {
                if (coordinate === void 0) { coordinate = null; }
                dequeueTimeoutId = setTimeout(function () { return dequeue(1); }, Settings.UseDoubleArrayGeodataResult ? Settings.UseDoubleArrayDequeueTimeout : 0);
                if (error) {
                    item.deferred.reject(error);
                }
                else {
                    if (geocodingCache)
                        geocodingCache.registerCoordinates(item.query, coordinate);
                    item.deferred.resolve(coordinate);
                }
            }
            function getBestResultIndex(resources, query) {
                var queryString = query.query.toLowerCase();
                // If string is of length 2 and is a country, check against the ISO country code of results, prefering exact matches
                if (queryString.length === 2 && query.category === CategoryTypes.CountryRegion) {
                    for (var index = 0; index < resources.length; index++) {
                        var iso2 = resources[index].address && resources[index].address.countryRegionIso2;
                        if (iso2 && queryString === iso2.toLowerCase()) {
                            return index;
                        }
                    }
                }
                // Prefer results that match the targetEntity (geotagged category) on the query
                var targetEntity = query.getBingEntity().toLowerCase();
                for (var index = 0; index < resources.length; index++) {
                    var resultEntity = (resources[index].entityType || "").toLowerCase();
                    if (resultEntity === targetEntity) {
                        return index;
                    }
                }
                return 0;
            }
            function reset() {
                geocodeQueue = [];
                activeRequests = 0;
                categoryToBingEntity = null;
                clearTimeout(dequeueTimeoutId);
            }
            services.reset = reset;
            reset();
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                return new GeocodingCache(maxCacheSize, maxCacheSizeOverflow);
            }
            services.createGeocodingCache = createGeocodingCache;
            var GeocodingCache = (function () {
                function GeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                    this.geocodeCache = {};
                    this.maxCacheSize = maxCacheSize;
                    this.maxCacheSizeOverflow = maxCacheSizeOverflow;
                }
                /**
                 * Retrieves the coordinate for the key from the cache, returning undefined on a cache miss.
                 */
                GeocodingCache.prototype.getCoordinates = function (query) {
                    // Check in-memory cache
                    var pair = this.geocodeCache[query.key];
                    if (pair) {
                        pair.query.incrementCacheHit();
                        return pair.coordinate;
                    }
                    // Check local storage cache
                    pair = powerbi.localStorageService.getData(query.key);
                    if (pair) {
                        this.registerInMemory(query, pair.coordinate);
                        return pair.coordinate;
                    }
                    return undefined;
                };
                /**
                 * Registers the query and coordinate to the cache.
                 */
                GeocodingCache.prototype.registerCoordinates = function (query, coordinate) {
                    this.registerInMemory(query, coordinate);
                    this.registerInStorage(query, coordinate);
                };
                GeocodingCache.prototype.registerInMemory = function (query, coordinate) {
                    var geocodeCache = this.geocodeCache;
                    var keys = Object.keys(geocodeCache);
                    var cacheSize = keys.length;
                    var maxCacheSize = this.maxCacheSize;
                    if (keys.length > (maxCacheSize + this.maxCacheSizeOverflow)) {
                        var sortedKeys = keys.sort(function (a, b) {
                            var cachedA = geocodeCache[a];
                            var cachedB = geocodeCache[b];
                            var ca = cachedA ? cachedA.query.getCacheHits() : 0;
                            var cb = cachedB ? cachedB.query.getCacheHits() : 0;
                            return ca < cb ? -1 : (ca > cb ? 1 : 0);
                        });
                        for (var i = 0; i < (cacheSize - maxCacheSize); i++) {
                            geocodeCache[sortedKeys[i]] = undefined;
                        }
                    }
                    geocodeCache[query.key] = { query: query, coordinate: coordinate };
                };
                GeocodingCache.prototype.registerInStorage = function (query, coordinate) {
                    powerbi.localStorageService.setData(query.key, { query: query, coordinate: coordinate });
                };
                return GeocodingCache;
            }());
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            function createGeolocation() {
                return new GeolocationService();
            }
            services.createGeolocation = createGeolocation;
            /**
             * HTML5 Implementation of IGeolocation
             */
            var GeolocationService = (function () {
                function GeolocationService() {
                    this.webGeolocation = navigator.geolocation;
                }
                GeolocationService.prototype.watchPosition = function (successCallback, errorCallback) {
                    return this.webGeolocation.watchPosition(function (position) {
                        successCallback(position);
                    }, function (error) {
                        if (errorCallback != null) {
                            errorCallback(error);
                        }
                    });
                };
                GeolocationService.prototype.clearWatch = function (watchId) {
                    this.webGeolocation.clearWatch(watchId);
                };
                GeolocationService.prototype.getCurrentPosition = function (successCallback, errorCallback) {
                    this.webGeolocation.getCurrentPosition(function (position) {
                        successCallback(position);
                    }, function (error) {
                        if (errorCallback != null) {
                            errorCallback(error);
                        }
                    });
                };
                return GeolocationService;
            }());
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var unsupportedVisuals = ['play', 'subview', 'smallMultiple'];
        var visualPluginFactory;
        (function (visualPluginFactory) {
            var VisualPluginService = (function () {
                function VisualPluginService(featureSwitches) {
                    this.plugins = powerbi.visuals.plugins;
                    this.featureSwitches = featureSwitches;
                }
                /**
                 * Gets metadata for all registered.
                 */
                VisualPluginService.prototype.getVisuals = function () {
                    var registry = this.plugins, names = Object.keys(registry);
                    return names.map(function (name) { return registry[name]; });
                };
                VisualPluginService.prototype.getPlugin = function (type) {
                    if (!type) {
                        return;
                    }
                    var plugin = this.plugins[type];
                    if (!plugin) {
                        return;
                    }
                    return plugin;
                };
                VisualPluginService.prototype.capabilities = function (type) {
                    var plugin = this.getPlugin(type);
                    if (plugin)
                        return plugin.capabilities;
                };
                VisualPluginService.prototype.requireSandbox = function (plugin) {
                    return plugin && plugin.custom;
                };
                VisualPluginService.prototype.removeAnyCustomVisuals = function () {
                    var plugins = powerbi.visuals.plugins;
                    for (var key in plugins) {
                        var p = plugins[key];
                        if (p.custom) {
                            delete plugins[key];
                        }
                    }
                };
                VisualPluginService.prototype.isCustomVisual = function (visual) {
                    if (visual) {
                        if (this.plugins[visual]) {
                            return this.plugins[visual].custom === true;
                        }
                        else if (_.include(unsupportedVisuals, visual)) {
                            /*use the hardcoded unsupported visual list to distinguish unsupported visual with custom visual when the plugin object is not in memory*/
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    return false;
                };
                VisualPluginService.prototype.shouldDisableVisual = function (type, mapDisabled) {
                    return (type === visuals.plugins.map.name || type === visuals.plugins.filledMap.name) && mapDisabled;
                };
                VisualPluginService.prototype.isScriptVisualQueryable = function () {
                    // Feature switch determines if Script visuals are query visuals - currently non-query in PBI site
                    return (this.featureSwitches !== undefined && this.featureSwitches.scriptVisualEnabled);
                };
                VisualPluginService.prototype.getInteractivityOptions = function (visualType) {
                    var interactivityOptions = {
                        overflow: 'hidden',
                    };
                    return interactivityOptions;
                };
                return VisualPluginService;
            }());
            visualPluginFactory.VisualPluginService = VisualPluginService;
            function createPlugin(visualPlugins, base, create, modifyPluginFn) {
                var visualPlugin = powerbi.Prototype.inherit(base);
                visualPlugin.create = create;
                if (modifyPluginFn) {
                    modifyPluginFn(visualPlugin);
                }
                visualPlugins[base.name] = visualPlugin;
            }
            visualPluginFactory.createPlugin = createPlugin;
            function createDashboardPlugins(plugins, options, featureSwitches) {
                var tooltipsOnDashboard = options.tooltipsEnabled;
                var lineChartLabelDensityEnabled = featureSwitches && featureSwitches.lineChartLabelDensityEnabled;
                var tablixFormattingEnabled = featureSwitches ? featureSwitches.tablixFormattingEnabled : false;
                // Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.barChart, function () { return new visuals.CartesianChart({
                    chartType: 6 /* StackedBar */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Clustered Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                    chartType: 5 /* ClusteredBar */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Clustered Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 3 /* ClusteredColumn */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                    chartType: 4 /* StackedColumn */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Data Dot Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 15 /* DataDotClusteredColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Data Dot Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 16 /* DataDotStackedColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Donut Chart
                createPlugin(plugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Funnel Chart
                createPlugin(plugins, powerbi.visuals.plugins.funnel, function () { return new visuals.FunnelChart({
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Gauge
                createPlugin(plugins, powerbi.visuals.plugins.gauge, function () { return new visuals.Gauge({
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Hundred Percent Stacked Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                    chartType: 7 /* HundredPercentStackedBar */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Hundred Percent Stacked Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 8 /* HundredPercentStackedColumn */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Line Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                    chartType: 0 /* Line */,
                    tooltipsEnabled: tooltipsOnDashboard,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                    chartType: 1 /* Area */,
                    tooltipsEnabled: tooltipsOnDashboard,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Stacked Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.stackedAreaChart, function () { return new visuals.CartesianChart({
                    chartType: 2 /* StackedArea */,
                    tooltipsEnabled: tooltipsOnDashboard,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Line Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 13 /* LineClusteredColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Line Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 14 /* LineStackedColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Pie Chart
                createPlugin(plugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                    sliceWidthRatio: 0,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Scatter Chart
                createPlugin(plugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                    chartType: 9 /* Scatter */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Treemap
                createPlugin(plugins, powerbi.visuals.plugins.treemap, function () { return new visuals.Treemap({
                    isScrollable: false,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Waterfall Chart
                createPlugin(plugins, powerbi.visuals.plugins.waterfallChart, function () { return new visuals.CartesianChart({
                    chartType: 12 /* Waterfall */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Map
                createPlugin(plugins, powerbi.visuals.plugins.map, function () { return new visuals.Map({
                    tooltipsEnabled: tooltipsOnDashboard,
                    disableZooming: true,
                    disablePanning: true,
                }); });
                // Filled Map
                createPlugin(plugins, powerbi.visuals.plugins.filledMap, function () { return new visuals.Map({
                    filledMap: true,
                    tooltipsEnabled: tooltipsOnDashboard,
                    disableZooming: true,
                    disablePanning: true,
                }); });
                // Matrix
                createPlugin(plugins, powerbi.visuals.plugins.matrix, function () { return new visuals.Matrix({
                    isFormattingPropertiesEnabled: tablixFormattingEnabled
                }); });
                // Table
                createPlugin(plugins, powerbi.visuals.plugins.table, function () { return new visuals.Table({
                    isFormattingPropertiesEnabled: tablixFormattingEnabled,
                    isConditionalFormattingEnabled: false,
                }); });
            }
            function createMinervaPlugins(plugins, featureSwitches) {
                var scriptVisualEnabled = featureSwitches ? featureSwitches.scriptVisualEnabled : false;
                var scriptVisualAuthoringEnabled = featureSwitches ? featureSwitches.scriptVisualAuthoringEnabled : false;
                var isLabelInteractivityEnabled = featureSwitches ? featureSwitches.isLabelInteractivityEnabled : false;
                var tablixFormattingEnabled = featureSwitches ? featureSwitches.tablixFormattingEnabled : false;
                var conditionalFormattingEnabled = featureSwitches ? featureSwitches.conditionalFormattingEnabled : false;
                var fillMapDataLabelsEnabled = featureSwitches ? featureSwitches.filledMapDataLabelsEnabled : false;
                var lineChartLabelDensityEnabled = featureSwitches ? featureSwitches.lineChartLabelDensityEnabled : false;
                // Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.barChart, function () { return new visuals.CartesianChart({
                    chartType: 6 /* StackedBar */,
                    isScrollable: true, animator: new visuals.WebColumnChartAnimator(),
                    tooltipsEnabled: true,
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Card
                createPlugin(plugins, powerbi.visuals.plugins.card, function () { return new visuals.Card({
                    isScrollable: true,
                    animator: new visuals.BaseAnimator(),
                }); });
                // Clustered Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                    chartType: 5 /* ClusteredBar */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Clustered Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 3 /* ClusteredColumn */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                    chartType: 4 /* StackedColumn */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Data Dot Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 15 /* DataDotClusteredColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.DataDotChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Data Dot Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 16 /* DataDotStackedColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.DataDotChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Donut Chart
                createPlugin(plugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                    animator: new visuals.WebDonutChartAnimator(),
                    isScrollable: true,
                    tooltipsEnabled: true,
                    behavior: new visuals.DonutChartWebBehavior(),
                }); });
                // Funnel Chart
                createPlugin(plugins, powerbi.visuals.plugins.funnel, function () { return new visuals.FunnelChart({
                    animator: new visuals.WebFunnelAnimator(),
                    behavior: new visuals.FunnelWebBehavior(),
                    tooltipsEnabled: true,
                }); });
                // Gauge
                createPlugin(plugins, powerbi.visuals.plugins.gauge, function () { return new visuals.Gauge({
                    animator: new visuals.BaseAnimator(),
                    tooltipsEnabled: true,
                }); });
                // Hundred Percent Stacked Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                    chartType: 7 /* HundredPercentStackedBar */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Hundred Percent Stacked Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 8 /* HundredPercentStackedColumn */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Line Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                    chartType: 0 /* Line */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                    chartType: 1 /* Area */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Stacked Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.stackedAreaChart, function () { return new visuals.CartesianChart({
                    chartType: 2 /* StackedArea */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.LineChartWebBehavior()]),
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Line Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 13 /* LineClusteredColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Line Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 14 /* LineStackedColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Pie Chart
                createPlugin(plugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                    sliceWidthRatio: 0,
                    animator: new visuals.WebDonutChartAnimator(),
                    isScrollable: true,
                    tooltipsEnabled: true,
                    behavior: new visuals.DonutChartWebBehavior(),
                }); });
                // Scatter Chart
                createPlugin(plugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                    chartType: 9 /* Scatter */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ScatterChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Treemap
                createPlugin(plugins, powerbi.visuals.plugins.treemap, function () { return new visuals.Treemap({
                    animator: new visuals.WebTreemapAnimator,
                    isScrollable: true,
                    behavior: new visuals.TreemapWebBehavior(),
                    tooltipsEnabled: true,
                }); });
                // Waterfall Chart
                createPlugin(plugins, powerbi.visuals.plugins.waterfallChart, function () { return new visuals.CartesianChart({
                    chartType: 12 /* Waterfall */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    behavior: new visuals.CartesianChartBehavior([new visuals.WaterfallChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    trendLinesEnabled: featureSwitches.trendLinesEnabled,
                }); });
                // Map
                createPlugin(plugins, powerbi.visuals.plugins.map, function () { return new visuals.Map({
                    behavior: new visuals.MapBehavior(),
                    tooltipsEnabled: true,
                    isLegendScrollable: true,
                }); });
                // Filled Map
                createPlugin(plugins, powerbi.visuals.plugins.filledMap, function () { return new visuals.Map({
                    filledMap: true,
                    behavior: new visuals.MapBehavior,
                    tooltipsEnabled: true,
                    filledMapDataLabelsEnabled: fillMapDataLabelsEnabled,
                    isLegendScrollable: true,
                }); });
                // Slicer
                createPlugin(plugins, powerbi.visuals.plugins.slicer, function () { return new visuals.Slicer({
                    behavior: new visuals.SlicerWebBehavior(),
                }); });
                // Matrix
                createPlugin(plugins, powerbi.visuals.plugins.matrix, function () { return new visuals.Matrix({
                    isFormattingPropertiesEnabled: tablixFormattingEnabled
                }); });
                // Table
                createPlugin(plugins, powerbi.visuals.plugins.table, function () { return new visuals.Table({
                    isFormattingPropertiesEnabled: tablixFormattingEnabled,
                    isConditionalFormattingEnabled: conditionalFormattingEnabled,
                }); });
                ;
                if (scriptVisualEnabled && scriptVisualAuthoringEnabled) {
                    // R visual
                    createPlugin(plugins, powerbi.visuals.plugins.scriptVisual, function () { return new visuals.ScriptVisual({ canRefresh: true }); });
                }
            }
            var MinervaVisualPluginService = (function (_super) {
                __extends(MinervaVisualPluginService, _super);
                function MinervaVisualPluginService(featureSwitches) {
                    _super.call(this, featureSwitches);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.visualPlugins = {};
                    this.addCustomVisualizations([]);
                    createMinervaPlugins(this.visualPlugins, this.featureSwitches);
                }
                MinervaVisualPluginService.prototype.getVisuals = function () {
                    // Current visual types that supports visual conversion. Please don't change the orders
                    // CAUTION: If you are adding new visual types, please check if you need to update the height of
                    // the visual convertion pane in visualization pane as well.
                    var convertibleVisualTypes = [
                        powerbi.visuals.plugins.barChart,
                        powerbi.visuals.plugins.columnChart,
                        powerbi.visuals.plugins.clusteredBarChart,
                        powerbi.visuals.plugins.clusteredColumnChart,
                        powerbi.visuals.plugins.hundredPercentStackedBarChart,
                        powerbi.visuals.plugins.hundredPercentStackedColumnChart,
                        powerbi.visuals.plugins.lineChart,
                        powerbi.visuals.plugins.areaChart,
                        powerbi.visuals.plugins.stackedAreaChart,
                        powerbi.visuals.plugins.lineStackedColumnComboChart,
                        powerbi.visuals.plugins.lineClusteredColumnComboChart,
                        powerbi.visuals.plugins.waterfallChart,
                        powerbi.visuals.plugins.scatterChart,
                        powerbi.visuals.plugins.pieChart,
                        powerbi.visuals.plugins.treemap,
                        powerbi.visuals.plugins.map,
                        powerbi.visuals.plugins.table,
                        powerbi.visuals.plugins.matrix,
                        powerbi.visuals.plugins.filledMap,
                        powerbi.visuals.plugins.funnel,
                        powerbi.visuals.plugins.gauge,
                        powerbi.visuals.plugins.multiRowCard,
                        powerbi.visuals.plugins.card,
                        powerbi.visuals.plugins.kpi,
                        powerbi.visuals.plugins.slicer,
                        powerbi.visuals.plugins.donutChart
                    ];
                    if (this.featureSwitches.scriptVisualEnabled && this.featureSwitches.scriptVisualAuthoringEnabled) {
                        convertibleVisualTypes.push(powerbi.visuals.plugins.scriptVisual);
                    }
                    // Add any visuals compiled in the developer tools
                    // Additionally add custom visuals.
                    for (var p in visuals.plugins) {
                        var plugin = visuals.plugins[p];
                        if (plugin.custom) {
                            this.pushPluginIntoConvertibleTypes(convertibleVisualTypes, plugin);
                        }
                    }
                    this.addCustomVisualizations(convertibleVisualTypes);
                    if (this.featureSwitches.dataDotChartEnabled) {
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotClusteredColumnComboChart);
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotStackedColumnComboChart);
                    }
                    return convertibleVisualTypes;
                };
                MinervaVisualPluginService.prototype.pushPluginIntoConvertibleTypes = function (convertibleVisualTypes, plugin) {
                    if (!convertibleVisualTypes.some(function (pl) { return pl.name === plugin.name; })) {
                        convertibleVisualTypes.push(plugin);
                    }
                };
                MinervaVisualPluginService.prototype.addCustomVisualizations = function (convertibleVisualTypes) {
                    // Read new visual from localstorage
                    var customVisualizationDict = powerbi.localStorageService.getData('customVisualMetaData');
                    for (var visualName in customVisualizationDict) {
                        var customVisualMetaData = customVisualizationDict[visualName];
                        if (!customVisualMetaData) {
                            continue;
                        }
                        var pluginName = customVisualMetaData.pluginName;
                        // Uncompiled new visuals should not be loaded into the report
                        if (!pluginName || !customVisualMetaData.sourceCode || !customVisualMetaData.sourceCode.javascriptCode) {
                            continue;
                        }
                        var plugin = this.getPlugin(pluginName);
                        // If the browser session got restarted or its a new window the plugin wont be available, so we need to add it
                        if (!plugin) {
                            var jsCode = customVisualMetaData.sourceCode.javascriptCode;
                            var script = $("<script/>", {
                                html: jsCode + '//# sourceURL=' + pluginName + '.js\n' + '//# sourceMappingURL=' + pluginName + '.js.map'
                            });
                            script.attr('pluginName', pluginName);
                            $('body').append(script);
                            var style = $("<style/>", {
                                html: customVisualMetaData.sourceCode.cssCode
                            });
                            style.attr('pluginName', pluginName);
                            $('head').append(style);
                            plugin = this.getPlugin(pluginName);
                            if (!plugin) {
                                continue;
                            }
                        }
                        this.pushPluginIntoConvertibleTypes(convertibleVisualTypes, plugin);
                    }
                };
                MinervaVisualPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type])
                        return this.visualPlugins[type];
                    return _super.prototype.getPlugin.call(this, type);
                };
                MinervaVisualPluginService.prototype.requireSandbox = function (plugin) {
                    return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                };
                return MinervaVisualPluginService;
            }(VisualPluginService));
            visualPluginFactory.MinervaVisualPluginService = MinervaVisualPluginService;
            var PlaygroundVisualPluginService = (function (_super) {
                __extends(PlaygroundVisualPluginService, _super);
                function PlaygroundVisualPluginService() {
                    _super.call(this, undefined);
                    this.visualPlugins = powerbi.visuals.plugins;
                    createMinervaPlugins(this.visualPlugins, {});
                }
                PlaygroundVisualPluginService.prototype.getVisuals = function () {
                    var registry = this.visualPlugins, names = Object.keys(registry);
                    return names.map(function (name) { return registry[name]; });
                };
                PlaygroundVisualPluginService.prototype.getPlugin = function (type) {
                    if (!type) {
                        return;
                    }
                    var plugin = this.visualPlugins[type];
                    if (!plugin) {
                        return;
                    }
                    return plugin;
                };
                PlaygroundVisualPluginService.prototype.capabilities = function (type) {
                    var plugin = this.getPlugin(type);
                    if (plugin) {
                        return plugin.capabilities;
                    }
                };
                return PlaygroundVisualPluginService;
            }(VisualPluginService));
            visualPluginFactory.PlaygroundVisualPluginService = PlaygroundVisualPluginService;
            /**
             * This plug-in service is used when displaying visuals on the dashboard.
             */
            var DashboardPluginService = (function (_super) {
                __extends(DashboardPluginService, _super);
                function DashboardPluginService(featureSwitches, options) {
                    _super.call(this, featureSwitches);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.visualPlugins = {};
                    createDashboardPlugins(this.visualPlugins, options, this.featureSwitches);
                }
                DashboardPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                DashboardPluginService.prototype.requireSandbox = function (plugin) {
                    return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                };
                return DashboardPluginService;
            }(VisualPluginService));
            visualPluginFactory.DashboardPluginService = DashboardPluginService;
            // This plug-in service is used when displaying visuals for insights.
            var InsightsPluginService = (function (_super) {
                __extends(InsightsPluginService, _super);
                function InsightsPluginService(featureSwitches) {
                    _super.call(this, featureSwitches);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.visualPlugins = {};
                    // Clustered Bar Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                        chartType: 5 /* ClusteredBar */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Column Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                        chartType: 4 /* StackedColumn */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Donut Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                        animator: new visuals.WebDonutChartAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Hundred Percent Stacked Bar Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                        chartType: 7 /* HundredPercentStackedBar */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Hundred Percent Stacked Column Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                        chartType: 8 /* HundredPercentStackedColumn */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Line Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                        chartType: 0 /* Line */,
                        animator: new visuals.BaseAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Area Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                        chartType: 1 /* Area */,
                        animator: new visuals.BaseAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Pie Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                        sliceWidthRatio: 0,
                        animator: new visuals.WebDonutChartAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Scatter Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                        chartType: 9 /* Scatter */,
                        animator: new visuals.BaseAnimator(),
                        tooltipsEnabled: true,
                    }); }, undefined);
                }
                InsightsPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                InsightsPluginService.prototype.requireSandbox = function (plugin) {
                    return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                };
                return InsightsPluginService;
            }(VisualPluginService));
            visualPluginFactory.InsightsPluginService = InsightsPluginService;
            var MobileVisualPluginService = (function (_super) {
                __extends(MobileVisualPluginService, _super);
                function MobileVisualPluginService(smallViewPortProperties, featureSwitches) {
                    var _this = this;
                    _super.call(this, featureSwitches);
                    this.smallViewPortProperties = smallViewPortProperties || {
                        CartesianSmallViewPortProperties: {
                            hideAxesOnSmallViewPort: true,
                            hideLegendOnSmallViewPort: true,
                            MinHeightLegendVisible: MobileVisualPluginService.MinHeightLegendVisible,
                            MinHeightAxesVisible: MobileVisualPluginService.MinHeightAxesVisible,
                        },
                        GaugeSmallViewPortProperties: {
                            hideGaugeSideNumbersOnSmallViewPort: true,
                            smallGaugeMarginsOnSmallViewPort: true,
                            MinHeightGaugeSideNumbersVisible: MobileVisualPluginService.MinHeightGaugeSideNumbersVisible,
                            GaugeMarginsOnSmallViewPort: MobileVisualPluginService.GaugeMarginsOnSmallViewPort,
                        },
                        FunnelSmallViewPortProperties: {
                            hideFunnelCategoryLabelsOnSmallViewPort: true,
                            minHeightFunnelCategoryLabelsVisible: MobileVisualPluginService.MinHeightFunnelCategoryLabelsVisible,
                        },
                        DonutSmallViewPortProperties: {
                            maxHeightToScaleDonutLegend: MobileVisualPluginService.MaxHeightToScaleDonutLegend,
                        },
                    };
                    // Disable tooltips for mobile
                    visuals.TooltipManager.ShowTooltips = false;
                    // Don't trim overflow data on mobile
                    var trimOrdinalDataOnOverflow = false;
                    var mapThrottleInterval = this.getMapThrottleInterval();
                    this.visualPlugins = {};
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                        chartType: 1 /* Area */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.barChart, function () { return new visuals.CartesianChart({
                        chartType: 6 /* StackedBar */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                        chartType: 5 /* ClusteredBar */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredColumnChart, function () { return new visuals.CartesianChart({
                        chartType: 3 /* ClusteredColumn */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                        chartType: 4 /* StackedColumn */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.comboChart, function () { return new visuals.CartesianChart({
                        chartType: 10 /* ComboChart */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotChart, function () { return new visuals.CartesianChart({
                        chartType: 11 /* DataDot */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 15 /* DataDotClusteredColumnCombo */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 16 /* DataDotStackedColumnCombo */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                        chartType: 7 /* HundredPercentStackedBar */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                        chartType: 8 /* HundredPercentStackedColumn */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.stackedAreaChart, function () { return new visuals.CartesianChart({
                        chartType: 2 /* StackedArea */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.waterfallChart, function () { return new visuals.CartesianChart({
                        chartType: 12 /* Waterfall */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                        chartType: 0 /* Line */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 13 /* LineClusteredColumnCombo */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 14 /* LineStackedColumnCombo */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                        chartType: 9 /* Scatter */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        behavior: new visuals.CartesianChartBehavior([new visuals.ScatterChartMobileBehavior()])
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.gauge, function () { return new visuals.Gauge({
                        gaugeSmallViewPortProperties: _this.smallViewPortProperties.GaugeSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.funnel, function () { return new visuals.FunnelChart({
                        animator: null,
                        funnelSmallViewPortProperties: _this.smallViewPortProperties.FunnelSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                        disableGeometricCulling: true,
                        smallViewPortProperties: _this.smallViewPortProperties.DonutSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                        sliceWidthRatio: 0,
                        disableGeometricCulling: true,
                        smallViewPortProperties: _this.smallViewPortProperties.DonutSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.matrix, function () { return new visuals.Matrix({
                        isTouchEnabled: true,
                        isFormattingPropertiesEnabled: featureSwitches ? featureSwitches.tablixFormattingEnabled : false
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.table, function () { return new visuals.Table({
                        isTouchEnabled: true,
                        isFormattingPropertiesEnabled: featureSwitches ? featureSwitches.tablixFormattingEnabled : false
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.map, function () { return new visuals.Map({
                        viewChangeThrottleInterval: mapThrottleInterval,
                        enableCurrentLocation: featureSwitches ? featureSwitches.mapCurrentLocationEnabled : false
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.filledMap, function () { return new visuals.Map({
                        filledMap: true,
                        viewChangeThrottleInterval: mapThrottleInterval
                    }); });
                }
                MobileVisualPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type])
                        return this.visualPlugins[type];
                    return _super.prototype.getPlugin.call(this, type);
                };
                MobileVisualPluginService.prototype.requireSandbox = function (plugin) {
                    if (this.featureSwitches)
                        return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                    else
                        return _super.prototype.requireSandbox.call(this, plugin);
                };
                // Windows phone webView chokes when zooming on heavy maps,
                // this is a workaround to allow a relatively smooth pinch to zoom experience.
                MobileVisualPluginService.prototype.getMapThrottleInterval = function () {
                    var windowsPhoneThrottleInterval = 100;
                    var userAgentLowerCase = navigator.userAgent.toLowerCase();
                    if (userAgentLowerCase.indexOf('windows phone') !== -1) {
                        return windowsPhoneThrottleInterval;
                    }
                    return undefined;
                };
                MobileVisualPluginService.prototype.getInteractivityOptions = function (visualType) {
                    var mobileOptions = {
                        overflow: this.getMobileOverflowString(visualType),
                        isInteractiveLegend: this.isChartSupportInteractivity(visualType),
                        selection: true,
                    };
                    return mobileOptions;
                };
                MobileVisualPluginService.prototype.getMobileOverflowString = function (visualType) {
                    switch (visualType) {
                        case 'multiRowCard':
                            return 'visible';
                        default:
                            return 'hidden';
                    }
                };
                MobileVisualPluginService.prototype.isChartSupportInteractivity = function (visualType) {
                    switch (visualType) {
                        case 'areaChart':
                        case 'barChart':
                        case 'clusteredBarChart':
                        case 'clusteredColumnChart':
                        case 'columnChart':
                        case 'donutChart':
                        case 'hundredPercentStackedBarChart':
                        case 'hundredPercentStackedColumnChart':
                        case 'lineChart':
                        case 'pieChart':
                        case 'scatterChart':
                        case 'table':
                        case 'matrix':
                        case 'multiRowCard':
                            return true;
                        default:
                            return false;
                    }
                };
                MobileVisualPluginService.MinHeightLegendVisible = 125;
                MobileVisualPluginService.MinHeightAxesVisible = 125;
                MobileVisualPluginService.MinHeightGaugeSideNumbersVisible = 80;
                MobileVisualPluginService.GaugeMarginsOnSmallViewPort = 10;
                MobileVisualPluginService.MinHeightFunnelCategoryLabelsVisible = 80;
                MobileVisualPluginService.MaxHeightToScaleDonutLegend = 300;
                return MobileVisualPluginService;
            }(VisualPluginService));
            visualPluginFactory.MobileVisualPluginService = MobileVisualPluginService;
            // this function is called by tests
            function create() {
                return new VisualPluginService(undefined);
            }
            visualPluginFactory.create = create;
            function createVisualPluginService(featureSwitch) {
                return new VisualPluginService(featureSwitch);
            }
            visualPluginFactory.createVisualPluginService = createVisualPluginService;
            function createMinerva(featureSwitches) {
                return new MinervaVisualPluginService(featureSwitches);
            }
            visualPluginFactory.createMinerva = createMinerva;
            function createDashboard(featureSwitches, options) {
                return new DashboardPluginService(featureSwitches, options);
            }
            visualPluginFactory.createDashboard = createDashboard;
            function createInsights(featureSwitches) {
                return new InsightsPluginService(featureSwitches);
            }
            visualPluginFactory.createInsights = createInsights;
            function createMobile(smallViewPortProperties, featureSwitches) {
                return new MobileVisualPluginService(smallViewPortProperties, featureSwitches);
            }
            visualPluginFactory.createMobile = createMobile;
        })(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var UNSELECTABLE_CLASS_NAME = "unselectable";
            function fire(eventHandlers, eventArgs) {
                if (eventHandlers) {
                    for (var i = 0; i < eventHandlers.length; i++) {
                        var h = eventHandlers[i];
                        h(eventArgs);
                    }
                }
            }
            controls.fire = fire;
            var ScrollbarButton = (function () {
                // Constructor
                function ScrollbarButton(owner, direction) {
                    this._owner = owner;
                    this._direction = direction;
                    this._timerHandle = undefined;
                    this.createView();
                    var that = this;
                    this._element.addEventListener("mousedown", function (e) { that.onMouseDown(e); });
                    $(this._element).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._svg).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Object.defineProperty(ScrollbarButton.prototype, "element", {
                    // Properties
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                // Methods
                ScrollbarButton.prototype.createView = function () {
                    var svgns = "http://www.w3.org/2000/svg";
                    this._polygon = document.createElementNS(svgns, "polygon");
                    this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8");
                    this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR);
                    this._svg = document.createElementNS(svgns, "svg");
                    var svgStyle = this._svg.style;
                    svgStyle.position = "absolute";
                    svgStyle.left = "0px";
                    svgStyle.top = "0px";
                    this._svg.appendChild(this._polygon);
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.arrowClassName;
                    this._element.appendChild(this._svg);
                    this._owner.element.appendChild(this._element);
                };
                ScrollbarButton.prototype.onMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._mouseUpWrapper) {
                        event.cancelBubble = true;
                        var that_1 = this;
                        this._mouseUpWrapper = function (event) { that_1.onMouseUp(event); };
                        Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
                    }
                    this._owner._scrollSmallIncrement(this._direction);
                    this._owner.refresh();
                    this._timerHandle = setTimeout(function () { that.onMouseDown(event); }, 100);
                    if (event.preventDefault) {
                        event.preventDefault(); // prevent dragging
                    }
                };
                ScrollbarButton.prototype.onMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper);
                    this._mouseUpWrapper = undefined;
                };
                ScrollbarButton.prototype.arrange = function (width, height, angle) {
                    var size = Math.min(width, height);
                    var scale = size / 16;
                    var x = (width - size) / 2;
                    var y = (height - size) / 2;
                    this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)");
                    this._svg.setAttributeNS(null, "width", width + "px");
                    this._svg.setAttributeNS(null, "height", height + "px");
                    controls.HTMLElementUtils.setElementWidth(this._element, width);
                    controls.HTMLElementUtils.setElementHeight(this._element, height);
                };
                // Const
                // TODO: Move to style
                ScrollbarButton.MIN_WIDTH = 26;
                ScrollbarButton.ARROW_COLOR = "#404040";
                return ScrollbarButton;
            }());
            controls.ScrollbarButton = ScrollbarButton;
            /** Scrollbar base class */
            var Scrollbar = (function () {
                function Scrollbar(parentElement, layoutKind) {
                    this.MIN_BAR_SIZE = 10;
                    this.min = 0;
                    this.max = 10;
                    this.viewMin = 0;
                    this.viewSize = 2;
                    this.smallIncrement = 1;
                    this._onscroll = [];
                    this._screenToOffsetScale = 1.0;
                    this.createView(parentElement, layoutKind);
                    var that = this;
                    this._element.addEventListener("mousedown", function (e) { that.onBackgroundMouseDown(e); });
                    this._middleBar.addEventListener("mousedown", function (e) { that.onMiddleBarMouseDown(e); });
                    this._timerHandle = undefined;
                    this._visible = true;
                    this.element["winControl"] = this;
                    $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Scrollbar.prototype.scrollBy = function (delta) {
                    this.scrollTo(this.viewMin + delta);
                };
                Scrollbar.prototype.scrollUp = function () {
                    this.scrollBy(-this.smallIncrement);
                };
                Scrollbar.prototype.scrollDown = function () {
                    this.scrollBy(this.smallIncrement);
                };
                Scrollbar.prototype.scrollPageUp = function () {
                    this.scrollBy(-this.viewSize);
                };
                Scrollbar.prototype.scrollPageDown = function () {
                    this.scrollBy(this.viewSize);
                };
                Object.defineProperty(Scrollbar.prototype, "width", {
                    get: function () {
                        return this._width;
                    },
                    set: function (value) {
                        this._width = value;
                        this._element.style.width = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "height", {
                    get: function () {
                        return this._height;
                    },
                    set: function (value) {
                        this._height = value;
                        this._element.style.height = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.refresh = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar.refresh()");
                };
                Object.defineProperty(Scrollbar.prototype, "element", {
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "maxButton", {
                    get: function () {
                        return this._maxButton;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "middleBar", {
                    get: function () {
                        return this._middleBar;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype._scrollSmallIncrement = function (direction) {
                    this.scrollBy(this.smallIncrement * direction);
                };
                Object.defineProperty(Scrollbar.prototype, "visible", {
                    get: function () {
                        return this._visible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
                    get: function () {
                        return this._timerHandle !== undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.show = function (value) {
                    this._visible = value;
                    this.element.style.visibility = value ? "visible" : "hidden";
                    this.invalidateArrange();
                };
                Scrollbar.prototype._getMouseOffset = function (event) {
                    if (event.offsetX !== undefined)
                        return { x: event.offsetX, y: event.offsetY };
                    if (event.layerX !== undefined)
                        return { x: event.layerX, y: event.layerY };
                    return { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype._getOffsetXDelta = function (event) {
                    return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetYDelta = function (event) {
                    return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetXTouchDelta = function (event) {
                    return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
                };
                Scrollbar.prototype._getOffsetYTouchDelta = function (event) {
                    return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
                };
                Scrollbar.prototype.initTouch = function (panel, allowMouseDrag) {
                    var _this = this;
                    this._touchPanel = panel;
                    this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                    if ("ontouchmove" in panel) {
                        panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
                        panel.addEventListener("touchmove", function (e) { return _this.onTouchMove(e); });
                        panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
                    }
                    else {
                        panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
                        panel.addEventListener("mousemove", function (e) { return _this.onTouchMouseMove(e); });
                        panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
                    }
                };
                Scrollbar.prototype.onTouchStart = function (e) {
                    if (e.touches.length === 1) {
                        this.onTouchMouseDown(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchMove = function (e) {
                    if (e.touches.length === 1) {
                        if (e.preventDefault)
                            e.preventDefault();
                        this.onTouchMouseMove(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchEnd = function (e) {
                    this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
                };
                Scrollbar.prototype.onTouchMouseDown = function (e) {
                    // except IE touch cancels mouse so not need for detection. For IE touch and mouse difference is detected by a flag.
                    if (!this._allowMouseDrag &&
                        e["pointerType"] === MSPointerEvent.MSPOINTER_TYPE_MOUSE) {
                        return;
                    }
                    if ("setCapture" in this._touchPanel) {
                        this._touchPanel.setCapture(true);
                    }
                    this._offsetTouchPrevPos = this._offsetTouchStartPos = null;
                    this._touchStarted = true;
                };
                Scrollbar.prototype._getOffsetTouchDelta = function (e) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetTouchDelta()");
                    return null;
                };
                Scrollbar.prototype.onTouchMouseMove = function (e) {
                    if (this._touchStarted) {
                        if (!this._offsetTouchStartPos) {
                            this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e);
                        }
                        var delta = this._getOffsetTouchDelta(e);
                        if (delta !== 0) {
                            this.scrollBy(-delta / this._getRunningSize(false) * this.viewSize);
                            this._offsetTouchPrevPos = this._getMouseOffset(e);
                        }
                        if (e.preventDefault)
                            e.preventDefault();
                        e.cancelBubble = true;
                    }
                };
                Scrollbar.prototype.onTouchMouseUp = function (e, bubble) {
                    if (this._touchStarted) {
                        if (this._offsetTouchStartPos) {
                            var end = this._getMouseOffset(e);
                            if (!bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3)) {
                                if (e.preventDefault)
                                    e.preventDefault();
                                e.cancelBubble = true;
                            }
                        }
                    }
                    if ("releaseCapture" in this._touchPanel) {
                        this._touchPanel.releaseCapture();
                    }
                    this._touchStarted = false;
                };
                Scrollbar.prototype.registerElementForMouseWheelScrolling = function (element) {
                    var _this = this;
                    element.addEventListener("mousewheel", function (e) { _this.onMouseWheel(e); });
                    element.addEventListener("DOMMouseScroll", function (e) { _this.onFireFoxMouseWheel(e); });
                };
                Scrollbar.prototype.createView = function (parentElement, layoutKind) {
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.className;
                    this._element.setAttribute("drag-resize-disabled", "true");
                    if (layoutKind === 0 /* Canvas */)
                        parentElement.appendChild(this._element);
                    this._minButton = new ScrollbarButton(this, -1);
                    this._maxButton = new ScrollbarButton(this, 1);
                    this._middleBar = document.createElement("div");
                    this._middleBar.className = Scrollbar.barClassName;
                    this._element.appendChild(this._middleBar);
                };
                Scrollbar.prototype.scrollTo = function (pos) {
                    var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
                    if (viewMin !== this.viewMin) {
                        this.viewMin = viewMin;
                        fire(this._onscroll, null);
                    }
                };
                Scrollbar.prototype._scrollByPage = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._scrollByPage()");
                };
                Scrollbar.prototype._getRunningSize = function (net) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getRunningSize()");
                    return null;
                };
                Scrollbar.prototype._getOffsetDelta = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetDelta()");
                    return null;
                };
                Scrollbar.prototype.scroll = function (event) {
                    var delta = this._getOffsetDelta(event) / this._getRunningSize(true) * (this.max - this.min);
                    if (delta < 0) {
                        if (this._getScreenMousePos(event) >= this._screenMaxMousePos) {
                            return;
                        }
                    }
                    else if (delta > 0) {
                        if (this._getScreenMousePos(event) <= this._screenMinMousePos) {
                            return;
                        }
                    }
                    this.scrollBy(delta);
                };
                Object.defineProperty(Scrollbar.prototype, "actualWidth", {
                    get: function () {
                        if (this._actualWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualHeight", {
                    get: function () {
                        if (!this._actualHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
                    get: function () {
                        if (!this._actualButtonWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
                    get: function () {
                        if (!this._actualButtonHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.arrange = function () {
                    if (!this._actualWidth) {
                        this._actualWidth = this._element.offsetWidth;
                        this._actualHeight = this._element.offsetHeight;
                        this._actualButtonWidth = this._calculateButtonWidth();
                        this._actualButtonHeight = this._calculateButtonHeight();
                        this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle());
                        this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle());
                        this._setMaxButtonPosition();
                    }
                };
                Scrollbar.prototype._calculateButtonWidth = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonWidth()");
                    return null;
                };
                Scrollbar.prototype._calculateButtonHeight = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonHeight()");
                    return null;
                };
                Scrollbar.prototype._getMinButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMinButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._getMaxButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMaxButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._setMaxButtonPosition = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._setMaxButtonPosition()");
                };
                Scrollbar.prototype.invalidateArrange = function () {
                    this._actualWidth = undefined;
                    this._actualHeight = undefined;
                    this._actualButtonWidth = undefined;
                    this._actualButtonHeight = undefined;
                };
                Scrollbar.prototype.onHoldBackgroundMouseDown = function (event) {
                    var _this = this;
                    var holdDelay = this._timerHandle ?
                        Scrollbar.ScrollbarBackgroundMousedownHoldDelay :
                        Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
                    this._timerHandle = setTimeout(function () {
                        _this.onBackgroundMouseDown(event);
                    }, holdDelay);
                };
                Scrollbar.prototype.onBackgroundMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._backgroundMouseUpWrapper) {
                        event.cancelBubble = true;
                        this._backgroundMouseUpWrapper = function (event) { that.onBackgroundMouseUp(event); };
                        Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    }
                    this._scrollByPage(event);
                    this.refresh();
                    this.onHoldBackgroundMouseDown(event);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onBackgroundMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    this._timerHandle = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    this._backgroundMouseUpWrapper = undefined;
                };
                Scrollbar.prototype.getPinchZoomY = function () {
                    return document.documentElement.clientHeight / window.innerHeight;
                };
                Scrollbar.prototype.onMiddleBarMouseDown = function (event) {
                    event.cancelBubble = true;
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                    this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element));
                    this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar));
                    this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
                    var that = this;
                    this._middleBarMouseMoveWrapper = function (e) { that.onMiddleBarMouseMove(e); };
                    Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseUpWrapper = function (e) { that.onMiddleBarMouseUp(e); };
                    Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onMiddleBarMouseMove = function (event) {
                    if (!this._screenPrevMousePos) {
                        return;
                    }
                    this.scroll(event);
                    this.refresh();
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype.onMiddleBarMouseUp = function (event) {
                    this._screenPrevMousePos = undefined;
                    Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseMoveWrapper = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    this._middleBarMouseUpWrapper = undefined;
                    if (event.preventDefault)
                        event.preventDefault(); // prevent other events
                };
                Scrollbar.prototype._getScreenContextualLeft = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualLeft()");
                    return null;
                };
                Scrollbar.prototype._getScreenContextualRight = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualRight()");
                    return null;
                };
                Scrollbar.prototype.onMouseWheel = function (e) {
                    if (e.wheelDelta) {
                        this.mouseWheel(e.wheelDelta);
                    }
                };
                Scrollbar.prototype.onFireFoxMouseWheel = function (e) {
                    if (e.detail) {
                        this.mouseWheel(-e.detail);
                    }
                };
                Scrollbar.prototype.mouseWheel = function (delta) {
                    if (this.visible) {
                        if (delta < 0) {
                            delta = Math.min(-Scrollbar.MouseWheelRange, delta);
                        }
                        else if (delta > 0) {
                            delta = Math.max(Scrollbar.MouseWheelRange, delta);
                        }
                        this.scrollBy(-delta / Scrollbar.MouseWheelRange * this.smallIncrement);
                    }
                };
                Scrollbar.prototype._getScreenMousePos = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenMousePos()");
                    return null;
                };
                Scrollbar.addDocumentMouseUpEvent = function (func) {
                    document.addEventListener("mouseup", func);
                };
                Scrollbar.removeDocumentMouseUpEvent = function (func) {
                    document.removeEventListener("mouseup", func);
                };
                Scrollbar.addDocumentMouseMoveEvent = function (func) {
                    document.addEventListener("mousemove", func);
                };
                Scrollbar.removeDocumentMouseMoveEvent = function (func) {
                    document.removeEventListener("mousemove", func);
                };
                Scrollbar.DefaultScrollbarWidth = "15px"; // protected
                Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500;
                Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50;
                Scrollbar.MouseWheelRange = 120;
                Scrollbar.className = "scroll-bar-div";
                Scrollbar.barClassName = "scroll-bar-part-bar";
                Scrollbar.arrowClassName = "scroll-bar-part-arrow";
                return Scrollbar;
            }());
            controls.Scrollbar = Scrollbar;
            /** Horizontal Scrollbar */
            var HorizontalScrollbar = (function (_super) {
                __extends(HorizontalScrollbar, _super);
                function HorizontalScrollbar(parentElement, layoutKind) {
                    _super.call(this, parentElement, layoutKind);
                    this.height = Scrollbar.DefaultScrollbarWidth;
                }
                HorizontalScrollbar.prototype._calculateButtonWidth = function () {
                    return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
                };
                HorizontalScrollbar.prototype._calculateButtonHeight = function () {
                    return this.actualHeight;
                };
                HorizontalScrollbar.prototype._getMinButtonAngle = function () {
                    return -180;
                };
                HorizontalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 0;
                };
                HorizontalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
                };
                HorizontalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualWidth - this.actualButtonWidth * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    barSize = Math.min(barSize, runningSize);
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight);
                    controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
                };
                HorizontalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.height = this.height;
                    }
                    else {
                        controls.HTMLElementUtils.setElementHeight(this.element, 0);
                    }
                };
                HorizontalScrollbar.prototype._scrollByPage = function (event) {
                    var left = this.middleBar.offsetLeft;
                    var right = left + this.middleBar.offsetWidth;
                    var x = (event.offsetX === undefined) ? event.layerX : event.offsetX;
                    if (x > right) {
                        this.scrollPageDown();
                    }
                    else if (x < left) {
                        this.scrollPageUp();
                    }
                };
                HorizontalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualWidth;
                    if (net) {
                        var barMinPos = this.actualButtonWidth + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                HorizontalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetXDelta(event);
                };
                HorizontalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetXTouchDelta(e);
                };
                HorizontalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().left;
                };
                HorizontalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().right;
                };
                HorizontalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenX;
                };
                return HorizontalScrollbar;
            }(Scrollbar));
            controls.HorizontalScrollbar = HorizontalScrollbar;
            /** Vertical Scrollbar */
            var VerticalScrollbar = (function (_super) {
                __extends(VerticalScrollbar, _super);
                function VerticalScrollbar(parentElement, layoutKind) {
                    _super.call(this, parentElement, layoutKind);
                    this.width = Scrollbar.DefaultScrollbarWidth;
                }
                VerticalScrollbar.prototype._calculateButtonWidth = function () {
                    return this.actualWidth;
                };
                VerticalScrollbar.prototype._calculateButtonHeight = function () {
                    return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
                };
                VerticalScrollbar.prototype._getMinButtonAngle = function () {
                    return -90;
                };
                VerticalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 90;
                };
                VerticalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
                };
                VerticalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualHeight - this.actualButtonHeight * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
                };
                VerticalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.width = this.width;
                    }
                    else {
                        controls.HTMLElementUtils.setElementWidth(this.element, 0);
                    }
                };
                VerticalScrollbar.prototype._scrollByPage = function (event) {
                    var top = this.middleBar.offsetTop;
                    var bottom = top + this.middleBar.offsetHeight;
                    var y = (event.offsetY === undefined) ? event.layerY : event.offsetY;
                    if (y > bottom) {
                        this.scrollPageDown();
                    }
                    else if (y < top) {
                        this.scrollPageUp();
                    }
                };
                VerticalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualHeight;
                    if (net) {
                        var barMinPos = this.actualButtonHeight + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                VerticalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetYDelta(event);
                };
                VerticalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetYTouchDelta(e);
                };
                VerticalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().top;
                };
                VerticalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().bottom;
                };
                VerticalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenY;
                };
                return VerticalScrollbar;
            }(Scrollbar));
            controls.VerticalScrollbar = VerticalScrollbar;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var UNSELECTABLE_CLASS_NAME = "unselectable";
                /** This class is responsible for tablix header resizing */
                var TablixResizer = (function () {
                    function TablixResizer(element, handler) {
                        this._element = element;
                        this._handler = handler;
                        this._elementMouseDownWrapper = null;
                        this._elementMouseMoveWrapper = null;
                        this._elementMouseOutWrapper = null;
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                        this._startMousePosition = null;
                        this._originalCursor = null;
                    }
                    TablixResizer.addDocumentMouseUpEvent = function (listener) {
                        document.addEventListener("mouseup", listener);
                    };
                    TablixResizer.removeDocumentMouseUpEvent = function (listener) {
                        document.removeEventListener("mouseup", listener);
                    };
                    TablixResizer.addDocumentMouseMoveEvent = function (listener) {
                        document.addEventListener("mousemove", listener);
                    };
                    TablixResizer.removeDocumentMouseMoveEvent = function (listener) {
                        document.removeEventListener("mousemove", listener);
                    };
                    TablixResizer.getMouseCoordinates = function (event) {
                        return { x: event.pageX, y: event.pageY };
                    };
                    TablixResizer.getMouseCoordinateDelta = function (previous, current) {
                        return { x: current.x - previous.x, y: current.y - previous.y };
                    };
                    TablixResizer.prototype.initialize = function () {
                        var _this = this;
                        this._elementMouseDownWrapper = function (e) { return _this.onElementMouseDown(e); };
                        this._element.addEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseMoveWrapper = function (e) { return _this.onElementMouseMove(e); };
                        this._element.addEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseOutWrapper = function (e) { return _this.onElementMouseOut(e); };
                        this._element.addEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = function (e) { return _this.onElementMouseDoubleClick(e); };
                        this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                    };
                    TablixResizer.prototype.uninitialize = function () {
                        this._element.removeEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseDownWrapper = null;
                        this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseMoveWrapper = null;
                        this._element.removeEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseOutWrapper = null;
                        this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = null;
                    };
                    Object.defineProperty(TablixResizer.prototype, "cell", {
                        get: function () {
                            // abstract
                            debug.assertFail("PureVirtualMethod: TablixResizer.cell");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixResizer.prototype, "element", {
                        get: function () {
                            return this._element;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixResizer.prototype._hotSpot = function (position) {
                        // abstract
                        debug.assertFail("PureVirtualMethod: TablixResizer._hotSpot");
                        return false;
                    };
                    TablixResizer.prototype.onElementMouseDown = function (event) {
                        var _this = this;
                        var position = TablixResizer.getMouseCoordinates(event);
                        if (!this._hotSpot(position))
                            return;
                        if ("setCapture" in this._element) {
                            this._element.setCapture();
                        }
                        event.cancelBubble = true;
                        this._startMousePosition = position;
                        this._documentMouseMoveWrapper = function (e) { return _this.onDocumentMouseMove(e); };
                        TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseUpWrapper = function (e) { return _this.onDocumentMouseUp(e); };
                        TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        if (document.documentElement) {
                            this._originalCursor = document.documentElement.style.cursor;
                            document.documentElement.style.cursor = TablixResizer.resizeCursor;
                        }
                        this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y);
                    };
                    TablixResizer.prototype.onElementMouseMove = function (event) {
                        if (!this._startMousePosition) {
                            if (this._hotSpot(TablixResizer.getMouseCoordinates(event))) {
                                if (this._originalCursor === null) {
                                    this._originalCursor = this._element.style.cursor;
                                    this._element.style.cursor = TablixResizer.resizeCursor;
                                }
                            }
                            else {
                                if (this._originalCursor !== null) {
                                    this._element.style.cursor = this._originalCursor;
                                    this._originalCursor = null;
                                }
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseOut = function (event) {
                        if (!this._startMousePosition) {
                            if (this._originalCursor !== null) {
                                this._element.style.cursor = this._originalCursor;
                                this._originalCursor = null;
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseDoubleClick = function (event) {
                        if (!this._hotSpot(TablixResizer.getMouseCoordinates(event)))
                            return;
                        this._handler.onReset(this.cell);
                    };
                    TablixResizer.prototype.onDocumentMouseMove = function (event) {
                        if (!this._startMousePosition)
                            return;
                        var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
                        this._handler.onResize(this.cell, delta.x, delta.y);
                        // Need to prevent default to prevent mouse move from triggering other effects (VSTS 6720639)
                        event.preventDefault();
                    };
                    TablixResizer.prototype.onDocumentMouseUp = function (event) {
                        this._startMousePosition = null;
                        if ("releaseCapture" in this._element) {
                            this._element.releaseCapture();
                        }
                        TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseMoveWrapper = null;
                        TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        this._documentMouseUpWrapper = null;
                        if (document.documentElement)
                            document.documentElement.style.cursor = this._originalCursor;
                        if (event.preventDefault)
                            event.preventDefault(); // prevent other events
                        this._handler.onEndResize(this.cell);
                    };
                    TablixResizer.resizeHandleSize = 4;
                    TablixResizer.resizeCursor = "e-resize";
                    return TablixResizer;
                }());
                internal.TablixResizer = TablixResizer;
                var TablixDomResizer = (function (_super) {
                    __extends(TablixDomResizer, _super);
                    function TablixDomResizer(cell, element, handler) {
                        _super.call(this, element, handler);
                        this._cell = cell;
                    }
                    Object.defineProperty(TablixDomResizer.prototype, "cell", {
                        get: function () {
                            return this._cell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixDomResizer.prototype._hotSpot = function (position) {
                        return position.x >= this.element.getBoundingClientRect().right - TablixResizer.resizeHandleSize;
                    };
                    return TablixDomResizer;
                }(TablixResizer));
                internal.TablixDomResizer = TablixDomResizer;
                var TablixCellPresenter = (function () {
                    function TablixCellPresenter(fitProportionally, layoutKind) {
                        // Table cell will be created once needed
                        this._tableCell = null;
                        // Content element
                        this._contentElement = internal.TablixUtils.createDiv();
                        // Content Host
                        this._contentHost = internal.TablixUtils.createDiv();
                        this.layoutKind = layoutKind;
                        this._contentElement.appendChild(this._contentHost);
                        this._resizer = null;
                    }
                    TablixCellPresenter.prototype.initialize = function (owner) {
                        this._owner = owner;
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerTableCell = function (tableCell) {
                        this._tableCell = tableCell;
                        tableCell.appendChild(this._contentElement);
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
                        get: function () {
                            return this._tableCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
                        /**
                         * Outer DIV
                         */
                        get: function () {
                            return this._contentElement;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
                        /**
                        * Inner DIV
                        */
                        get: function () {
                            return this._contentHost;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerClickHandler = function (handler) {
                        this._contentElement.onclick = handler;
                    };
                    TablixCellPresenter.prototype.unregisterClickHandler = function () {
                        this._contentElement.onclick = null;
                    };
                    TablixCellPresenter.prototype.onContentWidthChanged = function (value) {
                        controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
                    };
                    TablixCellPresenter.prototype.onContentHeightChanged = function (height) {
                        controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
                    };
                    TablixCellPresenter.prototype.onColumnSpanChanged = function (value) {
                        this._tableCell.colSpan = value;
                    };
                    TablixCellPresenter.prototype.onRowSpanChanged = function (value) {
                        this._tableCell.rowSpan = value;
                    };
                    TablixCellPresenter.prototype.onTextAlignChanged = function (value) {
                        this._tableCell.style.textAlign = value;
                    };
                    TablixCellPresenter.prototype.onClear = function () {
                        this._contentHost.className = "";
                        this._tableCell.className = "";
                    };
                    TablixCellPresenter.prototype.onHorizontalScroll = function (width, offset) {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
                    };
                    TablixCellPresenter.prototype.onVerticalScroll = function (height, offset) {
                        controls.HTMLElementUtils.setElementTop(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
                    };
                    TablixCellPresenter.prototype.onInitializeScrolling = function () {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementTop(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, -1);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
                    };
                    TablixCellPresenter.prototype.enableHorizontalResize = function (enable, handler) {
                        if (enable === (this._resizer !== null))
                            return;
                        if (enable) {
                            this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler);
                            this._resizer.initialize();
                        }
                        else {
                            this._resizer.uninitialize();
                            this._resizer = null;
                        }
                    };
                    /**
                     * In order to allow dragging of the tableCell we need to
                     * disable dragging of the container of the cell in IE.
                     */
                    TablixCellPresenter.prototype.disableDragResize = function () {
                        this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
                    };
                    // Attribute used to disable dragging in order to have cell resizing work.
                    TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled";
                    return TablixCellPresenter;
                }());
                internal.TablixCellPresenter = TablixCellPresenter;
                var TablixRowPresenter = (function () {
                    function TablixRowPresenter(fitProportionally) {
                        // Table row will be created once needed
                        this._tableRow = null;
                        this._fitProportionally = fitProportionally;
                    }
                    TablixRowPresenter.prototype.initialize = function (row) {
                        this._row = row;
                    };
                    TablixRowPresenter.prototype.createCellPresenter = function (layoutKind) {
                        return new TablixCellPresenter(this._fitProportionally, layoutKind);
                    };
                    TablixRowPresenter.prototype.registerRow = function (tableRow) {
                        this._tableRow = tableRow;
                    };
                    TablixRowPresenter.prototype.onAppendCell = function (cell) {
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reason we use InsertCell() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableCell = this._tableRow.insertCell(-1);
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.appendChild(presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onInsertCellBefore = function (cell, refCell) {
                        debug.assertValue(refCell._presenter.tableCell, 'refTableCell');
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reasons we use InsertCell() to create new table cells instead of AppendChild()
                            var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onRemoveCell = function (cell) {
                        this._tableRow.removeChild(cell._presenter.tableCell);
                    };
                    TablixRowPresenter.prototype.getHeight = function () {
                        return this.getCellHeight(this._row.getTablixCell());
                    };
                    TablixRowPresenter.prototype.getCellHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    TablixRowPresenter.prototype.getCellContentHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
                        get: function () {
                            return this._tableRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TablixRowPresenter;
                }());
                internal.TablixRowPresenter = TablixRowPresenter;
                var DashboardRowPresenter = (function (_super) {
                    __extends(DashboardRowPresenter, _super);
                    function DashboardRowPresenter(gridPresenter, fitProportionally) {
                        _super.call(this, fitProportionally);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardRowPresenter.prototype.getCellHeight = function (cell) {
                        if (!cell._presenter)
                            return 0;
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.tableCell);
                    };
                    DashboardRowPresenter.prototype.getCellContentHeight = function (cell) {
                        if (!cell._presenter)
                            return 0;
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.contentElement);
                    };
                    return DashboardRowPresenter;
                }(TablixRowPresenter));
                internal.DashboardRowPresenter = DashboardRowPresenter;
                var CanvasRowPresenter = (function (_super) {
                    __extends(CanvasRowPresenter, _super);
                    function CanvasRowPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowPresenter.prototype.getCellHeight = function (cell) {
                        if (!cell._presenter)
                            return 0;
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.tableCell);
                    };
                    CanvasRowPresenter.prototype.getCellContentHeight = function (cell) {
                        if (!cell._presenter)
                            return 0;
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.contentElement);
                    };
                    return CanvasRowPresenter;
                }(TablixRowPresenter));
                internal.CanvasRowPresenter = CanvasRowPresenter;
                var TablixColumnPresenter = (function () {
                    function TablixColumnPresenter() {
                    }
                    TablixColumnPresenter.prototype.initialize = function (column) {
                        this._column = column;
                    };
                    TablixColumnPresenter.prototype.getWidth = function () {
                        return this.getCellWidth(this._column.getTablixCell());
                    };
                    TablixColumnPresenter.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellWidth");
                        return -1;
                    };
                    TablixColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellContentWidth");
                        return -1;
                    };
                    return TablixColumnPresenter;
                }());
                internal.TablixColumnPresenter = TablixColumnPresenter;
                var DashboardColumnPresenter = (function (_super) {
                    __extends(DashboardColumnPresenter, _super);
                    function DashboardColumnPresenter(gridPresenter) {
                        _super.call(this);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardColumnPresenter.prototype.getCellWidth = function (cell) {
                        return this._gridPresenter.sizeComputationManager.cellWidth;
                    };
                    DashboardColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        return this._gridPresenter.sizeComputationManager.contentWidth;
                    };
                    return DashboardColumnPresenter;
                }(TablixColumnPresenter));
                internal.DashboardColumnPresenter = DashboardColumnPresenter;
                var CanvasColumnPresenter = (function (_super) {
                    __extends(CanvasColumnPresenter, _super);
                    function CanvasColumnPresenter(gridPresenter, index) {
                        _super.call(this);
                        this._gridPresenter = gridPresenter;
                        this._columnIndex = index;
                    }
                    CanvasColumnPresenter.prototype.getCellWidth = function (cell) {
                        var persistedWidth = this._gridPresenter.getPersistedCellWidth(this._columnIndex);
                        // Because persistedWidth could be 0 check specifically for null or undefined 
                        if (_.isNumber(persistedWidth))
                            return persistedWidth;
                        if (!cell._presenter)
                            return 0;
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        var persistedWidth = this._gridPresenter.getPersistedCellWidth(this._columnIndex);
                        // Because persistedWidth could be 0 check specifically for null or undefined 
                        if (_.isNumber(persistedWidth))
                            return persistedWidth;
                        if (!cell._presenter)
                            return 0;
                        var requiredWidth = controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                        if (requiredWidth > 0 && cell.colSpan === 1)
                            requiredWidth += 1; // Adding 1px because offsetWidth returns floored number, may risk getting ellipsis
                        return requiredWidth;
                    };
                    return CanvasColumnPresenter;
                }(TablixColumnPresenter));
                internal.CanvasColumnPresenter = CanvasColumnPresenter;
                var TablixGridPresenter = (function () {
                    function TablixGridPresenter(columnWidthManager) {
                        // Main Table
                        this._table = internal.TablixUtils.createTable();
                        this._table.className = UNSELECTABLE_CLASS_NAME;
                        // Footer Table
                        this._footerTable = internal.TablixUtils.createTable();
                        this._footerTable.className = UNSELECTABLE_CLASS_NAME;
                        // ColumnWidthManager
                        this._columnWidthManager = columnWidthManager;
                    }
                    TablixGridPresenter.prototype.initialize = function (owner, gridHost, footerHost, control) {
                        this._owner = owner;
                        gridHost.appendChild(this._table);
                        footerHost.appendChild(this._footerTable);
                    };
                    TablixGridPresenter.prototype.getWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getWidth");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getHeight");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioX = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioY = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.createRowPresenter = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createRowPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createColumnPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.onAppendRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._table.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onInsertRowBefore = function (row, refRow) {
                        debug.assertValue(refRow.presenter.tableRow, 'refTableRow');
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onRemoveRow = function (row) {
                        this._table.tBodies[0].removeChild(row.presenter.tableRow);
                    };
                    TablixGridPresenter.prototype.onAddFooterRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._footerTable.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onClear = function () {
                        controls.HTMLElementUtils.clearChildren(this._table);
                        controls.HTMLElementUtils.clearChildren(this._footerTable);
                    };
                    TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function (value) {
                        if (value) {
                            this._table.style.width = "100%";
                            this._footerTable.style.width = "100%";
                        }
                        else {
                            this._table.style.width = "auto";
                            this._footerTable.style.width = "auto";
                        }
                    };
                    TablixGridPresenter.prototype.invokeColumnResizeEndCallback = function (columnIndex, width) {
                        if (this._columnWidthManager)
                            this._columnWidthManager.onColumnWidthChanged(columnIndex, width);
                    };
                    TablixGridPresenter.prototype.getPersistedCellWidth = function (columnIndex) {
                        if (this._columnWidthManager)
                            return this._columnWidthManager.getPersistedColumnWidth(columnIndex);
                    };
                    return TablixGridPresenter;
                }());
                internal.TablixGridPresenter = TablixGridPresenter;
                var DashboardTablixGridPresenter = (function (_super) {
                    __extends(DashboardTablixGridPresenter, _super);
                    function DashboardTablixGridPresenter(sizeComputationManager) {
                        _super.call(this);
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
                    };
                    DashboardTablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        return new DashboardColumnPresenter(this);
                    };
                    Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
                        get: function () {
                            return this._sizeComputationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DashboardTablixGridPresenter.prototype.getWidth = function () {
                        return this._sizeComputationManager.gridWidth;
                    };
                    DashboardTablixGridPresenter.prototype.getHeight = function () {
                        return this._sizeComputationManager.gridHeight;
                    };
                    return DashboardTablixGridPresenter;
                }(TablixGridPresenter));
                internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
                var CanvasTablixGridPresenter = (function (_super) {
                    __extends(CanvasTablixGridPresenter, _super);
                    function CanvasTablixGridPresenter(columnWidthManager) {
                        _super.call(this, columnWidthManager);
                    }
                    CanvasTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
                    };
                    CanvasTablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        return new CanvasColumnPresenter(this, index);
                    };
                    CanvasTablixGridPresenter.prototype.getWidth = function () {
                        return controls.HTMLElementUtils.getElementWidth(this._table);
                    };
                    CanvasTablixGridPresenter.prototype.getHeight = function () {
                        return controls.HTMLElementUtils.getElementHeight(this._table);
                    };
                    return CanvasTablixGridPresenter;
                }(TablixGridPresenter));
                internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                /**
                 * Base class for Tablix realization manager.
                 */
                var TablixDimensionRealizationManager = (function () {
                    function TablixDimensionRealizationManager(binder) {
                        this._binder = binder;
                        this._adjustmentFactor = 1;
                    }
                    TablixDimensionRealizationManager.prototype._getOwner = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getOwner");
                        return null;
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
                        get: function () {
                            return this._adjustmentFactor;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
                        get: function () {
                            return this._itemsToRealizeCount;
                        },
                        set: function (count) {
                            this._itemsToRealizeCount = count;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
                        get: function () {
                            return this._itemsEstimatedContextualWidth;
                        },
                        set: function (contextualWidth) {
                            this._itemsEstimatedContextualWidth = contextualWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function () {
                        var owner = this._getOwner();
                        if (owner.measureEnabled && !owner.done) {
                            this._getEstimatedItemsToRealizeCount();
                        }
                        this._realizedLeavesCount = 0;
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function (gridContextualWidth, filled) {
                        if (!filled && !this._getOwner().allItemsRealized)
                            this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth);
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingSession = function () {
                        this._adjustmentFactor = 1;
                    };
                    TablixDimensionRealizationManager.prototype.onCornerCellRealized = function (item, cell) {
                    };
                    TablixDimensionRealizationManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        if (leaf) {
                            this._realizedLeavesCount++;
                        }
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizedLeavesCount < this._itemsToRealizeCount;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._calculateItemsToRealize");
                    };
                    TablixDimensionRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._getSizeAdjustment");
                        return 1;
                    };
                    return TablixDimensionRealizationManager;
                }());
                internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
                /**
                 * DOM implementation for Row Tablix realization manager.
                 */
                var RowRealizationManager = (function (_super) {
                    __extends(RowRealizationManager, _super);
                    function RowRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(RowRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateRowsToRealizeCount();
                    };
                    RowRealizationManager.prototype.estimateRowsToRealizeCount = function () {
                        debug.assertValue(this._owner, '_owner');
                        if (!this._owner.dimension.model) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        if (this._owner.alignToEnd)
                            this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1;
                        else
                            this.itemsToRealizeCount = Math.ceil((this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor)) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1;
                    };
                    RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (!this._owner.dimension.model || this._owner.dimension.getItemsCount() === 0)
                            return 0;
                        var levels = new RowWidths();
                        this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
                        var levelsArray = levels.items;
                        var levelCount = levelsArray.length;
                        var width = 0;
                        for (var i = 0; i < levelCount; i++) {
                            var level = levelsArray[i];
                            if (level.maxNonLeafWidth !== 0)
                                width += level.maxNonLeafWidth;
                            else
                                width += level.maxLeafWidth;
                        }
                        return width;
                    };
                    RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function (items, firstVisibleIndex, levels) {
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var binder = this.binder;
                        var length = hierarchyNavigator.getCount(items);
                        for (var i = firstVisibleIndex; i < length; i++) {
                            if (levels.leafCount === this.itemsToRealizeCount)
                                return;
                            var item = hierarchyNavigator.getAt(items, i);
                            var label = binder.getHeaderLabel(item);
                            var itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex);
                            var isLeaf = hierarchyNavigator.isLeaf(item);
                            var l = hierarchyNavigator.getLevel(item);
                            var level = levels.items[l];
                            if (!level) {
                                level = new RowWidth();
                                levels.items[l] = level;
                            }
                            if (isLeaf) {
                                level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth);
                                levels.leafCount = levels.leafCount + 1;
                            }
                            else {
                                level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth);
                                this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels);
                            }
                        }
                    };
                    RowRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
                    };
                    return RowRealizationManager;
                }(TablixDimensionRealizationManager));
                internal.RowRealizationManager = RowRealizationManager;
                /**
                 * DOM implementation for Column Tablix realization manager.
                 */
                var ColumnRealizationManager = (function (_super) {
                    __extends(ColumnRealizationManager, _super);
                    function ColumnRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
                    };
                    Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
                        get: function () {
                            return this._owner.otherLayoutManager.realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (this._owner.otherLayoutManager.done)
                            return this._owner.getOtherHierarchyContextualHeight();
                        return this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
                    };
                    ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function (rowHierarchyWidth) {
                        var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
                        if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        var binder = this.binder;
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var startColumnIndex = this._owner.dimension.getIntegerScrollOffset();
                        var endColumnIndex = this._owner.dimension.getItemsCount();
                        var columnCount = endColumnIndex - startColumnIndex;
                        var startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset();
                        var endRowIndex = this._owner.otherLayoutManager.dimension.getItemsCount();
                        this.itemsEstimatedContextualWidth = 0;
                        if (this._owner.alignToEnd) {
                            this.itemsToRealizeCount = columnCount;
                            return;
                        }
                        for (var i = startColumnIndex; i < endColumnIndex; i++) {
                            if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) {
                                this.itemsToRealizeCount = i - startColumnIndex;
                                return;
                            }
                            var maxWidth = 0;
                            var visibleSizeRatio = void 0;
                            if (i === startColumnIndex) {
                                visibleSizeRatio = this._owner.getVisibleSizeRatio();
                            }
                            else {
                                visibleSizeRatio = 1;
                            }
                            var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i);
                            var label = binder.getHeaderLabel(columnMember);
                            maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
                            for (var j = startRowIndex; j < endRowIndex; j++) {
                                var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
                                label = binder.getCellContent(intersection);
                                maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
                            }
                            this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
                        }
                        this.itemsToRealizeCount = columnCount;
                    };
                    ColumnRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
                    };
                    return ColumnRealizationManager;
                }(TablixDimensionRealizationManager));
                internal.ColumnRealizationManager = ColumnRealizationManager;
                var RowWidths = (function () {
                    function RowWidths() {
                        this.items = [];
                        this.leafCount = 0;
                    }
                    return RowWidths;
                }());
                internal.RowWidths = RowWidths;
                var RowWidth = (function () {
                    function RowWidth() {
                        this.maxLeafWidth = 0;
                        this.maxNonLeafWidth = 0;
                    }
                    return RowWidth;
                }());
                internal.RowWidth = RowWidth;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var TablixCell = (function () {
                    function TablixCell(presenter, extension, row) {
                        this._scrollable = false;
                        this._presenter = presenter;
                        this.extension = extension;
                        this._presenter.initialize(this);
                        this._row = row;
                        this.item = null;
                        this.type = null;
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        this._colSpan = 1;
                        this._rowSpan = 1;
                        this._contentWidth = -1;
                        this._contentHeight = -1;
                        this.position = new internal.TablixUtils.CellPosition();
                    }
                    Object.defineProperty(TablixCell.prototype, "colSpan", {
                        get: function () {
                            return this._colSpan;
                        },
                        set: function (value) {
                            if (this._colSpan !== value) {
                                this._presenter.onColumnSpanChanged(value);
                                this._colSpan = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "rowSpan", {
                        get: function () {
                            return this._rowSpan;
                        },
                        set: function (value) {
                            if (this._rowSpan !== value) {
                                this._presenter.onRowSpanChanged(value);
                                this._rowSpan = value;
                                if (value > 1)
                                    this.setContentHeight(this.getCellSpanningHeight());
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.getCellSpanningHeight = function () {
                        return this._row.getCellSpanningHeight(this);
                    };
                    Object.defineProperty(TablixCell.prototype, "textAlign", {
                        get: function () {
                            return this._textAlign;
                        },
                        set: function (value) {
                            if (value !== this._textAlign) {
                                this._presenter.onTextAlignChanged(value);
                                this._textAlign = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
                        get: function () {
                            return this._horizontalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "verticalOffset", {
                        get: function () {
                            return this._verticalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.isScrollable = function () {
                        return this._scrollable;
                    };
                    TablixCell.prototype.clear = function () {
                        if (this.isScrollable()) {
                            this.initializeScrolling();
                        }
                        this._presenter.onClear();
                        this.setContentWidth(-1);
                        this.setContentHeight(-1);
                    };
                    TablixCell.prototype.initializeScrolling = function () {
                        this._presenter.onInitializeScrolling();
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        if (this.colSpan === 1)
                            this.setContentWidth(-1);
                        if (this.rowSpan === 1)
                            this.setContentHeight(-1);
                    };
                    TablixCell.prototype.prepare = function (scrollable) {
                        if (this.isScrollable())
                            this.initializeScrolling();
                        this._scrollable = scrollable;
                    };
                    TablixCell.prototype.scrollVertically = function (height, offset) {
                        // Ceiling the offset because setting a fraction Width on the TD will ceil it
                        // We need to let the TD and the OuterDiv to align in order for Borders to touch
                        var offsetInPixels = Math.ceil(-height * offset);
                        this._verticalOffset = offsetInPixels;
                        if (this.isScrollable()) {
                            this._presenter.onVerticalScroll(height, offsetInPixels);
                            this.setContentHeight(height + offsetInPixels);
                        }
                        else {
                            this.setContentHeight(this._row.getCellSpanningHeight(this) + offsetInPixels);
                        }
                    };
                    TablixCell.prototype.scrollHorizontally = function (width, offset) {
                        if (!this.isScrollable()) {
                            return;
                        }
                        // Ceiling the offset because setting a fraction Width on the TD will ceil it
                        // We need to let the TD and the OuterDiv to align in order for Borders to touch
                        var offsetInPixels = Math.ceil(-width * offset);
                        this._horizontalOffset = offsetInPixels;
                        this._presenter.onHorizontalScroll(width, offsetInPixels);
                        this.setContentWidth(width + offsetInPixels);
                    };
                    TablixCell.prototype.setContentWidth = function (value) {
                        if (value === this._contentWidth)
                            return;
                        this._contentWidth = value;
                        this._presenter.onContentWidthChanged(value);
                    };
                    TablixCell.prototype.setContentHeight = function (value) {
                        if (value === this._contentHeight)
                            return;
                        this._contentHeight = value;
                        this._presenter.onContentHeightChanged(value);
                    };
                    TablixCell.prototype.enableHorizontalResize = function (enable, handler) {
                        this._presenter.enableHorizontalResize(enable, handler);
                    };
                    return TablixCell;
                }());
                internal.TablixCell = TablixCell;
                var TablixColumn = (function () {
                    function TablixColumn(presenter, columnIndex) {
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._contentWidth = -1;
                        this._width = -1;
                        this._sizeFixed = false;
                        this._aligningWidth = -1;
                        this._fixedToAligningWidth = false;
                        this._items = [];
                        this._itemType = null;
                        this._footerCell = null;
                        this._columnIndex = columnIndex;
                    }
                    TablixColumn.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCornerCells = [];
                        this._realizedBodyCells = [];
                    };
                    Object.defineProperty(TablixColumn.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getType = function () {
                        if (this._realizedCornerCells.length > 0)
                            return 0 /* CornerCell */;
                        return 2 /* ColumnHeader */;
                    };
                    TablixColumn.prototype.getColumnHeadersOrCorners = function () {
                        if (this._realizedCornerCells.length > 0)
                            return this._realizedCornerCells;
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.columnHeadersOrCornersEqual = function (newType, headers, hierarchyNavigator) {
                        if (this._items.length !== headers.length)
                            return false;
                        var count = this._items.length;
                        for (var i = 0; i < count; i++) {
                            if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator))
                                return false;
                        }
                        return true;
                    };
                    Object.defineProperty(TablixColumn.prototype, "itemType", {
                        get: function () {
                            return this._itemType;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getLeafItem = function () {
                        if (this._items.length === 0)
                            return null;
                        return this._items[this._items.length - 1];
                    };
                    TablixColumn.prototype.columnHeaderOrCornerEquals = function (type1, item1, type2, item2, hierarchyNavigator) {
                        if (type1 !== type2)
                            return false;
                        if (type1 === 0 /* CornerCell */) {
                            if (!hierarchyNavigator.cornerCellItemEquals(item1, item2))
                                return false;
                        }
                        else {
                            if (!hierarchyNavigator.headerItemEquals(item1, item2))
                                return false;
                        }
                        return true;
                    };
                    TablixColumn.prototype.OnLeafRealized = function (hierarchyNavigator) {
                        // if the headers/corner have changed we should clear the column size to accomodate for the new content
                        var type = this.getType();
                        var columnHeadersOrCorners = this.getColumnHeadersOrCorners();
                        if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) {
                            this.clearSpanningCellsWidth(this._realizedColumnHeaders);
                        }
                        else {
                            var count = columnHeadersOrCorners.length;
                            this._items = [];
                            for (var i = 0; i < count; i++) {
                                this._items.push(columnHeadersOrCorners[i].item);
                            }
                            this._itemType = type;
                            this.clearSize();
                        }
                    };
                    TablixColumn.prototype.clearSpanningCellsWidth = function (cells) {
                        for (var i = 0; i < cells.length; i++) {
                            var cell = cells[i];
                            if (cell.colSpan > 1) {
                                cell.setContentWidth(-1);
                            }
                        }
                    };
                    TablixColumn.prototype.addCornerCell = function (cell) {
                        cell._column = this;
                        this._realizedCornerCells.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    TablixColumn.prototype.addRowHeader = function (cell) {
                        cell._column = this;
                        this._realizedRowHeaders.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    TablixColumn.prototype.addColumnHeader = function (cell, isLeaf) {
                        cell._column = this;
                        this._realizedColumnHeaders.push(cell);
                        if (isLeaf) {
                            cell.setContentWidth(this._contentWidth);
                        }
                    };
                    TablixColumn.prototype.addBodyCell = function (cell) {
                        cell._column = this;
                        this._realizedBodyCells.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    Object.defineProperty(TablixColumn.prototype, "footer", {
                        get: function () {
                            return this._footerCell;
                        },
                        set: function (footerCell) {
                            this._footerCell = footerCell;
                            footerCell._column = this;
                            footerCell.setContentWidth(this._contentWidth);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.onResize = function (width) {
                        if (width === this.getContentContextualWidth())
                            return;
                        this._contentWidth = width;
                        this.setContentWidth(this._contentWidth);
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = false;
                        this._aligningWidth = -1;
                    };
                    TablixColumn.prototype.onResizeEnd = function (width) {
                        // Invoke resize callback
                        var gridPresenter = this.owner._presenter;
                        if (gridPresenter)
                            gridPresenter.invokeColumnResizeEndCallback(this._columnIndex, width);
                    };
                    TablixColumn.prototype.fixSize = function () {
                        var shouldAlign = this._aligningWidth !== -1;
                        var switched = shouldAlign !== this._fixedToAligningWidth;
                        if ((this._sizeFixed && !switched && !shouldAlign))
                            return;
                        if (this._aligningWidth === -1) {
                            this.setContentWidth(this._contentWidth);
                        }
                        else {
                            this.setContentWidth(this._aligningWidth);
                        }
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = this._aligningWidth !== -1;
                    };
                    TablixColumn.prototype.clearSize = function () {
                        this._contentWidth = -1;
                        this.setContentWidth(this._contentWidth);
                        this._sizeFixed = false;
                    };
                    TablixColumn.prototype.getContentContextualWidth = function () {
                        return this._contentWidth;
                    };
                    TablixColumn.prototype.getCellIContentContextualWidth = function (cell) {
                        return this._presenter.getCellContentWidth(cell);
                    };
                    TablixColumn.prototype.getCellSpanningWidthWithScrolling = function (cell, tablixGrid) {
                        var width = this.getContextualWidth() + this.getScrollingOffset();
                        if (cell.colSpan > 1) {
                            var index = this.getIndex(tablixGrid);
                            var columns = tablixGrid.realizedColumns;
                            for (var i = 1; i < cell.colSpan; i++)
                                width += columns[i + index].getContextualWidth();
                        }
                        return width;
                    };
                    TablixColumn.prototype.getScrollingOffset = function () {
                        var offset = 0;
                        if (this._realizedColumnHeaders.length > 0)
                            offset = this._realizedColumnHeaders[this._realizedColumnHeaders.length - 1].horizontalOffset;
                        return offset;
                    };
                    TablixColumn.prototype.getContextualWidth = function () {
                        if (this._width === -1 || this._contentWidth === -1)
                            this._width = this._presenter.getWidth();
                        return this._width;
                    };
                    TablixColumn.prototype.calculateSize = function () {
                        if (this._sizeFixed)
                            return this._contentWidth;
                        var contentWidth = 0;
                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._footerCell));
                        }
                        return this._contentWidth = contentWidth;
                    };
                    TablixColumn.prototype.setAligningContextualWidth = function (size) {
                        this._aligningWidth = size;
                    };
                    TablixColumn.prototype.getAligningContextualWidth = function () {
                        return this._aligningWidth;
                    };
                    TablixColumn.prototype.setContentWidth = function (value) {
                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (cell.colSpan === 1)
                                cell.setContentWidth(value);
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            if (cell.colSpan === 1)
                                cell.setContentWidth(value);
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            cell.setContentWidth(value);
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            cell.setContentWidth(value);
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1)
                                this._footerCell.setContentWidth(value);
                        }
                        this._width = value; // set cell width to new value
                    };
                    TablixColumn.prototype.getTablixCell = function () {
                        var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixColumn.prototype.getIndex = function (grid) {
                        return grid.realizedColumns.indexOf(this);
                    };
                    TablixColumn.prototype.getHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixColumn.prototype.getCellContextualSpan = function (cell) {
                        return cell.colSpan;
                    };
                    TablixColumn.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._row;
                    };
                    return TablixColumn;
                }());
                internal.TablixColumn = TablixColumn;
                var TablixRow = (function () {
                    function TablixRow(presenter) {
                        this._contentHeight = -1;
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._allocatedCells = [];
                        this._heightFixed = false;
                        this._contentHeight = -1;
                        this._height = -1;
                    }
                    TablixRow.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedBodyCells = [];
                        this._realizedCornerCells = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCellsCount = 0;
                    };
                    Object.defineProperty(TablixRow.prototype, "presenter", {
                        get: function () {
                            return this._presenter;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixRow.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixRow.prototype.releaseUnusedCells = function (owner) {
                        this.releaseCells(owner, this._realizedCellsCount);
                    };
                    TablixRow.prototype.releaseAllCells = function (owner) {
                        this.releaseCells(owner, 0);
                    };
                    TablixRow.prototype.releaseCells = function (owner, startIndex) {
                        var cells = this._allocatedCells;
                        var length = cells.length;
                        for (var i = startIndex; i < length; i++) {
                            var cell = cells[i];
                            owner._unbindCell(cell);
                            cell.clear();
                        }
                    };
                    TablixRow.prototype.moveScrollableCellsToEnd = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells[i];
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onAppendCell(cell);
                            this._allocatedCells.push(cell);
                        }
                        this._allocatedCells.splice(frontIndex, count);
                    };
                    TablixRow.prototype.moveScrollableCellsToStart = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells.pop();
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]);
                            this._allocatedCells.splice(frontIndex, 0, cell);
                        }
                    };
                    TablixRow.prototype.getOrCreateCornerCell = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.addCornerCell(cell);
                        this._realizedCornerCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateRowHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addRowHeader(cell);
                        this._realizedRowHeaders.push(cell);
                        if (leaf)
                            cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateColumnHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addColumnHeader(cell, leaf);
                        this._realizedColumnHeaders.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addBodyCell(cell);
                        this._realizedBodyCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterRowHeader = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.footer = cell;
                        this._realizedRowHeaders.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.footer = cell;
                        this._realizedBodyCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getRowHeaderLeafIndex = function () {
                        var index = -1;
                        var count = this._allocatedCells.length;
                        for (var i = 0; i < count; i++) {
                            if (this._allocatedCells[i].type !== 1 /* RowHeader */)
                                break;
                            index++;
                        }
                        return index;
                    };
                    TablixRow.prototype.getAllocatedCellAt = function (index) {
                        return this._allocatedCells[index];
                    };
                    TablixRow.prototype.moveCellsBy = function (delta) {
                        if (this._allocatedCells.length === 0)
                            return;
                        if (delta > 0) {
                            var refCell = this._allocatedCells[0];
                            for (var i = 0; i < delta; i++) {
                                var cell = this.createCell(this);
                                this._presenter.onInsertCellBefore(cell, refCell);
                                this._allocatedCells.unshift(cell);
                                refCell = cell;
                            }
                        }
                        else {
                            delta = -delta;
                            for (var i = 0; i < delta; i++) {
                                this._presenter.onRemoveCell(this._allocatedCells[i]);
                            }
                            this._allocatedCells.splice(0, delta);
                        }
                    };
                    TablixRow.prototype.getRealizedCellCount = function () {
                        return this._realizedCellsCount;
                    };
                    TablixRow.prototype.getRealizedHeadersCount = function () {
                        return this._realizedRowHeaders.length;
                    };
                    TablixRow.prototype.getRealizedHeaderAt = function (index) {
                        return this._realizedRowHeaders[index];
                    };
                    TablixRow.prototype.getTablixCell = function () {
                        var realizedCells;
                        if (this._realizedRowHeaders.length > 0) {
                            realizedCells = this._realizedRowHeaders;
                        }
                        else if (this._realizedCornerCells.length > 0) {
                            realizedCells = this._realizedCornerCells;
                        }
                        else {
                            realizedCells = this._realizedColumnHeaders;
                        }
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixRow.prototype.getOrCreateEmptySpaceCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        return cell;
                    };
                    TablixRow.prototype.createCell = function (row) {
                        var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
                        return new TablixCell(presenter, presenter, this);
                    };
                    TablixRow.prototype.getOrCreateCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        else {
                            cell.colSpan = 1;
                            cell.rowSpan = 1;
                        }
                        this._realizedCellsCount = this._realizedCellsCount + 1;
                        return cell;
                    };
                    TablixRow.prototype.onResize = function (height) {
                        if (height === this.getContentContextualWidth())
                            return;
                        this._contentHeight = height;
                        this.setContentHeight();
                        this._heightFixed = true;
                        this.setAligningContextualWidth(-1);
                    };
                    TablixRow.prototype.onResizeEnd = function (height) { };
                    TablixRow.prototype.fixSize = function () {
                        if (this.sizeFixed())
                            return;
                        this.setContentHeight();
                        this._heightFixed = true;
                    };
                    TablixRow.prototype.getContentContextualWidth = function () {
                        return this._contentHeight;
                    };
                    TablixRow.prototype.getCellIContentContextualWidth = function (cell) {
                        return this.presenter.getCellContentHeight(cell);
                    };
                    TablixRow.prototype.getCellSpanningHeight = function (cell) {
                        var height = this.getContextualWidth();
                        if (cell.rowSpan > 1) {
                            var index = this.getIndex(this.owner);
                            var rows = this.owner.realizedRows;
                            for (var i = 1; i < cell.rowSpan; i++)
                                height += rows[i + index].getContextualWidth();
                        }
                        return height;
                    };
                    TablixRow.prototype.getContextualWidth = function () {
                        if (this._height === -1 || this._contentHeight === -1)
                            this._height = this._presenter.getHeight();
                        return this._height;
                    };
                    TablixRow.prototype.sizeFixed = function () {
                        return this._heightFixed;
                    };
                    TablixRow.prototype.calculateSize = function () {
                        if (this._heightFixed)
                            return this._contentHeight;
                        var contentHeight = 0;
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
                        }
                        return this._contentHeight = contentHeight;
                    };
                    TablixRow.prototype.setAligningContextualWidth = function (size) {
                        // TODO should be implemented when we support variable row heights
                    };
                    TablixRow.prototype.getAligningContextualWidth = function () {
                        // TODO should be implemented when we support variable row heights
                        return -1;
                    };
                    TablixRow.prototype.setContentHeight = function () {
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan === 1)
                                cell.setContentHeight(this._contentHeight);
                            else
                                cell.setContentHeight(this.getCellSpanningHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedCornerCells[i].setContentHeight(this._contentHeight);
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1)
                                cell.setContentHeight(this._contentHeight);
                            else
                                cell.setContentHeight(this.getCellSpanningHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedBodyCells[i].setContentHeight(this._contentHeight);
                        }
                        this._height = -1;
                    };
                    TablixRow.prototype.getIndex = function (grid) {
                        return grid.realizedRows.indexOf(this);
                    };
                    TablixRow.prototype.getHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixRow.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixRow.prototype.getCellContextualSpan = function (cell) {
                        return cell.rowSpan;
                    };
                    TablixRow.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._column;
                    };
                    return TablixRow;
                }());
                internal.TablixRow = TablixRow;
                var TablixGrid = (function () {
                    function TablixGrid(presenter) {
                        this._presenter = presenter;
                        this._footerRow = null;
                    }
                    TablixGrid.prototype.initialize = function (owner, gridHost, footerHost) {
                        this._owner = owner;
                        this._presenter.initialize(this, gridHost, footerHost, owner);
                        this.fillColumnsProportionally = false;
                        this._realizedRows = [];
                        this._realizedColumns = [];
                        this._emptySpaceHeaderCell = null;
                        this._emptyFooterSpaceCell = null;
                    };
                    Object.defineProperty(TablixGrid.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
                        get: function () {
                            return this._fillColumnsProportionally;
                        },
                        set: function (value) {
                            if (this._fillColumnsProportionally === value)
                                return;
                            this._fillColumnsProportionally = value;
                            this._presenter.onFillColumnsProportionallyChanged(value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
                        get: function () {
                            return this._realizedColumns;
                        },
                        set: function (columns) {
                            this._realizedColumns = columns;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedRows", {
                        get: function () {
                            return this._realizedRows;
                        },
                        set: function (rows) {
                            this._realizedRows = rows;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "footerRow", {
                        get: function () {
                            return this._footerRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
                        get: function () {
                            return this._emptySpaceHeaderCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
                        get: function () {
                            return this._emptyFooterSpaceCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixGrid.prototype.ShowEmptySpaceCells = function (rowSpan, width) {
                        if (this._realizedRows.length === 0)
                            return;
                        if (this._realizedRows.length !== 0 && !this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell();
                            this._emptySpaceHeaderCell.rowSpan = rowSpan;
                            this._emptySpaceHeaderCell.colSpan = 1;
                            this._emptySpaceHeaderCell.setContentWidth(width);
                        }
                        if (this._footerRow && (this._emptyFooterSpaceCell === null)) {
                            this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell();
                            this._emptyFooterSpaceCell.rowSpan = 1;
                            this._emptyFooterSpaceCell.colSpan = 1;
                            this._emptyFooterSpaceCell.setContentWidth(width);
                        }
                    };
                    TablixGrid.prototype.HideEmptySpaceCells = function () {
                        if (this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell.clear();
                            this._emptySpaceHeaderCell = null;
                        }
                        if (this._emptyFooterSpaceCell) {
                            this._emptyFooterSpaceCell.clear();
                            this._emptyFooterSpaceCell = null;
                        }
                    };
                    TablixGrid.prototype.onStartRenderingSession = function (clear) {
                        if (clear) {
                            this.clearRows();
                            this.clearColumns();
                        }
                    };
                    TablixGrid.prototype.onStartRenderingIteration = function () {
                        this.initializeRows();
                        this.initializeColumns();
                    };
                    TablixGrid.prototype.onEndRenderingIteration = function () {
                        var rows = this._rows;
                        if (rows !== undefined) {
                            var rowCount = rows.length;
                            for (var i = 0; i < rowCount; i++) {
                                rows[i].releaseUnusedCells(this._owner);
                            }
                        }
                        if (this._footerRow) {
                            this._footerRow.releaseUnusedCells(this._owner);
                        }
                    };
                    TablixGrid.prototype.getOrCreateRow = function (rowIndex) {
                        var currentRow = this._rows[rowIndex];
                        if (currentRow === undefined) {
                            currentRow = new TablixRow(this._presenter.createRowPresenter());
                            currentRow.initialize(this);
                            this._presenter.onAppendRow(currentRow);
                            this._rows[rowIndex] = currentRow;
                        }
                        if (this._realizedRows[rowIndex] === undefined) {
                            this._realizedRows[rowIndex] = currentRow;
                        }
                        return currentRow;
                    };
                    TablixGrid.prototype.getOrCreateFootersRow = function () {
                        if (this._footerRow === null) {
                            this._footerRow = new TablixRow(this._presenter.createRowPresenter());
                            this._footerRow.initialize(this);
                            this._presenter.onAddFooterRow(this._footerRow);
                        }
                        return this._footerRow;
                    };
                    TablixGrid.prototype.moveRowsToEnd = function (moveFromIndex, count) {
                        for (var i = 0; i < count; i++) {
                            var row = this._rows[i + moveFromIndex];
                            debug.assertValue(row, "Invalid Row Index");
                            this._presenter.onRemoveRow(row);
                            this._presenter.onAppendRow(row);
                            this._rows.push(row);
                        }
                        this._rows.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveRowsToStart = function (moveToIndex, count) {
                        var refRow = this._rows[moveToIndex];
                        debug.assertValue(refRow, "Invalid Row Index");
                        for (var i = 0; i < count; i++) {
                            var row = this._rows.pop();
                            this._presenter.onRemoveRow(row);
                            this._presenter.onInsertRowBefore(row, refRow);
                            this._rows.splice(moveToIndex + i, 0, row);
                        }
                    };
                    TablixGrid.prototype.moveColumnsToEnd = function (moveFromIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToEnd(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns[i + moveFromIndex];
                            //Debug.assertValue(column, "Invalid Column Index");
                            this._columns.push(column);
                        }
                        this._columns.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveColumnsToStart = function (moveToIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToStart(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns.pop();
                            this._columns.splice(moveToIndex + i, 0, column);
                        }
                    };
                    TablixGrid.prototype.getOrCreateColumn = function (columnIndex) {
                        var currentColumn = this._columns[columnIndex];
                        if (currentColumn === undefined) {
                            currentColumn = new TablixColumn(this._presenter.createColumnPresenter(columnIndex), columnIndex);
                            currentColumn.initialize(this);
                            this._columns[columnIndex] = currentColumn;
                        }
                        if (this._realizedColumns[columnIndex] === undefined) {
                            this._realizedColumns[columnIndex] = currentColumn;
                        }
                        return currentColumn;
                    };
                    TablixGrid.prototype.initializeColumns = function () {
                        if (!this._columns)
                            this._columns = [];
                        var length = this._columns.length;
                        for (var i = 0; i < length; i++) {
                            this._columns[i].initialize(this);
                        }
                        this._realizedColumns = [];
                    };
                    TablixGrid.prototype.clearColumns = function () {
                        this._columns = null;
                        this._realizedColumns = null;
                    };
                    TablixGrid.prototype.initializeRows = function () {
                        // make sure rowDimension confirms it and it's not null in the grid
                        var hasFooter = this._owner.rowDimension.hasFooter() && (this._footerRow !== null);
                        this._realizedRows = [];
                        if (!this._rows) {
                            this._rows = [];
                        }
                        var rows = this._rows;
                        var length = rows.length;
                        for (var i = 0; i < length; i++) {
                            rows[i].initialize(this);
                        }
                        if (hasFooter) {
                            if (!this._footerRow) {
                                this.getOrCreateFootersRow();
                            }
                            this._footerRow.initialize(this);
                        }
                    };
                    TablixGrid.prototype.clearRows = function () {
                        var rows = this._rows;
                        if (rows) {
                            var length_1 = rows.length;
                            for (var i = 0; i < length_1; i++) {
                                rows[i].releaseAllCells(this._owner);
                            }
                            if (this._footerRow)
                                this._footerRow.releaseAllCells(this._owner);
                            this._presenter.onClear();
                            this._footerRow = null;
                            this._rows = null;
                            this._realizedRows = null;
                        }
                    };
                    TablixGrid.prototype.getWidth = function () {
                        return this._presenter.getWidth();
                    };
                    TablixGrid.prototype.getHeight = function () {
                        return this._presenter.getHeight();
                    };
                    return TablixGrid;
                }());
                internal.TablixGrid = TablixGrid;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var PixelConverter = jsCommon.PixelConverter;
                /**
                 * This class is used for layouts that don't or cannot
                 * rely on DOM measurements.  Instead they compute all required
                 * widths and heights and store it in this structure.
                 */
                var SizeComputationManager = (function () {
                    function SizeComputationManager() {
                    }
                    Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
                        get: function () {
                            return this._viewport ? this._viewport.width : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
                        get: function () {
                            return this._viewport ? this._viewport.height : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
                        get: function () {
                            return this.visibleWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
                        get: function () {
                            return this.visibleHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
                        get: function () {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
                        get: function () {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SizeComputationManager.prototype.updateColumnCount = function (columnCount) {
                        this._columnCount = columnCount;
                    };
                    SizeComputationManager.prototype.updateRowHeight = function (rowHeight) {
                        this._cellHeight = rowHeight;
                    };
                    SizeComputationManager.prototype.updateScalingFactor = function (scalingFactor) {
                        this._scalingFactor = scalingFactor;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                    };
                    SizeComputationManager.prototype.updateViewport = function (viewport) {
                        this._viewport = viewport;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                        this._cellHeight = this.computeColumnHeight();
                    };
                    SizeComputationManager.prototype.computeColumnWidth = function (totalColumnCount) {
                        var scalingFactor = this._scalingFactor;
                        if (!scalingFactor)
                            scalingFactor = 1;
                        var minimumColumnWidth = scalingFactor * SizeComputationManager.TablixMinimumColumnWidth;
                        var maxAllowedColumns = Math.floor(this._viewport.width / minimumColumnWidth);
                        return this.fitToColumnCount(maxAllowedColumns, totalColumnCount);
                    };
                    SizeComputationManager.prototype.computeColumnHeight = function () {
                        if (!this.hasImageContent)
                            return this._cellHeight;
                        var width = this._viewport.width;
                        if (width <= 250) {
                            // Small
                            return 20;
                        }
                        else if (width <= 510) {
                            // Medium
                            return 51;
                        }
                        else if (width <= 770) {
                            // Large
                            return 52;
                        }
                        debug.assertFail("Fixed size is only for viewport up to 770px width.");
                    };
                    SizeComputationManager.prototype.fitToColumnCount = function (maxAllowedColumnCount, totalColumnCount) {
                        var columnsToFit = Math.min(maxAllowedColumnCount, totalColumnCount);
                        return Math.floor(this._viewport.width / columnsToFit);
                    };
                    // Minimum size for a column, used to calculate layout
                    SizeComputationManager.TablixMinimumColumnWidth = 75;
                    return SizeComputationManager;
                }());
                internal.SizeComputationManager = SizeComputationManager;
                var DimensionLayoutManager = (function () {
                    function DimensionLayoutManager(owner, grid, realizationManager) {
                        //debug.assertValue(realizationManager, "Realization Manager must be defined");
                        this._owner = owner;
                        this._grid = grid;
                        this._lastScrollOffset = null;
                        this._isScrolling = false;
                        this._fixedSizeEnabled = true;
                        this._done = false;
                        this._realizationManager = realizationManager;
                    }
                    Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
                        get: function () {
                            return this._realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
                        get: function () {
                            return this._fixedSizeEnabled;
                        },
                        set: function (enable) {
                            this._fixedSizeEnabled = enable;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onCornerCellRealized = function (item, cell, leaf) {
                        this._realizationManager.onCornerCellRealized(item, cell);
                    };
                    DimensionLayoutManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        this._realizationManager.onHeaderRealized(item, cell, leaf);
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizationManager.needsToRealize;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getVisibleSizeRatio = function () {
                        return 1 - this.dimension.getFractionScrollOffset();
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
                        get: function () {
                            return this._alignToEnd;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "done", {
                        get: function () {
                            return this._done;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype._requiresMeasure = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._requiresMeasure");
                        return true;
                    };
                    DimensionLayoutManager.prototype.startScrollingSession = function () {
                        this._isScrolling = true;
                    };
                    DimensionLayoutManager.prototype.endScrollingSession = function () {
                        this._isScrolling = false;
                    };
                    DimensionLayoutManager.prototype.isScrolling = function () {
                        return this._isScrolling;
                    };
                    DimensionLayoutManager.prototype.isResizing = function () {
                        return false;
                    };
                    DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function () {
                        var otherDimension = this.dimension.otherDimension;
                        var count = otherDimension.getDepth();
                        var contextualHeight = 0;
                        var items = this._getRealizedItems();
                        if (items.length > 0) {
                            for (var i = 0; i < count; i++) {
                                contextualHeight += items[i].getContextualWidth();
                            }
                        }
                        return contextualHeight;
                    };
                    DimensionLayoutManager.prototype._isAutoSized = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._isAutoSized");
                        return false;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingSession = function () {
                        this._measureEnabled = this._requiresMeasure();
                        this._gridOffset = this.dimension.otherDimension.getDepth();
                    };
                    DimensionLayoutManager.prototype.onEndRenderingSession = function () {
                        this._realizationManager.onEndRenderingSession();
                        this._alignToEnd = false;
                        this._done = false;
                        this._measureEnabled = true;
                        this._sendDimensionsToControl();
                    };
                    /**
                     * Implementing classes must override this to send dimentions to TablixControl.
                     */
                    DimensionLayoutManager.prototype._sendDimensionsToControl = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._sendDimensionsToControl");
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
                        get: function () {
                            return this._measureEnabled;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getFooterContextualWidth = function () {
                        return 0;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingIteration = function (clear, contextualWidth) {
                        if (this._measureEnabled && !this._done) {
                            this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth();
                        }
                        this._realizationManager.onStartRenderingIteration();
                        if (clear) {
                            this._lastScrollOffset = null;
                        }
                        else if (this._lastScrollOffset !== null) {
                            this.swapElements();
                        }
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
                        get: function () {
                            return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || this.dimension.getItemsCount() === 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onEndRenderingIteration = function () {
                        if (this._done) {
                            return;
                        }
                        if (!this._measureEnabled) {
                            this._lastScrollOffset = this.dimension.scrollOffset;
                            this._done = true;
                            return;
                        }
                        var gridContextualWidth = this.getGridContextualWidth();
                        var filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                        var allRealized = this.allItemsRealized;
                        var newScrollOffset;
                        if (filled) {
                            newScrollOffset = this.scrollForwardToAlignEnd(gridContextualWidth);
                        }
                        else {
                            newScrollOffset = this.scrollBackwardToFill(gridContextualWidth);
                        }
                        this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
                        var originalScrollbarVisible = this.dimension.scrollbar.visible;
                        this.updateScrollbar(gridContextualWidth);
                        this._done = (filled || allRealized) &&
                            this.dimension.scrollbar.visible === originalScrollbarVisible &&
                            powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                        this.dimension.scrollOffset = newScrollOffset;
                        this._lastScrollOffset = this.dimension.scrollOffset;
                    };
                    DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function () {
                        if (this._lastScrollOffset !== null) {
                            var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
                            if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) {
                                return delta;
                            }
                        }
                        return null;
                    };
                    DimensionLayoutManager.prototype.swapElements = function () {
                        var delta = this.getScrollDeltaWithinPage();
                        if (delta !== null) {
                            var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
                            if (Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth) {
                                if (delta > 0) {
                                    this._moveElementsToBottom(otherHierarchyDepth, delta);
                                }
                                else if (delta < 0) {
                                    this._moveElementsToTop(otherHierarchyDepth, -delta);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype._getRealizedItems = function () {
                        // abstract
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._getRealizedItems");
                        return null;
                    };
                    DimensionLayoutManager.prototype.getRealizedItemsCount = function () {
                        var realizedItems = this._getRealizedItems();
                        return realizedItems.length;
                    };
                    DimensionLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToBottom");
                    };
                    DimensionLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToTop");
                    };
                    DimensionLayoutManager.prototype.isScrollingWithinPage = function () {
                        return this.getScrollDeltaWithinPage() !== null;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidth = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridContextualWidth");
                        return 0;
                    };
                    DimensionLayoutManager.prototype.updateScrollbar = function (gridContextualWidth) {
                        var scrollbar = this.dimension.scrollbar;
                        scrollbar.viewMin = this.dimension.scrollOffset;
                        scrollbar.min = 0;
                        scrollbar.max = this.dimension.getItemsCount();
                        scrollbar.viewSize = this.getViewSize(gridContextualWidth);
                        this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
                    };
                    DimensionLayoutManager.prototype.getViewSize = function (gridContextualWidth) {
                        var count = this.getRealizedItemsCount();
                        if (count === 0)
                            return 0;
                        var startIndex = this._gridOffset;
                        var sizeInItems = 0;
                        var sizeInPixels = 0;
                        var widthToFill = this._contextualWidthToFill;
                        var scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight();
                        var error = this.getMeaurementError(gridContextualWidth);
                        for (var i = startIndex; i < count; i++) {
                            var visibleRatio = void 0;
                            if (i === startIndex) {
                                visibleRatio = this.getVisibleSizeRatio();
                            }
                            else
                                visibleRatio = 1;
                            var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
                            sizeInPixels += itemContextualWidth;
                            sizeInItems += visibleRatio;
                            if (powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
                                sizeInItems -= ((sizeInPixels - scrollableArea) / itemContextualWidth) * visibleRatio;
                                break;
                            }
                        }
                        return sizeInItems;
                    };
                    DimensionLayoutManager.prototype.isScrollableHeader = function (item, items, index) {
                        if (index !== 0 || this.dimension.getFractionScrollOffset() === 0) {
                            return false;
                        }
                        var hierarchyNavigator = this.dimension._hierarchyNavigator;
                        if (hierarchyNavigator.isLeaf(item)) {
                            return true;
                        }
                        var currentItem = item;
                        var currentItems = items;
                        do {
                            currentItems = hierarchyNavigator.getChildren(currentItem);
                            currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1);
                            if (currentItem === undefined) {
                                break;
                            }
                            if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) {
                                return false;
                            }
                        } while (!hierarchyNavigator.isLeaf(currentItem));
                        return true;
                    };
                    DimensionLayoutManager.prototype.reachedEnd = function () {
                        return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    };
                    DimensionLayoutManager.prototype.scrollBackwardToFill = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this.reachedEnd()) {
                            var widthToFill = this._contextualWidthToFill - gridContextualWidth;
                            if (this.dimension.getItemsCount() > 0) {
                                var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
                                newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - (widthToFill / averageColumnwidth)));
                            }
                            this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision); // this is an aproximate scrolling back, we have to ensure it is aligned to the end of the control
                        }
                        return newScrollOffset;
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidth = function (index) {
                        var realizedItems = this._getRealizedItems();
                        if (index >= realizedItems.length)
                            return null;
                        return realizedItems[index].getContextualWidth();
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function (index) {
                        return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
                    };
                    DimensionLayoutManager.prototype.getSizeWithScrolling = function (size, index) {
                        var ratio;
                        if (this._gridOffset === index) {
                            ratio = this.getVisibleSizeRatio();
                        }
                        else {
                            ratio = 1;
                        }
                        return size * ratio;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function () {
                        var count = this.getRealizedItemsCount();
                        var contextualWidth = 0;
                        for (var i = 0; i < count; i++) {
                            contextualWidth += this.getItemContextualWidthWithScrolling(i);
                        }
                        return contextualWidth;
                    };
                    DimensionLayoutManager.prototype.getMeaurementError = function (gridContextualWidth) {
                        return gridContextualWidth / this.getGridContextualWidthFromItems();
                    };
                    DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this._alignToEnd) {
                            var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                            if (!withinThreshold) {
                                var count = this.getRealizedItemsCount();
                                var startIndex = this._gridOffset;
                                var widthToScroll = gridContextualWidth - this._contextualWidthToFill;
                                var error = this.getMeaurementError(gridContextualWidth);
                                for (var i = startIndex; i < count; i++) {
                                    var itemContextualWidth = this.getItemContextualWidth(i) * error;
                                    if (powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
                                        widthToScroll -= itemContextualWidth;
                                    }
                                    else {
                                        var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
                                        newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + (widthToScroll * visibleRatio / itemContextualWidth));
                                        break;
                                    }
                                }
                            }
                            this._alignToEnd = !withinThreshold;
                        }
                        return newScrollOffset;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.dimension");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
                        get: function () {
                            return this.dimension.otherDimension.layoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
                        get: function () {
                            return this._contextualWidthToFill;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getGridScale = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridScale");
                        return 0;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.otherScrollbarContextualWidth");
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getActualContextualWidth = function (gridContextualWidth) {
                        if (this._isAutoSized() && !this.canScroll(gridContextualWidth))
                            return gridContextualWidth;
                        return this._contextualWidthToFill;
                    };
                    DimensionLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.canScroll");
                        return false;
                    };
                    DimensionLayoutManager.prototype.calculateSizes = function () {
                        if (this.fixedSizeEnabled) {
                            this.calculateContextualWidths();
                            this.calculateSpans();
                        }
                    };
                    DimensionLayoutManager.prototype._calculateSize = function (item) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._calculateSize");
                        return null;
                    };
                    DimensionLayoutManager.prototype.calculateContextualWidths = function () {
                        var items = this._getRealizedItems();
                        var count = items.length;
                        for (var i = 0; i < count; i++) {
                            var item = items[i];
                            if (this.measureEnabled)
                                item.setAligningContextualWidth(-1);
                            this._calculateSize(item);
                        }
                    };
                    DimensionLayoutManager.prototype.calculateSpans = function () {
                        if (this.measureEnabled) {
                            this.updateNonScrollableItemsSpans();
                            this.updateScrollableItemsSpans();
                        }
                        // TODO override in row layout manager to add footer to calculation, this is required for Matrix
                    };
                    DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function () {
                        var otherDimensionItems = this.otherLayoutManager._getRealizedItems();
                        var otherDimensionItemsCount = otherDimensionItems.length;
                        var startIndex = this.dimension.getDepth();
                        for (var i = startIndex; i < otherDimensionItemsCount; i++) {
                            var otherDimensionItem = otherDimensionItems[i];
                            this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.updateScrollableItemsSpans = function () {
                        var otherRealizedItems = this.otherLayoutManager._getRealizedItems();
                        var otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length);
                        for (var i = 0; i < otherRealizedItemsCount; i++) {
                            var otherRealizedItem = otherRealizedItems[i];
                            this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.fixSizes = function () {
                        if (this.fixedSizeEnabled) {
                            var items = this._getRealizedItems();
                            var count = items.length;
                            for (var i = 0; i < count; i++) {
                                items[i].fixSize();
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateSpans = function (otherRealizedItem, cells) {
                        var realizedItems = this._getRealizedItems();
                        var cellCount = cells.length;
                        for (var j = 0; j < cellCount; j++) {
                            var cell = cells[j];
                            var owner = otherRealizedItem.getOtherDimensionOwner(cell);
                            var span = owner.getCellContextualSpan(cell);
                            if (span > 1) {
                                var totalSizeInSpan = 0;
                                var startIndex = owner.getIndex(this._grid);
                                for (var k = 0; k < span; k++) {
                                    var item = realizedItems[k + startIndex];
                                    totalSizeInSpan += item.getContentContextualWidth();
                                    if (k === span - 1)
                                        this.updateLastChildSize(cell, item, totalSizeInSpan);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateLastChildSize = function (spanningCell, item, totalSpanSize) {
                        var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
                        if (delta > 0)
                            item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
                    };
                    DimensionLayoutManager._pixelPrecision = 1.0001;
                    DimensionLayoutManager._scrollOffsetPrecision = 0.01;
                    return DimensionLayoutManager;
                }());
                internal.DimensionLayoutManager = DimensionLayoutManager;
                var ResizeState = (function () {
                    function ResizeState(column, width, scale) {
                        this.column = column;
                        this.item = column.getLeafItem();
                        this.itemType = column.itemType;
                        this.startColumnWidth = width;
                        this.resizingDelta = 0;
                        this.animationFrame = null;
                        this.scale = scale;
                    }
                    ResizeState.prototype.getNewSize = function () {
                        return this.startColumnWidth + this.resizingDelta;
                    };
                    return ResizeState;
                }());
                internal.ResizeState = ResizeState;
                var ColumnLayoutManager = (function (_super) {
                    __extends(ColumnLayoutManager, _super);
                    function ColumnLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                        this.fillProportionally = false;
                        this._resizeState = null;
                    }
                    Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.columnDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.isResizing = function () {
                        return this._resizeState !== null;
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
                        get: function () {
                            return this._grid.fillColumnsProportionally;
                        },
                        set: function (value) {
                            this._grid.fillColumnsProportionally = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioX();
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype._getRealizedItems = function () {
                        if (!this._grid.realizedColumns) {
                            this._grid.realizedColumns = [];
                        }
                        return this._grid.realizedColumns;
                    };
                    ColumnLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveColumnsToEnd(moveFromIndex, count);
                    };
                    ColumnLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveColumnsToStart(moveToIndex, count);
                    };
                    ColumnLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension or is scrolling or is resizing
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling()) || this.isScrolling() || this.isResizing();
                    };
                    ColumnLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getWidth();
                    };
                    ColumnLayoutManager.prototype.getFirstVisibleColumn = function () {
                        return this._grid.realizedColumns[this._gridOffset];
                    };
                    ColumnLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeWidth;
                    };
                    ColumnLayoutManager.prototype.applyScrolling = function () {
                        var columnOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleColumnWidth = 0;
                        if (columnOffset !== 0) {
                            var firstVisibleColumn = this.getFirstVisibleColumn();
                            if (firstVisibleColumn !== undefined) {
                                firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth();
                                this.scroll(firstVisibleColumn, firstVisibleColumnWidth, columnOffset);
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.scroll = function (firstVisibleColumn, width, offset) {
                        this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset);
                        this.scrollBodyCells(this._grid.realizedRows, width, offset);
                        if (firstVisibleColumn.footer !== null) {
                            firstVisibleColumn.footer.scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollCells = function (cells, width, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollBodyCells = function (rows, width, offset) {
                        var length = rows.length;
                        var cells;
                        var cell;
                        for (var i = 0; i < length; i++) {
                            cells = rows[i]._realizedBodyCells;
                            if (cells !== undefined) {
                                cell = cells[0];
                                if (cell !== undefined) {
                                    cell.scrollHorizontally(width, offset);
                                }
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.onStartResize = function (cell, currentX, currentY) {
                        this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
                    };
                    ColumnLayoutManager.prototype.onResize = function (cell, deltaX, deltaY) {
                        var _this = this;
                        if (this.isResizing()) {
                            this._resizeState.resizingDelta = Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth);
                            if (this._resizeState.animationFrame === null)
                                this._resizeState.animationFrame = requestAnimationFrame(function () { return _this.performResizing(); });
                        }
                    };
                    ColumnLayoutManager.prototype.onEndResize = function (cell) {
                        if (this.isResizing() && this._resizeState.animationFrame !== null) {
                            this.performResizing(); // if we reached the end and we are still waiting for the last animation frame, perform the pending resizing and clear the state 
                        }
                        this.endResizing();
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.onReset = function (cell) {
                        this._resizeState = new ResizeState(cell._column, -1, 1);
                        cell._column.clearSize();
                        this.endResizing();
                        this.owner.owner.refresh(false);
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.updateItemToResizeState = function (realizedColumns) {
                        if (this._resizeState === null)
                            return;
                        var columnCount = realizedColumns.length;
                        var hierarchyNavigator = this.owner.owner.hierarchyNavigator;
                        // Only iterate over the columns that belong to column hierachy (i.e. skip the row hierarchy rows)
                        // as this post-rendering adjustment only applies to them.
                        var startIndex = this.otherLayoutManager.dimension.getDepth();
                        for (var i = startIndex; i < columnCount; i++) {
                            var column = realizedColumns[i];
                            if (!column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator))
                                continue;
                            if (column !== this._resizeState.column) {
                                this._resizeState.column = column;
                                column.onResize(this._resizeState.getNewSize());
                                break;
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.performResizing = function () {
                        if (this._resizeState === null)
                            return;
                        this._resizeState.animationFrame = null;
                        var newSize = this._resizeState.getNewSize();
                        this._resizeState.column.onResize(newSize);
                        this.owner.owner.refresh(false);
                    };
                    ColumnLayoutManager.prototype.endResizing = function () {
                        if (this._resizeState === null)
                            return;
                        var newSize = this._resizeState.getNewSize();
                        this._resizeState.column.onResizeEnd(newSize);
                    };
                    /**
                     * Sends column related data (pixel size, column count, etc) to TablixControl.
                     */
                    ColumnLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale(); // in case of canvas we have to convert the size from device pixel to css pixel
                        this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
                    };
                    ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedBodyCellWidth");
                        return -1;
                    };
                    ColumnLayoutManager.minColumnWidth = 10;
                    return ColumnLayoutManager;
                }(DimensionLayoutManager));
                internal.ColumnLayoutManager = ColumnLayoutManager;
                var DashboardColumnLayoutManager = (function (_super) {
                    __extends(DashboardColumnLayoutManager, _super);
                    function DashboardColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        if (this.ignoreColumn(headerIndex))
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardColumnLayoutManager.prototype._calculateSize = function (item) {
                        var headerIndex = item.getIndex(this._grid);
                        var computedSize = 0;
                        if (!this.ignoreColumn(headerIndex)) {
                            // for dashboard layout it does not matter whether we pass an actual cell or not
                            computedSize = this.owner.getContentWidth(undefined);
                        }
                        item.onResize(computedSize);
                        item.onResizeEnd(computedSize);
                        return computedSize;
                    };
                    DashboardColumnLayoutManager.prototype.ignoreColumn = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        return headerIndex === 0 && !this.owner.binder.hasRowGroups();
                    };
                    return DashboardColumnLayoutManager;
                }(ColumnLayoutManager));
                internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
                var CanvasColumnLayoutManager = (function (_super) {
                    __extends(CanvasColumnLayoutManager, _super);
                    function CanvasColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        return this.owner.getEstimatedTextWidth(content);
                    };
                    CanvasColumnLayoutManager.prototype.calculateContextualWidths = function () {
                        var items = this._getRealizedItems();
                        var columnWidths = [];
                        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                            var item = items_1[_i];
                            if (this.measureEnabled)
                                item.setAligningContextualWidth(-1);
                            columnWidths.push(this._calculateSize(item));
                        }
                        // Save all column widths. Needed when user turns off auto-sizing for column widths.
                        this.owner.columnWidthsToPersist = columnWidths;
                    };
                    CanvasColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasColumnLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    return CanvasColumnLayoutManager;
                }(ColumnLayoutManager));
                internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
                var RowLayoutManager = (function (_super) {
                    __extends(RowLayoutManager, _super);
                    function RowLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                    }
                    Object.defineProperty(RowLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.rowDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioY();
                    };
                    Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.startScrollingSession = function () {
                        _super.prototype.startScrollingSession.call(this);
                    };
                    RowLayoutManager.prototype._getRealizedItems = function () {
                        if (!this._grid.realizedRows) {
                            this._grid.realizedRows = [];
                        }
                        return this._grid.realizedRows;
                    };
                    RowLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveRowsToEnd(moveFromIndex, count);
                    };
                    RowLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveRowsToStart(moveToIndex, count);
                    };
                    RowLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension and the column dimension is not resizing or row dimension is scrolling and reaching the end while scrolling 
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing())
                            || (this.isScrolling() && (this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount()));
                    };
                    RowLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getHeight();
                    };
                    RowLayoutManager.prototype.getFirstVisibleRow = function () {
                        return this._grid.realizedRows[this._gridOffset];
                    };
                    RowLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeHeight;
                    };
                    RowLayoutManager.prototype.applyScrolling = function () {
                        var rowOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleRowHeight = 0;
                        if (rowOffset !== 0) {
                            var firstVisibleRow = this.getFirstVisibleRow();
                            if (firstVisibleRow) {
                                firstVisibleRowHeight = firstVisibleRow.getContextualWidth();
                                this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset);
                            }
                        }
                    };
                    RowLayoutManager.prototype.scroll = function (firstVisibleRow, height, offset) {
                        this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset);
                        this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
                    };
                    RowLayoutManager.prototype.scrollCells = function (cells, height, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollVertically(height, offset);
                        }
                    };
                    RowLayoutManager.prototype.getFooterContextualWidth = function () {
                        if (this.owner.owner.rowDimension.hasFooter()) {
                            if (this.owner.grid.footerRow) {
                                return this.owner.grid.footerRow.getContextualWidth();
                            }
                        }
                        return 0;
                    };
                    RowLayoutManager.prototype.calculateContextualWidths = function () {
                        _super.prototype.calculateContextualWidths.call(this);
                        if (this.fixedSizeEnabled) {
                            var footerRow = this._grid.footerRow;
                            if (footerRow) {
                                this._calculateSize(footerRow);
                            }
                        }
                    };
                    RowLayoutManager.prototype.fixSizes = function () {
                        _super.prototype.fixSizes.call(this);
                        if (this.fixedSizeEnabled) {
                            if (this._grid.footerRow) {
                                this._grid.footerRow.fixSize();
                            }
                        }
                    };
                    /**
                     * Sends row related data (pixel size, column count, etc) to TablixControl.
                     */
                    RowLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale();
                        this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), (this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0));
                    };
                    RowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: RowLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    return RowLayoutManager;
                }(DimensionLayoutManager));
                internal.RowLayoutManager = RowLayoutManager;
                var DashboardRowLayoutManager = (function (_super) {
                    __extends(DashboardRowLayoutManager, _super);
                    function DashboardRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        return this.getHeaderWidth(headerIndex);
                    };
                    DashboardRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardRowLayoutManager.prototype._calculateSize = function (item) {
                        var computedSize = this.owner.getEstimatedRowHeight();
                        item.onResize(computedSize);
                        return computedSize;
                    };
                    DashboardRowLayoutManager.prototype.getHeaderWidth = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        if (headerIndex === 0 && !this.owner.binder.hasRowGroups())
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual text or not
                        return this.owner.getEstimatedTextWidth(undefined);
                    };
                    return DashboardRowLayoutManager;
                }(RowLayoutManager));
                internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
                var CanvasRowLayoutManager = (function (_super) {
                    __extends(CanvasRowLayoutManager, _super);
                    function CanvasRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasRowLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    return CanvasRowLayoutManager;
                }(RowLayoutManager));
                internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
                var TablixLayoutManager = (function () {
                    function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
                        this._allowHeaderResize = true;
                        this._binder = binder;
                        this._grid = grid;
                        this._columnLayoutManager = columnLayoutManager;
                        this._rowLayoutManager = rowLayoutManager;
                        this._columnWidthsToPersist = [];
                    }
                    TablixLayoutManager.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._container = owner.container;
                        this._gridHost = owner.contentHost;
                        this._footersHost = owner.footerHost;
                        this._grid.initialize(owner, this._gridHost, this._footersHost);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnWidthsToPersist", {
                        get: function () {
                            return this._columnWidthsToPersist;
                        },
                        set: function (columnWidths) {
                            this._columnWidthsToPersist = columnWidths;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.getTablixClassName = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getTablixClassName");
                        return null;
                    };
                    TablixLayoutManager.prototype.getLayoutKind = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getLayoutKind");
                        // TODO ckerer: this method should not be necessary when we are done refactoring!
                        return null;
                    };
                    TablixLayoutManager.prototype.getOrCreateColumnHeader = function (item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        var isLeaf = this.owner.hierarchyNavigator.isLeaf(item);
                        var cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf);
                        var rowIdx = this.owner.hierarchyNavigator.getLevel(item);
                        cell.position.row.index = rowIdx;
                        cell.position.row.isFirst = rowIdx === 0;
                        cell.position.row.isLast = isLeaf;
                        var colIdx = this.owner.hierarchyNavigator.getIndex(item);
                        cell.position.column.index = colIdx;
                        cell.position.column.isFirst = this.owner.hierarchyNavigator.areAllParentsFirst(item, items);
                        cell.position.column.isLast = this.owner.hierarchyNavigator.areAllParentsLast(item, items);
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateRowHeader = function (item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex);
                        var isLeaf = this.owner.hierarchyNavigator.isLeaf(item);
                        var scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
                        if (row.getRealizedCellCount() === 0) {
                            this.alignRowHeaderCells(item, row);
                        }
                        var cell = row.getOrCreateRowHeader(column, scrollable, this.owner.hierarchyNavigator.isLeaf(item));
                        var rowIdx = this.owner.hierarchyNavigator.getIndex(item);
                        cell.position.row.index = rowIdx;
                        cell.position.row.isFirst = this.owner.hierarchyNavigator.areAllParentsFirst(item, items);
                        cell.position.row.isLast = this.owner.hierarchyNavigator.areAllParentsLast(item, items);
                        var colIdx = this.owner.hierarchyNavigator.getLevel(item);
                        cell.position.column.index = colIdx;
                        cell.position.column.isFirst = colIdx === 0;
                        cell.position.column.isLast = isLeaf;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateCornerCell = function (item, rowLevel, columnLevel) {
                        var row = this._grid.getOrCreateRow(columnLevel);
                        var column = this._grid.getOrCreateColumn(rowLevel);
                        var columnDepth = this._columnLayoutManager.dimension.getDepth();
                        var isLeaf = columnLevel === (columnDepth - 1);
                        var cell = row.getOrCreateCornerCell(column);
                        var rowIdx = columnLevel;
                        cell.position.row.index = rowIdx;
                        cell.position.row.isFirst = rowIdx === 0;
                        cell.position.row.isLast = isLeaf;
                        var colIdx = rowLevel;
                        cell.position.column.index = colIdx;
                        cell.position.column.isFirst = colIdx === 0;
                        cell.position.column.isLast = colIdx === this._rowLayoutManager.dimension.getDepth() - 1;
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateBodyCell = function (cellItem, rowItem, rowItems, rowIndex, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        if (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0) {
                            scrollable = true;
                        }
                        else {
                            scrollable = this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
                        }
                        var cell = row.getOrCreateBodyCell(column, scrollable);
                        cell.position = cellItem.position;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function (cellItem, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        scrollable = (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0);
                        var cell = row.getOrCreateFooterBodyCell(column, scrollable);
                        cell.position = cellItem.position;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function (item, items) {
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(0);
                        //debug.assert(this.owner.hierarchyNavigator.isLeaf(item), "Leaf item expected");
                        var cell = row.getOrCreateFooterRowHeader(column);
                        cell.position = undefined;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getVisibleWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getVisibleHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateColumnCount");
                    };
                    TablixLayoutManager.prototype.updateViewport = function (viewport) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateViewport");
                    };
                    TablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedRowHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getCellWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getContentWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getContentWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
                        // default implementation has no adjustment
                    };
                    /**
                     * This call makes room for parent header cells where neccessary.
                     * Since HTML cells that span vertically displace other rows,
                     * room has to be made for spanning headers that leave an exiting
                     * row to enter the new row that it starts from and removed when
                     * returning to an entering row.
                     */
                    TablixLayoutManager.prototype.alignRowHeaderCells = function (item, currentRow) {
                        var index = currentRow.getRowHeaderLeafIndex();
                        if (index === -1) {
                            return;
                        }
                        var rowDimension = this._owner.rowDimension;
                        var leaf = rowDimension.getFirstVisibleChildLeaf(item);
                        if (!this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item)) {
                            return;
                        }
                        currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "grid", {
                        get: function () {
                            return this._grid;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
                        get: function () {
                            return this._rowLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
                        get: function () {
                            return this._columnLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.showEmptySpaceHeader");
                        return false;
                    };
                    TablixLayoutManager.prototype.onStartRenderingSession = function (scrollingDimension, parentElement, clear) {
                        if (this.showEmptySpaceHeader()) {
                            var cell = this._grid.emptySpaceHeaderCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceHeaderCell(cell);
                            }
                            cell = this._grid.emptySpaceFooterCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceFooterCell(cell);
                            }
                            this._grid.HideEmptySpaceCells();
                        }
                        this._scrollingDimension = scrollingDimension;
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.startScrollingSession();
                        }
                        this._rowLayoutManager.onStartRenderingSession();
                        this._columnLayoutManager.onStartRenderingSession();
                        this._grid.onStartRenderingSession(clear);
                        var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
                        if (measureEnabled)
                            this.measureSampleText(parentElement);
                    };
                    TablixLayoutManager.prototype.onEndRenderingSession = function () {
                        this._rowLayoutManager.onEndRenderingSession();
                        this._columnLayoutManager.onEndRenderingSession();
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.endScrollingSession();
                        }
                        this._scrollingDimension = null;
                        if (this.showEmptySpaceHeader()) {
                            var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
                            if (emptySpace > 0) {
                                this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
                                var cell = this._grid.emptySpaceHeaderCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceHeaderCell(cell);
                                }
                                cell = this._grid.emptySpaceFooterCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceFooterCell(cell);
                                }
                            }
                        }
                    };
                    TablixLayoutManager.prototype.onStartRenderingIteration = function (clear) {
                        this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight());
                        this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth());
                        this._grid.onStartRenderingIteration();
                    };
                    TablixLayoutManager.prototype.onEndRenderingIteration = function () {
                        this._grid.onEndRenderingIteration();
                        // ANDREMI: Comment out for static tablix
                        this._columnLayoutManager.calculateSizes(); // calculate the entire grid first without altering the tree to avoid multiple measure pass invoking
                        this._rowLayoutManager.calculateSizes();
                        this._columnLayoutManager.fixSizes(); // now assign the sizes
                        this._rowLayoutManager.fixSizes();
                        this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns); // if we are in a middle of a resize, the column to resize might have been swaped during the render, restore its resize state
                        this._columnLayoutManager.applyScrolling();
                        this._rowLayoutManager.applyScrolling();
                        this._columnLayoutManager.onEndRenderingIteration();
                        this._rowLayoutManager.onEndRenderingIteration();
                        return this._columnLayoutManager.done && this._rowLayoutManager.done;
                    };
                    TablixLayoutManager.prototype.onCornerCellRealized = function (item, cell) {
                        var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item);
                        var rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
                        if (columnLeaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf);
                        this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        var tablixCell = cell;
                        if (tablixCell.colSpan > 1)
                            tablixCell.setContentWidth(-1);
                        this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onColumnHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        if (leaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onBodyCellRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onBodyCellFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.setAllowHeaderResize = function (value) {
                        this._allowHeaderResize = value;
                    };
                    TablixLayoutManager.prototype.enableCellHorizontalResize = function (isLeaf, cell) {
                        var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
                        cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
                    };
                    TablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedTextWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.measureSampleText");
                    };
                    return TablixLayoutManager;
                }());
                internal.TablixLayoutManager = TablixLayoutManager;
                var DashboardTablixLayoutManager = (function (_super) {
                    __extends(DashboardTablixLayoutManager, _super);
                    function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
                        var dashboardColumnLayoutManager = new DashboardColumnLayoutManager(null, grid, columnRealizationManager);
                        var dashboardRowLayoutManager = new DashboardRowLayoutManager(null, grid, rowRealizationManager);
                        _super.call(this, binder, grid, dashboardColumnLayoutManager, dashboardRowLayoutManager);
                        dashboardColumnLayoutManager.owner = this;
                        dashboardRowLayoutManager.owner = this;
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixLayoutManager.createLayoutManager = function (binder) {
                        // computed sizes are shared between layout manager and grid presenter
                        var sizeComputationManager = new SizeComputationManager();
                        return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    DashboardTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "tablixDashboard";
                    };
                    DashboardTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 1 /* DashboardTile */;
                    };
                    DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return false;
                    };
                    DashboardTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        var textProperties = powerbi.TextMeasurementService.getSvgMeasurementProperties(parentElement);
                        this._characterHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                        this._sizeComputationManager.updateRowHeight(this._characterHeight);
                        var actualTextSize = PixelConverter.toPoint(parseFloat(textProperties.fontSize));
                        var scalingFactor = actualTextSize / controls.TablixDefaultTextSize;
                        this._sizeComputationManager.updateScalingFactor(powerbi.Double.toIncrement(scalingFactor, 0.05));
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleWidth = function () {
                        return this._sizeComputationManager.visibleWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleHeight = function () {
                        return this._sizeComputationManager.visibleHeight;
                    };
                    DashboardTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return this._sizeComputationManager.cellWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        // On the dashboard it does not matter what text we render, 
                        // we always use the same content width
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
                        this._sizeComputationManager.hasImageContent = hasImage;
                    };
                    DashboardTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // The total number of columns is the number (depth) of row groups + the number of (leaf) column group instances
                        var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0;
                        var columnInstances = columnDimension ? columnDimension.getItemsCount() : 0;
                        var totalColumnCount = rowDimensionDepth + columnInstances;
                        // Adjust the column count by the static row header (if any)
                        if (!this.binder.hasRowGroups())
                            totalColumnCount--;
                        this._sizeComputationManager.updateColumnCount(totalColumnCount);
                    };
                    DashboardTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        this._sizeComputationManager.updateViewport(viewport);
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this._characterHeight;
                    };
                    return DashboardTablixLayoutManager;
                }(TablixLayoutManager));
                internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
                var CanvasTablixLayoutManager = (function (_super) {
                    __extends(CanvasTablixLayoutManager, _super);
                    function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
                        var canvasColumnLayoutManager = new CanvasColumnLayoutManager(null, grid, columnRealizationManager);
                        var canvasRowLayoutManager = new CanvasRowLayoutManager(null, grid, rowRealizationManager);
                        _super.call(this, binder, grid, canvasColumnLayoutManager, canvasRowLayoutManager);
                        canvasColumnLayoutManager.owner = this;
                        canvasRowLayoutManager.owner = this;
                    }
                    CanvasTablixLayoutManager.createLayoutManager = function (binder, columnWidthManager) {
                        return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter(columnWidthManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    CanvasTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "tablixCanvas";
                    };
                    CanvasTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 0 /* Canvas */;
                    };
                    CanvasTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        // TODO: Use TextMeasurementService once the DOM methods are fixed (they are not working right now)
                        var textDiv = controls.internal.TablixUtils.createDiv();
                        textDiv.style.cssFloat = 'left';
                        textDiv.style.whiteSpace = 'nowrap';
                        textDiv.style.overflow = 'hidden';
                        textDiv.style.lineHeight = 'normal';
                        parentElement.appendChild(textDiv);
                        var textNode = document.createTextNode("a");
                        textDiv.appendChild(textNode);
                        this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv);
                        this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv);
                        textDiv.removeChild(textNode);
                        parentElement.removeChild(textDiv);
                    };
                    CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return !this._columnLayoutManager.fillProportionally;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleWidth = function () {
                        if (this._columnLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeWidth && this._owner.maxWidth) {
                                return this._owner.maxWidth;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementWidth(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleHeight = function () {
                        if (this._rowLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeHeight && this._owner.maxHeight) {
                                return this._owner.maxHeight;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementHeight(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function (text) {
                        return text ? text.length * this.characterWidth : 0;
                    };
                    CanvasTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this.characterHeight;
                    };
                    return CanvasTablixLayoutManager;
                }(TablixLayoutManager));
                internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var HTMLElementUtils;
            (function (HTMLElementUtils) {
                function clearChildren(element) {
                    if (!element) {
                        return;
                    }
                    while (element.hasChildNodes()) {
                        element.removeChild(element.firstChild);
                    }
                }
                HTMLElementUtils.clearChildren = clearChildren;
                function setElementTop(element, top) {
                    element.style.top = top + "px";
                }
                HTMLElementUtils.setElementTop = setElementTop;
                function setElementLeft(element, left) {
                    element.style.left = left + "px";
                }
                HTMLElementUtils.setElementLeft = setElementLeft;
                function setElementHeight(element, height) {
                    if (HTMLElementUtils.isAutoSize(height))
                        element.style.height = "";
                    else
                        element.style.height = height + "px";
                }
                HTMLElementUtils.setElementHeight = setElementHeight;
                function setElementWidth(element, width) {
                    if (HTMLElementUtils.isAutoSize(width))
                        element.style.width = "";
                    else
                        element.style.width = width + "px";
                }
                HTMLElementUtils.setElementWidth = setElementWidth;
                function getElementWidth(element) {
                    return element.offsetWidth;
                }
                HTMLElementUtils.getElementWidth = getElementWidth;
                function getElementHeight(element) {
                    return element.offsetHeight;
                }
                HTMLElementUtils.getElementHeight = getElementHeight;
                function isAutoSize(size) {
                    return size === -1;
                }
                HTMLElementUtils.isAutoSize = isAutoSize;
                function getAccumulatedScale(element) {
                    var scale = 1;
                    while (element) {
                        scale *= HTMLElementUtils.getScale(element);
                        element = element.parentElement;
                    }
                    return scale;
                }
                HTMLElementUtils.getAccumulatedScale = getAccumulatedScale;
                /**
                 * Get scale of element, return 1 when not scaled.
                 */
                function getScale(element) {
                    element = $(element);
                    var str = element.css('-webkit-transform') ||
                        element.css('-moz-transform') ||
                        element.css('-ms-transform') ||
                        element.css('-o-transform') ||
                        element.css('transform');
                    return (str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) ||
                        str.match(/\d+/) && Number(str.match(/\d+/)[0]))) || 1;
                }
                HTMLElementUtils.getScale = getScale;
            })(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var DomFactory = InJs.DomFactory;
                var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
                var TablixObjects;
                (function (TablixObjects) {
                    TablixObjects.ObjectGeneral = "general";
                    TablixObjects.ObjectGrid = "grid";
                    TablixObjects.ObjectColumnHeaders = "columnHeaders";
                    TablixObjects.ObjectRowHeaders = "rowHeaders";
                    TablixObjects.ObjectValues = "values";
                    TablixObjects.ObjectTotal = "total";
                    TablixObjects.ObjectSubTotals = "subTotals";
                    /**
                     * Represents a DataViewObjects property related to the Tablix
                     */
                    var TablixProperty = (function () {
                        /**
                         * Creates a new TablixProperty
                         * @param {string} objectName Object Name
                         * @param {string} propertyName Property Name
                         * @param {any} defaultValue Default value of the Property
                         * @param {ObjectValueGetterFunction} getterFuntion Function used to get the Property value from the Objects
                         */
                        function TablixProperty(objectName, propertyName, defaultValue, getterFuntion) {
                            this.objectName = objectName;
                            this.propertyName = propertyName;
                            this.defaultValue = defaultValue;
                            this.getterFuntion = getterFuntion;
                        }
                        /**
                         * Gets the PropertyIdentifier for the Property
                         * @returns PropertyIdentifier for the Property
                         */
                        TablixProperty.prototype.getPropertyID = function () {
                            return { objectName: this.objectName, propertyName: this.propertyName };
                        };
                        /**
                         * Gets the value of the Property from the Objects
                         * @param {DataViewObjects} objects DataView Objects to get the value from
                         * @param {boolean} useDefault True to fall back to the Default value if the Property is missing from the objects. False to return undefined
                         * @returns Value of the property
                         */
                        TablixProperty.prototype.getValue = function (objects, useDefault) {
                            // We use this when we intend to have undefined for missing properties. Useful in letting styles fallback to CSS if not defined
                            if (useDefault === false)
                                return this.getterFuntion(objects, this.getPropertyID());
                            else
                                return this.getterFuntion(objects, this.getPropertyID(), this.defaultValue);
                        };
                        return TablixProperty;
                    }());
                    TablixObjects.TablixProperty = TablixProperty;
                    // Per Column
                    TablixObjects.PropColumnFormatString = new TablixProperty(TablixObjects.ObjectGeneral, 'formatString', undefined, powerbi.DataViewObjects.getValue);
                    // General
                    TablixObjects.PropGeneralAutoSizeColumns = new TablixProperty(TablixObjects.ObjectGeneral, 'autoSizeColumnWidth', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralTextSize = new TablixProperty(TablixObjects.ObjectGeneral, 'textSize', 8, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralTableTotals = new TablixProperty(TablixObjects.ObjectGeneral, 'totals', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralMatrixRowSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'rowSubtotals', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralMatrixColumnSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'columnSubtotals', true, powerbi.DataViewObjects.getValue);
                    //Grid
                    TablixObjects.PropGridVertical = new TablixProperty(TablixObjects.ObjectGrid, 'gridVertical', false, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridVerticalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridVerticalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalWeight', 1, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridHorizontalTable = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridHorizontalMatrix = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', false, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridHorizontalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridHorizontalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalWeight', 1, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridRowPadding = new TablixProperty(TablixObjects.ObjectGrid, 'rowPadding', 0, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridOutlineColor = new TablixProperty(TablixObjects.ObjectGrid, 'outlineColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridOutlineWeight = new TablixProperty(TablixObjects.ObjectGrid, 'outlineWeight', 2, powerbi.DataViewObjects.getValue);
                    // Column Headers
                    TablixObjects.PropColumnsFontColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnsBackColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnsOutline = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'outline', "BottomOnly", powerbi.DataViewObjects.getValue);
                    // Row Headers
                    TablixObjects.PropRowsFontColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropRowsBackColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropRowsOutline = new TablixProperty(TablixObjects.ObjectRowHeaders, 'outline', "RightOnly", powerbi.DataViewObjects.getValue);
                    // Values
                    // VSTS 7167767: Remove temporary code for product demo.
                    TablixObjects.PropValuesBackColorConditionalFormatting = new TablixProperty(TablixObjects.ObjectValues, 'backgroundColorConditional', false, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropValuesFontColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorPrimary', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesBackColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'backColorPrimary', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesFontColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorSecondary', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesBackColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'backColorSecondary', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesOutline = new TablixProperty(TablixObjects.ObjectValues, 'outline', "None", powerbi.DataViewObjects.getValue);
                    TablixObjects.PropValuesUrlIconProp = new TablixProperty(TablixObjects.ObjectValues, 'urlIcon', false, powerbi.DataViewObjects.getValue);
                    // Total
                    TablixObjects.PropTotalFontColor = new TablixProperty(TablixObjects.ObjectTotal, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropTotalBackColor = new TablixProperty(TablixObjects.ObjectTotal, 'backColor', "#FFF", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropTotalOutline = new TablixProperty(TablixObjects.ObjectTotal, 'outline', "TopOnly", powerbi.DataViewObjects.getValue);
                    // SubTotals
                    TablixObjects.PropSubTotalsFontColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropSubTotalsBackColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropSubTotalsOutline = new TablixProperty(TablixObjects.ObjectSubTotals, 'outline', "TopOnly", powerbi.DataViewObjects.getValue);
                    /**
                     * Get the DataViewObject from the DataView
                     * @param {DataView} dataview The DataView
                     * @returns DataViewObjects (dataView.metadata.objects)
                     */
                    function getMetadadataObjects(dataview) {
                        if (dataview && dataview.metadata)
                            return dataview.metadata.objects;
                        return null;
                    }
                    TablixObjects.getMetadadataObjects = getMetadadataObjects;
                    function enumerateObjectInstances(options, enumeration, dataView, isFormattingPropertiesEnabled, isConditionalFormattingEnabled, tablixType) {
                        debug.assertValue(dataView, "dataView can't be undefined");
                        var objects = getMetadadataObjects(dataView);
                        var totalsShown = true;
                        if (tablixType === controls.TablixType.Table) {
                            totalsShown = shouldShowTableTotalsOption(dataView) && shouldShowTableTotals(objects);
                        }
                        else {
                            totalsShown =
                                (shouldShowColumnSubtotalsOption(dataView) && shouldShowColumnSubtotals(objects)) ||
                                    (shouldShowRowSubtotalsOption(dataView) && shouldShowRowSubtotals(objects));
                        }
                        switch (options.objectName) {
                            case TablixObjects.ObjectGeneral:
                                enumerateGeneralOptions(enumeration, objects, tablixType, dataView);
                                break;
                            case TablixObjects.ObjectGrid:
                                if (isFormattingPropertiesEnabled)
                                    enumerateGridOptions(enumeration, objects, tablixType);
                                break;
                            case TablixObjects.ObjectColumnHeaders:
                                if (isFormattingPropertiesEnabled)
                                    enumerateColumnHeadersOptions(enumeration, objects);
                                break;
                            case TablixObjects.ObjectRowHeaders:
                                if (isFormattingPropertiesEnabled)
                                    enumerateRowHeadersOptions(enumeration, objects);
                                break;
                            case TablixObjects.ObjectValues:
                                if (isFormattingPropertiesEnabled) {
                                    enumerateValuesOptions(enumeration, objects, tablixType);
                                    if (tablixType === controls.TablixType.Table && isConditionalFormattingEnabled)
                                        enumerateValuesOptionConditionalFormat(enumeration, objects);
                                }
                                break;
                            case TablixObjects.ObjectTotal:
                                if (isFormattingPropertiesEnabled && totalsShown)
                                    enumerateTotalOptions(enumeration, objects);
                                break;
                            case TablixObjects.ObjectSubTotals:
                                if (isFormattingPropertiesEnabled && totalsShown)
                                    enumerateSubTotalsOptions(enumeration, objects);
                                break;
                            default:
                                break;
                        }
                    }
                    TablixObjects.enumerateObjectInstances = enumerateObjectInstances;
                    function enumerateGeneralOptions(enumeration, objects, tablixType, dataView) {
                        var visualObjectinstance = {
                            selector: null,
                            objectName: TablixObjects.ObjectGeneral,
                            properties: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                            }
                        };
                        var properties = visualObjectinstance.properties;
                        // Total and SubTotals
                        switch (tablixType) {
                            case controls.TablixType.Table:
                                if (shouldShowTableTotalsOption(dataView))
                                    properties[TablixObjects.PropGeneralTableTotals.propertyName] = shouldShowTableTotals(objects);
                                break;
                            case controls.TablixType.Matrix:
                                if (shouldShowRowSubtotalsOption(dataView))
                                    properties[TablixObjects.PropGeneralMatrixRowSubtotals.propertyName] = shouldShowRowSubtotals(objects);
                                if (shouldShowColumnSubtotalsOption(dataView))
                                    properties[TablixObjects.PropGeneralMatrixColumnSubtotals.propertyName] = shouldShowColumnSubtotals(objects);
                                break;
                        }
                        enumeration.pushInstance(visualObjectinstance);
                    }
                    TablixObjects.enumerateGeneralOptions = enumerateGeneralOptions;
                    function enumerateGridOptions(enumeration, objects, tablixType) {
                        var visualObjectinstance = {
                            selector: null,
                            objectName: TablixObjects.ObjectGeneral,
                            properties: {}
                        };
                        var properties = visualObjectinstance.properties;
                        // Vertical Grid
                        var verticalGridEnabled = TablixObjects.PropGridVertical.getValue(objects);
                        properties[TablixObjects.PropGridVertical.propertyName] = verticalGridEnabled;
                        if (verticalGridEnabled) {
                            properties[TablixObjects.PropGridVerticalColor.propertyName] = TablixObjects.PropGridVerticalColor.getValue(objects);
                            properties[TablixObjects.PropGridVerticalWeight.propertyName] = TablixObjects.PropGridVerticalWeight.getValue(objects);
                        }
                        // Horizontal Grid
                        var horizontalGridEnabled = (tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).getValue(objects);
                        properties[(tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).propertyName] = horizontalGridEnabled;
                        if (horizontalGridEnabled) {
                            properties[TablixObjects.PropGridHorizontalColor.propertyName] = TablixObjects.PropGridHorizontalColor.getValue(objects);
                            properties[TablixObjects.PropGridHorizontalWeight.propertyName] = TablixObjects.PropGridHorizontalWeight.getValue(objects);
                        }
                        // Row Padding
                        properties[TablixObjects.PropGridRowPadding.propertyName] = TablixObjects.PropGridRowPadding.getValue(objects);
                        // Outline
                        properties[TablixObjects.PropGridOutlineColor.propertyName] = TablixObjects.PropGridOutlineColor.getValue(objects);
                        properties[TablixObjects.PropGridOutlineWeight.propertyName] = TablixObjects.PropGridOutlineWeight.getValue(objects);
                        enumeration.pushInstance(visualObjectinstance);
                    }
                    TablixObjects.enumerateGridOptions = enumerateGridOptions;
                    function enumerateColumnHeadersOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectColumnHeaders,
                            properties: {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateColumnHeadersOptions = enumerateColumnHeadersOptions;
                    function enumerateRowHeadersOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectRowHeaders,
                            properties: {
                                fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                                backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                                outline: TablixObjects.PropRowsOutline.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateRowHeadersOptions = enumerateRowHeadersOptions;
                    function enumerateValuesOptions(enumeration, objects, tablixType) {
                        var instance = {
                            selector: null,
                            objectName: TablixObjects.ObjectValues,
                            properties: {
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                                outline: TablixObjects.PropValuesOutline.getValue(objects),
                            }
                        };
                        if (tablixType === controls.TablixType.Table)
                            instance.properties[TablixObjects.PropValuesUrlIconProp.propertyName] = TablixObjects.PropValuesUrlIconProp.getValue(objects);
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateValuesOptions = enumerateValuesOptions;
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    function enumerateValuesOptionConditionalFormat(enumeration, objects) {
                        var instance = {
                            selector: null,
                            objectName: TablixObjects.ObjectValues,
                            properties: {
                                backgroundColorConditional: TablixObjects.PropValuesBackColorConditionalFormatting.getValue(objects),
                            }
                        };
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateValuesOptionConditionalFormat = enumerateValuesOptionConditionalFormat;
                    function enumerateTotalOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectTotal,
                            properties: {
                                fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                                backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                                outline: TablixObjects.PropTotalOutline.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateTotalOptions = enumerateTotalOptions;
                    function enumerateSubTotalsOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectSubTotals,
                            properties: {
                                fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                                backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateSubTotalsOptions = enumerateSubTotalsOptions;
                    function getTableObjects(dataView, isFormattingEnabled, isConditionalFormattingEnabled) {
                        var objects = getMetadadataObjects(dataView);
                        var formattingProperties = {
                            isFormattingEnabled: isFormattingEnabled,
                            // TODO: VSTS 7167767: Remove temporary code for product demo.
                            isConditionalFormattingEnabled: isConditionalFormattingEnabled,
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                totals: shouldShowTableTotals(objects),
                            },
                        };
                        if (isFormattingEnabled) {
                            formattingProperties.grid = {
                                gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                                gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                                gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                                gridHorizontal: TablixObjects.PropGridHorizontalTable.getValue(objects),
                                gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                                gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                                outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                                outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                                rowPadding: TablixObjects.PropGridRowPadding.getValue(objects, false),
                            };
                            formattingProperties.columnHeaders = {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects, false),
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects, false),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects),
                            };
                            formattingProperties.values = {
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects, false),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects, false),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects, false),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects, false),
                                outline: TablixObjects.PropValuesOutline.getValue(objects),
                                urlIcon: TablixObjects.PropValuesUrlIconProp.getValue(objects),
                            };
                            if (isConditionalFormattingEnabled) {
                                formattingProperties.values.conditionalFormatting = TablixObjects.PropValuesBackColorConditionalFormatting.getValue(objects);
                            }
                            formattingProperties.total = {
                                fontColor: TablixObjects.PropTotalFontColor.getValue(objects, false),
                                backColor: TablixObjects.PropTotalBackColor.getValue(objects, false),
                                outline: TablixObjects.PropTotalOutline.getValue(objects),
                            };
                        }
                        return formattingProperties;
                    }
                    TablixObjects.getTableObjects = getTableObjects;
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    function getTableObjectConditionalFormatEnabled(dataView) {
                        return TablixObjects.PropValuesBackColorConditionalFormatting.getValue(getMetadadataObjects(dataView));
                    }
                    TablixObjects.getTableObjectConditionalFormatEnabled = getTableObjectConditionalFormatEnabled;
                    function getMatrixObjects(dataView, isFormattingEnabled) {
                        var objects = getMetadadataObjects(dataView);
                        var formattingProperties = {
                            isFormattingEnabled: isFormattingEnabled,
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                rowSubtotals: shouldShowRowSubtotals(objects),
                                columnSubtotals: shouldShowColumnSubtotals(objects),
                            },
                        };
                        if (isFormattingEnabled) {
                            formattingProperties.grid = {
                                gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                                gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                                gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                                gridHorizontal: TablixObjects.PropGridHorizontalMatrix.getValue(objects),
                                gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                                gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                                outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                                outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                                rowPadding: TablixObjects.PropGridRowPadding.getValue(objects, false),
                            };
                            formattingProperties.columnHeaders = {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects, false),
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects, false),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects),
                            };
                            formattingProperties.rowHeaders = {
                                fontColor: TablixObjects.PropRowsFontColor.getValue(objects, false),
                                backColor: TablixObjects.PropRowsBackColor.getValue(objects, false),
                                outline: TablixObjects.PropRowsOutline.getValue(objects),
                            };
                            formattingProperties.values = {
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects, false),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects, false),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects, false),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects, false),
                                outline: TablixObjects.PropValuesOutline.getValue(objects),
                            };
                            formattingProperties.subtotals = {
                                fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects, false),
                                backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects, false),
                                outline: TablixObjects.PropSubTotalsOutline.getValue(objects),
                            };
                        }
                        return formattingProperties;
                    }
                    TablixObjects.getMatrixObjects = getMatrixObjects;
                    /**
                     * Generate default objects for the Table/Matrix to set default styling
                     * @param {TablixType} tablixType Tablix Type: table | matrix
                     * @returns DataViewObjects that can be attached to the DataViewMetadata
                     */
                    function generateTablixDefaultObjects(tablixType) {
                        return {
                            general: [{
                                    selector: null,
                                    properties: {
                                        textSize: DataViewObjectDefinitions.encodePropertyValue(12, { numeric: true }),
                                        totals: DataViewObjectDefinitions.encodePropertyValue(false, { bool: true }),
                                    }
                                }],
                        };
                    }
                    TablixObjects.generateTablixDefaultObjects = generateTablixDefaultObjects;
                    function getTextSizeInPx(textSize) {
                        return jsCommon.PixelConverter.fromPoint(textSize);
                    }
                    TablixObjects.getTextSizeInPx = getTextSizeInPx;
                    function shouldShowTableTotals(objects) {
                        return TablixObjects.PropGeneralTableTotals.getValue(objects);
                    }
                    TablixObjects.shouldShowTableTotals = shouldShowTableTotals;
                    function shouldShowTableTotalsOption(dataView) {
                        if (dataView && dataView.table && !_.isEmpty(dataView.table.columns)) {
                            var columns = dataView.table.columns;
                            if (_.some(columns, function (column) { return column.discourageAggregationAcrossGroups; }))
                                return false;
                        }
                        return true;
                    }
                    function shouldShowRowSubtotals(objects) {
                        return TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects);
                    }
                    TablixObjects.shouldShowRowSubtotals = shouldShowRowSubtotals;
                    function shouldShowRowSubtotalsOption(dataView) {
                        return !(dataView &&
                            dataView.matrix &&
                            dataView.matrix.rows &&
                            isDiscourageAggregationAcrossGroups(dataView.matrix.rows.levels));
                    }
                    function shouldShowColumnSubtotals(objects) {
                        return TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects);
                    }
                    TablixObjects.shouldShowColumnSubtotals = shouldShowColumnSubtotals;
                    function shouldShowColumnSubtotalsOption(dataView) {
                        return !(dataView &&
                            dataView.matrix &&
                            dataView.matrix.columns &&
                            isDiscourageAggregationAcrossGroups(dataView.matrix.columns.levels));
                    }
                    TablixObjects.shouldShowColumnSubtotalsOption = shouldShowColumnSubtotalsOption;
                    function isDiscourageAggregationAcrossGroups(levels) {
                        var lastLevel = _.last(levels);
                        // If the last item is not Aggregatable, disable totals option since there will be no totals at all to display
                        // However, if the non-aggregatable filed is in the middle, there are totals showing up in matrix.
                        // Therefore, we still allow users to turn it off
                        return lastLevel && _.some(lastLevel.sources, function (source) { return source.discourageAggregationAcrossGroups; });
                    }
                    TablixObjects.isDiscourageAggregationAcrossGroups = isDiscourageAggregationAcrossGroups;
                })(TablixObjects = internal.TablixObjects || (internal.TablixObjects = {}));
                var TablixUtils;
                (function (TablixUtils) {
                    TablixUtils.CssClassTablixDiv = "tablixDiv"; // Any DIV inside the table (outer and inner)
                    TablixUtils.CssClassContentElement = "tablixCellContentElement"; // Outer DIV
                    TablixUtils.CssClassContentHost = "tablixCellContentHost"; // Inner DIV
                    TablixUtils.CssClassTablixHeader = "tablixHeader"; // Any Header in the Table/Matrix
                    TablixUtils.CssClassTablixColumnHeaderLeaf = "tablixColumnHeaderLeaf"; // Leaf Column Headers
                    TablixUtils.CssClassTablixValueNumeric = "tablixValueNumeric"; // Numeric cells, will also be applied to all Matrix body cells
                    TablixUtils.CssClassTablixValueTotal = "tablixValueTotal"; // Total cells,  will also be applied to subtotal Matrix body cells
                    TablixUtils.CssClassValueURLIcon = "powervisuals-glyph url-icon tablixUrlIconGlyph"; // Any <a> Tag
                    TablixUtils.CssClassValueURLIconContainer = "tablixValueUrlIcon"; // Container for the <a> tag
                    TablixUtils.CssClassMatrixRowHeaderLeaf = "matrixRowHeaderLeaf"; // Matrix Leaf Row Headers
                    TablixUtils.CssClassMatrixRowHeaderSubTotal = "matrixRowHeaderSubTotal"; // Matrix SubTotal Row Headers
                    TablixUtils.CssClassTableFooter = 'tableFooterCell'; // Any cell in the Footer area
                    TablixUtils.CssClassTableBodyCell = 'tableBodyCell'; // Any cell in the Table Body
                    TablixUtils.CssClassTableBodyCellBottom = 'tableBodyCellBottom'; // Bottom-Most Body cell
                    TablixUtils.StringNonBreakingSpace = '&nbsp;';
                    TablixUtils.UnitOfMeasurement = 'px';
                    var SortIconContainerClassName = "tablixSortIconContainer";
                    TablixUtils.CellPaddingLeft = 10;
                    TablixUtils.CellPaddingRight = 5;
                    var EdgeSettings = (function () {
                        function EdgeSettings(weight, color, style) {
                            this.applyParams(true, weight, color, style);
                        }
                        EdgeSettings.prototype.applyParams = function (shown, weight, color, style) {
                            if (shown) {
                                this.weight = weight;
                                this.color = color;
                                this.style = style ? style : 'solid';
                            }
                            else {
                                this.weight = 0;
                                this.color = undefined;
                                this.style = undefined;
                            }
                        };
                        EdgeSettings.prototype.getCSS = function () {
                            var css = [];
                            if (_.isNumber(this.weight)) {
                                css.push(this.weight + TablixUtils.UnitOfMeasurement);
                                if (this.color)
                                    css.push(this.color);
                                if (this.style)
                                    css.push(this.style);
                            }
                            return css.join(' ');
                        };
                        return EdgeSettings;
                    }());
                    TablixUtils.EdgeSettings = EdgeSettings;
                    /**
                     * Style parameters for each Cell
                     */
                    var CellStyle = (function () {
                        function CellStyle() {
                            this.borders = {};
                            this.paddings = {};
                        }
                        /**
                         * Sets the Inline style for the Cell
                         * @param {ITablixCell} cell Cell to set style to
                         */
                        CellStyle.prototype.applyStyle = function (cell) {
                            var div = cell.extension.contentHost;
                            var style = div.style;
                            style.color = this.fontColor ? this.fontColor : "";
                            style.backgroundColor = this.backColor ? this.backColor : "";
                            style.borderTop = this.borders.top ? this.borders.top.getCSS() : "";
                            style.borderRight = this.borders.right ? this.borders.right.getCSS() : "";
                            style.borderBottom = this.borders.bottom ? this.borders.bottom.getCSS() : "";
                            style.borderLeft = this.borders.left ? this.borders.left.getCSS() : "";
                            style.paddingTop = _.isNumber(this.paddings.top) ? (this.paddings.top + TablixUtils.UnitOfMeasurement) : "";
                            style.paddingRight = _.isNumber(this.paddings.right) ? (this.paddings.right + TablixUtils.UnitOfMeasurement) : "";
                            style.paddingBottom = _.isNumber(this.paddings.bottom) ? (this.paddings.bottom + TablixUtils.UnitOfMeasurement) : "";
                            style.paddingLeft = _.isNumber(this.paddings.left) ? (this.paddings.left + TablixUtils.UnitOfMeasurement) : "";
                        };
                        CellStyle.prototype.getExtraTop = function () {
                            var extra = 0;
                            if (this.paddings.top)
                                extra += this.paddings.top;
                            if (this.borders.top)
                                extra += this.borders.top.weight;
                            return extra;
                        };
                        CellStyle.prototype.getExtraBottom = function () {
                            var extra = 0;
                            if (this.paddings.bottom)
                                extra += this.paddings.bottom;
                            if (this.borders.bottom)
                                extra += this.borders.bottom.weight;
                            return extra;
                        };
                        return CellStyle;
                    }());
                    TablixUtils.CellStyle = CellStyle;
                    /**
                     * Index within a dimension (row/column)
                     */
                    var DimensionPosition = (function () {
                        function DimensionPosition() {
                        }
                        return DimensionPosition;
                    }());
                    TablixUtils.DimensionPosition = DimensionPosition;
                    /**
                     * Poistion information about the cell
                     */
                    var CellPosition = (function () {
                        function CellPosition() {
                            this.row = new DimensionPosition();
                            this.column = new DimensionPosition();
                        }
                        CellPosition.prototype.isMatch = function (position) {
                            return this.column.index === position.column.index &&
                                this.row.index === position.row.index;
                        };
                        return CellPosition;
                    }());
                    TablixUtils.CellPosition = CellPosition;
                    var TablixVisualCell = (function () {
                        function TablixVisualCell(dataPoint, isTotal, columnMetadata, formatter) {
                            this.dataPoint = dataPoint;
                            this.columnMetadata = columnMetadata;
                            this.formatter = formatter;
                            this.isTotal = isTotal;
                            this.backColorCustomFormatting = undefined;
                            this.position = new TablixUtils.CellPosition();
                        }
                        Object.defineProperty(TablixVisualCell.prototype, "textContent", {
                            get: function () {
                                if (this.dataPoint == null)
                                    return '';
                                if (this.formatter)
                                    return this.formatter(this.dataPoint, this.columnMetadata, TablixObjects.PropColumnFormatString.getPropertyID());
                                else
                                    return this.dataPoint;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "domContent", {
                            get: function () {
                                if (this.columnMetadata && isValidStatusGraphic(this.columnMetadata.kpi, this.textContent))
                                    return createKpiDom(this.columnMetadata.kpi, this.textContent);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "isNumeric", {
                            get: function () {
                                if (this.columnMetadata)
                                    return this.columnMetadata.type.numeric && !this.columnMetadata.kpi;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "isValidUrl", {
                            get: function () {
                                if (this.columnMetadata)
                                    return visuals.converterHelper.isWebUrlColumn(this.columnMetadata) && jsCommon.UrlUtils.isValidUrl(this.textContent);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "isValidImage", {
                            get: function () {
                                if (this.columnMetadata)
                                    return visuals.converterHelper.isImageUrlColumn(this.columnMetadata) && jsCommon.UrlUtils.isValidImageUrl(this.textContent);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        TablixVisualCell.prototype.isMatch = function (item) {
                            return this.position.isMatch(item.position);
                        };
                        return TablixVisualCell;
                    }());
                    TablixUtils.TablixVisualCell = TablixVisualCell;
                    function createTable() {
                        return document.createElement("table");
                    }
                    TablixUtils.createTable = createTable;
                    function createDiv() {
                        var div = document.createElement("div");
                        div.className = "tablixDiv";
                        return div;
                    }
                    TablixUtils.createDiv = createDiv;
                    function resetCellCssClass(cell) {
                        cell.extension.contentElement.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentElement;
                        cell.extension.contentHost.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentHost;
                    }
                    TablixUtils.resetCellCssClass = resetCellCssClass;
                    function addCellCssClass(cell, style) {
                        cell.extension.contentHost.className += " " + style;
                    }
                    TablixUtils.addCellCssClass = addCellCssClass;
                    /**
                     * Clears all inline styles (border, fontColor, background) and resets CSS classes
                     * Performed with unbind-<Cell>
                     */
                    function clearCellStyle(cell) {
                        cell.extension.contentHost.className = "";
                        cell.extension.contentHost.style.cssText = "";
                    }
                    TablixUtils.clearCellStyle = clearCellStyle;
                    function clearCellTextAndTooltip(cell) {
                        cell.extension.contentHost.textContent = '';
                        cell.extension.contentHost.removeAttribute('title');
                        controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
                    }
                    TablixUtils.clearCellTextAndTooltip = clearCellTextAndTooltip;
                    function setCellTextAndTooltip(cell, text) {
                        var val = visuals.TextUtil.replaceSpaceWithNBSP(text);
                        cell.extension.contentHost.textContent = val;
                        cell.extension.contentHost.title = val;
                    }
                    TablixUtils.setCellTextAndTooltip = setCellTextAndTooltip;
                    function isValidSortClick(e) {
                        var colHeader = e.target;
                        var x = e.offsetX;
                        return x >= 0 && x < colHeader.offsetWidth - internal.TablixResizer.resizeHandleSize;
                    }
                    TablixUtils.isValidSortClick = isValidSortClick;
                    function appendATagToBodyCell(value, cell, urlIcon) {
                        var element = cell.extension.contentHost;
                        var atag = null;
                        if (element.childElementCount === 0) {
                            atag = document.createElement('a');
                            element.appendChild(atag);
                        }
                        else {
                            atag = element.children[0];
                        }
                        atag.href = value;
                        atag.target = '_blank';
                        atag.title = value;
                        if (urlIcon === true) {
                            atag.className = TablixUtils.CssClassValueURLIcon;
                            element.className = TablixUtils.CssClassValueURLIconContainer;
                        }
                        else {
                            atag.innerText = value;
                        }
                    }
                    TablixUtils.appendATagToBodyCell = appendATagToBodyCell;
                    function appendImgTagToBodyCell(value, cell) {
                        var element = cell.extension.contentHost;
                        var contentElement = element.parentElement;
                        var imgTag;
                        if (element.childElementCount === 0) {
                            imgTag = document.createElement('img');
                            element.appendChild(imgTag);
                        }
                        else {
                            imgTag = element.children[0];
                        }
                        // set padding for contentElement
                        contentElement.style.paddingBottom = '3px';
                        contentElement.style.paddingTop = '3px';
                        imgTag.src = value;
                        imgTag.style.maxHeight = '75px';
                        imgTag.style.maxWidth = '100px';
                        imgTag.style.height = '100%';
                    }
                    TablixUtils.appendImgTagToBodyCell = appendImgTagToBodyCell;
                    function createKpiDom(kpi, kpiValue) {
                        debug.assertValue(kpi, 'kpi');
                        debug.assertValue(kpiValue, 'kpiValue');
                        var className = visuals.KpiUtil.getClassForKpi(kpi, kpiValue) || '';
                        return DomFactory.div()
                            .addClass(className)
                            .css({
                            'display': 'inline-block',
                            'vertical-align': 'bottom',
                            'margin': '0 1px 1px 0',
                        });
                    }
                    TablixUtils.createKpiDom = createKpiDom;
                    function isValidStatusGraphic(kpi, kpiValue) {
                        if (!kpi || kpiValue === undefined) {
                            return false;
                        }
                        return !!visuals.KpiUtil.getClassForKpi(kpi, kpiValue);
                    }
                    TablixUtils.isValidStatusGraphic = isValidStatusGraphic;
                    function getCustomSortEventArgs(queryName, sortDirection) {
                        var sortDescriptors = [{
                                queryName: queryName,
                                sortDirection: sortDirection
                            }];
                        return { sortDescriptors: sortDescriptors };
                    }
                    TablixUtils.getCustomSortEventArgs = getCustomSortEventArgs;
                    function reverseSort(sortDirection) {
                        return sortDirection === 2 /* Descending */ ? 1 /* Ascending */ : 2 /* Descending */;
                    }
                    TablixUtils.reverseSort = reverseSort;
                    function createColumnHeaderWithSortIcon(item, cell) {
                        var colHeaderContainer = TablixUtils.createDiv();
                        if (item.sort) {
                            var itemSort = item.sort;
                            colHeaderContainer.appendChild(createSortIcon(itemSort, true));
                            colHeaderContainer.appendChild(createSortIcon(reverseSort(itemSort), false));
                        }
                        else {
                            colHeaderContainer.appendChild(createSortIcon(2 /* Descending */, false));
                        }
                        var colHeaderTitle = TablixUtils.createDiv();
                        // Preserving trailing and leading spaces
                        var title = item ? visuals.TextUtil.replaceSpaceWithNBSP(item.displayName) : '';
                        colHeaderTitle.textContent = title;
                        colHeaderContainer.appendChild(colHeaderTitle);
                        cell.extension.contentHost.title = title;
                        cell.extension.contentHost.appendChild(colHeaderContainer);
                    }
                    TablixUtils.createColumnHeaderWithSortIcon = createColumnHeaderWithSortIcon;
                    function createSortIcon(sort, isSorted) {
                        var imgSort = document.createElement('i');
                        imgSort.className = SortIconContainerClassName +
                            " " + (isSorted ? "sorted" : "future") +
                            " " + (sort === 1 /* Ascending */ ? "powervisuals-glyph caret-up" : "powervisuals-glyph caret-down");
                        return imgSort;
                    }
                    function checkSortIconExists(cell) {
                        for (var i = 0, len = cell.extension.contentElement.childElementCount; i < len; i++) {
                            var element = cell.extension.contentElement.children.item(i);
                            if (element.classList.contains(SortIconContainerClassName))
                                return true;
                        }
                        return false;
                    }
                    function removeSortIcons(cell) {
                        if (!checkSortIconExists(cell))
                            return;
                        $(cell.extension.contentElement).find('.' + SortIconContainerClassName).remove();
                    }
                    TablixUtils.removeSortIcons = removeSortIcons;
                })(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            controls.TablixDefaultTextSize = jsCommon.TextSizeDefaults.TextSizeMin;
            var TablixControl = (function () {
                function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
                    var _this = this;
                    this.scrollBarElementWidth = 9;
                    // Options (fontSize set after container initialized)
                    this.options = options;
                    var isInteractive = options.interactive;
                    this.isTouchEnabled = isInteractive && options.enableTouchSupport;
                    // Main Div
                    this.mainDiv = controls.internal.TablixUtils.createDiv();
                    this.mainDiv.classList.add(TablixControl.TablixTableAreaClassName);
                    // Footer Div
                    this.footerDiv = controls.internal.TablixUtils.createDiv();
                    this.footerDiv.classList.add(TablixControl.TablixFooterClassName);
                    if (this.isTouchEnabled)
                        this.InitializeTouchSupport();
                    this.gridDimensions = {};
                    this.containerElement = controls.internal.TablixUtils.createDiv();
                    this.className = layoutManager.getTablixClassName();
                    this.autoSizeWidth = false;
                    this.autoSizeHeight = false;
                    this.fontSize = options.fontSize;
                    parentDomElement.className = TablixControl.TablixContainerClassName;
                    parentDomElement.appendChild(this.containerElement);
                    this.containerElement.addEventListener("mousewheel", function (e) { _this.onMouseWheel(e); });
                    this.containerElement.addEventListener("DOMMouseScroll", function (e) { _this.onFireFoxMouseWheel(e); });
                    this.containerElement.appendChild(this.mainDiv);
                    this.containerElement.appendChild(this.footerDiv);
                    if (this.isTouchEnabled) {
                        this.touchInterpreter.initTouch(this.mainDiv, null, false);
                        this.footerTouchInterpreter.initTouch(this.footerDiv, this.mainDiv, false);
                    }
                    this.controlLayoutManager = layoutManager;
                    this.controlLayoutManager.initialize(this);
                    this.hierarchyTablixNavigator = hierarchyNavigator;
                    this.binder = binder;
                    this.columnDim = new controls.TablixColumnDimension(this);
                    this.rowDim = new controls.TablixRowDimension(this);
                    this.columnDim._otherDimension = this.rowDimension;
                    this.rowDim._otherDimension = this.columnDimension;
                    this.InitializeScrollbars();
                    if (!isInteractive) {
                        this.scrollbarWidth = 0;
                    }
                    this.updateHorizontalPosition();
                    this.updateVerticalPosition();
                    this.updateFooterVisibility();
                    this.lastRenderingArgs = {};
                }
                TablixControl.prototype.InitializeTouchSupport = function () {
                    this.touchManager = new controls.TouchUtils.TouchManager();
                    this.touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
                    this.footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
                    this.columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.columnTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.rowTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.bodyTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.footerTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.touchManager.addTouchRegion(this.columnTouchDelegate.dimension, this.columnTouchDelegate, this.columnTouchDelegate);
                    this.touchManager.addTouchRegion(this.rowTouchDelegate.dimension, this.rowTouchDelegate, this.rowTouchDelegate);
                    this.touchManager.addTouchRegion(this.bodyTouchDelegate.dimension, this.bodyTouchDelegate, this.bodyTouchDelegate);
                    this.touchManager.addTouchRegion(this.footerTouchDelegate.dimension, this.footerTouchDelegate, this.footerTouchDelegate);
                };
                TablixControl.prototype.InitializeScrollbars = function () {
                    // Row Dimension
                    this.rowDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var rowDimensionScrollbarStyle = this.rowDim.scrollbar.element.style;
                    rowDimensionScrollbarStyle.position = "absolute";
                    rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement;
                    rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement;
                    this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    // Default to true which is the more common case to avoid an extra rendering iteration
                    // when first rendering the visual
                    this.rowDim.scrollbar.show(true);
                    // Column Dimension
                    this.columnDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var columnDimensionScrollbarStyle = this.columnDim.scrollbar.element.style;
                    columnDimensionScrollbarStyle.position = "absolute";
                    columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement;
                    columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement;
                    this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    this.columnDim.scrollbar.show(false);
                };
                Object.defineProperty(TablixControl.prototype, "container", {
                    get: function () {
                        return this.containerElement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "contentHost", {
                    get: function () {
                        return this.mainDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "footerHost", {
                    get: function () {
                        return this.footerDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "className", {
                    set: function (value) {
                        this.containerElement.className = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
                    get: function () {
                        return this.hierarchyTablixNavigator;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.getBinder = function () {
                    return this.binder;
                };
                Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
                    get: function () {
                        return this._autoSizeWidth;
                    },
                    set: function (value) {
                        this._autoSizeWidth = value;
                        if (!value) {
                            this.containerElement.style.minWidth = this.containerElement.style.maxWidth = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
                    get: function () {
                        return this._autoSizeHeight;
                    },
                    set: function (value) {
                        if (!value) {
                            this.containerElement.style.minHeight = this.containerElement.style.maxHeight = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxWidth", {
                    get: function () {
                        return this.maximumWidth;
                    },
                    set: function (value) {
                        this.maximumWidth = value;
                        this.containerElement.style.maxWidth = this.maximumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "viewport", {
                    get: function () {
                        return this.viewPort;
                    },
                    set: function (value) {
                        this.viewPort = value;
                        this.containerElement.style.width = this.viewPort.width + TablixControl.UnitOfMeasurement;
                        this.containerElement.style.height = this.viewPort.height + TablixControl.UnitOfMeasurement;
                        this.rowDim.scrollbar.invalidateArrange();
                        this.columnDim.scrollbar.invalidateArrange();
                        this.controlLayoutManager.updateViewport(this.viewPort);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxHeight", {
                    get: function () {
                        return this.maximumHeight;
                    },
                    set: function (value) {
                        this.maximumHeight = value;
                        this.containerElement.style.maxHeight = this.maximumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minWidth", {
                    get: function () {
                        return this.minimumWidth;
                    },
                    set: function (value) {
                        this.minimumWidth = value;
                        this.containerElement.style.minWidth = this.minimumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minHeight", {
                    get: function () {
                        return this.minimumHeight;
                    },
                    set: function (value) {
                        this.minimumHeight = value;
                        this.containerElement.style.minHeight = this.minimumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "fontSize", {
                    set: function (value) {
                        this.textFontSize = !value ? TablixControl.DefaultFontSize : value;
                        this.containerElement.style.fontSize = this.textFontSize;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
                    set: function (value) {
                        this.scrollBarElementWidth = value;
                        this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.updateModels = function (resetScrollOffsets, rowModel, columnModel) {
                    this.rowDim.model = rowModel;
                    this.rowDim.modelDepth = this.hierarchyNavigator.getRowHierarchyDepth();
                    this.columnDim.model = columnModel;
                    this.columnDim.modelDepth = this.hierarchyNavigator.getColumnHierarchyDepth();
                    if (resetScrollOffsets) {
                        this.rowDim.scrollOffset = 0;
                        this.columnDim.scrollOffset = 0;
                    }
                    this.layoutManager.updateColumnCount(this.rowDim, this.columnDim);
                };
                TablixControl.prototype.updateColumnDimensions = function (rowHierarchyWidth, columnHierarchyWidth, count) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.columnCount = count;
                    gridDimensions.rowHierarchyWidth = rowHierarchyWidth;
                    gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
                };
                TablixControl.prototype.updateRowDimensions = function (columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.rowCount = count;
                    gridDimensions.rowHierarchyHeight = rowHierarchyHeight;
                    gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight;
                    gridDimensions.columnHierarchyHeight = columnHierarchyHeight;
                    gridDimensions.footerHeight = footerHeight;
                };
                TablixControl.prototype.updateTouchDimensions = function () {
                    var gridDimensions = this.gridDimensions;
                    this.columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight);
                    this.columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                    this.rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this.rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this.bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this.bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this.footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight);
                    this.footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                };
                TablixControl.prototype.onMouseWheel = function (e) {
                    var dimension = this.determineDimensionToScroll();
                    if (dimension)
                        dimension.scrollbar.onMouseWheel(e);
                };
                TablixControl.prototype.onFireFoxMouseWheel = function (e) {
                    var dimension = this.determineDimensionToScroll();
                    if (dimension)
                        dimension.scrollbar.onFireFoxMouseWheel(e);
                };
                TablixControl.prototype.determineDimensionToScroll = function () {
                    if (this.rowDim.scrollbar.visible)
                        return this.rowDim;
                    // In the absence of the vertical scrollbar, we scroll the
                    // horizontal scrollbar.
                    if (this.columnDim.scrollbar.visible)
                        return this.columnDim;
                    return null;
                };
                Object.defineProperty(TablixControl.prototype, "layoutManager", {
                    get: function () {
                        return this.controlLayoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "columnDimension", {
                    get: function () {
                        return this.columnDim;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "rowDimension", {
                    get: function () {
                        return this.rowDim;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.refresh = function (clear) {
                    this.render(clear, null);
                };
                TablixControl.prototype._onScrollAsync = function (dimension) {
                    var _this = this;
                    requestAnimationFrame(function () { _this.performPendingScroll(dimension); });
                };
                TablixControl.prototype.performPendingScroll = function (dimension) {
                    this.render(false, dimension);
                };
                TablixControl.prototype.updateHorizontalPosition = function () {
                    if (this.rowDim.scrollbar.visible) {
                        this.columnDim.scrollbar.element.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.mainDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    }
                    else {
                        this.columnDim.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this.mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.updateFooterVisibility = function () {
                    if (this.rowDim.hasFooter() ? (this.footerDiv.style.display !== "block") : (this.footerDiv.style.display !== "none")) {
                        if (this.rowDim.hasFooter()) {
                            this.footerDiv.style.display = "block";
                        }
                        else {
                            this.footerDiv.style.display = "none";
                        }
                    }
                };
                TablixControl.prototype.updateVerticalPosition = function () {
                    var hasVerticalScrollbar = this.rowDim.scrollbar.visible;
                    // TODO: ideally the tablix control would not know about where it is rendered but the layout manager
                    //       would provider that information; we should refactor the layout manager so that getLayoutKind is not needed anymore.
                    var isDashboardTile = this.controlLayoutManager.getLayoutKind() === 1 /* DashboardTile */;
                    var showFooter = hasVerticalScrollbar || isDashboardTile;
                    if (showFooter) {
                        var mainBottom = this.footerDiv.offsetHeight;
                        var footerBottom = 0;
                        var verticalScrollbarBottom = 0;
                        // If we have a horizontal scrollbar, we need to adjust the bottom
                        // value by the scrollbar width
                        var hasHorizontalScrollbar = this.columnDim.scrollbar.visible;
                        if (hasHorizontalScrollbar) {
                            mainBottom += this.scrollBarElementWidth;
                            footerBottom += this.scrollBarElementWidth;
                            verticalScrollbarBottom = this.scrollBarElementWidth;
                        }
                        this.mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement;
                        this.rowDim.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement;
                        // With a vertical scrollbar, the footer is always rendered at the bottom
                        this.footerDiv.style.removeProperty("top");
                    }
                    else {
                        // Without a vertical scrollbar, the footer is rendered below the last row;
                        // this is controlled by the top value only
                        this.footerDiv.style.top = this.gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.removeProperty("bottom");
                        this.mainDiv.style.removeProperty("bottom");
                    }
                };
                TablixControl.prototype.alreadyRendered = function (scrollingDimension) {
                    if (scrollingDimension !== this.lastRenderingArgs.scrollingDimension ||
                        this.rowDimension.scrollOffset !== this.lastRenderingArgs.rowScrollOffset ||
                        this.columnDimension.scrollOffset !== this.lastRenderingArgs.columnScrollOffset) {
                        return false;
                    }
                    return true;
                };
                TablixControl.prototype.render = function (clear, scrollingDimension) {
                    // at time of rendering always ensure the scroll offset is valid
                    this.columnDim.makeScrollOffsetValid();
                    this.rowDim.makeScrollOffsetValid();
                    if (clear || scrollingDimension === null) {
                        this.lastRenderingArgs = {};
                    }
                    else if (this.alreadyRendered(scrollingDimension)) {
                        return;
                    }
                    var done = false;
                    this.renderIterationCount = 0;
                    this.controlLayoutManager.onStartRenderingSession(scrollingDimension, this.mainDiv, clear);
                    var binder = this.binder;
                    binder.onStartRenderingSession();
                    var priorFooterHeight = this.gridDimensions.footerHeight;
                    var priorRowHierarchyHeight = this.gridDimensions.rowHierarchyHeight;
                    var priorRowHierarchyContentHeight = this.gridDimensions.rowHierarchyContentHeight;
                    while (!done && this.renderIterationCount < TablixControl.MaxRenderIterationCount) {
                        var hScrollbarVisibility = this.columnDim.scrollbar.visible;
                        var vScrollbarVisibility = this.rowDim.scrollbar.visible;
                        this.columnDim._onStartRenderingIteration();
                        this.rowDim._onStartRenderingIteration();
                        this.controlLayoutManager.onStartRenderingIteration(clear);
                        // These calls add cells to the table.
                        // Column needs to be rendered before rows as the row call will pair up with columns to produce the body cells.
                        this.renderCorner();
                        this.columnDim._render();
                        this.rowDim._render();
                        done = this.controlLayoutManager.onEndRenderingIteration();
                        this.columnDim._onEndRenderingIteration();
                        this.rowDim._onEndRenderingIteration();
                        if ((hScrollbarVisibility !== this.columnDim.scrollbar.visible)) {
                            this.updateVerticalPosition();
                        }
                        if (vScrollbarVisibility !== this.rowDim.scrollbar.visible) {
                            this.updateHorizontalPosition();
                        }
                        this.renderIterationCount++;
                    }
                    this.controlLayoutManager.onEndRenderingSession();
                    binder.onEndRenderingSession();
                    if (this.isTouchEnabled)
                        this.updateTouchDimensions();
                    this.lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    this.lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    this.updateContainerDimensions();
                    var lastRenderingArgs = this.lastRenderingArgs;
                    lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    lastRenderingArgs.scrollingDimension = scrollingDimension;
                    if (priorFooterHeight !== this.gridDimensions.footerHeight ||
                        priorRowHierarchyHeight !== this.gridDimensions.rowHierarchyHeight ||
                        priorRowHierarchyContentHeight !== this.gridDimensions.rowHierarchyContentHeight) {
                        this.updateVerticalPosition();
                    }
                    // NOTE: it is critical that we refresh the scrollbars only after the vertical
                    //       position was updated above; otherwise the measurements can be incorrect.
                    if (this.options.interactive) {
                        this.columnDim.scrollbar.refresh();
                        this.rowDim.scrollbar.refresh();
                    }
                };
                TablixControl.prototype.updateContainerDimensions = function () {
                    var gridDimensions = this.gridDimensions;
                    if (this._autoSizeWidth) {
                        var vScrollBarWidth = this.rowDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.width =
                            gridDimensions.rowHierarchyWidth +
                                gridDimensions.columnHierarchyWidth +
                                vScrollBarWidth +
                                TablixControl.UnitOfMeasurement;
                    }
                    if (this._autoSizeHeight) {
                        var hScrollBarHeight = this.columnDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.height =
                            gridDimensions.columnHierarchyHeight +
                                gridDimensions.rowHierarchyHeight +
                                gridDimensions.footerHeight +
                                hScrollBarHeight +
                                TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.cornerCellMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 0 /* CornerCell */ && previousItem && this.hierarchyTablixNavigator.cornerCellItemEquals(item, previousItem);
                };
                TablixControl.prototype.renderCorner = function () {
                    var columnDepth = this.columnDim.getDepth();
                    var rowDepth = this.rowDim.getDepth();
                    for (var i = 0; i < columnDepth; i++) {
                        for (var j = 0; j < rowDepth; j++) {
                            var item = this.hierarchyTablixNavigator.getCorner(j, i);
                            var cell = this.controlLayoutManager.getOrCreateCornerCell(item, j, i);
                            var match = this.cornerCellMatch(item, cell);
                            if (!match) {
                                this._unbindCell(cell);
                                cell.type = 0 /* CornerCell */;
                                cell.item = item;
                                this.binder.bindCornerCell(item, cell);
                            }
                            this.controlLayoutManager.onCornerCellRealized(item, cell);
                        }
                    }
                };
                TablixControl.prototype._unbindCell = function (cell) {
                    switch (cell.type) {
                        case 3 /* BodyCell */:
                            this.binder.unbindBodyCell(cell.item, cell);
                            break;
                        case 2 /* ColumnHeader */:
                            this.binder.unbindColumnHeader(cell.item, cell);
                            break;
                        case 1 /* RowHeader */:
                            this.binder.unbindRowHeader(cell.item, cell);
                            break;
                        case 0 /* CornerCell */:
                            this.binder.unbindCornerCell(cell.item, cell);
                    }
                    cell.item = null;
                    cell.type = null;
                };
                TablixControl.prototype.onTouchEvent = function (args) {
                    var colShift;
                    var rowShift;
                    var that;
                    if ((args) && (args.length > 0)) {
                        if (("columnDim" in args[0]) && ("rowDim" in args[0])) {
                            that = args[0];
                            colShift = that.columnDim.scrollbar.visible ? args[1] : 0;
                            rowShift = that.rowDim.scrollbar.visible ? args[2] : 0;
                            that.columnDim.scrollbar.viewMin = Math.max(0, that.columnDim.scrollbar.viewMin + colShift);
                            that.columnDim.scrollOffset = Math.max(0, that.columnDim.scrollOffset + colShift);
                            that.rowDim.scrollbar.viewMin = Math.max(0, that.rowDim.scrollbar.viewMin + rowShift);
                            that.rowDim.scrollOffset = Math.max(0, that.rowDim.scrollOffset + rowShift);
                            if (colShift === 0) {
                                that._onScrollAsync(that.rowDim);
                            }
                            else if (rowShift === 0) {
                                that._onScrollAsync(that.columnDim);
                            }
                            else {
                                that._onScrollAsync(null);
                            }
                        }
                    }
                };
                TablixControl.UnitOfMeasurement = 'px';
                TablixControl.TablixContainerClassName = 'tablixContainer';
                TablixControl.TablixTableAreaClassName = "tablixTableArea";
                TablixControl.TablixFooterClassName = "tableFooterArea";
                TablixControl.DefaultFontSize = jsCommon.PixelConverter.fromPoint(controls.TablixDefaultTextSize);
                /*
                * This is workaround for the infinite loop in rendering
                * BugID: 6518621
                * ToDo: Investigate the underlying cause for rendering to never report completion
                * Rendering typically require 3-5 iterations to complete, so 10 is enough
                */
                TablixControl.MaxRenderIterationCount = 10;
                return TablixControl;
            }());
            controls.TablixControl = TablixControl;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TablixDimension = (function () {
                function TablixDimension(tablixControl) {
                    this._scrollStep = 0.1;
                    this._owner = tablixControl;
                    this._hierarchyNavigator = tablixControl.hierarchyNavigator;
                    this._binder = tablixControl.getBinder();
                    this._tablixLayoutManager = tablixControl.layoutManager;
                    this.scrollOffset = 0;
                }
                TablixDimension.prototype._onStartRenderingIteration = function () {
                    this.updateScrollPosition();
                };
                TablixDimension.prototype._onEndRenderingIteration = function () {
                };
                TablixDimension.prototype.getValidScrollOffset = function (scrollOffset) {
                    return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
                };
                TablixDimension.prototype.makeScrollOffsetValid = function () {
                    this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
                };
                TablixDimension.prototype.getIntegerScrollOffset = function () {
                    return Math.floor(this.scrollOffset);
                };
                TablixDimension.prototype.getFractionScrollOffset = function () {
                    return this.scrollOffset - this.getIntegerScrollOffset();
                };
                Object.defineProperty(TablixDimension.prototype, "scrollbar", {
                    get: function () {
                        return this._scrollbar;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype.getFirstVisibleItem = function (level) {
                    return this._scrollItems[level];
                };
                TablixDimension.prototype.getFirstVisibleChild = function (item) {
                    return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
                };
                TablixDimension.prototype.getFirstVisibleChildIndex = function (item) {
                    var startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
                    var firstVisibleIndex;
                    if (startItem === undefined || (startItem !== undefined && this._hierarchyNavigator.getParent(startItem) !== item)) {
                        firstVisibleIndex = 0;
                    }
                    else {
                        firstVisibleIndex = this._hierarchyNavigator.getIndex(startItem);
                    }
                    return firstVisibleIndex;
                };
                TablixDimension.prototype._initializeScrollbar = function (parentElement, touchDiv, layoutKind) {
                    var _this = this;
                    this._scrollbar = this._createScrollbar(parentElement, layoutKind);
                    this._scrollbar._onscroll.push(function (e) { return _this.onScroll(); });
                    if (touchDiv) {
                        this.scrollbar.initTouch(touchDiv, true);
                        touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom");
                    }
                };
                TablixDimension.prototype.getItemsCount = function () {
                    return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
                };
                TablixDimension.prototype.getDepth = function () {
                    return this.modelDepth;
                };
                TablixDimension.prototype.onScroll = function () {
                    this.scrollOffset = this._scrollbar.viewMin;
                    this._owner._onScrollAsync(this);
                };
                Object.defineProperty(TablixDimension.prototype, "otherDimension", {
                    get: function () {
                        return this._otherDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixDimension.prototype, "layoutManager", {
                    get: function () {
                        return this._layoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    // abstract
                    debug.assertFail("PureVirtualMethod: TablixDimension._createScrollbar");
                    return null;
                };
                TablixDimension.prototype.updateScrollPosition = function () {
                    this._scrollItems = [];
                    if (!this.model) {
                        return;
                    }
                    var firstVisibleScrollIndex = this.getIntegerScrollOffset();
                    var firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
                    if (!firstVisible) {
                        return;
                    }
                    this._firstVisibleScrollIndex = firstVisibleScrollIndex;
                    do {
                        this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible;
                        firstVisible = this._hierarchyNavigator.getParent(firstVisible);
                    } while (firstVisible !== null);
                };
                return TablixDimension;
            }());
            controls.TablixDimension = TablixDimension;
            var TablixRowDimension = (function (_super) {
                __extends(TablixRowDimension, _super);
                function TablixRowDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.rowLayoutManager;
                    this._footer = null;
                }
                TablixRowDimension.prototype.setFooter = function (footerHeader) {
                    this._footer = footerHeader;
                    this._owner.updateFooterVisibility();
                };
                TablixRowDimension.prototype.hasFooter = function () {
                    return (this._footer !== null);
                };
                /**
                 * This method first populates the footer followed by each row and their correlating body cells from top to bottom.
                 */
                TablixRowDimension.prototype._render = function () {
                    var firstVisibleRowItem = this.getFirstVisibleItem(0);
                    if (this.hasFooter()) {
                        this.addFooterRowHeader(this._footer);
                        this.addFooterBodyCells(this._footer);
                    }
                    if (firstVisibleRowItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
                    }
                };
                TablixRowDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    return new controls.VerticalScrollbar(parentElement, layoutKind);
                };
                /**
                 * This function is a recursive call (with its recursive behavior in addNode()) that will navigate
                 * through the row hierarchy in DFS (Depth First Search) order and continue into a single row
                 * upto its estimated edge.
                 */
                TablixRowDimension.prototype.addNodes = function (items, rowIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    //for loop explores children of current "items"
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var item = this._hierarchyNavigator.getAt(items, i);
                        var cell = this.addNode(item, items, rowIndex, depth);
                        rowIndex += cell.rowSpan; //next node is bumped down according cells vertical span
                    }
                };
                TablixRowDimension.prototype.getFirstVisibleChildLeaf = function (item) {
                    var leaf = item;
                    while (!this._hierarchyNavigator.isLeaf(leaf)) {
                        leaf = this.getFirstVisibleChild(leaf);
                    }
                    return leaf;
                };
                TablixRowDimension.prototype.bindRowHeader = function (item, cell) {
                    this._binder.bindRowHeader(item, cell);
                };
                /**
                 * This method can be thought of as the continuation of addNodes() as it continues the DFS (Depth First Search)
                 * started from addNodes(). This function also handles ending the recursion with "_needsToRealize" being set to
                 * false.
                 *
                 * Once the body cells are reached, populating is done linearly with addBodyCells().
                 */
                TablixRowDimension.prototype.addNode = function (item, items, rowIndex, depth) {
                    var previousCount;
                    var rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item));
                    var match = this.rowHeaderMatch(item, rowHeaderCell);
                    if (!match) {
                        this._owner._unbindCell(rowHeaderCell);
                        rowHeaderCell.type = 1 /* RowHeader */;
                        rowHeaderCell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item);
                        rowHeaderCell.rowSpan = 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                        this.addBodyCells(item, items, rowIndex);
                    }
                    else {
                        previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item));
                        rowHeaderCell.colSpan = 1;
                        rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                    }
                    return rowHeaderCell;
                };
                TablixRowDimension.prototype.rowHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 1 /* RowHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                TablixRowDimension.prototype.addBodyCells = function (item, items, rowIndex) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth();
                    var hierarchyNavigator = this._hierarchyNavigator;
                    var otherModel = this._otherDimension.model;
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i));
                        var cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
                        this.bindBodyCell(cellItem, cell);
                        layoutManager.onBodyCellRealized(cellItem, cell);
                    }
                };
                TablixRowDimension.prototype.bindBodyCell = function (item, cell) {
                    var match = this.bodyCelMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 3 /* BodyCell */;
                        cell.item = item;
                        this._binder.bindBodyCell(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterRowHeader = function (item) {
                    var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
                    cell.colSpan = this.getDepth();
                    var match = this.rowHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 1 /* RowHeader */;
                        cell.item = item;
                        this.bindRowHeader(item, cell);
                        this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterBodyCells = function (rowItem) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth();
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i);
                        //get corelating body cell and bind it
                        var item = this._hierarchyNavigator.getIntersection(rowItem, columnItem);
                        var cell = layoutManager.getOrCreateFooterBodyCell(item, i);
                        this.bindBodyCell(item, cell);
                        layoutManager.onBodyCellFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.bodyCelMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 3 /* BodyCell */ && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
                };
                return TablixRowDimension;
            }(TablixDimension));
            controls.TablixRowDimension = TablixRowDimension;
            var TablixColumnDimension = (function (_super) {
                __extends(TablixColumnDimension, _super);
                function TablixColumnDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.columnLayoutManager;
                }
                TablixColumnDimension.prototype._render = function () {
                    var firstVisibleColumnItem = this.getFirstVisibleItem(0);
                    if (firstVisibleColumnItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
                    }
                };
                TablixColumnDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    var scrollbar = new controls.HorizontalScrollbar(parentElement, layoutKind);
                    // Set smallest increment of the scrollbar to 0.2 rows
                    scrollbar.smallIncrement = 0.2;
                    return scrollbar;
                };
                TablixColumnDimension.prototype.addNodes = function (items, columnIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
                        columnIndex += cell.colSpan;
                    }
                };
                TablixColumnDimension.prototype.addNode = function (item, items, columnIndex, depth) {
                    var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex);
                    var match = this.columnHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 2 /* ColumnHeader */;
                        cell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item);
                    }
                    else {
                        var previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
                        // In case we have a grand total with multiple measures, the multi-measures will be direct children
                        // There can be difference in level > 1. In this case, we want the Total cell to have rowspan = the difference
                        var childrenLevelDifference = this._hierarchyNavigator.getChildrenLevelDifference(item);
                        if (childrenLevelDifference === Infinity)
                            cell.rowSpan = 1;
                        else
                            cell.rowSpan = childrenLevelDifference;
                        cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                    }
                    if (!match)
                        this._binder.bindColumnHeader(item, cell);
                    this._tablixLayoutManager.onColumnHeaderRealized(item, cell);
                    return cell;
                };
                TablixColumnDimension.prototype.columnHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 2 /* ColumnHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                return TablixColumnDimension;
            }(TablixDimension));
            controls.TablixColumnDimension = TablixColumnDimension;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            /**
             * This class represents the touch region of the column headers (this can also apply to footer/total).
             * This class is reponsible for interpreting gestures in terms of pixels to changes in column position.
             *
             * Unlike the table body, this can only scroll in one direction.
             */
            var ColumnTouchDelegate = (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function ColumnTouchDelegate(region) {
                    this.dim = region;
                    this.averageSize = 1; //default
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of columns to be shifted per delta in pixels.
                 *
                 * @param xRatio Column to pixel ratio (# columns / # pixels).
                 */
                ColumnTouchDelegate.prototype.setScrollDensity = function (xRatio) {
                    this.averageSize = xRatio;
                };
                /**
                 * Resize element.
                 *
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                ColumnTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this.dim.x = x;
                    this.dim.y = y;
                    this.dim.width = width;
                    this.dim.height = height;
                };
                /**
                 * @see IPixelToItem.
                 */
                ColumnTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSize, 0, down, -dx * this.averageSize, 0);
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                ColumnTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this.tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                ColumnTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                return ColumnTouchDelegate;
            }());
            controls.ColumnTouchDelegate = ColumnTouchDelegate;
            /**
             * This class represents the touch region of the row headers (left or right side aligned).
             * This class is reponsible for interpreting gestures in terms of pixels to changes in row position.
             *
             * Unlike the table body, this can only scroll in one direction.
             */
            var RowTouchDelegate = (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function RowTouchDelegate(region) {
                    this.dim = region;
                    this.averageSize = 30; //default
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of rows to be shifted per delta in pixels.
                 *
                 * @param yRatio Row to pixel ratio (# rows / # pixels).
                 */
                RowTouchDelegate.prototype.setScrollDensity = function (yRatio) {
                    this.averageSize = yRatio;
                };
                /**
                 * Resize element.
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                RowTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this.dim.x = x;
                    this.dim.y = y;
                    this.dim.width = width;
                    this.dim.height = height;
                };
                /**
                 * @see: IPixelToItem
                 */
                RowTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    var event = new controls.TouchUtils.TouchEvent(0, y * this.averageSize, down, 0, -dy * this.averageSize);
                    return event;
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                RowTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this.tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                RowTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                return RowTouchDelegate;
            }());
            controls.RowTouchDelegate = RowTouchDelegate;
            /**
             * This class represents the touch region covering the body of the table.
             * This class is reponsible for interpreting gestures in terms of pixels to
             * changes in row and column position.
             */
            var BodyTouchDelegate = (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function BodyTouchDelegate(region) {
                    this.dim = region;
                    this.averageSizeX = BodyTouchDelegate.DefaultAverageSizeX;
                    this.averageSizeY = BodyTouchDelegate.DefaultAverageSizeY;
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
                    /**
                     * Returns dimension.
                     *
                     * @return The dimentions of the region this delegate listens to.
                     */
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of rows and columns to be shifted per delta in pixels.
                 *
                 * @param xRatio Column to pixel ratio (# columns / # pixels)
                 * @param yRatio Row to pixel ratio (# rows / # pixels)
                 */
                BodyTouchDelegate.prototype.setScrollDensity = function (xRatio, yRatio) {
                    this.averageSizeX = xRatio;
                    this.averageSizeY = yRatio;
                };
                /**
                 * Resize element.
                 *
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                BodyTouchDelegate.prototype.resize = function (x, y, width, height) {
                    var dimension = this.dim;
                    dimension.x = x;
                    dimension.y = y;
                    dimension.width = width;
                    dimension.height = height;
                };
                /**
                 * @see: IPixelToItem.
                 */
                BodyTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSizeX, y * this.averageSizeY, down, -dx * this.averageSizeX, -dy * this.averageSizeY);
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                BodyTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [this.tablixControl, e.dx, e.dy];
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                BodyTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                BodyTouchDelegate.DefaultAverageSizeX = 30;
                BodyTouchDelegate.DefaultAverageSizeY = 30;
                return BodyTouchDelegate;
            }());
            controls.BodyTouchDelegate = BodyTouchDelegate;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TouchUtils;
            (function (TouchUtils) {
                var Point = (function () {
                    function Point(x, y) {
                        this.x = x || 0;
                        this.y = y || 0;
                    }
                    Point.prototype.offset = function (offsetX, offsetY) {
                        this.x += offsetX;
                        this.y += offsetY;
                    };
                    return Point;
                }());
                TouchUtils.Point = Point;
                var Rectangle = (function (_super) {
                    __extends(Rectangle, _super);
                    function Rectangle(x, y, width, height) {
                        _super.call(this, x, y);
                        this.width = width || 0;
                        this.height = height || 0;
                    }
                    Object.defineProperty(Rectangle.prototype, "point", {
                        get: function () {
                            return new Point(this.x, this.y);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Rectangle.prototype.contains = function (p) {
                        return Rectangle.contains(this, p);
                    };
                    Rectangle.contains = function (rect, p) {
                        if (p && !Rectangle.isEmpty(rect)) {
                            return rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height;
                        }
                        return false;
                    };
                    Rectangle.isEmpty = function (rect) {
                        return !(rect !== undefined && rect.width >= 0 && rect.height >= 0);
                    };
                    return Rectangle;
                }(Point));
                TouchUtils.Rectangle = Rectangle;
                (function (MouseButton) {
                    MouseButton[MouseButton["NoClick"] = 0] = "NoClick";
                    MouseButton[MouseButton["LeftClick"] = 1] = "LeftClick";
                    MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
                    MouseButton[MouseButton["CenterClick"] = 3] = "CenterClick";
                })(TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
                var MouseButton = TouchUtils.MouseButton;
                /**
                 * A simple touch event class that's abstracted away from any platform specific traits.
                 */
                var TouchEvent = (function () {
                    /**
                     * @constructor
                     * @param x X Location of mouse.
                     * @param y Y Location of mouse.
                     * @param isMouseDown Indicates if the mouse button is held down or a finger press on screen.
                     * @param dx (optional) The change in x of the gesture.
                     * @param dy (optional) The change in y of the gesture.
                     */
                    function TouchEvent(x, y, isMouseDown, dx, dy) {
                        this._x = x;
                        this._y = y;
                        this.isMouseButtonDown = isMouseDown;
                        this._dx = dx || 0;
                        this._dy = dy || 0;
                    }
                    Object.defineProperty(TouchEvent.prototype, "x", {
                        get: function () {
                            return this._x;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "y", {
                        get: function () {
                            return this._y;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dx", {
                        get: function () {
                            return this._dx;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dy", {
                        get: function () {
                            return this._dy;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
                        /**
                         * Returns a boolean indicating if the mouse button is held down.
                         *
                         * @return: True if the the mouse button is held down,
                         * otherwise false.
                         */
                        get: function () {
                            return this.isMouseButtonDown;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TouchEvent;
                }());
                TouchUtils.TouchEvent = TouchEvent;
                /**
                 * This class "listens" to the TouchEventInterpreter  to recieve touch events and sends it to all
                 * "Touch Delegates" with  TouchRegions that contain the mouse event. Prior to sending off the
                 * event, its position is put in respect to the delegate's TouchRegion and converted to the appropriate
                 * unit (see IPixelToItem).
                 */
                var TouchManager = (function () {
                    /**
                     * Default constructor.
                     *
                     * The default behavior is to enable thresholds and lock to axis.
                     */
                    function TouchManager() {
                        this.touchList = [];
                        this.swipeDirection = 2 /* FreeForm */;
                        this.matchingDirectionCount = 0;
                        this.lockThreshold = true;
                        this.scrollThreshold = true;
                        this.lastTouchEvent = new TouchEvent(0, 0, false);
                    }
                    Object.defineProperty(TouchManager.prototype, "lastEvent", {
                        get: function () {
                            return this.lastTouchEvent;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * @param region Rectangle indicating the locations of the touch region.
                     * @param handler Handler for recieved touch events.
                     * @param converter Converts from pixels to the wanted item of measure (rows, columns, etc).
                     *
                     * EXAMPLE: dx -> from # of pixels to the right to # of columns moved to the right.
                     */
                    TouchManager.prototype.addTouchRegion = function (region, handler, converter) {
                        var item = {
                            lastPoint: new TouchEvent(0, 0, false),
                            handler: handler,
                            region: region,
                            converter: converter
                        };
                        this.touchList = this.touchList.concat([item]);
                    };
                    /**
                     * Sends a mouse up event to all regions with their last event as a mouse down event.
                     */
                    TouchManager.prototype.upAllTouches = function () {
                        var eventPoint;
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].lastPoint.isMouseDown) {
                                eventPoint = this.touchList[i].converter.getPixelToItem(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, 0, 0, false);
                                this.touchList[i].handler.touchEvent(eventPoint);
                            }
                            this.touchList[i].lastPoint = new TouchEvent(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, false);
                        }
                        this.lastTouchEvent = new TouchEvent(0, 0, false);
                    };
                    TouchManager.prototype.touchEvent = function (e) {
                        var list;
                        var length;
                        var x = 0;
                        var y = 0;
                        var dx = 0;
                        var dy = 0;
                        var angle = 0;
                        var eventPoint = null;
                        //assume there are already regions in the middle of a drag event and get those regions
                        list = this._getActive();
                        //if this is the start of a mouse drag event, repopulate the list with touched regions
                        if (!this.lastTouchEvent.isMouseDown && e.isMouseDown) {
                            list = this._findRegions(e);
                        }
                        //determine the delta values and update last event (delta ignored on first mouse down event)
                        dx = this.lastTouchEvent.x - e.x;
                        dy = this.lastTouchEvent.y - e.y;
                        this.lastTouchEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy);
                        //go through the list
                        length = list.length;
                        for (var i = 0; i < length; i++) {
                            x = e.x - list[i].region.point.x;
                            y = e.y - list[i].region.point.y;
                            //is this in the middle of a drag?
                            if (list[i].lastPoint.isMouseDown && e.isMouseDown) {
                                dx = x - list[i].lastPoint.x;
                                dy = y - list[i].lastPoint.y;
                                //calculate the absolute angle from the horizontal axis
                                angle = Math.abs(180 / Math.PI * Math.atan(dy / dx));
                                if (this.scrollThreshold) {
                                    //is the gesture already locked? (6 prior events within the threshold)
                                    if (this.lockThreshold && (this.matchingDirectionCount > 5)) {
                                        if (this.swipeDirection === 1 /* Horizontal */) {
                                            dy = 0;
                                        }
                                        else if (this.swipeDirection === 0 /* Vertical */) {
                                            dx = 0;
                                        }
                                    }
                                    else {
                                        //is it within the horizontal threshold?
                                        if (angle < 20) {
                                            dy = 0;
                                            if (this.swipeDirection === 1 /* Horizontal */) {
                                                this.matchingDirectionCount++;
                                            }
                                            else {
                                                this.matchingDirectionCount = 1;
                                                this.swipeDirection = 1 /* Horizontal */;
                                            }
                                        }
                                        else {
                                            //calculate the absolute angle from the vertical axis
                                            angle = Math.abs(180 / Math.PI * Math.atan(dx / dy));
                                            //is it within the horizontal threshold?
                                            if (angle < 20) {
                                                dx = 0;
                                                if (this.swipeDirection === 0 /* Vertical */) {
                                                    this.matchingDirectionCount++;
                                                }
                                                else {
                                                    this.matchingDirectionCount = 1;
                                                    this.swipeDirection = 0 /* Vertical */;
                                                }
                                            }
                                            else {
                                                if (this.swipeDirection === 2 /* FreeForm */) {
                                                    this.matchingDirectionCount++;
                                                }
                                                else {
                                                    this.swipeDirection = 2 /* FreeForm */;
                                                    this.matchingDirectionCount = 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                dx = 0;
                                dy = 0;
                                this.swipeDirection = 2 /* FreeForm */;
                                this.matchingDirectionCount = 0;
                            }
                            list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy);
                            eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown);
                            list[i].handler.touchEvent(eventPoint);
                        }
                    };
                    /**
                     * @param e Position of event used to find touched regions
                     * @return Array of regions that contain the event point.
                     */
                    TouchManager.prototype._findRegions = function (e) {
                        var list = [];
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].region.contains(new Point(e.x, e.y))) {
                                list = list.concat([this.touchList[i]]);
                            }
                        }
                        return list;
                    };
                    /**
                     * @return Array of regions that contain a mouse down event. (see ITouchHandlerSet.lastPoint).
                     */
                    TouchManager.prototype._getActive = function () {
                        var list = [];
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].lastPoint.isMouseDown) {
                                list = list.concat([this.touchList[i]]);
                            }
                        }
                        return list;
                    };
                    return TouchManager;
                }());
                TouchUtils.TouchManager = TouchManager;
                var MinDistanceForSwipe = 80;
                var MaxTimeForSwipe = 600;
                /**
                 * This class is responsible for establishing connections to handle touch events
                 * and to interpret those events so they're compatible with the touch abstractions.
                 *
                 * Touch events with platform specific handles should be done here.
                 */
                var TouchEventInterpreter = (function () {
                    function TouchEventInterpreter(manager) {
                        this.manager = manager;
                        this.allowMouseDrag = true;
                        this.touchPanel = null;
                        this.scale = 1;
                        this.documentMouseMoveWrapper = null;
                        this.documentMouseUpWrapper = null;
                        this.sliding = false;
                    }
                    TouchEventInterpreter.prototype.initTouch = function (panel, touchReferencePoint, allowMouseDrag) {
                        var _this = this;
                        panel.style.setProperty("-ms-touch-action", "pinch-zoom");
                        this.touchReferencePoint = touchReferencePoint;
                        this.touchPanel = panel;
                        this.allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                        if ("ontouchmove" in panel) {
                            panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
                            panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
                        }
                        else {
                            panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
                            panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
                        }
                    };
                    TouchEventInterpreter.prototype.getXYByClient = function (pageX, pageY, rect) {
                        var x = rect.left;
                        var y = rect.top;
                        // Fix for Safari
                        if (window["scrollX"] !== undefined) {
                            x += window["scrollX"];
                            y += window["scrollY"];
                        }
                        var point = new Point(0, 0);
                        point.offset(pageX - x, pageY - y);
                        return point;
                    };
                    TouchEventInterpreter.prototype.onTouchStart = function (e) {
                        if (e.touches.length === 1) {
                            e.cancelBubble = true;
                            var mouchEvent = e.touches[0];
                            this.touchStartTime = new Date().getTime();
                            this.touchStartPageY = mouchEvent.pageY;
                            this.onTouchMouseDown(mouchEvent);
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMove = function (e) {
                        if (e.touches.length === 1) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            var mouchEvent = e.touches[0];
                            this.touchLastPageY = mouchEvent.pageY;
                            this.touchLastPageX = mouchEvent.pageX;
                            // while sliding ignore the touch move event 
                            if (!this.sliding) {
                                this.onTouchMouseMove(mouchEvent);
                            }
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchEnd = function (e) {
                        this.clearTouchEvents();
                        var swipeInfo = this.getSwipeInfo();
                        if (this.didUserSwipe(swipeInfo)) {
                            this.startSlideAffect(swipeInfo);
                        }
                        else if (!this.sliding) {
                            this.upAllTouches();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseDown = function (e) {
                        var _this = this;
                        this.scale = controls.HTMLElementUtils.getAccumulatedScale(this.touchPanel);
                        //any prior touch scrolling that produced a selection outside Tablix will prevent the next touch scroll (1262519)
                        document.getSelection().removeAllRanges();
                        this.rect = (this.touchReferencePoint ? this.touchReferencePoint : this.touchPanel).getBoundingClientRect();
                        if ("ontouchmove" in this.touchPanel) {
                            this.documentMouseMoveWrapper = function (e) { return _this.onTouchMove(e); };
                            document.addEventListener("touchmove", this.documentMouseMoveWrapper);
                            this.documentMouseUpWrapper = function (e) { return _this.onTouchEnd(e); };
                            document.addEventListener("touchend", this.documentMouseUpWrapper);
                        }
                        else {
                            this.documentMouseMoveWrapper = function (e) { return _this.onTouchMouseMove(e); };
                            document.addEventListener("mousemove", this.documentMouseMoveWrapper);
                            this.documentMouseUpWrapper = function (e) { return _this.onTouchMouseUp(e); };
                            document.addEventListener("mouseup", this.documentMouseUpWrapper);
                        }
                        if ("setCapture" in this.touchPanel) {
                            this.touchPanel.setCapture();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseMove = function (e) {
                        var event;
                        var point;
                        var rect = this.rect;
                        var validMouseDragEvent = (rect !== null) && (e.which !== MouseButton.NoClick);
                        // Ignore events that are not part of a drag event
                        if (!validMouseDragEvent || this.sliding)
                            return;
                        point = this.getXYByClient(e.pageX, e.pageY, rect);
                        event = new TouchEvent(point.x / this.scale, point.y / this.scale, validMouseDragEvent);
                        this.manager.touchEvent(event);
                        if (e.preventDefault)
                            e.preventDefault();
                        else if ("returnValue" in e)
                            e["returnValue"] = false;
                    };
                    TouchEventInterpreter.prototype.onTouchMouseUp = function (e, bubble) {
                        this.upAllTouches();
                        this.clearTouchEvents();
                    };
                    TouchEventInterpreter.prototype.getSwipeInfo = function () {
                        var touchEndTime = new Date().getTime();
                        var touchTime = touchEndTime - this.touchStartTime;
                        var touchDist = this.touchLastPageY - this.touchStartPageY;
                        var touchDirection = touchDist < 0 ? -1 : 1;
                        return {
                            direction: touchDirection,
                            distance: touchDist,
                            endTime: touchEndTime,
                            time: touchTime,
                        };
                    };
                    TouchEventInterpreter.prototype.didUserSwipe = function (swipeInfo) {
                        return swipeInfo.time < MaxTimeForSwipe && swipeInfo.distance * swipeInfo.direction > MinDistanceForSwipe;
                    };
                    /**
                     * In case of swipe - auto advance to the swipe direction in 2 steps.
                     */
                    TouchEventInterpreter.prototype.startSlideAffect = function (swipeInfo) {
                        var _this = this;
                        if (this.sliding) {
                            return;
                        }
                        this.sliding = true;
                        var point = this.getXYByClient(this.touchLastPageX, this.touchLastPageY, this.rect);
                        this.slide(point, 300, swipeInfo);
                        // second step
                        requestAnimationFrame(function () {
                            // in case the user is now scrolling in the opposite direction stop the slide
                            if (!_this.didUserChangeDirection(swipeInfo)) {
                                _this.slide(point, 200, swipeInfo);
                            }
                            _this.clearSlide();
                        });
                    };
                    TouchEventInterpreter.prototype.didUserChangeDirection = function (swipeInfo) {
                        if (this.touchStartTime <= swipeInfo.endTime) {
                            return false;
                        }
                        var updatedDist = this.touchLastPageY - this.touchStartPageY;
                        var updatedDirection = updatedDist < 0 ? -1 : 1;
                        return updatedDirection !== swipeInfo.direction;
                    };
                    TouchEventInterpreter.prototype.slide = function (point, slideDist, swipeInfo) {
                        var updatedDist = this.touchStartTime > swipeInfo.endTime ? this.touchLastPageY - this.touchStartPageY : 0;
                        point.y += slideDist * swipeInfo.direction + updatedDist;
                        var event = new TouchEvent(point.x / this.scale, point.y / this.scale, true);
                        this.manager.touchEvent(event);
                    };
                    TouchEventInterpreter.prototype.clearSlide = function () {
                        this.sliding = false;
                        this.upAllTouches();
                    };
                    TouchEventInterpreter.prototype.upAllTouches = function () {
                        if (this.documentMouseMoveWrapper !== null)
                            return;
                        this.rect = null;
                        this.manager.upAllTouches();
                    };
                    TouchEventInterpreter.prototype.clearTouchEvents = function () {
                        if ("releaseCapture" in this.touchPanel) {
                            this.touchPanel.releaseCapture();
                        }
                        if (this.documentMouseMoveWrapper === null)
                            return;
                        if ("ontouchmove" in this.touchPanel) {
                            document.removeEventListener("touchmove", this.documentMouseMoveWrapper);
                            document.removeEventListener("touchend", this.documentMouseUpWrapper);
                        }
                        else {
                            document.removeEventListener("mousemove", this.documentMouseMoveWrapper);
                            document.removeEventListener("mouseup", this.documentMouseUpWrapper);
                        }
                        this.documentMouseMoveWrapper = null;
                        this.documentMouseUpWrapper = null;
                    };
                    return TouchEventInterpreter;
                }());
                TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
            })(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            (function (TablixType) {
                TablixType[TablixType["Matrix"] = 0] = "Matrix";
                TablixType[TablixType["Table"] = 1] = "Table";
            })(controls.TablixType || (controls.TablixType = {}));
            var TablixType = controls.TablixType;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var PropAutoSizeWidth = controls.internal.TablixObjects.PropGeneralAutoSizeColumns;
            var getMetadataObjects = controls.internal.TablixObjects.getMetadadataObjects;
            var TablixColumnWidthManager = (function () {
                function TablixColumnWidthManager(dataView, isMatrix, hostPersistCallBack, matrixLeafNodes) {
                    this.columnWidthObjects = [];
                    this.isMatrix = isMatrix;
                    this.updateDataView(dataView, matrixLeafNodes);
                    this.hostPersistCallBack = hostPersistCallBack;
                }
                /**
                 * Update the current DataView
                 * @param {dataView} DataView new DataView
                 * @param {MatrixVisualNode[]} matrixLeafNodes? (Optional)Matrix Leaf Nodes
                 */
                TablixColumnWidthManager.prototype.updateDataView = function (dataView, matrixLeafNodes) {
                    this.previousDataView = this.currentDataView;
                    if (this.previousDataView)
                        this.previousAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.previousDataView));
                    else
                        this.previousAutoColumnSizePropertyValue = undefined;
                    this.currentDataView = dataView;
                    if (this.currentDataView)
                        this.currentAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.currentDataView));
                    else
                        this.currentAutoColumnSizePropertyValue = undefined;
                    this.matrixLeafNodes = matrixLeafNodes;
                    this.updateColumnWidthObjects();
                    this.updateTablixColumnWidths();
                };
                /**
                * Destroy columnWidthObjects and construct it again from the currently displayed Columns
                */
                TablixColumnWidthManager.prototype.updateColumnWidthObjects = function () {
                    this.columnWidthObjects.length = 0;
                    if (this.isMatrix)
                        this.updateMatrixColumnWidthObjects();
                    else
                        this.updateTableColumnWidthObjects();
                };
                TablixColumnWidthManager.prototype.updateTableColumnWidthObjects = function () {
                    if (this.currentDataView && this.currentDataView.table) {
                        var columnMetaData = this.currentDataView.table.columns;
                        for (var i = 0, len = columnMetaData.length; i < len; i++) {
                            var query = columnMetaData[i].queryName;
                            this.columnWidthObjects.push({
                                queryName: query,
                                width: undefined
                            });
                        }
                    }
                };
                TablixColumnWidthManager.prototype.updateMatrixColumnWidthObjects = function () {
                    // Matrix visual columns are row headers and column hierarchy leaves
                    if (this.currentDataView && this.currentDataView.matrix && this.currentDataView.matrix.rows) {
                        // Get query names of row groups (row headers)
                        for (var i = 0, len = this.currentDataView.matrix.rows.levels.length; i < len; i++) {
                            var rowGroup = this.currentDataView.matrix.rows.levels[i]; // TODO: Investigate multi-source groups
                            if (!_.isEmpty(rowGroup.sources))
                                this.columnWidthObjects.push({
                                    queryName: rowGroup.sources[0].queryName,
                                    width: undefined
                                });
                        }
                    }
                    // Get query names of columns leaves or values
                    if (this.matrixLeafNodes) {
                        for (var i = 0, len = this.matrixLeafNodes.length; i < len; i++) {
                            var query = this.matrixLeafNodes[i].queryName;
                            this.columnWidthObjects.push({
                                queryName: query,
                                width: undefined
                            });
                        }
                    }
                };
                /**
                 * Update the column widths after a dataViewChange
                 */
                TablixColumnWidthManager.prototype.updateTablixColumnWidths = function () {
                    var columnMetaData = this.currentDataView && this.currentDataView.metadata && this.currentDataView.metadata.columns;
                    if (columnMetaData) {
                        // Auto-Size false to true.
                        // Blow away any saved widths and revert back to default of calculating column sizes
                        if (this.shouldClearAllColumnWidths()) {
                            this.autoSizeAllColumns();
                        }
                        else {
                            this.deserializeColumnWidths(columnMetaData);
                        }
                    }
                };
                /**
                 * Read the Column Widths from the Columns metadata
                 * @param {DataViewMetadataColumn[]} columnMetaData Columns metadata
                 */
                TablixColumnWidthManager.prototype.deserializeColumnWidths = function (columnMetaData) {
                    // Clear existing widths
                    this.columnWidthObjects.forEach(function (obj) {
                        obj.width = undefined;
                    });
                    for (var _i = 0, columnMetaData_1 = columnMetaData; _i < columnMetaData_1.length; _i++) {
                        var column = columnMetaData_1[_i];
                        var columnWidthPropValue = powerbi.DataViewObjects.getValue(column.objects, TablixColumnWidthManager.columnWidthProp);
                        if (!_.isNumber(columnWidthPropValue)) {
                            continue;
                        }
                        for (var _a = 0, _b = this.columnWidthObjects; _a < _b.length; _a++) {
                            var obj = _b[_a];
                            if (obj.queryName === column.queryName) {
                                obj.width = columnWidthPropValue;
                            }
                        }
                    }
                };
                /**
                 * Returns a value indicating that autoSizeColumns was flipped from true to false
                 */
                TablixColumnWidthManager.prototype.shouldPersistAllColumnWidths = function () {
                    // We don't have a previous DataView -> Don't persist
                    if (!this.previousDataView)
                        // TODO: 6928446
                        // Once 6927388 gets fixed, we need to persist the DataView is first loaded with AutoSize off to count for missing set widths
                        return false;
                    else
                        return !this.currentAutoColumnSizePropertyValue && this.previousAutoColumnSizePropertyValue;
                };
                /**
                 * Returns a value indicating that autoSizeColumns was flipped from false to true
                 */
                TablixColumnWidthManager.prototype.shouldClearAllColumnWidths = function () {
                    return this.previousDataView != null && this.previousAutoColumnSizePropertyValue === false
                        && this.currentDataView != null && this.currentAutoColumnSizePropertyValue === true;
                };
                /**
                 * Returns the current columnWidthObjects
                 * @returns current columnWidthObjects including undefined widths for autosized columns
                 */
                TablixColumnWidthManager.prototype.getColumnWidthObjects = function () {
                    return this.columnWidthObjects;
                };
                /**
                 * Returns the current columnWidthObjects for only the fixed-size columns
                 * @returns Returns the current columnWidthObjects excluding auto-sized columns
                 */
                TablixColumnWidthManager.prototype.getFixedColumnWidthObjects = function () {
                    return this.columnWidthObjects.filter(function (obj) {
                        return obj.width != null;
                    });
                };
                /**
                 * Get the persisted width of a certain column in px, or undefined if the columns is set to autosize or index is out of range
                 * @param {number} index index of the Column
                 * @returns Column persisted width in pixel
                 */
                TablixColumnWidthManager.prototype.getPersistedColumnWidth = function (index) {
                    var colIndex = this.isMatrix ? index : index - 1;
                    var item = this.columnWidthObjects[colIndex];
                    if (item)
                        return item.width;
                    else
                        return undefined;
                };
                /**
                 * Call the host to persist the data
                 * @param {boolean} generateInstances
                 */
                TablixColumnWidthManager.prototype.callHostToPersist = function (generateInstances) {
                    if (generateInstances)
                        this.generateVisualObjectInstancesToPersist();
                    if (this.hostPersistCallBack) {
                        this.hostPersistCallBack(this.visualObjectInstancesToPersist);
                    }
                };
                /**
                 * Remove all persisted columns widths and Update visualObjectInstancesToPersist
                 */
                TablixColumnWidthManager.prototype.autoSizeAllColumns = function () {
                    this.visualObjectInstancesToPersist = {
                        merge: [this.getAutoSizeColumnWidthObject()],
                        remove: [],
                    };
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var columnWidthObject = _a[_i];
                        this.visualObjectInstancesToPersist.remove.push({
                            selector: { metadata: columnWidthObject.queryName },
                            objectName: 'general',
                            properties: {
                                columnWidth: undefined
                            }
                        });
                    }
                    this.callHostToPersist(false);
                };
                /**
                 * Remove persisted column width for a specific column and Update visualObjectInstancesToPersist
                 */
                TablixColumnWidthManager.prototype.onColumnAutosized = function (queryName) {
                    // If AutoSize option is ON, remove the persisted value
                    // Else, update the persisted value
                    var width = this.currentAutoColumnSizePropertyValue ? undefined : -1;
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        if (obj.queryName === queryName) {
                            obj.width = width;
                        }
                    }
                    ;
                    // If AutoSize option is ON, remove the persisted value
                    if (this.currentAutoColumnSizePropertyValue) {
                        this.visualObjectInstancesToPersist = {
                            remove: [{
                                    selector: { metadata: queryName },
                                    objectName: 'general',
                                    properties: { columnWidth: undefined }
                                }],
                        };
                        this.callHostToPersist(false);
                    }
                    // Else, do nothing. A Column Resize will be triggered soon
                };
                /**
                 * Handler for a column width change by the user
                 * @param {number} index zero-based index of the column, including hidden row header for table
                 * @param {number} width new width
                 */
                TablixColumnWidthManager.prototype.onColumnWidthChanged = function (index, width) {
                    // Table has a hidden row headers column
                    var colIndex = this.isMatrix ? index : index - 1;
                    if (_.isEmpty(this.columnWidthObjects) || colIndex < 0 || colIndex >= this.columnWidthObjects.length)
                        return;
                    var queryName = this.columnWidthObjects[colIndex].queryName;
                    // Column Autosize
                    if (width === -1) {
                        this.onColumnAutosized(queryName);
                    }
                    else {
                        for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                            var obj = _a[_i];
                            if (obj.queryName === queryName) {
                                obj.width = width;
                            }
                        }
                        ;
                        this.callHostToPersist(true);
                    }
                };
                /**
                 * Persist all column widths, called when autoSizeColumns flipped to false
                 * @param {number[]} widthsToPersist Widths to persist, including an empty row header for table
                 */
                TablixColumnWidthManager.prototype.persistAllColumnWidths = function (widthsToPersist) {
                    var _this = this;
                    // Table indices are offset with an empty header. 
                    var widths = this.isMatrix ? widthsToPersist : widthsToPersist.slice(1, widthsToPersist.length);
                    // ToDo: Handle this properly
                    // This happens when autosizing turns OFF before knowing all widths (lots of columns outside of ViewPort)
                    if (this.columnWidthObjects.length !== widths.length) {
                        return;
                    }
                    // Pick the maximum for each queryName
                    // This will ensure going from autoSize ON to OFF will not show any ellipsis
                    var dictionary = new Array();
                    widths.forEach(function (w, i) {
                        var query = _this.columnWidthObjects[i].queryName;
                        if (dictionary[query] == null)
                            dictionary[query] = w;
                        else
                            dictionary[query] = Math.max(w, dictionary[query]);
                    });
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        var width = dictionary[obj.queryName];
                        if (width != null)
                            obj.width = width;
                    }
                    this.callHostToPersist(true);
                };
                /**
                 * Construct a ColumnAutoSize object
                 * @returns ColumnAutoSize object
                 */
                TablixColumnWidthManager.prototype.getAutoSizeColumnWidthObject = function () {
                    return {
                        selector: null,
                        objectName: 'general',
                        properties: {
                            autoSizeColumnWidth: this.currentAutoColumnSizePropertyValue
                        }
                    };
                };
                /**
                 * Generate visualObjectInstances with autoSizeColumns and Column Widths
                 */
                TablixColumnWidthManager.prototype.generateVisualObjectInstancesToPersist = function () {
                    // ToDo: Ensure lists need to be reset after call to persist
                    // AutoSize Property
                    this.visualObjectInstancesToPersist = {
                        merge: [this.getAutoSizeColumnWidthObject()]
                    };
                    // Column Widths
                    var added = new Array();
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        // Only persist width if we have a valid queryName to use as selector
                        // ToDo: Not sure how we can have an item without a queryName
                        if (obj.queryName && _.isNumber(obj.width) && !added[obj.queryName]) {
                            this.visualObjectInstancesToPersist.merge.push({
                                selector: { metadata: obj.queryName },
                                objectName: 'general',
                                properties: {
                                    columnWidth: obj.width
                                }
                            });
                            added[obj.queryName] = true;
                        }
                    }
                };
                /**
                * PropertyID for Column Widths (General > columnWidth)
                */
                TablixColumnWidthManager.columnWidthProp = { objectName: 'general', propertyName: 'columnWidth' };
                return TablixColumnWidthManager;
            }());
            controls.TablixColumnWidthManager = TablixColumnWidthManager;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Base class for values that are animated when resized.
         */
        var AnimatedText = (function () {
            function AnimatedText(name) {
                this.mainText = jsCommon.CssConstants.createClassAndSelector('mainText');
                this.name = name;
                this.visualConfiguration = { maxFontSize: 60 };
            }
            AnimatedText.prototype.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            this.metaDataColumn = column;
                            break;
                        }
                    }
                }
            };
            AnimatedText.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
                var textProperties = {
                    fontFamily: null,
                    fontSize: null,
                    text: textToMeasure
                };
                var fontHeight = this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight, 0);
                return fontHeight;
            };
            AnimatedText.prototype.getAdjustedFontHeightCore = function (textProperties, availableWidth, seedFontHeight, iteration) {
                // Too many attempts - just return what we have so we don't sacrifice perf
                if (iteration > 10) {
                    return seedFontHeight;
                }
                textProperties.fontSize = jsCommon.PixelConverter.toString(seedFontHeight);
                var candidateLength = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                if (candidateLength < availableWidth)
                    return seedFontHeight;
                return this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight * 0.9, iteration + 1);
            };
            AnimatedText.prototype.clear = function () {
                this.svg.select(this.mainText.selector).text('');
            };
            AnimatedText.prototype.doValueTransition = function (startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate, formatter) {
                if (!forceUpdate && startValue === endValue && endValue != null)
                    return;
                if (!startValue)
                    startValue = 0;
                var svg = this.svg, viewport = this.currentViewport, height = viewport.height, width = viewport.width, endValueArr = [endValue], seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(seedFontHeight), metaDataColumn = this.metaDataColumn;
                // Respect the formatter default value
                if (!formatter) {
                    formatter = visuals.valueFormatter.create({
                        format: this.getFormatString(metaDataColumn),
                        value: endValue,
                        displayUnitSystemType: displayUnitSystemType,
                        formatSingleValues: true,
                        allowFormatBeautification: true,
                        columnType: metaDataColumn ? metaDataColumn.type : undefined
                    });
                }
                var startText = formatter.format(startValue), endText = formatter.format(endValue);
                svg.attr('class', this.name);
                var textElement = svg
                    .selectAll('text')
                    .data(endValueArr);
                textElement
                    .enter()
                    .append('text')
                    .attr('class', this.mainText.class);
                var fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
                translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2);
                var textElementUpdate = textElement
                    .text(startText)
                    .attr({
                    'text-anchor': this.getTextAnchor(),
                    'font-size': fontHeight,
                    'transform': visuals.SVGUtil.translate(translateX, translateY),
                })
                    .style({
                    'fill': this.style.titleText.color.value,
                })
                    .call(visuals.tooltipUtils.tooltipUpdate, [startText]);
                if (endValue == null) {
                    textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [endText]);
                }
                else if (metaDataColumn && visuals.AxisHelper.isDateTime(metaDataColumn.type)) {
                    textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [endText]);
                }
                else {
                    var interpolatedValue_1 = startValue;
                    textElementUpdate
                        .transition()
                        .duration(duration)
                        .tween('text', function (d) {
                        var i = d3.interpolate(interpolatedValue_1, d);
                        return function (t) {
                            var num = i(t);
                            this.textContent = formatter.format(num);
                        };
                    });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(animationOptions);
            };
            AnimatedText.prototype.setTextColor = function (color) {
                this.style.titleText.color.value = color;
            };
            AnimatedText.prototype.getSeedFontHeight = function (boundingWidth, boundingHeight) {
                // Simply an estimate - it should eventually be modified based on the actual text length
                var estimatedSize = Math.floor(Math.min(boundingWidth, boundingHeight) * 0.75);
                var maxFontSize = this.visualConfiguration.maxFontSize;
                if (maxFontSize)
                    return Math.min(maxFontSize, estimatedSize);
                return estimatedSize;
            };
            AnimatedText.prototype.getTranslateX = function (width) {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                        case 'left':
                            return 0;
                        case 'right':
                            return width;
                    }
                }
                return width / 2;
            };
            AnimatedText.prototype.getTranslateY = function (height) {
                return height;
            };
            AnimatedText.prototype.getTextAnchor = function () {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                        case 'left':
                            return 'start';
                        case 'right':
                            return 'end';
                    }
                }
                return 'middle';
            };
            AnimatedText.prototype.getFormatString = function (column) {
                debug.assertAnyValue(column, 'column');
                return visuals.valueFormatter.getFormatString(column, AnimatedText.formatStringProp);
            };
            /** Note: Public for testability */
            AnimatedText.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            return AnimatedText;
        }());
        visuals.AnimatedText = AnimatedText;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Renders a number that can be animate change in value.
         */
        var AnimatedNumber = (function (_super) {
            __extends(AnimatedNumber, _super);
            function AnimatedNumber(svg, animator) {
                _super.call(this, 'animatedNumber');
                if (svg)
                    this.svg = svg;
                if (animator)
                    this.animator = animator;
            }
            AnimatedNumber.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                if (!this.svg)
                    this.svg = d3.select(element.get(0)).append('svg');
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportDependantProperties();
            };
            AnimatedNumber.prototype.updateViewportDependantProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width)
                    .attr('height', viewport.height);
            };
            AnimatedNumber.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                var dataView = dataViews[0];
                this.updateViewportDependantProperties();
                this.getMetaDataColumn(dataView);
                var newValue = dataView && dataView.single ? dataView.single.value : 0;
                if (newValue != null) {
                    this.updateInternal(newValue, options.suppressAnimations, true, this.formatter);
                }
            };
            AnimatedNumber.prototype.setFormatter = function (formatter) {
                this.formatter = formatter;
            };
            AnimatedNumber.prototype.onDataChanged = function (options) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            };
            AnimatedNumber.prototype.onResizing = function (viewport) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: viewport
                });
            };
            AnimatedNumber.prototype.canResizeTo = function (viewport) {
                // Temporarily disabling resize restriction.
                return true;
            };
            AnimatedNumber.prototype.updateInternal = function (target, suppressAnimations, forceUpdate, formatter) {
                if (forceUpdate === void 0) { forceUpdate = false; }
                var start = this.value || 0;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.doValueTransition(start, target, 
                /*displayUnitSystemType*/ null, this.options.animation, duration, forceUpdate, formatter);
                this.value = target;
            };
            return AnimatedNumber;
        }(visuals.AnimatedText));
        visuals.AnimatedNumber = AnimatedNumber;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BasicShapeVisual = (function () {
            function BasicShapeVisual(options) {
            }
            Object.defineProperty(BasicShapeVisual.prototype, "shapeType", {
                /**property for the shape line color */
                get: function () {
                    return this.data ? this.data.shapeType : BasicShapeVisual.DefaultShape;
                },
                set: function (shapeType) {
                    this.data.shapeType = shapeType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "lineColor", {
                /**property for the shape line color */
                get: function () {
                    return this.data ? this.data.lineColor : BasicShapeVisual.DefaultStrokeColor;
                },
                set: function (color) {
                    this.data.lineColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "lineTransparency", {
                /**property for the shape line transparency */
                get: function () {
                    return this.data ? this.data.lineTransparency : BasicShapeVisual.DefaultLineTransValue;
                },
                set: function (trans) {
                    this.data.lineTransparency = trans;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "lineWeight", {
                /**property for the shape line weight */
                get: function () {
                    return this.data ? this.data.lineWeight : BasicShapeVisual.DefaultWeightValue;
                },
                set: function (weight) {
                    this.data.lineWeight = weight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "roundEdge", {
                /**property for the shape round edge */
                get: function () {
                    return this.data ? this.data.roundEdge : BasicShapeVisual.DefaultRoundEdgeValue;
                },
                set: function (roundEdge) {
                    this.data.roundEdge = roundEdge;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "showFill", {
                /**property for showing the fill properties */
                get: function () {
                    return this.data ? this.data.showFill : BasicShapeVisual.DefaultFillShowValue;
                },
                set: function (show) {
                    this.data.showFill = show;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "fillColor", {
                /**property for the shape line color */
                get: function () {
                    return this.data ? this.data.fillColor : BasicShapeVisual.DefaultFillColor;
                },
                set: function (color) {
                    this.data.fillColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "shapeTransparency", {
                /**property for the shape fill transparency */
                get: function () {
                    return this.data ? this.data.shapeTransparency : BasicShapeVisual.DefaultFillTransValue;
                },
                set: function (trans) {
                    this.data.shapeTransparency = trans;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "angle", {
                /**property for the shape angle */
                get: function () {
                    return this.data ? this.data.angle : BasicShapeVisual.DefaultAngle;
                },
                set: function (angle) {
                    this.data.angle = this.scaleTo360Deg(angle);
                },
                enumerable: true,
                configurable: true
            });
            BasicShapeVisual.prototype.init = function (options) {
                this.element = options.element;
                this.selection = d3.select(this.element.context);
                this.currentViewport = options.viewport;
            };
            BasicShapeVisual.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = options.dataViews;
                if (!_.isEmpty(dataViews)) {
                    var dataView = options.dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var dataViewObject = options.dataViews[0].metadata.objects;
                        this.data = this.getDataFromDataView(dataViewObject);
                    }
                }
                this.render();
            };
            BasicShapeVisual.prototype.getDataFromDataView = function (dataViewObject) {
                if (dataViewObject) {
                    return {
                        shapeType: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.general.shapeType, BasicShapeVisual.DefaultShape),
                        lineColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.lineColor, BasicShapeVisual.DefaultStrokeColor)),
                        lineTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.transparency, BasicShapeVisual.DefaultLineTransValue),
                        lineWeight: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.weight, BasicShapeVisual.DefaultWeightValue),
                        roundEdge: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.roundEdge, BasicShapeVisual.DefaultRoundEdgeValue),
                        shapeTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.transparency, BasicShapeVisual.DefaultFillTransValue),
                        fillColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.fillColor, BasicShapeVisual.DefaultFillColor)),
                        showFill: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.show, BasicShapeVisual.DefaultFillShowValue),
                        angle: this.scaleTo360Deg(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.rotation.angle, BasicShapeVisual.DefaultAngle))
                    };
                }
                return null;
            };
            BasicShapeVisual.prototype.scaleTo360Deg = function (angle) {
                if (angle !== 0 && (Math.abs(angle) % 360) === 0)
                    return angle;
                angle = angle % 360;
                angle = (angle + 360) % 360;
                return angle;
            };
            BasicShapeVisual.prototype.getValueFromColor = function (color) {
                return color.solid ? color.solid.color : color;
            };
            BasicShapeVisual.prototype.enumerateObjectInstances = function (options) {
                var objectInstances = [];
                switch (options.objectName) {
                    case 'line':
                        var instance = {
                            selector: null,
                            properties: {
                                lineColor: this.lineColor,
                                transparency: this.lineTransparency,
                                weight: this.lineWeight
                            },
                            objectName: options.objectName
                        };
                        if (this.data.shapeType === visuals.basicShapeType.rectangle) {
                            instance.properties['roundEdge'] = this.roundEdge;
                        }
                        objectInstances.push(instance);
                        return objectInstances;
                    case 'fill':
                        if (this.shapeType !== visuals.basicShapeType.line) {
                            objectInstances.push({
                                selector: null,
                                properties: {
                                    show: this.showFill,
                                    fillColor: this.fillColor,
                                    transparency: this.shapeTransparency
                                },
                                objectName: options.objectName
                            });
                        }
                        return objectInstances;
                    case 'rotation':
                        objectInstances.push({
                            selector: null,
                            properties: {
                                angle: this.angle
                            },
                            objectName: options.objectName
                        });
                        return objectInstances;
                }
                return null;
            };
            BasicShapeVisual.prototype.render = function () {
                this.selection.html('');
                switch (this.shapeType) {
                    case visuals.basicShapeType.rectangle:
                        visuals.ShapeFactory.createRectangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.oval:
                        visuals.ShapeFactory.createOval(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.line:
                        visuals.ShapeFactory.createLine(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.arrow:
                        visuals.ShapeFactory.createUpArrow(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.triangle:
                        visuals.ShapeFactory.createTriangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    default:
                        break;
                }
            };
            BasicShapeVisual.DefaultShape = visuals.basicShapeType.rectangle;
            BasicShapeVisual.DefaultStrokeColor = '#00B8AA';
            BasicShapeVisual.DefaultFillColor = '#E6E6E6';
            BasicShapeVisual.DefaultFillShowValue = true;
            BasicShapeVisual.DefaultFillTransValue = 0;
            BasicShapeVisual.DefaultWeightValue = 3;
            BasicShapeVisual.DefaultLineTransValue = 0;
            BasicShapeVisual.DefaultRoundEdgeValue = 0;
            BasicShapeVisual.DefaultAngle = 0;
            return BasicShapeVisual;
        }());
        visuals.BasicShapeVisual = BasicShapeVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var DEFAULT_AXIS_SCALE_TYPE = visuals.axisScale.linear;
        var COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = 0.1;
        // the interactive right margin is set to be the circle selection radius of the hover line
        var INTERACTIVITY_RIGHT_MARGIN = 6;
        visuals.DEFAULT_AXIS_COLOR = '#777';
        /**
         * Renders a data series as a cartestian visual.
         */
        var CartesianChart = (function () {
            function CartesianChart(options) {
                this.xRefLine = createClassAndSelector('x-ref-line');
                this.y1RefLine = createClassAndSelector('y1-ref-line');
                var isScrollable = false;
                this.trimOrdinalDataOnOverflow = true;
                if (options) {
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    this.type = options.chartType;
                    this.isLabelInteractivityEnabled = options.isLabelInteractivityEnabled;
                    this.lineChartLabelDensityEnabled = options.lineChartLabelDensityEnabled;
                    if (options.trimOrdinalDataOnOverflow !== undefined)
                        this.trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow;
                    if (options.isScrollable)
                        isScrollable = options.isScrollable;
                    this.animator = options.animator;
                    if (options.cartesianSmallViewPortProperties) {
                        this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
                    }
                    if (options.behavior) {
                        this.behavior = options.behavior;
                    }
                    this.trendLinesEnabled = !!options.trendLinesEnabled;
                }
                this.axes = new CartesianAxes(isScrollable, ScrollableAxes.ScrollbarWidth, this.trimOrdinalDataOnOverflow);
                this.svgAxes = new SvgCartesianAxes(this.axes);
                this.svgBrush = new SvgBrush(ScrollableAxes.ScrollbarWidth);
                this.scrollableAxes = new ScrollableAxes(this.axes, this.svgBrush);
            }
            CartesianChart.getAxisVisibility = function (type) {
                switch (type) {
                    case 6 /* StackedBar */:
                    case 5 /* ClusteredBar */:
                    case 7 /* HundredPercentStackedBar */:
                        return 1 /* ShowLinesOnXAxis */;
                    case 9 /* Scatter */:
                        return 3 /* ShowLinesOnBothAxis */;
                    default:
                        return 2 /* ShowLinesOnYAxis */;
                }
            };
            CartesianChart.prototype.init = function (options) {
                this.visualInitOptions = options;
                this.layers = [];
                var element = this.element = options.element;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                var chartAreaSvg = this.chartAreaSvg = d3.select(element.get(0)).append('svg');
                chartAreaSvg.classed(CartesianChart.ClassName, true);
                chartAreaSvg.style('position', 'absolute');
                if (this.behavior) {
                    this.clearCatcher = visuals.appendClearCatcher(chartAreaSvg);
                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
                }
                if (options.style.maxMarginFactor != null)
                    this.axes.setMaxMarginFactor(options.style.maxMarginFactor);
                var axisLinesVisibility = CartesianChart.getAxisVisibility(this.type);
                this.axes.setAxisLinesVisibility(axisLinesVisibility);
                this.svgAxes.init(chartAreaSvg);
                this.svgBrush.init(chartAreaSvg);
                this.sharedColorPalette = new SharedColorPalette(options.style.colorPalette.dataColors);
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.type !== 12 /* Waterfall */ ? this.interactivityService : undefined, this.axes.isScrollable);
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
            };
            CartesianChart.prototype.isPlayAxis = function () {
                if (!this.dataViews || !this.dataViews[0])
                    return false;
                var dataView = this.dataViews[0];
                var categoryRoleIsPlay = dataView.categorical
                    && dataView.categorical.categories
                    && dataView.categorical.categories[0]
                    && dataView.categorical.categories[0].source
                    && dataView.categorical.categories[0].source.roles
                    && dataView.categorical.categories[0].source.roles['Play'];
                return this.type === 9 /* Scatter */
                    && (this.animator || this.isMobileChart)
                    && dataView.matrix != null
                    && (!dataView.categorical || categoryRoleIsPlay);
            };
            CartesianChart.getIsScalar = function (objects, propertyId, type) {
                var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                if (!objects || axisTypeValue === undefined) {
                    // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time. 
                    // If we have the property, it will override the type.
                    return !visuals.AxisHelper.isOrdinal(type);
                }
                // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.
                return (axisTypeValue === visuals.axisType.scalar) && !visuals.AxisHelper.isOrdinal(type);
            };
            CartesianChart.getAdditionalTelemetry = function (dataView) {
                var telemetry = {};
                var categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
                if (categoryColumn) {
                    telemetry.axisType = visuals.CartesianChart.getIsScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type)
                        ? 'scalar'
                        : 'categorical';
                }
                return telemetry;
            };
            CartesianChart.detectScalarMapping = function (dataViewMapping) {
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return false;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (_.isEmpty(categoryItems))
                    return false;
                var categoryType = categoryItems[0].type;
                if (!dataViewMapping.metadata)
                    return false;
                var objects = dataViewMapping.metadata.objects;
                return CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType);
            };
            CartesianChart.prototype.populateObjectProperties = function (dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata) {
                        this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
                        this.xAxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, 'xAxisReferenceLine');
                        this.y1AxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, 'y1AxisReferenceLine');
                    }
                    else {
                        this.legendObjectProperties = {};
                    }
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                }
            };
            CartesianChart.prototype.updateInternal = function (options, dataChanged) {
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (!dataViews)
                    return;
                if (this.layers.length === 0) {
                    // Lazily instantiate the chart layers on the first data load.
                    this.layers = this.createAndInitLayers(dataViews);
                    debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');
                }
                var layers = this.layers;
                if (dataChanged) {
                    if (!_.isEmpty(dataViews)) {
                        this.populateObjectProperties(dataViews);
                        this.axes.update(dataViews);
                        this.svgAxes.update(this.categoryAxisProperties, this.valueAxisProperties);
                        var dataView = dataViews[0];
                        if (dataView.metadata) {
                            // flatten background data
                            this.background = {
                                image: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.image),
                                transparency: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.transparency, visuals.visualBackgroundHelper.getDefaultTransparency()),
                            };
                        }
                    }
                    this.sharedColorPalette.clearPreferredScale();
                    for (var i = 0, len = layers.length; i < len; i++) {
                        layers[i].setData(getLayerData(dataViews, i, len));
                        if (len > 1)
                            this.sharedColorPalette.rotateScale();
                    }
                    var shouldAddTrendLayer = this.isTrendPropertySet(dataViews) && dataViews.length > 1;
                    this.trendLine = shouldAddTrendLayer ? visuals.TrendLineHelper.readDataView(dataViews[1]) : undefined;
                }
                this.render(!this.hasSetData || options.suppressAnimations, options.resizeMode);
                this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);
                if (dataViews && dataViews.length > 0) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    this.axes.addWarnings(warnings);
                    if (warnings && warnings.length > 0)
                        this.hostServices.setWarnings(warnings);
                }
            };
            CartesianChart.prototype.isTrendPropertySet = function (dataViews) {
                var objects = this.extractMetadataObjects(dataViews);
                return CartesianLayerFactory.shouldAddTrendLayer(objects);
            };
            // TODO: Remove onDataChanged & onResizing once we have a flag to distinguish between resize and data changed events.
            CartesianChart.prototype.onDataChanged = function (options) {
                this.updateInternal({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                }, true);
            };
            // TODO: Remove onDataChanged & onResizing once we have a flag to distinguish between resize and data changed events.
            CartesianChart.prototype.onResizing = function (viewport, resizeMode) {
                this.updateInternal({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: viewport,
                    resizeMode: resizeMode,
                }, false);
            };
            CartesianChart.prototype.scrollTo = function (position) {
                this.scrollableAxes.scrollTo(position);
            };
            CartesianChart.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                var layersLength = this.layers ? this.layers.length : 0;
                if (options.objectName === 'legend') {
                    if (!this.shouldShowLegendCard())
                        return;
                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');
                    var labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                    var fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: fontSize,
                        },
                        objectName: options.objectName
                    });
                }
                else if (options.objectName === 'categoryAxis' && this.axes.hasCategoryAxis()) {
                    this.getCategoryAxisValues(enumeration);
                }
                else if (options.objectName === 'valueAxis') {
                    this.getValueAxisValues(enumeration);
                }
                else if (options.objectName === 'y1AxisReferenceLine') {
                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.y1AxisReferenceLines, refLinedefaultColor, options.objectName);
                }
                else if (options.objectName === 'xAxisReferenceLine') {
                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.xAxisReferenceLines, refLinedefaultColor, options.objectName);
                }
                else if (options.objectName === 'trend') {
                    // TODO: make sure we have a trend line, we should..
                    if (this.trendLinesEnabled) {
                        if (!_.isEmpty(this.layers) && _.all(this.layers, function (layer) { return layer.supportsTrendLine(); })) {
                            visuals.TrendLineHelper.enumerateObjectInstances(enumeration, this.trendLine);
                        }
                    }
                }
                else if (options.objectName === 'plotArea') {
                    visuals.visualBackgroundHelper.enumeratePlot(enumeration, this.background);
                }
                if (options.objectName === 'dataPoint' &&
                    visuals.ComboChart.isComboChart(this.type)) {
                    visuals.ComboChart.enumerateDataPoints(enumeration, options, this.layers);
                }
                else {
                    for (var i = 0, len = layersLength; i < len; i++) {
                        var layer = this.layers[i];
                        if (layer.enumerateObjectInstances) {
                            layer.enumerateObjectInstances(enumeration, options);
                        }
                    }
                }
                return enumeration.complete();
            };
            CartesianChart.prototype.shouldShowLegendCard = function () {
                var layers = this.layers;
                var dataViews = this.dataViews;
                if (layers && dataViews) {
                    var layersLength = layers.length;
                    var layersWithValuesCtr = 0;
                    for (var i = 0; i < layersLength; i++) {
                        if (layers[i].hasLegend()) {
                            return true;
                        }
                        // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)
                        var dataView = dataViews[i];
                        if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {
                            layersWithValuesCtr++;
                            if (layersWithValuesCtr > 1) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            };
            CartesianChart.prototype.getAxisScaleOptions = function (axisType) {
                var scaleOptions = [DEFAULT_AXIS_SCALE_TYPE];
                if (this.axes.isLogScaleAllowed(axisType))
                    scaleOptions.push(visuals.axisScale.log);
                return scaleOptions;
            };
            CartesianChart.prototype.getCategoryAxisValues = function (enumeration) {
                if (!this.categoryAxisProperties) {
                    return;
                }
                var supportedType = visuals.axisType.both;
                var isScalar = false;
                var scaleOptions = this.getAxisScaleOptions(0 /* X */);
                if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
                    supportedType = this.layers[0].getSupportedCategoryAxisType();
                    if (supportedType === visuals.axisType.scalar) {
                        isScalar = true;
                    }
                    else {
                        isScalar = visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties);
                    }
                }
                if (!isScalar) {
                    this.categoryAxisProperties['start'] = null;
                    this.categoryAxisProperties['end'] = null;
                }
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: 'categoryAxis',
                    validValues: {
                        axisScale: scaleOptions,
                        axisStyle: this.axes.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                    }
                };
                instance.properties['show'] = this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
                if (this.axes.isYAxisCategorical())
                    instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                if (supportedType === visuals.axisType.both) {
                    instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;
                }
                if (isScalar) {
                    instance.properties['axisScale'] = this.categoryAxisProperties['axisScale'] || DEFAULT_AXIS_SCALE_TYPE;
                    instance.properties['start'] = this.categoryAxisProperties['start'];
                    instance.properties['end'] = this.categoryAxisProperties['end'];
                }
                instance.properties['showAxisTitle'] = this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
                instance.properties['axisStyle'] = this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly;
                instance.properties['labelColor'] = this.categoryAxisProperties['labelColor'] || visuals.DEFAULT_AXIS_COLOR;
                if (isScalar) {
                    instance.properties['labelDisplayUnits'] = this.categoryAxisProperties['labelDisplayUnits'] ? this.categoryAxisProperties['labelDisplayUnits'] : 0;
                    var labelPrecision = this.categoryAxisProperties['labelPrecision'];
                    instance.properties['labelPrecision'] = (labelPrecision === undefined || labelPrecision < 0)
                        ? visuals.dataLabelUtils.defaultLabelPrecision
                        : labelPrecision;
                }
                enumeration.pushInstance(instance);
            };
            //todo: wrap all these object getters and other related stuff into an interface
            CartesianChart.prototype.getValueAxisValues = function (enumeration) {
                if (!this.valueAxisProperties) {
                    return;
                }
                var scaleOptions = this.getAxisScaleOptions(1 /* Y1 */);
                var secScaleOption = this.getAxisScaleOptions(2 /* Y2 */);
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: 'valueAxis',
                    validValues: {
                        axisScale: scaleOptions,
                        secAxisScale: secScaleOption,
                        axisStyle: this.axes.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                    }
                };
                instance.properties['show'] = this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
                if (!this.axes.isYAxisCategorical()) {
                    instance.properties['position'] = this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                }
                instance.properties['axisScale'] = this.valueAxisProperties['axisScale'] || DEFAULT_AXIS_SCALE_TYPE;
                instance.properties['start'] = this.valueAxisProperties['start'];
                instance.properties['end'] = this.valueAxisProperties['end'];
                instance.properties['showAxisTitle'] = this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;
                instance.properties['axisStyle'] = this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly;
                instance.properties['labelColor'] = this.valueAxisProperties['labelColor'] || visuals.DEFAULT_AXIS_COLOR;
                if (this.type !== 7 /* HundredPercentStackedBar */ && this.type !== 8 /* HundredPercentStackedColumn */) {
                    instance.properties['labelDisplayUnits'] = this.valueAxisProperties['labelDisplayUnits'] ? this.valueAxisProperties['labelDisplayUnits'] : 0;
                    var labelPrecision = this.valueAxisProperties['labelPrecision'];
                    instance.properties['labelPrecision'] = (labelPrecision === undefined || labelPrecision < 0)
                        ? visuals.dataLabelUtils.defaultLabelPrecision
                        : labelPrecision;
                }
                enumeration.pushInstance(instance);
                if (this.layers.length === 2) {
                    instance.properties['secShow'] = this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.axes.hasY2Axis();
                    if (instance.properties['secShow']) {
                        instance.properties['axisLabel'] = '';
                    }
                }
                if (this.axes.hasY2Axis() && instance.properties['secShow']) {
                    enumeration.pushContainer({
                        displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ShowSecondary'),
                    });
                    var secInstance = {
                        selector: null,
                        properties: {},
                        objectName: 'valueAxis'
                    };
                    secInstance.properties['secAxisLabel'] = '';
                    secInstance.properties['secPosition'] = this.valueAxisProperties['secPosition'] != null ? this.valueAxisProperties['secPosition'] : visuals.yAxisPosition.right;
                    secInstance.properties['secAxisScale'] = this.valueAxisProperties['secAxisScale'] || DEFAULT_AXIS_SCALE_TYPE;
                    secInstance.properties['secStart'] = this.valueAxisProperties['secStart'];
                    secInstance.properties['secEnd'] = this.valueAxisProperties['secEnd'];
                    secInstance.properties['secShowAxisTitle'] = this.valueAxisProperties['secShowAxisTitle'] != null ? this.valueAxisProperties['secShowAxisTitle'] : false;
                    enumeration
                        .pushInstance(secInstance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            secAxisStyle: this.valueAxisProperties['secAxisStyle'] ? this.valueAxisProperties['secAxisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties['secLabelColor'],
                            secLabelDisplayUnits: this.valueAxisProperties['secLabelDisplayUnits'] ? this.valueAxisProperties['secLabelDisplayUnits'] : 0,
                            secLabelPrecision: this.valueAxisProperties['secLabelPrecision'] < 0 ? 0 : this.valueAxisProperties['secLabelPrecision']
                        },
                        objectName: 'valueAxis',
                        validValues: {
                            secAxisStyle: this.axes.secondaryValueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly],
                            axisScale: scaleOptions
                        },
                    });
                    enumeration.popContainer();
                }
            };
            CartesianChart.prototype.onClearSelection = function () {
                if (this.hasSetData) {
                    for (var i = 0, len = this.layers.length; i < len; i++) {
                        var layer = this.layers[i];
                        layer.onClearSelection();
                        layer.render(true /* suppressAnimations */);
                    }
                }
            };
            CartesianChart.prototype.extractMetadataObjects = function (dataViews) {
                var objects;
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata)
                        objects = dataViewMetadata.objects;
                }
                return objects;
            };
            CartesianChart.prototype.createAndInitLayers = function (dataViews) {
                var _this = this;
                var objects = this.extractMetadataObjects(dataViews);
                // Create the layers
                var layers = CartesianLayerFactory.createLayers(this.type, objects, this.interactivityService, this.animator, this.axes.isScrollable, this.tooltipsEnabled, this.lineChartLabelDensityEnabled);
                // Initialize the layers
                var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                cartesianOptions.svg = this.svgAxes.getScrollableRegion();
                cartesianOptions.labelsContext = this.svgAxes.getLabelsRegion();
                cartesianOptions.cartesianHost = {
                    updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },
                    getSharedColors: function () { return _this.sharedColorPalette; },
                    triggerRender: function (suppressAnimations) { return _this.render(suppressAnimations); },
                };
                cartesianOptions.chartType = this.type;
                for (var i = 0, len = layers.length; i < len; i++)
                    layers[i].init(cartesianOptions);
                return layers;
            };
            CartesianChart.prototype.renderLegend = function () {
                var layers = this.layers;
                var legendData = { title: "", dataPoints: [] };
                for (var i = 0, len = layers.length; i < len; i++) {
                    this.layerLegendData = layers[i].calculateLegend();
                    if (this.layerLegendData) {
                        legendData.title = i === 0 ? this.layerLegendData.title || ""
                            : legendData.title;
                        legendData.labelColor = this.layerLegendData.labelColor;
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                        legendData.fontSize = this.layerLegendData.fontSize || visuals.SVGLegend.DefaultFontSizeInPt;
                        if (this.layerLegendData.grouped) {
                            legendData.grouped = true;
                        }
                    }
                }
                var legendProperties = this.legendObjectProperties;
                if (legendProperties) {
                    visuals.LegendData.update(legendData, legendProperties);
                    var position = legendProperties[visuals.legendProps.position];
                    if (position)
                        this.legend.changeOrientation(visuals.LegendPosition[position]);
                }
                else {
                    this.legend.changeOrientation(visuals.LegendPosition.Top);
                }
                if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
                    legendData.dataPoints = [];
                }
                this.legend.drawLegend(legendData, this.currentViewport);
            };
            CartesianChart.prototype.hideLegends = function () {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.render = function (suppressAnimations, resizeMode) {
                var _this = this;
                // Note: interactive legend shouldn't be rendered explicitly here
                // The interactive legend is being rendered in the render method of ICartesianVisual
                if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
                    this.renderLegend();
                }
                var legendMargins = this.legendMargins = this.legend.getMargins();
                var legendOrientation = this.legend.getOrientation();
                var hideAxisLabels = this.hideAxisLabels(legendMargins);
                var plotAreaViewport = {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
                var padding = powerbi.Prototype.inherit(SvgCartesianAxes.AxisPadding);
                var playAxisControlLayout;
                if (this.isPlayAxis()) {
                    plotAreaViewport.height -= CartesianChart.PlayAxisBottomMargin;
                    playAxisControlLayout = {
                        left: visuals.Legend.isLeft(legendOrientation) ? legendMargins.width : 0,
                        top: visuals.Legend.isTop(legendOrientation) ? legendMargins.height + plotAreaViewport.height : plotAreaViewport.height,
                        height: CartesianChart.PlayAxisBottomMargin,
                        width: plotAreaViewport.width
                    };
                }
                this.chartAreaSvg.attr({
                    'width': plotAreaViewport.width,
                    'height': plotAreaViewport.height,
                });
                visuals.Legend.positionChartArea(this.chartAreaSvg, this.legend);
                var interactivityRightMargin = this.calculateInteractivityRightMargin();
                var _a = this.getMinimumDomainExtents(), ensureXDomain = _a[0], ensureYDomain = _a[1];
                var axesLayout = this.axes.negotiateAxes(this.layers, plotAreaViewport, padding, playAxisControlLayout, hideAxisLabels, CartesianChart.TextProperties, interactivityRightMargin, ensureXDomain, ensureYDomain);
                // Even if the caller thinks animations are ok, now that we've laid out the axes and legend we should disable animations
                // if the plot area changed. Animations for property changes like legend on/off are not desired.
                var plotAreaHasChanged = !this.renderedPlotArea
                    || (this.renderedPlotArea.height !== axesLayout.plotArea.height ||
                        this.renderedPlotArea.width !== axesLayout.plotArea.width);
                suppressAnimations = suppressAnimations || plotAreaHasChanged;
                this.scrollableAxes.render(axesLayout, this.layers, suppressAnimations, function (layers, axesLayout, suppressAnimations) { return _this.renderPlotArea(layers, axesLayout, suppressAnimations, legendMargins, resizeMode); });
                this.renderedPlotArea = axesLayout.plotArea;
            };
            /**
             * Gets any minimum domain extents.
             * Reference lines and trend lines may enforce minimum extents on X and/or Y domains.
             */
            CartesianChart.prototype.getMinimumDomainExtents = function () {
                var xs = [];
                var ys = [];
                if (!_.isEmpty(this.xAxisReferenceLines)) {
                    var xAxisReferenceLineProperties = this.xAxisReferenceLines[0].object;
                    var value = visuals.ReferenceLineHelper.extractReferenceLineValue(xAxisReferenceLineProperties);
                    xs.push(value);
                }
                if (!_.isEmpty(this.y1AxisReferenceLines)) {
                    var y1AxisReferenceLineProperties = this.y1AxisReferenceLines[0].object;
                    var value = visuals.ReferenceLineHelper.extractReferenceLineValue(y1AxisReferenceLineProperties);
                    ys.push(value);
                }
                if (this.trendLine && !_.isEmpty(this.trendLine.points)) {
                    xs = xs.concat(_.map(this.trendLine.points, function (p) { return p.x; }));
                    ys = ys.concat(_.map(this.trendLine.points, function (p) { return p.y; }));
                }
                var ensureXDomain = {
                    min: d3.min(xs),
                    max: d3.max(xs)
                };
                var ensureYDomain = {
                    min: d3.min(ys),
                    max: d3.max(ys)
                };
                return [ensureXDomain, ensureYDomain];
            };
            CartesianChart.prototype.getPlotAreaRect = function (axesLayout, legendMargins) {
                var rect = {
                    left: axesLayout.margin.left,
                    top: axesLayout.margin.top,
                    width: axesLayout.plotArea.width,
                    height: axesLayout.plotArea.height,
                };
                // Adjust the margins to the legend position 
                if (this.legend) {
                    var legendPosition_1 = this.legend.getOrientation();
                    if (visuals.Legend.isTop(legendPosition_1)) {
                        rect.top += legendMargins.height;
                    }
                    else if (visuals.Legend.isLeft(legendPosition_1)) {
                        rect.left += legendMargins.width;
                    }
                }
                return rect;
            };
            CartesianChart.prototype.renderBackgroundImage = function (layout) {
                visuals.visualBackgroundHelper.renderBackgroundImage(this.background, this.element, layout);
            };
            CartesianChart.prototype.hideAxisLabels = function (legendMargins) {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.calculateInteractivityRightMargin = function () {
                // add right margin in order not to cut the circle selection of the hover line 
                if (this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend && !this.trimOrdinalDataOnOverflow) {
                    return INTERACTIVITY_RIGHT_MARGIN;
                }
                else {
                    return 0;
                }
            };
            CartesianChart.prototype.renderPlotArea = function (layers, axesLayout, suppressAnimations, legendMargins, resizeMode) {
                debug.assertValue(layers, 'layers');
                var axes = axesLayout.axes;
                var plotArea = axesLayout.plotArea;
                var plotAreaRect = this.getPlotAreaRect(axesLayout, legendMargins);
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.renderBackgroundImage(plotAreaRect);
                this.svgAxes.renderAxes(axesLayout, duration);
                this.renderReferenceLines(axesLayout);
                this.renderLayers(layers, plotArea, axes, suppressAnimations, resizeMode);
                this.renderTrendLine(axesLayout);
            };
            CartesianChart.prototype.renderTrendLine = function (axesLayout) {
                var scrollableRegion = this.svgAxes.getScrollableRegion();
                visuals.TrendLineHelper.render(this.trendLine, scrollableRegion, axesLayout.axes, axesLayout.plotArea);
            };
            CartesianChart.prototype.renderReferenceLines = function (axesLayout) {
                var axes = axesLayout.axes;
                var plotArea = axesLayout.plotArea;
                var scrollableRegion = this.svgAxes.getScrollableRegion();
                var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                var showY1ReferenceLines = false;
                if (this.y1AxisReferenceLines) {
                    for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                        var referenceLineProperties = _a[_i];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                            var isHorizontal = !axes.y1.isCategoryAxis;
                            var y1RefLineOptions = {
                                graphicContext: scrollableRegion,
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                classAndSelector: this.y1RefLine,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal
                            };
                            visuals.ReferenceLineHelper.render(y1RefLineOptions);
                            showY1ReferenceLines = true;
                        }
                    }
                }
                if (!showY1ReferenceLines) {
                    scrollableRegion.selectAll(this.y1RefLine.selector).remove();
                }
                var showXReferenceLines = false;
                if (this.xAxisReferenceLines) {
                    for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                        var referenceLineProperties = _c[_b];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                            var isHorizontal = false;
                            var xRefLineOptions = {
                                graphicContext: scrollableRegion,
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                classAndSelector: this.xRefLine,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal
                            };
                            visuals.ReferenceLineHelper.render(xRefLineOptions);
                            showXReferenceLines = true;
                        }
                    }
                }
                if (!showXReferenceLines) {
                    scrollableRegion.selectAll(this.xRefLine.selector).remove();
                }
            };
            CartesianChart.prototype.getReferenceLineLabels = function (axes, plotArea) {
                var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                var referenceLineLabels = [];
                if (this.y1AxisReferenceLines) {
                    for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                        var referenceLineProperties = _a[_i];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                            var isHorizontal = !axes.y1.isCategoryAxis;
                            var y1RefLineLabelOptions = {
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal,
                                key: JSON.stringify({
                                    type: 'y1AxisReferenceLine',
                                    id: referenceLineProperties.id,
                                }),
                            };
                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(y1RefLineLabelOptions));
                        }
                    }
                }
                if (this.xAxisReferenceLines) {
                    for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                        var referenceLineProperties = _c[_b];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                            var isHorizontal = false;
                            var xRefLineLabelOptions = {
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal,
                                key: JSON.stringify({
                                    type: 'xAxisReferenceLine',
                                    id: referenceLineProperties.id,
                                }),
                            };
                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(xRefLineLabelOptions));
                        }
                    }
                }
                return referenceLineLabels;
            };
            CartesianChart.prototype.renderDataLabels = function (labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, isCombo) {
                var labelBackgroundRegion = this.svgAxes.getLabelBackground();
                var labelRegion = this.svgAxes.getLabelsRegion();
                if (this.behavior) {
                    var labelLayoutOptions = visuals.NewDataLabelUtils.getDataLabelLayoutOptions(this.type);
                    var labelLayout = new powerbi.LabelLayout(labelLayoutOptions);
                    var dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                    if (isCombo) {
                        visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", 0.7);
                    }
                    var svgLabels = void 0;
                    if (this.animator && !suppressAnimations) {
                        var isPlayAxis = this.isPlayAxis();
                        var duration = isPlayAxis ? visuals.PlayChart.FrameAnimationDuration : this.animator.getDuration();
                        svgLabels = visuals.NewDataLabelUtils.animateDefaultLabels(labelRegion, dataLabels, duration, labelsAreNumeric, isPlayAxis ? 'linear' : undefined);
                    }
                    else {
                        svgLabels = visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                    }
                    if (labelLayoutOptions.allowLeaderLines) {
                        var filteredLabels = _.filter(dataLabels, function (d) { return d.leaderLinePoints != null && !_.isEmpty(d.leaderLinePoints) && d.identity != null; });
                        visuals.NewDataLabelUtils.drawLabelLeaderLines(labelRegion, filteredLabels, function (d) { return d.identity.getKey(); });
                    }
                    if (this.interactivityService && this.isLabelInteractivityEnabled) {
                        var labelsBehaviorOptions = {
                            labelItems: svgLabels,
                        };
                        this.interactivityService.bind(dataLabels, new visuals.LabelsBehavior(), labelsBehaviorOptions, { isLabels: true });
                    }
                }
                else {
                    var labelLayout = new powerbi.LabelLayout({
                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset,
                        attemptToMoveLabelsIntoViewport: true,
                    });
                    var dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                    if (isCombo) {
                        visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", 0.7);
                    }
                    visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                }
            };
            CartesianChart.prototype.renderLayers = function (layers, plotArea, axes, suppressAnimations, resizeMode) {
                var labelDataPointGroups = [];
                var dataPoints = [];
                var layerBehaviorOptions = [];
                var labelsAreNumeric = true;
                for (var i = 0, len = layers.length; i < len; i++) {
                    var result = layers[i].render(suppressAnimations, resizeMode);
                    if (result) {
                        if (this.behavior) {
                            // NOTE: these are not needed if we don't have interactivity
                            dataPoints = dataPoints.concat(result.dataPoints);
                            layerBehaviorOptions.push(result.behaviorOptions);
                        }
                        if (result.labelDataPointGroups) {
                            var resultLabelDataPointsGroups = result.labelDataPointGroups;
                            for (var _i = 0, resultLabelDataPointsGroups_1 = resultLabelDataPointsGroups; _i < resultLabelDataPointsGroups_1.length; _i++) {
                                var resultLabelDataPointsGroup = resultLabelDataPointsGroups_1[_i];
                                if (!resultLabelDataPointsGroup)
                                    continue;
                                labelDataPointGroups.push({
                                    labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultLabelDataPointsGroup.labelDataPoints || []),
                                    maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,
                                });
                            }
                        }
                        else {
                            var resultsLabelDataPoints = result.labelDataPoints || [];
                            labelDataPointGroups.push({
                                labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultsLabelDataPoints),
                                maxNumberOfLabels: resultsLabelDataPoints.length,
                            });
                        }
                        labelsAreNumeric = labelsAreNumeric && result.labelsAreNumeric;
                    }
                }
                var referenceLineLabels = this.getReferenceLineLabels(axes, plotArea);
                if (!_.isEmpty(referenceLineLabels)) {
                    labelDataPointGroups.unshift({
                        labelDataPoints: referenceLineLabels,
                        maxNumberOfLabels: referenceLineLabels.length,
                    });
                }
                this.renderDataLabels(labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, visuals.ComboChart.isComboChart(this.type));
                if (this.interactivityService) {
                    var behaviorOptions = {
                        layerOptions: layerBehaviorOptions,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                }
            };
            /**
             * Returns the actual viewportWidth if visual is not scrollable.
             * @return If visual is scrollable, returns the plot area needed to draw all the datapoints.
             */
            CartesianChart.getPreferredPlotArea = function (categoryCount, categoryThickness, viewport, isScrollable, isScalar, margin, noOuterPadding) {
                if (!margin)
                    margin = { top: 0, right: 0, bottom: 0, left: 0 };
                var plotArea = {
                    height: viewport.height - margin.top - margin.bottom,
                    width: viewport.width - margin.left - margin.right
                };
                if (!isScalar && isScrollable) {
                    var preferredCategorySpan = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness, noOuterPadding);
                    plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                }
                return plotArea;
            };
            /**
             * Returns preferred Category span if the visual is scrollable.
             */
            CartesianChart.getPreferredCategorySpan = function (categoryCount, categoryThickness, noOuterPadding) {
                var span = (categoryThickness * categoryCount);
                if (noOuterPadding)
                    return span;
                return span + (categoryThickness * CartesianChart.OuterPaddingRatio * 2);
            };
            /**
             * Note: Public for testing access.
             */
            CartesianChart.getLayout = function (data, options) {
                var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable;
                var categoryThickness = CartesianChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar, trimOrdinalDataOnOverflow);
                // Total width of the outer padding, the padding that exist on the far right and far left of the chart.
                var totalOuterPadding = categoryThickness * CartesianChart.OuterPaddingRatio * 2;
                // visibleCategoryCount will be used to discard data that overflows on ordinal-axis charts.
                // Needed for dashboard visuals            
                var calculatedBarCount = powerbi.Double.floorWithPrecision((availableWidth - totalOuterPadding) / categoryThickness);
                var visibleCategoryCount = Math.min(calculatedBarCount, categoryCount);
                var willScroll = visibleCategoryCount < categoryCount && isScrollable;
                var outerPaddingRatio = CartesianChart.OuterPaddingRatio;
                if (!isScalar && !willScroll) {
                    // use dynamic outer padding to improve spacing when we have few categories
                    var oneOuterPadding = (availableWidth - (categoryThickness * visibleCategoryCount)) / 2;
                    outerPaddingRatio = oneOuterPadding / categoryThickness;
                }
                // If scrollable, visibleCategoryCount will be total categories
                if (!isScalar && isScrollable)
                    visibleCategoryCount = categoryCount;
                return {
                    categoryCount: visibleCategoryCount,
                    categoryThickness: categoryThickness,
                    outerPaddingRatio: outerPaddingRatio,
                    isScalar: isScalar
                };
            };
            /**
             * Returns the thickness for each category.
             * For clustered charts, you still need to divide by
             * the number of series to get column width after calling this method.
             * For linear or time scales, category thickness accomodates for
             * the minimum interval between consequtive points.
             * For all types, return value has accounted for outer padding,
             * but not inner padding.
             */
            CartesianChart.getCategoryThickness = function (seriesList, numCategories, plotLength, domain, isScalar, trimOrdinalDataOnOverflow) {
                var thickness;
                if (numCategories < 2)
                    thickness = plotLength * (1 - CartesianChart.OuterPaddingRatio);
                else if (isScalar && domain && domain.length > 1) {
                    // the smallest interval defines the column width.
                    var minInterval = CartesianChart.getMinInterval(seriesList);
                    var domainSpan = domain[domain.length - 1] - domain[0];
                    // account for outside padding
                    var ratio = minInterval / (domainSpan + (minInterval * CartesianChart.OuterPaddingRatio * 2));
                    thickness = plotLength * ratio;
                    thickness = Math.max(thickness, CartesianChart.MinScalarRectThickness);
                }
                else {
                    // Divide the available width up including outer padding (in terms of category thickness) on
                    // both sides of the chart, and categoryCount categories. Reverse math:
                    // availableWidth = (categoryThickness * categoryCount) + (categoryThickness * (outerPadding * 2)),
                    // availableWidth = categoryThickness * (categoryCount + (outerPadding * 2)),
                    // categoryThickness = availableWidth / (categoryCount + (outerpadding * 2))
                    thickness = plotLength / (numCategories + (CartesianChart.OuterPaddingRatio * 2));
                    if (trimOrdinalDataOnOverflow) {
                        thickness = Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
                    }
                }
                // spec calls for using the whole plot area, but the max rectangle thickness is "as if there were three categories"
                // (outerPaddingRatio has the same units as '# of categories' so they can be added)
                var maxRectThickness = plotLength / (3 + (CartesianChart.OuterPaddingRatio * 2));
                thickness = Math.min(thickness, maxRectThickness);
                if (!isScalar && numCategories >= 3 && trimOrdinalDataOnOverflow) {
                    return Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
                }
                return thickness;
            };
            CartesianChart.getMinInterval = function (seriesList) {
                var minInterval = Number.MAX_VALUE;
                if (seriesList.length > 0) {
                    var series0data = seriesList[0].data.filter(function (d) { return !d.highlight; });
                    for (var i = 0, ilen = series0data.length - 1; i < ilen; i++) {
                        minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
                    }
                }
                return minInterval;
            };
            CartesianChart.MinOrdinalRectThickness = 20;
            CartesianChart.MinScalarRectThickness = 2;
            CartesianChart.OuterPaddingRatio = 0.4;
            CartesianChart.InnerPaddingRatio = 0.2;
            CartesianChart.TickLabelPadding = 2; // between text labels, used by AxisHelper
            CartesianChart.ClassName = 'cartesianChart';
            CartesianChart.PlayAxisBottomMargin = 80; //do not change unless we add dynamic label measurements for play slider
            CartesianChart.FontSize = 11;
            CartesianChart.FontSizeString = jsCommon.PixelConverter.toString(CartesianChart.FontSize);
            CartesianChart.TextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: CartesianChart.FontSizeString,
            };
            return CartesianChart;
        }());
        visuals.CartesianChart = CartesianChart;
        function getLayerData(dataViews, currentIdx, totalLayers) {
            if (totalLayers > 1) {
                if (dataViews && dataViews.length > currentIdx)
                    return [dataViews[currentIdx]];
                return [];
            }
            return dataViews;
        }
        function hasMultipleYAxes(layers) {
            debug.assertValue(layers, 'layers');
            return layers.length > 1;
        }
        /**
         * Returns a boolean, that indicates if y axis title should be displayed.
         * @return True if y axis title should be displayed,
         * otherwise false.
         */
        function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
            return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||
                (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));
        }
        function tryMergeYDomains(layers, visualOptions) {
            debug.assert(layers.length < 3, 'merging of more than 2 layers is not supported');
            var noMerge = {
                domain: undefined,
                merged: false,
                tickCount: undefined
            };
            if (layers.length < 2)
                return noMerge;
            var min;
            var max;
            var minOfMax;
            var maxOfMin;
            // TODO: replace full calculateAxesProperties with just a data domain calc
            // we need to be aware of which chart require zero (column/bar) and which don't (line)
            var y1props = layers[0].calculateAxesProperties(visualOptions)[1];
            var y2props = layers[1].calculateAxesProperties(visualOptions)[1];
            var firstYDomain = y1props.scale.domain();
            var secondYDomain = y2props.scale.domain();
            if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0) {
                noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length);
            }
            min = Math.min(firstYDomain[0], secondYDomain[0]);
            max = Math.max(firstYDomain[1], secondYDomain[1]);
            if (visualOptions.forceMerge) {
                return {
                    domain: [min, max],
                    merged: true,
                    tickCount: noMerge.tickCount
                };
            }
            // If domains don't intersect don't merge axis.
            if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0])
                return noMerge;
            maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]);
            minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
            var range = (max - min);
            if (range === 0) {
                return noMerge;
            }
            var intersection = Math.abs((minOfMax - maxOfMin) / range);
            // Only merge if intersection of domains greater than 10% of total range.
            if (intersection < COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE)
                return noMerge;
            else
                return {
                    domain: [min, max],
                    merged: true,
                    tickCount: noMerge.tickCount
                };
        }
        /**
         * Computes the Cartesian Chart axes from the set of layers.
         */
        function calculateAxes(layers, viewport, margin, playAxisControlLayout, categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible, existingAxisProperties, trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain) {
            debug.assertValue(layers, 'layers');
            var visualOptions = {
                viewport: viewport,
                margin: margin,
                forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
                forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,
                showCategoryAxisLabel: false,
                showValueAxisLabel: false,
                trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow,
                categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : DEFAULT_AXIS_SCALE_TYPE,
                valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : DEFAULT_AXIS_SCALE_TYPE,
                categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties['labelDisplayUnits'] != null ? categoryAxisProperties['labelDisplayUnits'] : 0,
                valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties['labelDisplayUnits'] != null ? valueAxisProperties['labelDisplayUnits'] : 0,
                categoryAxisPrecision: categoryAxisProperties ? visuals.CartesianHelper.getPrecision(categoryAxisProperties['labelPrecision']) : null,
                valueAxisPrecision: valueAxisProperties ? visuals.CartesianHelper.getPrecision(valueAxisProperties['labelPrecision']) : null,
                playAxisControlLayout: playAxisControlLayout,
                ensureXDomain: ensureXDomain,
                ensureYDomain: ensureYDomain,
            };
            var skipMerge = valueAxisProperties && valueAxisProperties['secShow'] === true;
            // TODO: should show trendline?
            var yAxisWillMerge = false;
            var mergeResult;
            if (hasMultipleYAxes(layers) && !skipMerge) {
                mergeResult = tryMergeYDomains(layers, visualOptions);
                yAxisWillMerge = mergeResult.merged;
                if (yAxisWillMerge) {
                    visualOptions.forcedYDomain = mergeResult.domain;
                }
                else {
                    visualOptions.forcedTickCount = mergeResult.tickCount;
                }
            }
            if (valueAxisProperties) {
                visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);
            }
            var result;
            for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                var currentlayer = layers[layerNumber];
                if (layerNumber === 1 && !yAxisWillMerge) {
                    visualOptions.forcedYDomain = valueAxisProperties ? [valueAxisProperties['secStart'], valueAxisProperties['secEnd']] : null;
                    visualOptions.valueAxisScaleType = valueAxisProperties && valueAxisProperties['secAxisScale'] != null ? valueAxisProperties['secAxisScale'] : DEFAULT_AXIS_SCALE_TYPE;
                    visualOptions.valueAxisDisplayUnits = valueAxisProperties && valueAxisProperties['secLabelDisplayUnits'] != null ? valueAxisProperties['secLabelDisplayUnits'] : 0;
                    visualOptions.valueAxisPrecision = valueAxisProperties ? visuals.CartesianHelper.getPrecision(valueAxisProperties['secLabelPrecision']) : null;
                }
                visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']); //here
                visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                var axes = currentlayer.calculateAxesProperties(visualOptions);
                if (layerNumber === 0) {
                    result = {
                        x: axes[0],
                        y1: axes[1]
                    };
                }
                else if (axes && !result.y2) {
                    if (result.x.usingDefaultDomain || _.isEmpty(result.x.dataDomain)) {
                        visualOptions.showValueAxisLabel = (!!valueAxisProperties && !!valueAxisProperties['showAxisTitle']);
                        var axes_1 = currentlayer.calculateAxesProperties(visualOptions);
                        // no categories returned for the first layer, use second layer x-axis properties
                        result.x = axes_1[0];
                        // and 2nd value axis to be the primary
                        result.y1 = axes_1[1];
                    }
                    else {
                        // make sure all layers use the same x-axis/scale for drawing
                        currentlayer.overrideXScale(result.x);
                        if (!yAxisWillMerge && !axes[1].usingDefaultDomain)
                            result.y2 = axes[1];
                    }
                }
                if (existingAxisProperties && existingAxisProperties.x) {
                    result.x.willLabelsFit = existingAxisProperties.x.willLabelsFit;
                    result.x.willLabelsWordBreak = existingAxisProperties.x.willLabelsWordBreak;
                }
                else {
                    var width = viewport.width - (margin.left + margin.right);
                    result.x.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(result.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    // If labels do not fit and we are not scrolling, try word breaking
                    result.x.willLabelsWordBreak = (!result.x.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(result.x, margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                }
            }
            return result;
        }
        var SvgBrush = (function () {
            function SvgBrush(brushWidth) {
                this.brush = d3.svg.brush();
                this.brushWidth = brushWidth;
            }
            SvgBrush.prototype.init = function (element) {
                this.element = element;
            };
            SvgBrush.prototype.remove = function () {
                this.element.selectAll(SvgBrush.Brush.selector).remove();
                this.brushGraphicsContext = undefined;
            };
            SvgBrush.prototype.getExtent = function () {
                return this.brush.extent();
            };
            SvgBrush.prototype.setExtent = function (extent) {
                this.brush.extent(extent);
            };
            SvgBrush.prototype.setScale = function (scale) {
                if (this.isHorizontal)
                    this.brush.x(scale);
                else
                    this.brush.y(scale);
            };
            SvgBrush.prototype.setOrientation = function (isHorizontal) {
                this.isHorizontal = isHorizontal;
            };
            SvgBrush.prototype.renderBrush = function (extentLength, brushX, brushY, scrollCallback) {
                var _this = this;
                if (!this.brushGraphicsContext) {
                    this.brushGraphicsContext = this.element.append("g")
                        .classed(SvgBrush.Brush.class, true);
                }
                this.scrollCallback = scrollCallback;
                this.brush
                    .on("brush", function () { return window.requestAnimationFrame(scrollCallback); })
                    .on("brushend", function () { return _this.resizeExtent(extentLength, _this.isHorizontal); });
                var brushContext = this.brushContext = this.brushGraphicsContext
                    .attr({
                    "transform": visuals.SVGUtil.translate(brushX, brushY),
                    "drag-resize-disabled": "true" /* Disables resizing of the visual when dragging the scrollbar in edit mode */
                })
                    .call(this.brush);
                /* Disabling the zooming feature */
                brushContext.selectAll(".resize rect")
                    .remove();
                brushContext.select(".background")
                    .style('cursor', 'default');
                brushContext.selectAll(".extent")
                    .style({
                    "fill-opacity": SvgBrush.FillOpacity,
                    "cursor": "default",
                });
                if (this.isHorizontal)
                    brushContext.selectAll("rect").attr("height", this.brushWidth);
                else
                    brushContext.selectAll("rect").attr("width", this.brushWidth);
            };
            SvgBrush.prototype.scroll = function () {
                this.scrollCallback();
            };
            SvgBrush.prototype.resizeExtent = function (extentLength, isHorizontal) {
                var brushContext = this.brushContext;
                if (isHorizontal)
                    brushContext.select(".extent").attr("width", extentLength);
                else
                    brushContext.select(".extent").attr("height", extentLength);
            };
            SvgBrush.Brush = createClassAndSelector('brush');
            SvgBrush.FillOpacity = 0.125;
            return SvgBrush;
        }());
        var ScrollableAxes = (function () {
            function ScrollableAxes(axes, svgBrush) {
                this.axes = axes;
                this.brush = svgBrush;
            }
            ScrollableAxes.prototype.filterDataToViewport = function (mainAxisScale, layers, axes, scrollScale, extent, visibleCategoryCount) {
                if (scrollScale) {
                    var selected = void 0;
                    var data_1 = [];
                    // NOTE: using start + numVisibleCategories to make sure we don't have issues with exactness related to extent start/end
                    //      (don't use extent[1])
                    /*
                     When extent[0] and extent[1] are very close to the boundary of a new index, due to floating point err,
                     the "start" might move to the next index but the "end" might not change until you slide one more pixel.
                     It makes things really jittery during scrolling, sometimes you see N columns and sometimes you briefly see N+1.
                    */
                    var startIndex = visuals.AxisHelper.lookupOrdinalIndex(scrollScale, extent[0]);
                    var endIndex = startIndex + visibleCategoryCount; // NOTE: intentionally 1 past end index
                    var domain = scrollScale.domain();
                    selected = domain.slice(startIndex, endIndex); // NOTE: Up to but not including 'end'
                    if (selected && selected.length > 0) {
                        for (var i = 0; i < layers.length; i++) {
                            data_1[i] = layers[i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
                        }
                        mainAxisScale.domain(selected);
                        var axisPropsToUpdate = void 0;
                        if (this.axes.isXScrollBarVisible) {
                            axisPropsToUpdate = axes.x;
                        }
                        else {
                            axisPropsToUpdate = axes.y1;
                        }
                        axisPropsToUpdate.axis.scale(mainAxisScale);
                        axisPropsToUpdate.scale(mainAxisScale);
                        // tick values are indices for ordinal axes
                        axisPropsToUpdate.axis.ticks(selected.length);
                        axisPropsToUpdate.axis.tickValues(selected);
                        // use the original tick format to format the tick values
                        var tickFormat_1 = axisPropsToUpdate.axis.tickFormat();
                        axisPropsToUpdate.values = _.map(selected, function (d) { return tickFormat_1(d); });
                    }
                }
            };
            ScrollableAxes.prototype.render = function (axesLayout, layers, suppressAnimations, renderDelegate) {
                var _this = this;
                var plotArea = axesLayout.plotArea;
                if (plotArea.width < 1 || plotArea.height < 1)
                    return; //do nothing - too small
                var axisScale;
                var brushX;
                var brushY;
                var scrollbarLength;
                var numVisibleCategories;
                var categoryThickness;
                var newAxisLength;
                if (this.axes.isXScrollBarVisible) {
                    axisScale = axesLayout.axes.x.scale;
                    brushX = axesLayout.margin.left;
                    brushY = axesLayout.viewport.height;
                    categoryThickness = axesLayout.axes.x.categoryThickness;
                    var outerPadding = axesLayout.axes.x.outerPadding;
                    numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.width - outerPadding * 2) / categoryThickness);
                    scrollbarLength = (numVisibleCategories + 1) * categoryThickness;
                    newAxisLength = plotArea.width;
                }
                else if (this.axes.isYScrollBarVisible) {
                    axisScale = axesLayout.axes.y1.scale;
                    brushX = axesLayout.viewport.width;
                    brushY = axesLayout.margin.top;
                    categoryThickness = axesLayout.axes.y1.categoryThickness;
                    var outerPadding = axesLayout.axes.y1.outerPadding;
                    numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.height - outerPadding * 2) / categoryThickness);
                    scrollbarLength = (numVisibleCategories + 1) * categoryThickness;
                    newAxisLength = plotArea.height;
                }
                else {
                    // No scrollbars, render the chart normally.
                    this.brush.remove();
                    renderDelegate(layers, axesLayout, suppressAnimations);
                    return;
                }
                // viewport is REALLY small
                if (numVisibleCategories < 1)
                    return; // don't do anything
                this.scrollScale = axisScale.copy();
                this.scrollScale.rangeBands([0, scrollbarLength]); //no inner/outer padding, keep the math simple
                this.brushMinExtent = this.scrollScale(numVisibleCategories - 1);
                // Options: use newAxisLength to squeeze-pop and keep the chart balanced, 
                //          or use scrollbarLength to keep rects still - but it leaves unbalanced right edge
                // 1. newAxisLength ex: As you resize smaller we constantly adjust the inner/outer padding to keep things balanced with the same # of rects, 
                //      when we need to drop a rect we pop out the rectangle and the padding seems to jump (to keep things cenetered and balanced). 
                // 2. scrollbarLenghth ex: As you resize smaller we can leave all rectangles in the exact same place, no squeezing inner/outer padding,
                //      when we need to drop a rect we just remove it - but this leaves the right side with lots of empty room (bad for dashboard tiles)
                // we are using option 1 to squeeze pop and show balanced layout at all sizes, but this is the less ideal experience during resize.
                // we should consider using option 2 during resize, then switch to option 1 when resize ends.
                axisScale.rangeBands([0, newAxisLength], CartesianChart.InnerPaddingRatio, CartesianChart.OuterPaddingRatio);
                this.brush.setOrientation(this.axes.isXScrollBarVisible);
                this.brush.setScale(this.scrollScale);
                this.brush.setExtent([0, this.brushMinExtent]);
                // This function will be called whenever we scroll.
                var renderOnScroll = function (extent, suppressAnimations) {
                    _this.filterDataToViewport(axisScale, layers, axesLayout.axes, _this.scrollScale, extent, numVisibleCategories);
                    renderDelegate(layers, axesLayout, suppressAnimations);
                };
                var scrollCallback = function () { return _this.onBrushed(scrollbarLength, renderOnScroll); };
                this.brush.renderBrush(this.brushMinExtent, brushX, brushY, scrollCallback);
                renderOnScroll(this.brush.getExtent(), suppressAnimations);
            };
            // FOR UNIT TESTING ONLY
            ScrollableAxes.prototype.scrollTo = function (position) {
                debug.assert(this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible, 'scrolling is not available');
                debug.assertValue(this.scrollScale, 'scrollScale');
                var extent = this.brush.getExtent();
                var extentLength = extent[1] - extent[0];
                var halfCategoryThickness = (this.scrollScale(1) - this.scrollScale(0)) / 2;
                extent[0] = this.scrollScale(position) + halfCategoryThickness;
                extent[1] = extent[0] + extentLength + halfCategoryThickness;
                this.brush.setExtent(extent);
                var scrollbarLength = this.scrollScale.rangeExtent()[1];
                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
                this.brush.scroll();
            };
            ScrollableAxes.prototype.onBrushed = function (scrollbarLength, render) {
                var brush = this.brush;
                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
                var extent = brush.getExtent();
                render(extent, /*suppressAnimations*/ true);
            };
            ScrollableAxes.clampBrushExtent = function (brush, scrollbarLength, minExtent) {
                var extent = brush.getExtent();
                var width = extent[1] - extent[0];
                if (width === minExtent && extent[1] <= scrollbarLength && extent[0] >= 0)
                    return;
                if (width > minExtent) {
                    var padding = (width - minExtent) / 2;
                    extent[0] += padding;
                    extent[1] -= padding;
                }
                else if (width < minExtent) {
                    var padding = (minExtent - width) / 2;
                    extent[0] -= padding;
                    extent[1] += padding;
                }
                if (extent[0] < 0) {
                    extent[0] = 0;
                    extent[1] = minExtent;
                }
                else if (extent[0] > scrollbarLength - minExtent) {
                    extent[0] = scrollbarLength - minExtent;
                    extent[1] = scrollbarLength;
                }
                brush.setExtent(extent);
            };
            ScrollableAxes.ScrollbarWidth = 10;
            return ScrollableAxes;
        }());
        var SvgCartesianAxes = (function () {
            function SvgCartesianAxes(axes) {
                this.axes = axes;
            }
            SvgCartesianAxes.prototype.getScrollableRegion = function () {
                return this.axisGraphicsContextScrollable;
            };
            SvgCartesianAxes.prototype.getLabelsRegion = function () {
                return this.labelRegion;
            };
            SvgCartesianAxes.prototype.getLabelBackground = function () {
                return this.labelBackgroundRegion;
            };
            SvgCartesianAxes.prototype.getXAxis = function () {
                return this.xAxisGraphicsContext;
            };
            SvgCartesianAxes.prototype.getY1Axis = function () {
                return this.y1AxisGraphicsContext;
            };
            SvgCartesianAxes.prototype.getY2Axis = function () {
                return this.y2AxisGraphicsContext;
            };
            SvgCartesianAxes.prototype.update = function (categoryAxisProperties, valueAxisProperties) {
                this.categoryAxisProperties = categoryAxisProperties;
                this.valueAxisProperties = valueAxisProperties;
            };
            SvgCartesianAxes.prototype.init = function (svg) {
                /*
                    The layout of the visual will look like:
                    <svg>
                        <g>
                            <nonscrollable axis/>
                        </g>
                        <svgScrollable>
                            <g>
                                <scrollable axis/>
                            </g>
                        </svgScrollable>
                        <g xbrush/>
                    </svg>
    
                */
                var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
                this.svgScrollable = svg.append('svg')
                    .classed('svgScrollable', true)
                    .style('overflow', 'hidden');
                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
                this.labelBackgroundRegion = this.svgScrollable.append('g')
                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
                this.labelRegion = this.svgScrollable.append('g')
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                var showLinesOnX = this.axes.showLinesOnX;
                var showLinesOnY = this.axes.showLinesOnY;
                // NOTE: We infer the axis which should scroll based on whether or not we draw grid lines for the other axis, and
                // only allow one axis to scroll.
                var scrollX = showLinesOnY;
                var scrollY = !scrollX;
                if (scrollY) {
                    this.y1AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
                }
                else {
                    this.y1AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
                }
                if (scrollX) {
                    this.xAxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                }
                else {
                    this.xAxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'x axis');
                }
                this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
                this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
                this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
            };
            SvgCartesianAxes.updateAnimatedTickTooltips = function (axisSelection, values) {
                axisSelection.each('end', function () {
                    d3.select(this)
                        .selectAll('text')
                        .append('title')
                        .text(function (d, i) { return values[i]; });
                });
            };
            SvgCartesianAxes.updateTickTooltips = function (axisSelection, values) {
                axisSelection.selectAll('text').append('title').text(function (d, i) { return values[i]; });
            };
            SvgCartesianAxes.prototype.renderAxes = function (axesLayout, duration) {
                var marginLimits = axesLayout.marginLimits;
                var plotArea = axesLayout.plotArea;
                var viewport = axesLayout.viewport;
                var margin = axesLayout.margin;
                var axes = axesLayout.axes;
                var tickLabelMargins = axesLayout.tickLabelMargins;
                var bottomMarginLimit = marginLimits.bottom;
                var leftRightMarginLimit = marginLimits.left;
                var xLabelColor;
                var yLabelColor;
                var y2LabelColor;
                if (this.axes.shouldRenderAxis(axes.x)) {
                    if (axes.x.isCategoryAxis) {
                        xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                    }
                    else {
                        xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                    }
                    axes.x.axis.orient("bottom");
                    // we only rotate ordinal tick labels
                    if (!axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale))
                        axes.x.axis.tickPadding(SvgCartesianAxes.TickPaddingRotatedX);
                    var xAxisGraphicsElement = this.xAxisGraphicsContext;
                    if (duration) {
                        xAxisGraphicsElement
                            .transition()
                            .duration(duration)
                            .call(axes.x.axis)
                            .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.x.values);
                    }
                    else {
                        xAxisGraphicsElement
                            .call(axes.x.axis);
                    }
                    xAxisGraphicsElement
                        .call(SvgCartesianAxes.darkenZeroLine)
                        .call(SvgCartesianAxes.setAxisLabelColor, xLabelColor);
                    var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
                    if (axes.x.willLabelsWordBreak) {
                        xAxisTextNodes
                            .call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, axes.x, bottomMarginLimit);
                    }
                    else {
                        xAxisTextNodes
                            .call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.svgEllipsis, !axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale), bottomMarginLimit === tickLabelMargins.xMax, axes.x, margin, this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible);
                    }
                    if (!duration) {
                        SvgCartesianAxes.updateTickTooltips(xAxisGraphicsElement, axes.x.values);
                    }
                }
                else {
                    this.xAxisGraphicsContext.selectAll('*').remove();
                }
                if (this.axes.shouldRenderAxis(axes.y1)) {
                    if (axes.y1.isCategoryAxis) {
                        yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                    }
                    else {
                        yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                    }
                    var showY1OnRight = this.axes.shouldShowY1OnRight();
                    var y1TickPadding = showY1OnRight ? axesLayout.tickPadding.right : axesLayout.tickPadding.left;
                    axes.y1.axis
                        .tickSize(-plotArea.width)
                        .tickPadding(y1TickPadding)
                        .orient(this.axes.getYAxisOrientation().toLowerCase());
                    var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                    if (duration) {
                        y1AxisGraphicsElement
                            .transition()
                            .duration(duration)
                            .call(axes.y1.axis)
                            .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y1.values);
                    }
                    else {
                        y1AxisGraphicsElement
                            .call(axes.y1.axis);
                    }
                    y1AxisGraphicsElement
                        .call(SvgCartesianAxes.darkenZeroLine)
                        .call(SvgCartesianAxes.setAxisLabelColor, yLabelColor);
                    if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
                        y1AxisGraphicsElement.selectAll('text')
                            .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                        // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                        leftRightMarginLimit - y1TickPadding, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!duration) {
                        SvgCartesianAxes.updateTickTooltips(y1AxisGraphicsElement, axes.y1.values);
                    }
                    if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {
                        y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;
                        var y2TickPadding = showY1OnRight ? axesLayout.tickPadding.left : axesLayout.tickPadding.right;
                        axes.y2.axis
                            .tickSize(SvgCartesianAxes.Y2TickSize)
                            .tickPadding(y2TickPadding)
                            .orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
                        var y2AxisGraphicsElement = this.y2AxisGraphicsContext;
                        if (duration) {
                            y2AxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(axes.y2.axis)
                                .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y2.values);
                        }
                        else {
                            y2AxisGraphicsElement
                                .call(axes.y2.axis);
                        }
                        y2AxisGraphicsElement
                            .call(SvgCartesianAxes.darkenZeroLine)
                            .call(SvgCartesianAxes.setAxisLabelColor, y2LabelColor);
                        if (tickLabelMargins.yRight >= leftRightMarginLimit) {
                            y2AxisGraphicsElement.selectAll('text')
                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                            leftRightMarginLimit - y2TickPadding, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!duration) {
                            SvgCartesianAxes.updateTickTooltips(y2AxisGraphicsElement, axes.y2.values);
                        }
                    }
                    else {
                        this.y2AxisGraphicsContext.selectAll('*').remove();
                    }
                }
                else {
                    this.y1AxisGraphicsContext.selectAll('*').remove();
                    this.y2AxisGraphicsContext.selectAll('*').remove();
                }
                // Axis labels
                //TODO: Add label for second Y axis for combo chart
                var axisLabels = axesLayout.axisLabels;
                var chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                if (chartHasAxisLabels) {
                    var hideXAxisTitle = !this.axes.shouldRenderAxisTitle(axes.x, /* defaultValue */ true, /* secondary */ false);
                    var hideYAxisTitle = !this.axes.shouldRenderAxisTitle(axes.y1, /* defaultValue */ true, /* secondary */ false);
                    var hideY2AxisTitle = !this.axes.shouldRenderAxisTitle(axes.y2, /* defaultValue */ false, /* secondary */ true);
                    var renderAxisOptions = {
                        axisLabels: axisLabels,
                        viewport: viewport,
                        margin: margin,
                        hideXAxisTitle: hideXAxisTitle,
                        hideYAxisTitle: hideYAxisTitle,
                        hideY2AxisTitle: hideY2AxisTitle,
                        xLabelColor: xLabelColor,
                        yLabelColor: yLabelColor,
                        y2LabelColor: y2LabelColor,
                        fontSize: SvgCartesianAxes.AxisLabelFontSize,
                    };
                    this.renderAxesLabels(renderAxisOptions);
                }
                else {
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                }
                this.translateAxes(viewport, margin);
            };
            SvgCartesianAxes.prototype.renderAxesLabels = function (options) {
                debug.assertValue(options, 'options');
                debug.assertValue(options.viewport, 'options.viewport');
                debug.assertValue(options.axisLabels, 'options.axisLabels');
                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                var margin = options.margin;
                var width = options.viewport.width - (margin.left + margin.right);
                var height = options.viewport.height;
                var fontSize = options.fontSize;
                var heightOffset = fontSize;
                var showOnRight = this.axes.shouldShowY1OnRight();
                if (!options.hideXAxisTitle) {
                    var xAxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .text(options.axisLabels.x)
                        .call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "xAxisLabel",
                                "transform": visuals.SVGUtil.translate(width / 2, height - heightOffset)
                            });
                        });
                    });
                    xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null);
                    xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.x]);
                }
                if (!options.hideYAxisTitle) {
                    var yAxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .text(options.axisLabels.y)
                        .call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? width + margin.right - fontSize : -margin.left,
                                "x": -((height - margin.top - margin.bottom) / 2),
                                "dy": "1em",
                            });
                        });
                    });
                    yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null);
                    yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y]);
                }
                if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                    var y2AxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .text(options.axisLabels.y2)
                        .call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? -margin.left : width + margin.right - fontSize,
                                "x": -((height - margin.top - margin.bottom) / 2),
                                "dy": "1em",
                            });
                        });
                    });
                    y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null);
                    y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y2]);
                }
            };
            // Margin convention: http://bl.ocks.org/mbostock/3019563
            SvgCartesianAxes.prototype.translateAxes = function (viewport, margin) {
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var showY1OnRight = this.axes.shouldShowY1OnRight();
                this.xAxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(0, height));
                this.y1AxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0));
                this.y2AxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0));
                this.svgScrollable.attr({
                    'x': 0,
                    'width': viewport.width,
                    'height': viewport.height
                });
                this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.labelRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                if (this.axes.isXScrollBarVisible) {
                    this.svgScrollable.attr({
                        'x': margin.left
                    });
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.labelRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.svgScrollable.attr('width', width);
                }
                else if (this.axes.isYScrollBarVisible) {
                    this.svgScrollable.attr('height', height + margin.top);
                }
            };
            /**
             * Within the context of the given selection (g), find the offset of
             * the zero tick using the d3 attached datum of g.tick elements.
             * 'Classed' is undefined for transition selections
             */
            SvgCartesianAxes.darkenZeroLine = function (g) {
                // remove zero-line class from all first, filtering can cause lines that are no longer zero to still be dark (since the key is index based)
                g.selectAll('g.tick line').classed('zero-line', false);
                var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
                if (zeroTick) {
                    d3.select(zeroTick).select('line').classed('zero-line', true);
                }
            };
            SvgCartesianAxes.setAxisLabelColor = function (g, fill) {
                g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);
            };
            // These match D3's internal axis padding values
            SvgCartesianAxes.AxisPadding = {
                left: 10,
                right: 10,
                top: 0,
                bottom: 13,
            };
            SvgCartesianAxes.AxisGraphicsContext = createClassAndSelector('axisGraphicsContext');
            SvgCartesianAxes.TickPaddingRotatedX = 5;
            SvgCartesianAxes.AxisLabelFontSize = 11;
            SvgCartesianAxes.Y2TickSize = -6;
            return SvgCartesianAxes;
        }());
        visuals.SvgCartesianAxes = SvgCartesianAxes;
        var CartesianAxes = (function () {
            function CartesianAxes(isScrollable, scrollbarWidth, trimOrdinalDataOnOverflow) {
                this.scrollbarWidth = scrollbarWidth;
                this.isScrollable = isScrollable;
                this.maxMarginFactor = CartesianAxes.MaxMarginFactor;
                this.yAxisOrientation = visuals.yAxisPosition.left;
                this.trimOrdinalDataOnOverflow = trimOrdinalDataOnOverflow;
            }
            CartesianAxes.prototype.shouldShowY1OnRight = function () {
                return this.yAxisOrientation === visuals.yAxisPosition.right;
            };
            CartesianAxes.prototype.isYAxisCategorical = function () {
                return this.layout && this.layout.axes.y1.isCategoryAxis;
            };
            CartesianAxes.prototype.hasCategoryAxis = function () {
                var axes = this.layout && this.layout.axes;
                if (!axes)
                    return false;
                return this.isYAxisCategorical()
                    ? axes.y1 && axes.y1.axis != null
                    : axes.x && axes.x.axis != null;
            };
            CartesianAxes.prototype.hasY2Axis = function () {
                return this.layout && this.layout.axes.y2 != null;
            };
            CartesianAxes.prototype.getYAxisOrientation = function () {
                return this.yAxisOrientation;
            };
            CartesianAxes.prototype.setAxisLinesVisibility = function (axisLinesVisibility) {
                this.showLinesOnX = EnumExtensions.hasFlag(axisLinesVisibility, 3 /* ShowLinesOnBothAxis */) ||
                    EnumExtensions.hasFlag(axisLinesVisibility, 1 /* ShowLinesOnXAxis */);
                this.showLinesOnY = EnumExtensions.hasFlag(axisLinesVisibility, 3 /* ShowLinesOnBothAxis */) ||
                    EnumExtensions.hasFlag(axisLinesVisibility, 2 /* ShowLinesOnYAxis */);
            };
            CartesianAxes.prototype.setMaxMarginFactor = function (factor) {
                this.maxMarginFactor = factor;
            };
            CartesianAxes.prototype.update = function (dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                }
                var axisPosition = this.valueAxisProperties['position'];
                this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
            };
            CartesianAxes.prototype.addWarnings = function (warnings) {
                var axes = this.layout && this.layout.axes;
                if (axes && axes.x && axes.x.hasDisallowedZeroInDomain
                    || axes.y1 && axes.y1.hasDisallowedZeroInDomain
                    || axes.y2 && axes.y2.hasDisallowedZeroInDomain) {
                    warnings.unshift(new visuals.ZeroValueWarning());
                }
            };
            /**
             * Negotiate the axes regions, the plot area, and determine if we need a scrollbar for ordinal categories.
             * @param layers an array of Cartesian layout layers (column, line, etc.)
             * @param parentViewport the full viewport for the visual
             * @param padding the D3 axis padding values
             * @param playAxisControlLayout if this is a playable Cartesian chart, includes the layout for the play controls (start/stop, time slider)
             * @param hideAxisLabels forces axis titles to be hidden
             * @param textProperties text properties to be used by text measurement
             * @param interactivityRightMargin extra right margin for the interactivity
             * @param ensureXDomain if non null, includes values that must be part of the axis domain
             * @param ensureYDomain if non null, includes values that must be part of the axis domain
             */
            CartesianAxes.prototype.negotiateAxes = function (layers, parentViewport, padding, playAxisControlLayout, hideAxisLabels, textProperties, interactivityRightMargin, ensureXDomain, ensureYDomain) {
                // 1> MinMargins -> some initial axis properties / text
                // 2> Get axis margins for the initial text, no rotateXTickLabels90. margins grown? -> axis properties / text again (possibly more tick labels now)
                // ?> do we have more labels? do we need rotate? are we done?
                // 3> margins again (rotate? margins grow?) -> text again (less tick labls now?)
                // FREEZE PROPERTIES THAT CAN CHANGE
                // 4> margins (final), axes (final)
                // 1.a) initialize margins
                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
                var viewport = powerbi.Prototype.inherit(parentViewport);
                var leftRightMarginLimit = viewport.width * this.maxMarginFactor;
                var bottomMarginLimit = Math.max(CartesianAxes.MinimumMargin.bottom, Math.ceil(viewport.height * this.maxMarginFactor));
                var marginLimits = {
                    left: leftRightMarginLimit,
                    right: leftRightMarginLimit,
                    top: 0,
                    bottom: bottomMarginLimit,
                };
                // 1.b) Calculate axis properties using initial margins
                var axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                /*scrollbarVisible*/ false, 
                /*previousAxisProperties*/ null, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                // these are used by getTickLabelMargins
                var renderXAxis = this.shouldRenderAxis(axes.x);
                var renderY1Axis = this.shouldRenderAxis(axes.y1);
                var renderY2Axis = this.shouldRenderAxis(axes.y2, true);
                var showY1OnRight = this.shouldShowY1OnRight();
                var plotArea = {
                    width: viewport.width - (margin.left + margin.right),
                    height: viewport.height - (margin.top + margin.bottom)
                };
                var isScalar = false;
                if (!_.isEmpty(layers)) {
                    if (layers[0].getVisualCategoryAxisIsScalar)
                        isScalar = layers[0].getVisualCategoryAxisIsScalar();
                }
                // 2.a) calculate axis tick margins
                var tickLabelMargins = undefined;
                tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, 
                /*scrolling*/ false, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisLabels, isScalar ? 0 : interactivityRightMargin);
                // if any of these change, we need to calculate margins again
                var previousTickCountY1 = axes.y1 && axes.y1.values.length;
                var previousTickCountY2 = axes.y2 && axes.y2.values.length;
                var previousWillFitX = axes.x && axes.x.willLabelsFit;
                var previousWillBreakX = axes.x && axes.x.willLabelsWordBreak;
                // 2.b) Re-calculate the axes with the new margins.
                axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                /*scrollbarVisible*/ false, 
                /*previousAxes*/ null, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                plotArea.width = viewport.width - (margin.left + margin.right);
                plotArea.height = viewport.height - (margin.top + margin.bottom);
                // check properties that affect getTickLabelMargin - if these are the same, we don't need to calculate axis margins again
                var preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                var rotateXTickLabels90 = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                var allDone = ((!axes.y1 || axes.y1.values.length === previousTickCountY1)
                    && (!axes.y2 || axes.y2.values.length === previousTickCountY2)
                    && (!axes.x || axes.x.willLabelsFit === previousWillFitX)
                    && (!axes.x || axes.x.willLabelsWordBreak === previousWillBreakX)
                    && !rotateXTickLabels90);
                this.isXScrollBarVisible = false;
                this.isYScrollBarVisible = false;
                if (!allDone) {
                    // 3.a) calculate axis tick margins
                    tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, rotateXTickLabels90, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                    margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisLabels, isScalar ? 0 : interactivityRightMargin);
                    // 3.b) Re-calculate the axes with the new final margins
                    axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                    /*scrollbarVisible*/ rotateXTickLabels90, axes, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                    // now we can determine if we need actual scrolling
                    // rotateXTickLabels90 will give more plotArea to categories since the left-overflow of a rotated category label doesn't exist anymore
                    plotArea.width = viewport.width - (margin.left + margin.right);
                    plotArea.height = viewport.height - (margin.top + margin.bottom);
                    preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                    var willScroll = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                    if (willScroll) {
                        if (this.showLinesOnY) {
                            this.isXScrollBarVisible = true;
                            plotArea.height -= this.scrollbarWidth;
                            viewport.height -= this.scrollbarWidth;
                        }
                        if (this.showLinesOnX) {
                            this.isYScrollBarVisible = true;
                            plotArea.width -= this.scrollbarWidth;
                            viewport.width -= this.scrollbarWidth;
                        }
                        // 3.c) Re-calculate the axes with the final margins (and the updated viewport - scrollbarWidth)
                        axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                        /*scrollbarVisible*/ true, axes, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                    }
                }
                ///////DONE
                var axisLabels = hideAxisLabels ?
                    { x: null, y: null, y2: null } :
                    { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                this.layout = {
                    axes: axes,
                    axisLabels: axisLabels,
                    margin: margin,
                    marginLimits: marginLimits,
                    viewport: viewport,
                    plotArea: plotArea,
                    preferredPlotArea: preferredPlotArea,
                    tickLabelMargins: tickLabelMargins,
                    tickPadding: padding,
                    rotateXTickLabels90: rotateXTickLabels90,
                };
                return this.layout;
            };
            CartesianAxes.prototype.getPreferredPlotArea = function (axes, layers, isScalar) {
                var preferredPlotArea;
                if (!isScalar && this.isScrollable && !_.isEmpty(layers) && layers[0].getPreferredPlotArea) {
                    var categoryThickness = this.showLinesOnY ? axes.x.categoryThickness : axes.y1.categoryThickness;
                    var categoryCount = this.showLinesOnY ? axes.x.dataDomain.length : axes.y1.dataDomain.length;
                    preferredPlotArea = layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                }
                return preferredPlotArea;
            };
            CartesianAxes.prototype.willAllCategoriesFitInPlotArea = function (plotArea, preferredPlotArea) {
                if (this.showLinesOnY && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.width, plotArea.width)) {
                    return false;
                }
                if (this.showLinesOnX && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.height, plotArea.height)) {
                    return false;
                }
                return true;
            };
            CartesianAxes.prototype.updateAxisMargins = function (axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisTitles, interactivityRightMargin) {
                // We look at the y axes as main and second sides, if the y axis orientation is right then the main side represents the right side.
                var maxY1Padding = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxY2Padding = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, maxXAxisBottom = tickLabelMargins.xMax;
                maxY1Padding += padding.left;
                if ((renderY2Axis && !showY1OnRight) || (showY1OnRight && renderY1Axis))
                    maxY2Padding += padding.right;
                maxXAxisBottom += padding.bottom;
                // Adjust for axis titles
                if (hideAxisTitles) {
                    axes.x.axisLabel = null;
                    axes.y1.axisLabel = null;
                    if (axes.y2) {
                        axes.y2.axisLabel = null;
                    }
                }
                this.addUnitTypeToAxisLabels(axes);
                var axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                if (axisLabels.x != null)
                    maxXAxisBottom += CartesianAxes.XAxisLabelPadding;
                if (axisLabels.y != null)
                    maxY1Padding += CartesianAxes.YAxisLabelPadding;
                if (axisLabels.y2 != null)
                    maxY2Padding += CartesianAxes.YAxisLabelPadding;
                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
                margin.left = showY1OnRight ? maxY2Padding : maxY1Padding;
                margin.right = showY1OnRight ? maxY1Padding : maxY2Padding;
                margin.right += interactivityRightMargin; // for mobile interactive legend
                margin.bottom = maxXAxisBottom;
                return margin;
            };
            CartesianAxes.prototype.isLogScaleAllowed = function (axisType) {
                var axes = this.layout && this.layout.axes;
                if (!axes)
                    return false;
                switch (axisType) {
                    case 0 /* X */:
                        return axes.x.isLogScaleAllowed;
                    case 1 /* Y1 */:
                        return axes.y1.isLogScaleAllowed;
                    case 2 /* Y2 */:
                        return axes.y2 && axes.y2.isLogScaleAllowed;
                }
            };
            CartesianAxes.prototype.axesHaveTicks = function (viewport) {
                if (!this.layout)
                    return false;
                var margin = this.layout.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                // TODO: this is never the case, remove.
                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0
                    && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
                    return false;
                }
                return true;
            };
            CartesianAxes.prototype.shouldRenderAxisTitle = function (axisProperties, defaultValue, secondary) {
                var propertyName = secondary ? 'secShowAxisTitle' : 'showAxisTitle';
                return !!this.getAxisProperty(axisProperties, propertyName, defaultValue);
            };
            CartesianAxes.prototype.shouldRenderAxis = function (axisProperties, secondary) {
                if (secondary === void 0) { secondary = false; }
                if (!axisProperties)
                    return false;
                var propertyName = secondary ? 'secShow' : 'show';
                return this.getAxisProperty(axisProperties, propertyName, true)
                    && axisProperties.values
                    && axisProperties.values.length > 0;
            };
            CartesianAxes.prototype.getAxisProperty = function (axisProperties, propertyName, defaultValue) {
                if (!axisProperties)
                    return defaultValue;
                var properties = axisProperties.isCategoryAxis
                    ? this.categoryAxisProperties
                    : this.valueAxisProperties;
                if (properties && properties[propertyName] != null)
                    return properties[propertyName];
                else
                    return defaultValue;
            };
            // TODO: clean this up
            CartesianAxes.prototype.addUnitTypeToAxisLabels = function (axes) {
                var unitType = CartesianAxes.getUnitType(axes.x.formatter);
                if (axes.x.isCategoryAxis) {
                    this.categoryAxisHasUnitType = unitType != null;
                }
                else {
                    this.valueAxisHasUnitType = unitType != null;
                }
                if (axes.x.axisLabel && unitType) {
                    if (axes.x.isCategoryAxis) {
                        axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);
                    }
                    else {
                        axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);
                    }
                }
                unitType = CartesianAxes.getUnitType(axes.y1.formatter);
                if (!axes.y1.isCategoryAxis) {
                    this.valueAxisHasUnitType = unitType != null;
                }
                else {
                    this.categoryAxisHasUnitType = unitType != null;
                }
                if (axes.y1.axisLabel && unitType) {
                    if (!axes.y1.isCategoryAxis) {
                        axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);
                    }
                    else {
                        axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);
                    }
                }
                if (axes.y2) {
                    var unitType_1 = CartesianAxes.getUnitType(axes.y2.formatter);
                    this.secondaryValueAxisHasUnitType = unitType_1 != null;
                    if (axes.y2.axisLabel && unitType_1) {
                        axes.y2.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y2.axisLabel, unitType_1, true);
                    }
                }
            };
            CartesianAxes.getUnitType = function (formatter) {
                if (formatter &&
                    formatter.displayUnit &&
                    formatter.displayUnit.value > 1)
                    return formatter.displayUnit.title;
            };
            CartesianAxes.YAxisLabelPadding = 20;
            CartesianAxes.XAxisLabelPadding = 18;
            CartesianAxes.MaxMarginFactor = 0.25;
            CartesianAxes.MinimumMargin = {
                left: 1,
                right: 1,
                top: 8,
                bottom: 25,
            };
            return CartesianAxes;
        }());
        visuals.CartesianAxes = CartesianAxes;
        var CartesianLayerFactory;
        (function (CartesianLayerFactory) {
            function createLayers(type, objects, interactivityService, animator, isScrollable, tooltipsEnabled, lineChartLabelDensityEnabled) {
                if (isScrollable === void 0) { isScrollable = false; }
                var layers = [];
                var cartesianOptions = {
                    isScrollable: isScrollable,
                    animator: animator,
                    interactivityService: interactivityService,
                    tooltipsEnabled: tooltipsEnabled,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                };
                switch (type) {
                    case 1 /* Area */:
                        layers.push(createLineChartLayer(2 /* area */, /* inComboChart */ false, cartesianOptions));
                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
                        break;
                    case 0 /* Line */:
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ false, cartesianOptions));
                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
                        break;
                    case 2 /* StackedArea */:
                        layers.push(createLineChartLayer(16 /* stackedArea */, /* inComboChart */ false, cartesianOptions));
                        break;
                    case 9 /* Scatter */:
                        layers.push(createScatterChartLayer(cartesianOptions));
                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
                        break;
                    case 12 /* Waterfall */:
                        layers.push(createWaterfallChartLayer(cartesianOptions));
                        break;
                    case 11 /* DataDot */:
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;
                    case 4 /* StackedColumn */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                        break;
                    case 3 /* ClusteredColumn */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                        break;
                    case 8 /* HundredPercentStackedColumn */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));
                        break;
                    case 6 /* StackedBar */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedBar, cartesianOptions));
                        break;
                    case 5 /* ClusteredBar */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredBar, cartesianOptions));
                        break;
                    case 7 /* HundredPercentStackedBar */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedBar, cartesianOptions));
                        break;
                    case 10 /* ComboChart */:
                        var columnType = getComboColumnType();
                        layers.push(createColumnChartLayer(columnType, cartesianOptions));
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
                        break;
                    case 13 /* LineClusteredColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
                        break;
                    case 14 /* LineStackedColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
                        break;
                    case 15 /* DataDotClusteredColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;
                    case 16 /* DataDotStackedColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;
                }
                // Linear regression line layer
                //if (shouldAddTrendLayer(objects))
                //    layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
                return layers;
            }
            CartesianLayerFactory.createLayers = createLayers;
            function shouldAddTrendLayer(objects) {
                var trendObject = powerbi.DataViewObjects.getObject(objects, 'trend', null);
                if (trendObject)
                    return powerbi.DataViewObject.getValue(trendObject, 'show', false);
            }
            CartesianLayerFactory.shouldAddTrendLayer = shouldAddTrendLayer;
            function createLineChartLayer(type, inComboChart, defaultOptions, isTrendLayer) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    tooltipsEnabled: !isTrendLayer && defaultOptions.tooltipsEnabled,
                    chartType: type,
                    lineChartLabelDensityEnabled: defaultOptions.lineChartLabelDensityEnabled,
                    isTrendLayer: isTrendLayer,
                };
                if (inComboChart) {
                    options.chartType = options.chartType | 8 /* lineShadow */;
                }
                return new visuals.LineChart(options);
            }
            function createScatterChartLayer(defaultOptions) {
                defaultOptions.isScrollable = false;
                return new visuals.ScatterChart(defaultOptions);
            }
            function createWaterfallChartLayer(defaultOptions) {
                return new visuals.WaterfallChart(defaultOptions);
            }
            function createDataDotChartLayer(defaultOptions) {
                return new visuals.DataDotChart(defaultOptions);
            }
            function createColumnChartLayer(type, defaultOptions) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    tooltipsEnabled: defaultOptions.tooltipsEnabled,
                    chartType: type
                };
                return new visuals.ColumnChart(options);
            }
            function getComboColumnType(objects) {
                // This supports existing serialized forms of pinned combo-chart visuals
                var columnType = visuals.ColumnChartType.clusteredColumn;
                if (objects) {
                    var comboChartTypes = objects.general;
                    if (comboChartTypes) {
                        switch (comboChartTypes.visualType1) {
                            case 'Column':
                                columnType = visuals.ColumnChartType.clusteredColumn;
                                break;
                            case 'ColumnStacked':
                                columnType = visuals.ColumnChartType.stackedColumn;
                                break;
                            default:
                                debug.assertFail('Unsupported cartesian chart type ' + comboChartTypes.visualType1);
                        }
                        // second visual is always LineChart (for now)
                        if (comboChartTypes.visualType2) {
                            debug.assert(comboChartTypes.visualType2 === 'Line', 'expecting a LineChart for VisualType2');
                        }
                    }
                }
                return columnType;
            }
        })(CartesianLayerFactory || (CartesianLayerFactory = {}));
        var SharedColorPalette = (function () {
            function SharedColorPalette(palette) {
                this.palette = palette;
                this.clearPreferredScale();
            }
            SharedColorPalette.prototype.getColorScaleByKey = function (scaleKey) {
                this.setPreferredScale(scaleKey);
                return this.preferredScale;
            };
            SharedColorPalette.prototype.getNewColorScale = function () {
                return this.preferredScale;
            };
            SharedColorPalette.prototype.getColorByIndex = function (index) {
                return this.palette.getColorByIndex(index);
            };
            SharedColorPalette.prototype.getSentimentColors = function () {
                return this.palette.getSentimentColors();
            };
            SharedColorPalette.prototype.getBasePickerColors = function () {
                return this.palette.getBasePickerColors();
            };
            SharedColorPalette.prototype.clearPreferredScale = function () {
                this.preferredScale = this.palette.getNewColorScale();
                this.rotated = false;
            };
            SharedColorPalette.prototype.rotateScale = function () {
                // We create a new rotated the scale such that the first color of the new scale is the first
                // free color of the previous scale. Note that the new scale does not have any colors allocated
                // to particular keys.
                this.preferredScale = this.preferredScale.clone();
                this.preferredScale.clearAndRotateScale();
                this.rotated = true;
            };
            SharedColorPalette.prototype.setPreferredScale = function (scaleKey) {
                if (!this.rotated) {
                    // The first layer to express a preference sets the preferred scale.
                    this.preferredScale = this.palette.getColorScaleByKey(scaleKey);
                }
            };
            return SharedColorPalette;
        }());
        visuals.SharedColorPalette = SharedColorPalette;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var flagBar = 1 << 1;
        var flagColumn = 1 << 2;
        var flagClustered = 1 << 3;
        var flagStacked = 1 << 4;
        var flagStacked100 = flagStacked | (1 << 5);
        (function (ColumnChartType) {
            ColumnChartType[ColumnChartType["clusteredBar"] = flagBar | flagClustered] = "clusteredBar";
            ColumnChartType[ColumnChartType["clusteredColumn"] = flagColumn | flagClustered] = "clusteredColumn";
            ColumnChartType[ColumnChartType["hundredPercentStackedBar"] = flagBar | flagStacked100] = "hundredPercentStackedBar";
            ColumnChartType[ColumnChartType["hundredPercentStackedColumn"] = flagColumn | flagStacked100] = "hundredPercentStackedColumn";
            ColumnChartType[ColumnChartType["stackedBar"] = flagBar | flagStacked] = "stackedBar";
            ColumnChartType[ColumnChartType["stackedColumn"] = flagColumn | flagStacked] = "stackedColumn";
        })(visuals.ColumnChartType || (visuals.ColumnChartType = {}));
        var ColumnChartType = visuals.ColumnChartType;
        var RoleNames = {
            category: 'Category',
            series: 'Series',
            y: 'Y',
        };
        /**
         * Renders a stacked and clustered column chart.
         */
        var ColumnChart = (function () {
            function ColumnChart(options) {
                debug.assertValue(options, 'options');
                var chartType = options.chartType;
                debug.assertValue(chartType, 'chartType');
                this.chartType = chartType;
                this.categoryAxisType = null;
                this.animator = options.animator;
                this.isScrollable = options.isScrollable;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.interactivityService = options.interactivityService;
            }
            ColumnChart.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                dataViewMapping.categorical.dataVolume = 4;
                if (visuals.CartesianChart.detectScalarMapping(dataViewMapping)) {
                    var dataViewCategories = dataViewMapping.categorical.categories;
                    dataViewCategories.dataReductionAlgorithm = { sample: {} };
                }
            };
            ColumnChart.getSortableRoles = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!_.isEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects = void 0;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    //TODO: column chart should be sortable by X if it has scalar axis
                    // But currenly it doesn't support this. Return 'category' once
                    // it is supported.
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) {
                        return ['Category', 'Y'];
                    }
                }
                return null;
            };
            ColumnChart.prototype.updateVisualMetadata = function (x, y, margin) {
                this.xAxisProperties = x;
                this.yAxisProperties = y;
                this.margin = margin;
            };
            ColumnChart.prototype.init = function (options) {
                this.svg = options.svg;
                this.svg.classed(ColumnChart.ColumnChartClassName, true);
                this.mainGraphicsContext = this.svg.append('svg').classed('columnChartMainGraphicsContext', true);
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.interactivity = options.interactivity;
                this.colors = this.style.colorPalette.dataColors;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.isComboChart = visuals.ComboChart.isComboChart(options.chartType);
                this.element = options.element;
            };
            ColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {
                var availableWidth;
                if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                    availableWidth = this.currentViewport.height - (this.margin.top + this.margin.bottom);
                }
                else {
                    availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
                }
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isScalar = this.data ? this.data.scalarCategoryAxis : false;
                var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain, options.ensureXDomain);
                return visuals.CartesianChart.getLayout(this.data, {
                    availableWidth: availableWidth,
                    categoryCount: numCategoryValues,
                    domain: domain,
                    isScalar: isScalar,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
            };
            ColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, dataViewMetadata, chartType, interactivityService, tooltipsEnabled) {
                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                if (isScalar === void 0) { isScalar = false; }
                if (dataViewMetadata === void 0) { dataViewMetadata = null; }
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colors, 'colors');
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                var converterStrategy = new ColumnChartConverterHelper(dataView);
                var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString);
                var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
                var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PercentStacked || EnumExtensions.hasFlag(chartType, flagStacked));
                var defaultLegendLabelColor = visuals.LegendData.DefaultLegendLabelFillColor;
                var defaultDataPointColor = undefined;
                var showAllDataPoints = undefined;
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    defaultLegendLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.legend.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                    var labelsObj = objects['labels'];
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                }
                // Allocate colors
                var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultLegendLabelColor, defaultDataPointColor);
                var legend = legendAndSeriesInfo.legend.dataPoints;
                var seriesSources = legendAndSeriesInfo.seriesSources;
                // Determine data points
                var result = ColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled);
                var columnSeries = result.series;
                var valuesMetadata = [];
                for (var j = 0, jlen = legend.length; j < jlen; j++) {
                    valuesMetadata.push(seriesSources[j]);
                }
                var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                if (!EnumExtensions.hasFlag(chartType, flagColumn)) {
                    // Replace between x and y axes
                    var temp = labels.xAxisLabel;
                    labels.xAxisLabel = labels.yAxisLabel;
                    labels.yAxisLabel = temp;
                }
                if (interactivityService) {
                    for (var _i = 0, columnSeries_1 = columnSeries; _i < columnSeries_1.length; _i++) {
                        var series = columnSeries_1[_i];
                        interactivityService.applySelectionStateToData(series.data);
                    }
                    interactivityService.applySelectionStateToData(legendAndSeriesInfo.legend.dataPoints);
                }
                return {
                    categories: categories,
                    categoryFormatter: categoryFormatter,
                    series: columnSeries,
                    valuesMetadata: valuesMetadata,
                    legendData: legendAndSeriesInfo.legend,
                    hasHighlights: result.hasHighlights,
                    categoryMetadata: categoryMetadata,
                    scalarCategoryAxis: isScalar,
                    labelSettings: labelSettings,
                    axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },
                    hasDynamicSeries: result.hasDynamicSeries,
                    isMultiMeasure: result.isMultiMeasure,
                    defaultDataPointColor: defaultDataPointColor,
                    showAllDataPoints: showAllDataPoints,
                };
            };
            ColumnChart.canSupportOverflow = function (chartType, seriesCount) {
                return !EnumExtensions.hasFlag(chartType, flagStacked) || seriesCount === 1;
            };
            ColumnChart.createDataPoints = function (dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled) {
                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                if (isScalar === void 0) { isScalar = false; }
                var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
                var categoryCount = categories.length;
                var seriesCount = legend.length;
                var columnSeries = [];
                if (seriesCount < 1 || categoryCount < 1)
                    return { series: columnSeries, hasHighlights: false, hasDynamicSeries: false, isMultiMeasure: false };
                var dvCategories = dataViewCat.categories;
                categoryMetadata = (dvCategories && dvCategories.length > 0)
                    ? dvCategories[0].source
                    : null;
                var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var baseValuesPos = [], baseValuesNeg = [];
                var rawValues = [];
                var rawHighlightValues = [];
                var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
                var isMultiMeasure = !hasDynamicSeries && seriesCount > 1;
                var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different
                var hasHighlights = converterStrategy.hasHighlightValues(0);
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesValues = [];
                    var seriesHighlightValues = [];
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                        seriesValues[categoryIndex] = value;
                        if (hasHighlights) {
                            var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesHighlightValues[categoryIndex] = highlightValue;
                            // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.
                            if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) ||
                                (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {
                                highlightsOverflow = true;
                            }
                        }
                    }
                    rawValues.push(seriesValues);
                    if (hasHighlights) {
                        rawHighlightValues.push(seriesHighlightValues);
                    }
                }
                if (highlightsOverflow && !ColumnChart.canSupportOverflow(chartType, seriesCount)) {
                    highlightsOverflow = false;
                    hasHighlights = false;
                    rawValues = rawHighlightValues;
                }
                var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings = void 0;
                    if (!hasDynamicSeries) {
                        var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
                        var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
                        if (labelObjects) {
                            seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
                        }
                    }
                    columnSeries.push({
                        displayName: legendItem.label,
                        key: 'series' + seriesIndex,
                        index: seriesIndex,
                        data: seriesDataPoints,
                        identity: legendItem.identity,
                        color: legendItem.color,
                        labelSettings: seriesLabelSettings,
                    });
                    if (seriesCount > 1)
                        dataPointObjects = seriesObjectsList[seriesIndex];
                    var metadata = dataViewCat.values[seriesIndex].source;
                    var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(dataViewCat);
                    var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCat);
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        if (seriesIndex === 0) {
                            baseValuesPos.push(0);
                            baseValuesNeg.push(0);
                        }
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                        if (value == null) {
                            // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.
                            // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.
                            if (seriesIndex > 0)
                                continue;
                        }
                        var originalValue = value;
                        var categoryValue = categories[categoryIndex];
                        // ignore variant measures
                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
                            continue;
                        if (isDateTime && categoryValue)
                            categoryValue = categoryValue.getTime();
                        if (isScalar && (categoryValue == null || isNaN(categoryValue)))
                            continue;
                        var multipliers = void 0;
                        if (is100PercentStacked)
                            multipliers = visuals.StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);
                        var unadjustedValue = value, isNegative = value < 0;
                        if (multipliers) {
                            if (isNegative)
                                value *= multipliers.neg;
                            else
                                value *= multipliers.pos;
                        }
                        var valueAbsolute = Math.abs(value);
                        var position = void 0;
                        if (isNegative) {
                            position = baseValuesNeg[categoryIndex];
                            if (!isNaN(valueAbsolute))
                                baseValuesNeg[categoryIndex] -= valueAbsolute;
                        }
                        else {
                            if (!isNaN(valueAbsolute))
                                baseValuesPos[categoryIndex] += valueAbsolute;
                            position = baseValuesPos[categoryIndex];
                        }
                        var seriesGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex].values[0] : null;
                        var category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;
                        var identity = visuals.SelectionIdBuilder.builder()
                            .withCategory(category, categoryIndex)
                            .withSeries(dataViewCat.values, seriesGroup)
                            .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))
                            .createSelectionId();
                        var rawCategoryValue = categories[categoryIndex];
                        var color = ColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
                        var gradientColumnForTooltip = gradientMeasureIndex === 0 ? null : gradientValueColumn;
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, null, gradientColumnForTooltip);
                        }
                        var series = columnSeries[seriesIndex];
                        var dataPointLabelSettings = (series.labelSettings) ? series.labelSettings : defaultLabelSettings;
                        var labelColor = dataPointLabelSettings.labelColor;
                        var lastValue = undefined;
                        //Stacked column/bar label color is white by default (except last series)
                        if ((EnumExtensions.hasFlag(chartType, flagStacked))) {
                            lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
                            labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor;
                        }
                        var dataPoint = {
                            categoryValue: categoryValue,
                            value: value,
                            position: position,
                            valueAbsolute: valueAbsolute,
                            valueOriginal: unadjustedValue,
                            seriesIndex: seriesIndex,
                            labelSettings: dataPointLabelSettings,
                            categoryIndex: categoryIndex,
                            color: color,
                            selected: false,
                            originalValue: value,
                            originalPosition: position,
                            originalValueAbsolute: valueAbsolute,
                            identity: identity,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            labelFill: labelColor,
                            labelFormatString: metadata.format,
                            lastSeries: lastValue,
                            chartType: chartType
                        };
                        seriesDataPoints.push(dataPoint);
                        if (hasHighlights) {
                            var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];
                            var unadjustedValueHighlight = valueHighlight;
                            var highlightedTooltip = true;
                            if (valueHighlight === null) {
                                valueHighlight = 0;
                                highlightedTooltip = false;
                            }
                            if (is100PercentStacked) {
                                valueHighlight *= multipliers.pos;
                            }
                            var absoluteValueHighlight = Math.abs(valueHighlight);
                            var highlightPosition = position;
                            if (valueHighlight > 0) {
                                highlightPosition -= valueAbsolute - absoluteValueHighlight;
                            }
                            else if (valueHighlight === 0 && value > 0) {
                                highlightPosition -= valueAbsolute;
                            }
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var rawCategoryValue_1 = categories[categoryIndex];
                            var highlightedValue = highlightedTooltip ? valueHighlight : undefined;
                            var tooltipInfo_1 = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo_1 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue_1, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue, gradientColumnForTooltip);
                            }
                            if (highlightedTooltip) {
                                // Override non highlighted data point
                                dataPoint.tooltipInfo = tooltipInfo_1;
                            }
                            var highlightDataPoint = {
                                categoryValue: categoryValue,
                                value: valueHighlight,
                                position: highlightPosition,
                                valueAbsolute: absoluteValueHighlight,
                                valueOriginal: unadjustedValueHighlight,
                                seriesIndex: seriesIndex,
                                labelSettings: dataPointLabelSettings,
                                categoryIndex: categoryIndex,
                                color: color,
                                selected: false,
                                highlight: true,
                                originalValue: value,
                                originalPosition: position,
                                originalValueAbsolute: valueAbsolute,
                                drawThinner: highlightsOverflow,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                tooltipInfo: tooltipInfo_1,
                                labelFormatString: metadata.format,
                                labelFill: labelColor,
                                lastSeries: lastValue,
                                chartType: chartType
                            };
                            seriesDataPoints.push(highlightDataPoint);
                        }
                    }
                }
                return {
                    series: columnSeries,
                    hasHighlights: hasHighlights,
                    hasDynamicSeries: hasDynamicSeries,
                    isMultiMeasure: isMultiMeasure,
                };
            };
            ColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {
                debug.assertValue(legendItem, 'legendItem');
                debug.assertValue(categoryIndex, 'categoryIndex');
                debug.assertAnyValue(dataPointObjects, 'dataPointObjects');
                if (dataPointObjects) {
                    var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                    if (colorOverride)
                        return colorOverride;
                }
                return legendItem.color;
            };
            ColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
                //run for the next series and check if current series is last
                for (var i = seriesIndex + 1; i < seriesCount; i++) {
                    var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                    if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {
                        lastValue = false;
                        break;
                    }
                }
                return lastValue;
            };
            ColumnChart.sliceSeries = function (series, endIndex, startIndex) {
                if (startIndex === void 0) { startIndex = 0; }
                var newSeries = [];
                if (series && series.length > 0) {
                    for (var i = 0, len = series.length; i < len; i++) {
                        var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        // TODO: [investigate] possible perf improvement.
                        // if data[n].categoryIndex > endIndex implies data[n+1].categoryIndex > endIndex
                        // then we could short circuit the filter loop.
                        iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });
                    }
                }
                return newSeries;
            };
            ColumnChart.getInteractiveColumnChartDomElement = function (element) {
                return element.children("svg").get(0);
            };
            ColumnChart.prototype.setData = function (dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var is100PctStacked = EnumExtensions.hasFlag(this.chartType, flagStacked100);
                this.data = {
                    categories: [],
                    categoryFormatter: null,
                    series: [],
                    valuesMetadata: [],
                    legendData: null,
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked || EnumExtensions.hasFlag(this.chartType, flagStacked)),
                    axesLabels: { x: null, y: null },
                    hasDynamicSeries: false,
                    defaultDataPointColor: null,
                    isMultiMeasure: false,
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCat = this.dataViewCat = dataView.categorical;
                        var dvCategories = dataViewCat.categories;
                        var categoryMetadata = (dvCategories && dvCategories.length > 0)
                            ? dvCategories[0].source
                            : null;
                        var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                        this.data = ColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), is100PctStacked, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.columnChartProps.categoryAxis.axisType, categoryType), dataView.metadata, this.chartType, this.interactivityService, this.tooltipsEnabled);
                    }
                }
                this.setChartStrategy();
            };
            ColumnChart.prototype.setChartStrategy = function () {
                switch (this.chartType) {
                    case ColumnChartType.clusteredBar:
                        this.columnChart = new visuals.ClusteredBarChartStrategy();
                        break;
                    case ColumnChartType.clusteredColumn:
                        this.columnChart = new visuals.ClusteredColumnChartStrategy();
                        break;
                    case ColumnChartType.stackedBar:
                    case ColumnChartType.hundredPercentStackedBar:
                        this.columnChart = new visuals.StackedBarChartStrategy();
                        break;
                    case ColumnChartType.stackedColumn:
                    case ColumnChartType.hundredPercentStackedColumn:
                    default:
                        this.columnChart = new visuals.StackedColumnChartStrategy();
                        break;
                }
                // For single series, render stacked as a clustered
                if (EnumExtensions.hasFlag(this.chartType, flagStacked) && this.data.series.length === 1) {
                    switch (this.chartType) {
                        case (ColumnChartType.stackedBar):
                            this.columnChart = new visuals.ClusteredBarChartStrategy();
                            break;
                        case (ColumnChartType.stackedColumn):
                            this.columnChart = new visuals.ClusteredColumnChartStrategy();
                            break;
                    }
                }
            };
            ColumnChart.prototype.calculateLegend = function () {
                // if we're in interactive mode, return the interactive legend
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    return this.createInteractiveLegendDataPoints(0);
                }
                var legendData = this.data ? this.data.legendData : null;
                var legendDataPoints = legendData ? legendData.dataPoints : [];
                if (_.isEmpty(legendDataPoints))
                    return null;
                return legendData;
            };
            ColumnChart.prototype.hasLegend = function () {
                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
            };
            ColumnChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        if (!visuals.GradientUtils.hasGradientRole(this.dataViewCat))
                            this.enumerateDataPoints(enumeration);
                        break;
                    case 'labels':
                        this.enumerateDataLabels(enumeration);
                        break;
                }
            };
            ColumnChart.prototype.enumerateDataLabels = function (enumeration) {
                var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length, showLabelPerSeries = !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata);
                //Draw default settings
                visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries));
                if (seriesCount === 0)
                    return;
                //Draw series settings
                if (showLabelPerSeries && labelSettings.showLabelPerSeries) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i], labelSettings_1 = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;
                        enumeration.pushContainer({ displayName: series.displayName });
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_1, series));
                        enumeration.popContainer();
                    }
                }
            };
            ColumnChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, series, showAll) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: true,
                    displayUnits: !EnumExtensions.hasFlag(this.chartType, flagStacked100),
                    precision: true,
                    selector: series && series.identity ? series.identity.getSelector() : null,
                    showAll: showAll,
                    fontSize: true,
                };
            };
            ColumnChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var seriesCount = data.series.length;
                if (seriesCount === 0)
                    return;
                if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: series.displayName,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: { solid: { color: series.color } }
                            },
                        });
                    }
                }
                else {
                    // For single-category, single-measure column charts, the user can color the individual bars.
                    var singleSeriesData = data.series[0].data;
                    var categoryFormatter = data.categoryFormatter;
                    // Add default color and show all slices
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                        }
                    }).pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: !!data.showAllDataPoints
                        }
                    });
                    for (var i = 0; i < singleSeriesData.length; i++) {
                        var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                            selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                            properties: {
                                fill: { solid: { color: singleSeriesDataPoints.color } }
                            },
                        });
                    }
                }
            };
            ColumnChart.prototype.calculateAxesProperties = function (options) {
                var data = this.data;
                this.currentViewport = options.viewport;
                var margin = this.margin = options.margin;
                var origCatgSize = (data && data.categories) ? data.categories.length : 0;
                var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                    categoryCount: 0,
                    categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                    outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                    isScalar: false
                };
                this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null;
                if (data && !chartLayout.isScalar && !this.isScrollable && options.trimOrdinalDataOnOverflow) {
                    // trim data that doesn't fit on dashboard
                    var catgSize = Math.min(origCatgSize, chartLayout.categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = powerbi.Prototype.inherit(data);
                        data.series = ColumnChart.sliceSeries(data.series, catgSize);
                        data.categories = data.categories.slice(0, catgSize);
                    }
                }
                this.columnChart.setData(data);
                var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                var is100Pct = EnumExtensions.hasFlag(this.chartType, flagStacked100);
                var chartContext = {
                    height: preferredPlotArea.height,
                    width: preferredPlotArea.width,
                    duration: 0,
                    hostService: this.hostService,
                    mainGraphicsContext: this.mainGraphicsContext,
                    margin: this.margin,
                    layout: chartLayout,
                    animator: this.animator,
                    interactivityService: this.interactivityService,
                    viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                    viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                    is100Pct: is100Pct,
                    isComboChart: this.isComboChart,
                };
                this.ApplyInteractivity(chartContext);
                this.columnChart.setupVisualProps(chartContext);
                var ensureXDomain;
                var ensureYDomain;
                var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                if (isBarChart) {
                    var temp = options.forcedXDomain;
                    options.forcedXDomain = options.forcedYDomain;
                    options.forcedYDomain = temp;
                    // In the case of clustered and stacked bar charts, the y1 reference line is a vertical line
                    ensureXDomain = options.ensureYDomain;
                }
                else {
                    ensureYDomain = options.ensureYDomain;
                }
                this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType, isBarChart ? options.valueAxisDisplayUnits : options.categoryAxisDisplayUnits, isBarChart ? options.valueAxisPrecision : options.categoryAxisPrecision, ensureXDomain);
                this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType, isBarChart ? options.categoryAxisDisplayUnits : options.valueAxisDisplayUnits, isBarChart ? options.categoryAxisPrecision : options.valueAxisPrecision, ensureYDomain);
                if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {
                    this.xAxisProperties.axisLabel = data.axesLabels.x;
                }
                else {
                    this.xAxisProperties.axisLabel = null;
                }
                if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {
                    this.yAxisProperties.axisLabel = data.axesLabels.y;
                }
                else {
                    this.yAxisProperties.axisLabel = null;
                }
                return [this.xAxisProperties, this.yAxisProperties];
            };
            ColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                var plotArea = {
                    height: this.currentViewport.height - this.margin.top - this.margin.bottom,
                    width: this.currentViewport.width - this.margin.left - this.margin.right
                };
                if (this.isScrollable && !isScalar) {
                    var preferredCategorySpan = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                    if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                        plotArea.height = Math.max(preferredCategorySpan, plotArea.height);
                    }
                    else
                        plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                }
                return plotArea;
            };
            ColumnChart.prototype.ApplyInteractivity = function (chartContext) {
                var _this = this;
                var interactivity = this.interactivity;
                if (interactivity) {
                    if (interactivity.dragDataPoint) {
                        chartContext.onDragStart = function (datum) {
                            if (!datum.identity)
                                return;
                            _this.hostService.onDragStart({
                                event: d3.event,
                                data: {
                                    data: datum.identity.getSelector()
                                }
                            });
                        };
                    }
                    if (interactivity.isInteractiveLegend) {
                        var dragMove = function () {
                            var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself
                            var x = mousePoint[0];
                            var y = mousePoint[1];
                            var index = _this.columnChart.getClosestColumnIndex(x, y);
                            _this.selectColumn(index);
                        };
                        var ColumnChartSvg = ColumnChart.getInteractiveColumnChartDomElement(this.element);
                        //set click interaction on the visual
                        this.svg.on('click', dragMove);
                        //set click interaction on the background
                        d3.select(ColumnChartSvg)
                            .on('click', dragMove)
                            .style('touch-action', 'none');
                        var drag = d3.behavior.drag()
                            .origin(Object)
                            .on("drag", dragMove);
                        //set drag interaction on the visual
                        this.svg.call(drag);
                        //set drag interaction on the background
                        d3.select(ColumnChartSvg).call(drag);
                    }
                }
            };
            ColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {
                if (force === void 0) { force = false; }
                if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)
                    return; // same column, nothing to do here
                var legendData = this.createInteractiveLegendDataPoints(indexOfColumnSelected);
                var legendDataPoints = legendData.dataPoints;
                this.cartesianVisualHost.updateLegend(legendData);
                if (legendDataPoints.length > 0) {
                    this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
                }
                this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
            };
            ColumnChart.prototype.createInteractiveLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data || _.isEmpty(data.series))
                    return { dataPoints: [] };
                var formatStringProp = visuals.columnChartProps.general.formatString;
                var legendDataPoints = [];
                var category = data.categories && data.categories[columnIndex];
                var allSeries = data.series;
                var dataPoints = data.legendData && data.legendData.dataPoints;
                var converterStrategy = new ColumnChartConverterHelper(this.dataViewCat);
                for (var i = 0, len = allSeries.length; i < len; i++) {
                    var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);
                    var valueMetadata = data.valuesMetadata[i];
                    var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                    var dataPointColor = void 0;
                    if (allSeries.length === 1) {
                        var series = allSeries[0];
                        dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                    }
                    else {
                        dataPointColor = dataPoints.length > i && dataPoints[i].color;
                    }
                    legendDataPoints.push({
                        color: dataPointColor,
                        icon: visuals.LegendIcon.Box,
                        label: formattedLabel,
                        category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                        identity: visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return { dataPoints: legendDataPoints };
            };
            ColumnChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            ColumnChart.prototype.render = function (suppressAnimations) {
                var columnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);
                var data = this.data;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var width = viewport.width - (margin.left + margin.right);
                this.mainGraphicsContext
                    .attr('height', height)
                    .attr('width', width);
                if (this.tooltipsEnabled)
                    visuals.TooltipManager.addTooltip(columnChartDrawInfo.eventGroup, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                var allDataPoints = [];
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        allDataPoints = allDataPoints.concat(data.series[i].data);
                    }
                    behaviorOptions = {
                        datapoints: allDataPoints,
                        eventGroup: columnChartDrawInfo.eventGroup,
                        bars: columnChartDrawInfo.shapesSelection,
                        hasHighlights: data.hasHighlights,
                        mainGraphicsContext: this.mainGraphicsContext,
                        viewport: columnChartDrawInfo.viewport,
                        axisOptions: columnChartDrawInfo.axisOptions,
                        showLabel: data.labelSettings.show
                    };
                }
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    if (this.data.series.length > 0) {
                        this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(this.data.series), true); // start with the last column
                    }
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return { dataPoints: allDataPoints, behaviorOptions: behaviorOptions, labelDataPoints: columnChartDrawInfo.labelDataPoints, labelsAreNumeric: true };
            };
            ColumnChart.prototype.onClearSelection = function () {
                if (this.interactivityService) {
                    this.interactivityService.clearSelection();
                }
            };
            ColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return this.data ? this.data.scalarCategoryAxis : false;
            };
            ColumnChart.prototype.getSupportedCategoryAxisType = function () {
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
            };
            ColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = powerbi.Prototype.inherit(this.data);
                data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                this.columnChart.setData(data);
                return data;
            };
            ColumnChart.getLabelFill = function (labelColor, isInside, isCombo) {
                if (labelColor) {
                    return labelColor;
                }
                if (isInside && !isCombo) {
                    return visuals.NewDataLabelUtils.defaultInsideLabelColor;
                }
                return visuals.NewDataLabelUtils.defaultLabelColor;
            };
            ColumnChart.ColumnChartClassName = 'columnChart';
            ColumnChart.clusteredValidLabelPositions = [16 /* OutsideEnd */, 4 /* InsideEnd */, 1 /* InsideCenter */, 2 /* InsideBase */];
            ColumnChart.stackedValidLabelPositions = [1 /* InsideCenter */, 4 /* InsideEnd */, 2 /* InsideBase */];
            ColumnChart.SeriesClasses = jsCommon.CssConstants.createClassAndSelector('series');
            return ColumnChart;
        }());
        visuals.ColumnChart = ColumnChart;
        var ColumnChartConverterHelper = (function () {
            function ColumnChartConverterHelper(dataView) {
                this.dataView = dataView;
            }
            ColumnChartConverterHelper.prototype.getLegend = function (colors, defaultLegendLabelColor, defaultColor) {
                var legend = [];
                var seriesSources = [];
                var seriesObjects = [];
                var grouped = false;
                var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);
                var legendTitle = undefined;
                if (this.dataView && this.dataView.values) {
                    var allValues = this.dataView.values;
                    var valueGroups = allValues.grouped();
                    var hasDynamicSeries = !!(allValues && allValues.source);
                    var formatStringProp = visuals.columnChartProps.general.formatString;
                    for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
                        var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
                        for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
                            var series = values[valueIndex];
                            var source = series.source;
                            // Gradient measures do not create series.
                            if (DataRoleHelper.hasRole(source, 'Gradient') && !DataRoleHelper.hasRole(source, 'Y'))
                                continue;
                            seriesSources.push(source);
                            seriesObjects.push(series.objects);
                            var selectionId = series.identity ?
                                visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :
                                visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));
                            var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
                            var color = hasDynamicSeries
                                ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)
                                : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                            legend.push({
                                icon: visuals.LegendIcon.Box,
                                color: color,
                                label: label,
                                identity: selectionId,
                                selected: false,
                            });
                            if (series.identity && source.groupName !== undefined) {
                                grouped = true;
                            }
                        }
                    }
                    var dvValues = this.dataView.values;
                    legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                }
                var legendData = {
                    title: legendTitle,
                    dataPoints: legend,
                    grouped: grouped,
                    labelColor: defaultLegendLabelColor,
                };
                return {
                    legend: legendData,
                    seriesSources: seriesSources,
                    seriesObjects: seriesObjects,
                };
            };
            ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {
                return this.dataView.values[series].values[category];
            };
            ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {
                return this.dataView.values[index].source.queryName;
            };
            ColumnChartConverterHelper.prototype.hasHighlightValues = function (series) {
                var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
                return column && !!column.highlights;
            };
            ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {
                return this.dataView.values[series].highlights[category];
            };
            return ColumnChartConverterHelper;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var ClusteredColumnChartStrategy = (function () {
            function ClusteredColumnChartStrategy() {
            }
            ClusteredColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
                this.viewportWidth = columnChartProps.viewportWidth;
                this.isComboChart = columnChartProps.isComboChart;
            };
            ClusteredColumnChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            ClusteredColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain);
                // create clustered offset scale
                var seriesLength = this.data.series.length;
                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal()
                    .domain(this.data.series.map(function (s) { return s.index; }))
                    .rangeBands([0, seriesLength * columnWidth]);
                return props;
            };
            ClusteredColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
                var height = this.viewportHeight;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true) || visuals.emptyDomain;
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomain, ensureYDomain);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                this.yProps = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: this.data.valuesMetadata[0],
                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    shouldClamp: shouldClamp,
                });
                return this.yProps;
            };
            ClusteredColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data could not be null or undefined');
                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var clusteredColumnLayout = this.layout = ClusteredColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredColumnLayout,
                        itemCS: ClusteredColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredColumnLayout, ClusteredColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            ClusteredColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            /**
             * Get the chart's columns centers (x value).
             */
            ClusteredColumnChartStrategy.prototype.getColumnsCenters = function () {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var xScaleOffset_1 = 0;
                        if (!this.categoryLayout.isScalar)
                            xScaleOffset_1 = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_1; });
                    }
                }
                return this.columnsCenters;
            };
            ClusteredColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height,
                    });
                    handle.append('circle')
                        .attr({
                        cx: x,
                        cy: this.height,
                        r: '6px',
                    })
                        .classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ x1: x, x2: x });
                    handle.select('circle').attr({ cx: x });
                }
            };
            ClusteredColumnChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledY0 = yScale(0);
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0); },
                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value)); },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset; },
                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.originalValue), 0); },
                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.originalValue)); },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        y: function (d) { return scaledY0; },
                        height: function (d) { return 0; },
                    },
                };
            };
            ClusteredColumnChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {
                    var currentSeries = series_2[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        // Calculate label text
                        var formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: visuals.ColumnChart.clusteredValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            ClusteredColumnChartStrategy.classes = {
                item: {
                    class: 'column',
                    selector: '.column',
                },
            };
            return ClusteredColumnChartStrategy;
        }());
        visuals.ClusteredColumnChartStrategy = ClusteredColumnChartStrategy;
        var ClusteredBarChartStrategy = (function () {
            function ClusteredBarChartStrategy() {
            }
            ClusteredBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
                this.viewportWidth = barChartProps.viewportWidth;
                this.isComboChart = barChartProps.isComboChart;
            };
            ClusteredBarChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            ClusteredBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
                // create clustered offset scale
                var seriesLength = this.data.series.length;
                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal()
                    .domain(this.data.series.map(function (s) { return s.index; }))
                    .rangeBands([0, seriesLength * columnWidth]);
                return props;
            };
            ClusteredBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
                debug.assert(forcedTickCount === undefined, 'Cannot have clustered bar chart as combo chart.');
                var width = this.width;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true) || visuals.emptyDomain;
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomain, ensureXDomain);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                this.xProps = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedDomain,
                    metaDataColumn: this.data.valuesMetadata[0],
                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    shouldClamp: shouldClamp,
                });
                this.xProps.axis.tickSize(-this.viewportHeight, 0);
                return this.xProps;
            };
            ClusteredBarChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data could not be null or undefined');
                this.barsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var clusteredBarLayout = this.layout = ClusteredBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredBarLayout,
                        itemCS: ClusteredBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredBarLayout, ClusteredBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            ClusteredBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredBarChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            /**
             * Get the chart's columns centers (y value).
             */
            ClusteredBarChartStrategy.prototype.getBarsCenters = function () {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var yScaleOffset_1 = 0;
                        if (!this.categoryLayout.isScalar)
                            yScaleOffset_1 = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_1; });
                    }
                }
                return this.barsCenters;
            };
            ClusteredBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y,
                    });
                    handle.append('circle')
                        .attr({
                        cx: 0,
                        cy: y,
                        r: '6px',
                    })
                        .classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ y1: y, y2: y });
                    handle.select('circle').attr({ cy: y });
                }
            };
            ClusteredBarChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledX0 = xScale(0);
                var yScaleOffset = 0;
                if (isScalar)
                    yScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value)); },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)); },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.originalValue), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return 0; },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                    },
                };
            };
            ClusteredBarChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_3 = series; _i < series_3.length; _i++) {
                    var currentSeries = series_3[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((this.interactivityService && this.interactivityService.hasSelection() && !dataPoint.selected) || (data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate label text
                        var formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 3 /* HorizontalLeftBased */ : 4 /* HorizontalRightBased */,
                                validPositions: visuals.ColumnChart.clusteredValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            ClusteredBarChartStrategy.classes = {
                item: {
                    class: 'bar',
                    selector: '.bar'
                },
            };
            return ClusteredBarChartStrategy;
        }());
        visuals.ClusteredBarChartStrategy = ClusteredBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var StackedColumnChartStrategy = (function () {
            function StackedColumnChartStrategy() {
            }
            StackedColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
                this.viewportWidth = columnChartProps.viewportWidth;
                this.isComboChart = columnChartProps.isComboChart;
            };
            StackedColumnChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            StackedColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue);
                return props;
            };
            StackedColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, y1ReferenceLineValue) {
                var height = this.viewportHeight;
                var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
                var valueDomainArr = [valueDomain.min, valueDomain.max];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr, y1ReferenceLineValue);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
                var metadataColumn = this.data.valuesMetadata[0];
                var formatString = is100Pct ?
                    this.graphicsContext.hostService.getLocalizedString('Percentage')
                    : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                this.yProps = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: metadataColumn,
                    formatString: formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    is100Pct: is100Pct,
                    shouldClamp: shouldClamp,
                });
                return this.yProps;
            };
            StackedColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data should not be null or undefined');
                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var stackedColumnLayout = this.layout = StackedColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedColumnLayout,
                        itemCS: StackedColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width },
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedColumnLayout, StackedColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            StackedColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            /**
             * Get the chart's columns centers (x value).
             */
            StackedColumnChartStrategy.prototype.getColumnsCenters = function () {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var xScaleOffset_2 = 0;
                        if (!this.categoryLayout.isScalar)
                            xScaleOffset_2 = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_2; });
                    }
                }
                return this.columnsCenters;
            };
            StackedColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height,
                    });
                    handle.append('circle')
                        .attr({
                        cx: x,
                        cy: this.height,
                        r: '6px',
                    })
                        .classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ x1: x, x2: x });
                    handle.select('circle').attr({ cx: x });
                }
            };
            StackedColumnChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = columnWidth / 2;
                // d.position is the top left corner (for drawing) - set in columnChart.converter
                // for positive values, this is the previous stack position + the new value,
                // for negative values it is just the previous stack position
                return {
                    shapeLayout: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d) { return yScale(d.position); },
                        height: function (d) { return yScale(d.position - d.valueAbsolute) - yScale(d.position); },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d) { return yScale(d.originalPosition); },
                        height: function (d) { return yScale(d.originalPosition - d.originalValueAbsolute) - yScale(d.originalPosition); },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d) { return d.value >= 0 ? yScale(d.position - d.valueAbsolute) : yScale(d.position); },
                        height: function (d) { return 0; }
                    },
                };
            };
            StackedColumnChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_4 = series; _i < series_4.length; _i++) {
                    var currentSeries = series_4[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        // Calculate label text
                        var formatString = "";
                        if (this.graphicsContext.is100Pct) {
                            formatString = visuals.NewDataLabelUtils.hundredPercentFormat;
                        }
                        else {
                            formatString = dataPoint.labelFormatString;
                        }
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: visuals.ColumnChart.stackedValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            StackedColumnChartStrategy.classes = {
                item: {
                    class: 'column',
                    selector: '.column'
                },
                highlightItem: {
                    class: 'highlightColumn',
                    selector: '.highlightColumn'
                },
            };
            return StackedColumnChartStrategy;
        }());
        visuals.StackedColumnChartStrategy = StackedColumnChartStrategy;
        var StackedBarChartStrategy = (function () {
            function StackedBarChartStrategy() {
            }
            StackedBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
                this.viewportWidth = barChartProps.viewportWidth;
                this.isComboChart = barChartProps.isComboChart;
            };
            StackedBarChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            StackedBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
                return props;
            };
            StackedBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                debug.assert(forcedTickCount === undefined, 'Cannot have stacked bar chart as combo chart.');
                var width = this.width;
                var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
                var valueDomainArr = [valueDomain.min, valueDomain.max];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomainArr, ensureXDomain);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
                var metadataColumn = this.data.valuesMetadata[0];
                var formatString = is100Pct ?
                    this.graphicsContext.hostService.getLocalizedString('Percentage')
                    : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                this.xProps = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedDomain,
                    metaDataColumn: metadataColumn,
                    formatString: formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    is100Pct: is100Pct,
                    shouldClamp: shouldClamp,
                });
                this.xProps.axis.tickSize(-this.viewportHeight, 0);
                return this.xProps;
            };
            StackedBarChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data should not be null or undefined');
                this.barsCenters = null; // invalidate the barsCenters so that will be calculated again
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var stackedBarLayout = this.layout = StackedBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedBarLayout,
                        itemCS: StackedBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width },
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedBarLayout, StackedBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            StackedBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastInteractiveSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedBarChartStrategy.classes.item.selector, selectedColumnIndex, lastInteractiveSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            /**
             * Get the chart's columns centers (y value).
             */
            StackedBarChartStrategy.prototype.getBarsCenters = function () {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var yScaleOffset_2 = 0;
                        if (!this.categoryLayout.isScalar)
                            yScaleOffset_2 = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_2; });
                    }
                }
                return this.barsCenters;
            };
            StackedBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y
                    });
                    handle.append('circle')
                        .classed('drag-handle', true)
                        .attr({
                        cx: 0,
                        cy: y,
                        r: '6px',
                    });
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ y1: y, y2: y });
                    handle.select('circle').attr({ cy: y });
                }
            };
            StackedBarChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var yScaleOffset = 0;
                if (isScalar)
                    yScaleOffset = columnWidth / 2;
                // d.position is the top right corner for bars - set in columnChart.converter
                // for positive values, this is the previous stack position + the new value,
                // for negative values it is just the previous stack position
                return {
                    shapeLayout: {
                        width: function (d) { return xScale(d.position) - xScale(d.position - d.valueAbsolute); },
                        x: function (d) { return xScale(d.position - d.valueAbsolute); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return xScale(d.originalPosition) - xScale(d.originalPosition - d.originalValueAbsolute); },
                        x: function (d) { return xScale(d.originalPosition - d.originalValueAbsolute); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return 0; },
                        x: function (d) { return d.value >= 0 ? xScale(d.position - d.valueAbsolute) : xScale(d.position); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                };
            };
            StackedBarChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_5 = series; _i < series_5.length; _i++) {
                    var currentSeries = series_5[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((this.interactivityService && this.interactivityService.hasSelection() && !dataPoint.selected) || (data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate label text
                        var formatString = undefined;
                        if (this.graphicsContext.is100Pct) {
                            formatString = visuals.NewDataLabelUtils.hundredPercentFormat;
                        }
                        else {
                            formatString = dataPoint.labelFormatString;
                        }
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 3 /* HorizontalLeftBased */ : 4 /* HorizontalRightBased */,
                                validPositions: visuals.ColumnChart.stackedValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            StackedBarChartStrategy.classes = {
                item: {
                    class: 'bar',
                    selector: '.bar'
                },
                highlightItem: {
                    class: 'highlightBar',
                    selector: '.highlightBar'
                },
            };
            return StackedBarChartStrategy;
        }());
        visuals.StackedBarChartStrategy = StackedBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * This module only supplies the capabilities for comboCharts.
         * Implementation is in cartesianChart and the various ICartesianVisual implementations.
         */
        var ComboChart;
        (function (ComboChart) {
            ComboChart.capabilities = visuals.comboChartCapabilities;
            /**
             * Handles the case of a column layer in a combo chart. In this case, the column layer is enumearated last.
             */
            function enumerateDataPoints(enumeration, options, layers) {
                if (!layers)
                    return;
                var columnChartLayerIndex;
                var layersLength = layers.length;
                for (var layerIndex = 0; layerIndex < layersLength; layerIndex++) {
                    var layer = layers[layerIndex];
                    if (layer.enumerateObjectInstances) {
                        if (layer instanceof visuals.ColumnChart) {
                            columnChartLayerIndex = layerIndex;
                            continue;
                        }
                        layer.enumerateObjectInstances(enumeration, options);
                    }
                }
                if (columnChartLayerIndex !== undefined)
                    layers[columnChartLayerIndex].enumerateObjectInstances(enumeration, options);
            }
            ComboChart.enumerateDataPoints = enumerateDataPoints;
            function customizeQuery(options) {
                // If there is a dynamic series but no values on the column data view mapping, remove the dynamic series
                var columnMapping = !_.isEmpty(options.dataViewMappings) && options.dataViewMappings[0];
                if (columnMapping) {
                    var columnValuesMapping = columnMapping.categorical && columnMapping.categorical.values;
                    var seriesSelect = columnValuesMapping.group && !_.isEmpty(columnValuesMapping.group.select) && columnValuesMapping.group.select[0];
                    if (_.isEmpty(seriesSelect.for.in.items))
                        columnValuesMapping.group.by.items = undefined;
                }
                if (columnMapping && columnMapping.categorical) {
                    columnMapping.categorical.dataVolume = 4;
                }
                var lineMapping = options.dataViewMappings.length > 1 && options.dataViewMappings[1];
                if (lineMapping && lineMapping.categorical) {
                    lineMapping.categorical.dataVolume = 4;
                }
            }
            ComboChart.customizeQuery = customizeQuery;
            function getSortableRoles(options) {
                if (options && options.dataViewMappings.length > 0) {
                    var dataViewMapping = options.dataViewMappings[0];
                    //TODO: column chart should be sortable by X if it has scalar axis
                    // But currenly it doesn't support this. Return 'category' once
                    // it is supported.
                    if (!visuals.CartesianChart.detectScalarMapping(dataViewMapping))
                        return ['Category', 'Y', 'Y2'];
                }
                return null;
            }
            ComboChart.getSortableRoles = getSortableRoles;
            function isComboChart(chartType) {
                return chartType === 10 /* ComboChart */
                    || chartType === 13 /* LineClusteredColumnCombo */
                    || chartType === 14 /* LineStackedColumnCombo */
                    || chartType === 15 /* DataDotClusteredColumnCombo */
                    || chartType === 16 /* DataDotStackedColumnCombo */;
            }
            ComboChart.isComboChart = isComboChart;
        })(ComboChart = visuals.ComboChart || (visuals.ComboChart = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataColorPalette = (function () {
            /**
             * Creates a DataColorPalette using the given theme, or the default theme.
             */
            function DataColorPalette(colors, sentimentcolors) {
                // Hardcoded values for Color Picker.
                this.basePickerColors = [
                    { value: '#FFFFFF' },
                    { value: '#000000' },
                    { value: '#00B8AA' },
                    { value: '#374649' },
                    { value: '#FD625E' },
                    { value: '#F2C811' },
                    { value: '#5F6B6D' },
                    { value: '#8AD4EB' },
                    { value: '#FE9666' },
                    { value: '#A66999' }
                ];
                // TODO: Default theme is currently hardcoded. Theme should eventually come from PV and be added as a parameter in the ctor. 
                this.colors = colors || ThemeManager.getDefaultTheme();
                this.sentimentColors = sentimentcolors || ThemeManager.defaultSentimentColors;
                this.scales = {};
            }
            DataColorPalette.prototype.getColorScaleByKey = function (key) {
                var scale = this.scales[key];
                if (scale === undefined) {
                    scale = this.createScale();
                    this.scales[key] = scale;
                }
                return scale;
            };
            DataColorPalette.prototype.getNewColorScale = function () {
                return this.createScale();
            };
            DataColorPalette.prototype.getColorByIndex = function (index) {
                debug.assert(index >= 0 && index < this.colors.length, 'index is out of bounds');
                return this.colors[index];
            };
            DataColorPalette.prototype.getSentimentColors = function () {
                return this.sentimentColors;
            };
            DataColorPalette.prototype.getBasePickerColors = function () {
                return this.basePickerColors;
            };
            DataColorPalette.prototype.getAllColors = function () {
                return this.colors;
            };
            DataColorPalette.prototype.createScale = function () {
                return D3ColorScale.createFromColors(this.colors);
            };
            return DataColorPalette;
        }());
        visuals.DataColorPalette = DataColorPalette;
        var D3ColorScale = (function () {
            function D3ColorScale(scale) {
                this.scale = scale;
            }
            D3ColorScale.prototype.getColor = function (key) {
                return this.scale(key);
            };
            D3ColorScale.prototype.clearAndRotateScale = function () {
                var offset = this.scale.domain().length;
                var rotatedColors = ArrayExtensions.rotate(this.scale.range(), offset);
                this.scale = d3.scale.ordinal().range(rotatedColors);
            };
            D3ColorScale.prototype.clone = function () {
                return new D3ColorScale(this.scale.copy());
            };
            D3ColorScale.prototype.getDomain = function () {
                return this.scale.domain();
            };
            D3ColorScale.createFromColors = function (colors) {
                return new D3ColorScale(d3.scale.ordinal().range(colors));
            };
            return D3ColorScale;
        }());
        visuals.D3ColorScale = D3ColorScale;
        // TODO: When theming support is added, this should be changed into a fully fledged service. For now though we will
        var ThemeManager = (function () {
            function ThemeManager() {
            }
            ThemeManager.getDefaultTheme = function () {
                if (!ThemeManager.defaultTheme) {
                    // Extend the list of available colors by cycling the base colors
                    ThemeManager.defaultTheme = [];
                    var baseColors = ThemeManager.defaultBaseColors;
                    for (var i = 0; i < ThemeManager.colorSectorCount; ++i) {
                        for (var j = 0, jlen = baseColors.length; j < jlen; ++j) {
                            ThemeManager.defaultTheme.push({
                                value: jsCommon.Color.rotate(baseColors[j].value, i / ThemeManager.colorSectorCount)
                            });
                        }
                    }
                }
                return ThemeManager.defaultTheme;
            };
            ThemeManager.colorSectorCount = 12;
            // declare the Theme code as a private implementation detail inside the DataColorPalette so that the code stays hidden
            // until it's ready for wider use.
            ThemeManager.defaultBaseColors = [
                // First loop
                { value: '#01B8AA' },
                { value: '#374649' },
                { value: '#FD625E' },
                { value: '#F2C80F' },
                { value: '#5F6B6D' },
                { value: '#8AD4EB' },
                { value: '#FE9666' },
                { value: '#A66999' },
                { value: '#3599B8' },
                { value: '#DFBFBF' },
                // Second loop
                { value: '#4AC5BB' },
                { value: '#5F6B6D' },
                { value: '#FB8281' },
                { value: '#F4D25A' },
                { value: '#7F898A' },
                { value: '#A4DDEE' },
                { value: '#FDAB89' },
                { value: '#B687AC' },
                { value: '#28738A' },
                { value: '#A78F8F' },
                // Third loop
                { value: '#168980' },
                { value: '#293537' },
                { value: '#BB4A4A' },
                { value: '#B59525' },
                { value: '#475052' },
                { value: '#6A9FB0' },
                { value: '#BD7150' },
                { value: '#7B4F71' },
                { value: '#1B4D5C' },
                { value: '#706060' },
                // Fourth loop
                { value: '#0F5C55' },
                { value: '#1C2325' },
                { value: '#7D3231' },
                { value: '#796419' },
                { value: '#303637' },
                { value: '#476A75' },
                { value: '#7E4B36' },
                { value: '#52354C' },
                { value: '#0D262E' },
                { value: '#544848' },
            ];
            ThemeManager.defaultSentimentColors = [
                { value: '#C0433A' },
                { value: '#E8D62E' },
                { value: '#79C75B' },
            ];
            return ThemeManager;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/**
 * IMPORTANT: This chart is not currently enabled in the PBI system and is under development.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * The data dot chart shows a set of circles with the data value inside them.
         * The circles are regularly spaced similar to column charts.
         * The radius of all dots is the same across the chart.
         * This is most often combined with a column chart to create the 'chicken pox' chart.
         * If any of the data values do not fit within the circles, then the data values are hidden
         * and the y axis for the dots is displayed instead.
         * This chart only supports a single series of data.
         * This chart does not display a legend.
         */
        var DataDotChart = (function () {
            function DataDotChart(options) {
                this.isScrollable = options.isScrollable;
                this.interactivityService = options.interactivityService;
            }
            DataDotChart.prototype.init = function (options) {
                this.options = options;
                // Common properties
                this.svg = options.svg;
                this.svg.classed(DataDotChart.ClassName, true);
                this.mainGraphicsG = this.svg.append('g')
                    .classed('dataDotChartMainGraphicsContext', true);
                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.cartesianVisualHost = options.cartesianHost;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                // Interactivity properties
                this.interactivity = options.interactivity;
                this.element = options.element;
            };
            DataDotChart.prototype.setData = function (dataViews) {
                this.data = {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false,
                };
                if (dataViews.length > 0) {
                    // I only handle a single data view
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCategorical = this.dataViewCategorical = dataView.categorical;
                        var dvCategories = dataViewCategorical.categories;
                        // I default to text unless there is a category type
                        var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                        if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                            categoryType = dvCategories[0].source.type;
                        this.data = DataDotChart.converter(dataView, visuals.valueFormatter.format(null), this.interactivityService);
                    }
                }
            };
            DataDotChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                if (data && data.series && data.series.data)
                    data.series = { data: data.series.data.slice(startIndex, endIndex), xCol: data.series.xCol, yCol: data.series.yCol };
                return data;
            };
            DataDotChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                this.currentViewport = options.viewport;
                this.margin = options.margin;
                var data = this.clippedData = this.data;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var series = data ? data.series : null;
                var seriesArray = series && series.data && series.data.length > 0 ? [series] : [];
                var categoryCount = series && series.data ? series.data.length : 0;
                // If there are highlights, then the series is 2x in length and highlights are interwoven.
                if (data.hasHighlights) {
                    categoryCount = categoryCount / 2;
                }
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (DataDotChart.hasDataPoint(series)) {
                    xMetaDataColumn = series.xCol;
                    yMetaDataColumn = series.yCol;
                }
                var layout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
                var outerPadding = layout.categoryThickness * visuals.CartesianChart.OuterPaddingRatio;
                // clip data that won't fit
                if (!this.isScrollable) {
                    this.clippedData = DataDotChart.createClippedDataIfOverflowed(data, layout.categoryCount);
                }
                var yDomain = visuals.AxisHelper.createValueDomain(seriesArray, /*includeZero:*/ true) || visuals.emptyDomain;
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, yDomain, options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, DataDotChart.formatStringProp),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false
                });
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
                var xDomain = visuals.AxisHelper.createDomain(seriesArray, axisType, /*isScalar:*/ false, options.forcedXDomain, options.ensureXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, DataDotChart.formatStringProp),
                    outerPadding: outerPadding,
                    isScalar: false,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    categoryThickness: layout.categoryThickness,
                    getValueFn: function (index, type) { return _this.lookupXValue(index, type); },
                    isCategoryAxis: true
                });
                return [this.xAxisProperties, this.yAxisProperties];
            };
            DataDotChart.createClippedDataIfOverflowed = function (data, categoryCount) {
                // If there are highlights, then the series is 2x in length and highlights are interwoven.
                var requiredLength = data.hasHighlights ? Math.min(data.series.data.length, categoryCount * 2) : Math.min(data.series.data.length, categoryCount);
                if (requiredLength >= data.series.data.length) {
                    return data;
                }
                var clipped = powerbi.Prototype.inherit(data);
                clipped.series = powerbi.Prototype.inherit(data.series); // This prevents clipped and data from sharing the series object
                clipped.series.data = clipped.series.data.slice(0, requiredLength);
                return clipped;
            };
            DataDotChart.hasDataPoint = function (series) {
                return (series && series.data && series.data.length > 0);
            };
            DataDotChart.prototype.lookupXValue = function (index, type) {
                var data = this.data;
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime)
                    return new Date(index);
                if (data && data.series) {
                    var seriesData = data.series.data;
                    if (seriesData) {
                        var dataAtIndex = seriesData[index];
                        if (dataAtIndex) {
                            return dataAtIndex.categoryValue;
                        }
                    }
                }
                return index;
            };
            DataDotChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            DataDotChart.prototype.render = function (suppressAnimations) {
                var _this = this;
                if (!this.clippedData)
                    return;
                var data = this.clippedData;
                var dataPoints = data.series.data;
                var hasHighlights = data.hasHighlights;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var dotWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var dotRadius = dotWidth / 2;
                var dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey);
                var hasSelection = this.interactivityService ? this.interactivityService.hasSelection() : false;
                this.mainGraphicsContext.attr('width', width)
                    .attr('height', height);
                var dots = this.mainGraphicsContext.selectAll(DataDotChart.DotClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
                dots.enter()
                    .append('circle')
                    .classed(DataDotChart.DotClassName, true);
                dots
                    .style({ 'fill': dotColor.value })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); })
                    .classed('null-value', function (d) { return d.value === null; })
                    .attr({
                    r: function (d) { return dotRadius; },
                    cx: function (d) { return xScale(d.categoryIndex) + dotRadius; },
                    cy: function (d) { return yScale(d.value); }
                });
                dots.exit().remove();
                var dotLabels = this.mainGraphicsContext.selectAll(DataDotChart.DotLabelClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
                dotLabels.enter()
                    .append('text')
                    .classed(DataDotChart.DotLabelClassName, true)
                    .attr({
                    'text-anchor': DataDotChart.DotLabelTextAnchor,
                    dy: DataDotChart.DotLabelVerticalOffset
                });
                dotLabels
                    .classed('null-value', function (d) { return d.value === null; })
                    .classed('overflowed', false)
                    .attr({
                    x: function (d) { return xScale(d.categoryIndex) + dotRadius; },
                    y: function (d) { return yScale(d.value); }
                })
                    .text(function (d) { return _this.yAxisProperties.formatter.format(d.value); });
                var overflowed = false;
                dotLabels
                    .each(function () {
                    // jQuery fails to properly inspect SVG class elements, the $('<div>') notation works around it.
                    if (!overflowed && !$("<div>").addClass($(this).attr("class")).hasClass("null-value")) {
                        var width_1 = powerbi.TextMeasurementService.measureSvgTextElementWidth(this);
                        if (width_1 > dotWidth) {
                            dotLabels.classed('overflowed', true);
                            overflowed = true;
                        }
                    }
                });
                dotLabels.exit().remove();
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    behaviorOptions = {
                        dots: dots,
                        dotLabels: dotLabels,
                        datapoints: dataPoints
                    };
                }
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return { dataPoints: dataPoints, behaviorOptions: behaviorOptions, labelDataPoints: [], labelsAreNumeric: true };
            };
            DataDotChart.prototype.calculateLegend = function () {
                return this.createLegendDataPoints(0); // start with index 0
            };
            DataDotChart.prototype.hasLegend = function () {
                return this.data && this.data.hasDynamicSeries;
            };
            DataDotChart.prototype.createLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data)
                    return null;
                var series = data.series;
                var seriesData = series.data;
                var legendDataPoints = [];
                var category;
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
                // Category will be the same for all series. This is an optimization.
                if (data.series && data.series.data) {
                    var firstDataPoint = data.series.data[0];
                    category = firstDataPoint && this.lookupXValue(firstDataPoint.categoryValue, axisType);
                }
                // Create a legend data point for the specified column                
                if (series.yCol) {
                    var formatStringProp = DataDotChart.formatStringProp;
                    var lineDataPoint = seriesData[columnIndex];
                    var measure = lineDataPoint && lineDataPoint.value;
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCategorical.values, formatStringProp);
                    var dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey);
                    var dataViewCategoricalValues = this.dataViewCategorical.values;
                    var identity = dataViewCategoricalValues && dataViewCategoricalValues.length > columnIndex ?
                        visuals.SelectionId.createWithIdAndMeasure(dataViewCategoricalValues[columnIndex].identity, dataViewCategoricalValues[columnIndex].source.queryName) :
                        visuals.SelectionId.createWithMeasure(dataViewCategoricalValues.source.queryName);
                    legendDataPoints.push({
                        color: dotColor.value,
                        icon: visuals.LegendIcon.Line,
                        label: label,
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: identity,
                        selected: false
                    });
                }
                return { dataPoints: legendDataPoints };
            };
            DataDotChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
                // cartesianChart handles calling render again.
            };
            DataDotChart.converter = function (dataView, blankCategoryValue, interactivityService) {
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0
                    ? categorical.categories[0]
                    : {
                        source: undefined,
                        values: [blankCategoryValue],
                        identity: undefined
                    };
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                // I only handle a single series
                if (!_.isEmpty(categorical.values)) {
                    var measure = categorical.values[0];
                    var hasHighlights = !!measure.highlights;
                    var dataPoints = [];
                    for (var categoryIndex = 0, len = measure.values.length; categoryIndex < len; categoryIndex++) {
                        debug.assert(!category.identity || categoryIndex < category.identity.length, 'Category identities is smaller than category values.');
                        // I create the identity from the category.  If there is no category, then I use the measure name to create identity
                        var identity = category.identity ?
                            visuals.SelectionId.createWithIdAndMeasure(category.identity[categoryIndex], measure.source.queryName) :
                            visuals.SelectionId.createWithMeasure(measure.source.queryName);
                        var categoryValue = categoryValues[categoryIndex];
                        // ignore variant measures
                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
                            continue;
                        dataPoints.push({
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: measure.values[categoryIndex],
                            categoryIndex: categoryIndex,
                            seriesIndex: 0,
                            selected: false,
                            identity: identity,
                            highlight: false
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlightValue = measure.highlights[categoryIndex];
                            dataPoints.push({
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: highlightValue,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: false,
                                identity: highlightIdentity,
                                highlight: true
                            });
                        }
                    }
                    if (interactivityService)
                        interactivityService.applySelectionStateToData(dataPoints);
                    return {
                        series: {
                            xCol: category.source,
                            yCol: measure.source,
                            data: dataPoints
                        },
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: true,
                    };
                }
                return {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false,
                };
            };
            DataDotChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            DataDotChart.ClassName = 'dataDotChart';
            DataDotChart.DotClassName = 'dot';
            DataDotChart.DotClassSelector = '.dot';
            DataDotChart.DotColorKey = 'dataDot';
            DataDotChart.DotLabelClassName = 'label';
            DataDotChart.DotLabelClassSelector = '.label';
            DataDotChart.DotLabelVerticalOffset = '0.4em';
            DataDotChart.DotLabelTextAnchor = 'middle';
            return DataDotChart;
        }());
        visuals.DataDotChart = DataDotChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        /**
         * Renders a funnel chart.
         */
        var FunnelChart = (function () {
            function FunnelChart(options) {
                this.labelPositionObjects = [visuals.labelPosition.outsideEnd, visuals.labelPosition.insideCenter];
                if (options) {
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    if (options.funnelSmallViewPortProperties) {
                        this.funnelSmallViewPortProperties = options.funnelSmallViewPortProperties;
                    }
                    if (options.animator) {
                        this.animator = options.animator;
                    }
                    if (options.behavior) {
                        this.behavior = options.behavior;
                    }
                }
            }
            FunnelChart.isValidValueColumn = function (valueColumn) {
                debug.assertValue(valueColumn, 'valueColumn');
                return DataRoleHelper.hasRole(valueColumn.source, 'Y');
            };
            FunnelChart.getFirstValidValueColumn = function (values) {
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var valueColumn = values_1[_i];
                    if (!FunnelChart.isValidValueColumn(valueColumn))
                        continue;
                    return valueColumn;
                }
                return undefined;
            };
            FunnelChart.converter = function (dataView, colors, hostServices, defaultDataPointColor, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var slices = [];
                var formatStringProp = visuals.funnelChartProps.general.formatString;
                var categorical = dataView.categorical;
                var categories = categorical.categories || [];
                var values = categorical.values;
                var valueMetaData = [];
                if (values) {
                    valueMetaData = _.map(values, function (v) { return v.source; });
                }
                var hasHighlights = values && values.length > 0 && values[0] && !!values[0].highlights;
                var highlightsOverflow = false;
                var hasNegativeValues = false;
                var allValuesAreNegative = false;
                var categoryLabels = [];
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultFunnelLabelSettings();
                var percentBarLabelSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true);
                var colorHelper = new visuals.ColorHelper(colors, visuals.funnelChartProps.dataPoint.fill, defaultDataPointColor);
                var firstValue;
                var firstHighlight;
                var previousValue;
                var previousHighlight;
                var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(categorical);
                var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(categorical);
                var defaultSeriesIndex = 0;
                var seriesIndexGradientAddedFirst = 1;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects['labels'];
                    if (labelsObj)
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    var percentLabelsObj = dataView.metadata.objects['percentBarLabel'];
                    if (percentLabelsObj)
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(percentLabelsObj, percentBarLabelSettings);
                }
                // Always take the first valid value field
                var firstValueColumn = !_.isEmpty(values) && FunnelChart.getFirstValidValueColumn(values);
                // If we don't have a valid value column, just return
                if (!firstValueColumn)
                    return {
                        slices: slices,
                        categoryLabels: categoryLabels,
                        valuesMetadata: valueMetaData,
                        hasHighlights: hasHighlights,
                        highlightsOverflow: highlightsOverflow,
                        canShowDataLabels: true,
                        dataLabelsSettings: dataLabelsSettings,
                        hasNegativeValues: hasNegativeValues,
                        allValuesAreNegative: allValuesAreNegative,
                        percentBarLabelSettings: percentBarLabelSettings,
                    };
                //If Color saturation added before Values
                var seriesIndex = gradientMeasureIndex === defaultSeriesIndex ? seriesIndexGradientAddedFirst : defaultSeriesIndex;
                // Calculate the first value for percent tooltip values
                firstValue = firstValueColumn.values[0];
                if (hasHighlights) {
                    firstHighlight = firstValueColumn.highlights[0];
                }
                if (categories.length === 1) {
                    // Single Category, Value and (optional) Gradient
                    var category = categories[0];
                    var categoryValues = category.values;
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp);
                    for (var i = 0, ilen = categoryValues.length; i < ilen; i++) {
                        var measureName = firstValueColumn.source.queryName;
                        var identity = visuals.SelectionIdBuilder.builder()
                            .withCategory(category, i)
                            .withMeasure(measureName)
                            .createSelectionId();
                        var value = firstValueColumn.values[i];
                        var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString);
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null, gradientValueColumn);
                            if (hasHighlights) {
                                var highlight = firstValueColumn.highlights[i];
                                if (highlight !== 0) {
                                    tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlight, gradientValueColumn);
                                }
                            }
                            FunnelChart.addFunnelPercentsToTooltip(tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
                        }
                        // Same color for all bars
                        var color = colorHelper.getColorForMeasure(category.objects && category.objects[i], '');
                        slices.push({
                            label: formattedCategoryValue,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.labelColor,
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = firstValueColumn.highlights[i];
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo_2 = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo_2 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue, gradientValueColumn);
                                FunnelChart.addFunnelPercentsToTooltip(tooltipInfo_2, hostServices, firstHighlight ? highlight / firstHighlight : null, previousHighlight ? highlight / previousHighlight : null, true);
                            }
                            slices.push({
                                label: formattedCategoryValue,
                                value: value,
                                originalValue: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                selected: false,
                                key: highlightIdentity.getKey(),
                                highlight: true,
                                highlightValue: highlight,
                                originalHighlightValue: highlight,
                                tooltipInfo: tooltipInfo_2,
                                color: color,
                            });
                            previousHighlight = highlight;
                        }
                        previousValue = value;
                    }
                }
                else if (valueMetaData.length > 0 && values && values.length > 0) {
                    // Multi-measures
                    for (var i = 0, len = values.length; i < len; i++) {
                        var valueColumn = values[i];
                        if (!FunnelChart.isValidValueColumn(valueColumn))
                            continue;
                        var value = valueColumn.values[0];
                        var identity = visuals.SelectionId.createWithMeasure(valueColumn.source.queryName);
                        var categoryValue = valueMetaData[i].displayName;
                        var valueIndex = categorical.categories ? null : i;
                        var tooltipInfo = void 0;
                        // Same color for all bars
                        var color = colorHelper.getColorForMeasure(valueColumn.source.objects, '');
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, valueIndex, i);
                            if (hasHighlights) {
                                var highlight = valueColumn.highlights[0];
                                if (highlight !== 0) {
                                    tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, 0, i, highlight);
                                }
                            }
                            FunnelChart.addFunnelPercentsToTooltip(tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
                        }
                        slices.push({
                            label: valueMetaData[i].displayName,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.labelColor,
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = valueColumn.highlights[0];
                            if (highlight > value) {
                                highlightsOverflow = true;
                            }
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo_3 = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo_3 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, 0, i, highlightedValue);
                                FunnelChart.addFunnelPercentsToTooltip(tooltipInfo_3, hostServices, firstHighlight ? highlight / firstHighlight : null, previousHighlight ? highlight / previousHighlight : null, true);
                            }
                            slices.push({
                                label: valueMetaData[i].displayName,
                                value: value,
                                originalValue: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                selected: false,
                                highlight: true,
                                originalHighlightValue: highlight,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo_3,
                                color: color,
                            });
                            previousHighlight = highlight;
                        }
                        previousValue = value;
                    }
                }
                for (var i = 0; i < slices.length; i += hasHighlights ? 2 : 1) {
                    var slice = slices[i];
                    categoryLabels.push(slice.label);
                }
                // Calculate negative value warning flags
                allValuesAreNegative = slices.length > 0 && _.every(slices, function (slice) { return (slice.highlight ? slice.highlightValue <= 0 : true) && slice.value < 0; });
                for (var _i = 0, slices_1 = slices; _i < slices_1.length; _i++) {
                    var slice = slices_1[_i];
                    if (allValuesAreNegative) {
                        slice.value = Math.abs(slice.value);
                        if (slice.highlight)
                            slice.highlightValue = Math.abs(slice.highlightValue);
                    }
                    else {
                        var value = slice.value;
                        var isValueNegative = value < 0;
                        if (isValueNegative)
                            slice.value = 0;
                        var isHighlightValueNegative = false;
                        if (slice.highlight) {
                            var highlightValue = slice.highlightValue;
                            isHighlightValueNegative = highlightValue < 0;
                            slice.highlightValue = isHighlightValueNegative ? 0 : highlightValue;
                        }
                        if (!hasNegativeValues)
                            hasNegativeValues = isValueNegative || isHighlightValueNegative;
                    }
                    if (slice.highlightValue > slice.value) {
                        highlightsOverflow = true;
                    }
                }
                return {
                    slices: slices,
                    categoryLabels: categoryLabels,
                    valuesMetadata: valueMetaData,
                    hasHighlights: hasHighlights,
                    highlightsOverflow: highlightsOverflow,
                    canShowDataLabels: true,
                    dataLabelsSettings: dataLabelsSettings,
                    hasNegativeValues: hasNegativeValues,
                    allValuesAreNegative: allValuesAreNegative,
                    percentBarLabelSettings: percentBarLabelSettings,
                };
            };
            FunnelChart.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'dataPoint':
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        if (!hasGradientRole) {
                            this.enumerateDataPoints(enumeration);
                        }
                        break;
                    case 'labels':
                        var labelSettingsOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.dataLabelsSettings, true, this.labelPositionObjects);
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingsOptions);
                        break;
                    case 'percentBarLabel':
                        var percentLabelSettingOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.percentBarLabelSettings, false);
                        visuals.dataLabelUtils.enumerateDataLabels(percentLabelSettingOptions);
                        break;
                }
                return enumeration.complete();
            };
            FunnelChart.getLabelSettingsOptions = function (enumeration, labelSettings, isDataLabels, positionObject) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: true,
                    displayUnits: isDataLabels,
                    precision: isDataLabels,
                    position: isDataLabels,
                    positionObject: positionObject,
                    fontSize: true,
                };
            };
            FunnelChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var slices = data.slices;
                enumeration.pushInstance({
                    objectName: 'dataPoint',
                    selector: null,
                    properties: {
                        defaultColor: { solid: { color: this.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                    },
                });
                for (var i = 0; i < slices.length; i++) {
                    var slice = slices[i];
                    if (slice.highlight)
                        continue;
                    var color = slice.color;
                    var selector = slice.identity.getSelector();
                    var isSingleSeries = !!selector.data;
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        displayName: slice.label,
                        selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
                        properties: {
                            fill: { solid: { color: color } }
                        },
                    });
                }
            };
            FunnelChart.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                var svg = this.svg = d3.select(element.get(0))
                    .append('svg')
                    .classed(FunnelChart.VisualClassName, true);
                if (this.behavior)
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.currentViewport = options.viewport;
                this.margin = {
                    left: 5,
                    right: 5,
                    top: 0,
                    bottom: 0
                };
                var style = options.style;
                this.colors = style.colorPalette.dataColors;
                this.hostServices = options.host;
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
                }
                this.percentGraphicsContext = svg.append('g').classed(FunnelChart.Selectors.percentBar.root.class, true);
                this.funnelGraphicsContext = svg.append('g');
                this.axisGraphicsContext = svg.append('g');
                this.updateViewportProperties();
            };
            FunnelChart.prototype.updateViewportProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width)
                    .attr('height', viewport.height);
            };
            FunnelChart.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.data = {
                    slices: [],
                    categoryLabels: [],
                    valuesMetadata: [],
                    hasHighlights: false,
                    highlightsOverflow: false,
                    canShowDataLabels: true,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
                    hasNegativeValues: false,
                    allValuesAreNegative: false,
                    percentBarLabelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true),
                };
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (dataViews && dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var defaultColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, visuals.funnelChartProps.dataPoint.defaultColor);
                        if (defaultColor)
                            this.defaultDataPointColor = defaultColor;
                    }
                    if (dataView.categorical) {
                        this.data = FunnelChart.converter(dataView, this.colors, this.hostServices, this.defaultDataPointColor, this.tooltipsEnabled);
                        if (this.interactivityService) {
                            this.interactivityService.applySelectionStateToData(this.data.slices);
                        }
                    }
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    if (this.data.allValuesAreNegative) {
                        warnings.unshift(new visuals.AllNegativeValuesWarning());
                    }
                    else if (this.data.hasNegativeValues) {
                        warnings.unshift(new visuals.NegativeValuesNotSupportedWarning());
                    }
                    this.hostServices.setWarnings(warnings);
                }
                this.updateViewportProperties();
                this.updateInternal(options.suppressAnimations);
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            FunnelChart.prototype.onDataChanged = function (options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            FunnelChart.prototype.onResizing = function (viewport) {
                this.currentViewport = viewport;
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: this.currentViewport
                });
            };
            FunnelChart.prototype.getMaxLabelLength = function (labels, properties) {
                var max = 0;
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                for (var i = 0, len = labels.length; i < len; i++) {
                    properties.text = labels[i];
                    max = Math.max(max, textMeasurer(properties));
                }
                return max + FunnelChart.LabelFunnelPadding;
            };
            FunnelChart.prototype.updateInternal = function (suppressAnimations) {
                if (this.data == null)
                    return;
                var data = this.data;
                var slices = data.slices;
                var slicesWithoutHighlights = slices.filter(function (d) { return !d.highlight; });
                var isHidingPercentBars = this.isHidingPercentBars();
                var axisOptions = this.setUpAxis();
                var margin = axisOptions.margin;
                var verticalRange = axisOptions.verticalRange;
                var funnelContext = this.funnelGraphicsContext.attr('transform', visuals.SVGUtil.translateAndRotate(margin.left, margin.top, verticalRange / 2, verticalRange / 2, 90));
                this.percentGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.svg.style('font-family', visuals.dataLabelUtils.StandardFontFamily);
                var layout = FunnelChart.getLayout(data, axisOptions);
                var labelLayout = visuals.dataLabelUtils.getFunnelChartLabelLayout(data, axisOptions, FunnelChart.InnerTextMinimumPadding, data.dataLabelsSettings, this.currentViewport);
                var result;
                var shapes;
                var dataLabels;
                if (this.animator && !suppressAnimations) {
                    var animationOptions = {
                        viewModel: data,
                        interactivityService: this.interactivityService,
                        layout: layout,
                        axisGraphicsContext: this.axisGraphicsContext,
                        shapeGraphicsContext: funnelContext,
                        percentGraphicsContext: this.percentGraphicsContext,
                        labelGraphicsContext: this.svg,
                        axisOptions: axisOptions,
                        slicesWithoutHighlights: slicesWithoutHighlights,
                        labelLayout: labelLayout,
                        isHidingPercentBars: isHidingPercentBars,
                        visualInitOptions: this.options,
                    };
                    result = this.animator.animate(animationOptions);
                    shapes = result.shapes;
                    dataLabels = result.dataLabels;
                }
                if (!this.animator || suppressAnimations || result.failed) {
                    FunnelChart.drawDefaultAxis(this.axisGraphicsContext, axisOptions, isHidingPercentBars);
                    shapes = FunnelChart.drawDefaultShapes(data, slices, funnelContext, layout, this.interactivityService && this.interactivityService.hasSelection());
                    FunnelChart.drawPercentBars(data, this.percentGraphicsContext, layout, isHidingPercentBars);
                    if (data.dataLabelsSettings.show && data.canShowDataLabels) {
                        dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(data.slices, this.svg, labelLayout);
                    }
                    else {
                        visuals.dataLabelUtils.cleanDataLabels(this.svg);
                    }
                }
                if (this.interactivityService) {
                    var interactors = FunnelChart.drawInteractorShapes(slices, funnelContext, layout);
                    var behaviorOptions = {
                        bars: shapes,
                        interactors: interactors,
                        clearCatcher: this.clearCatcher,
                        hasHighlights: data.hasHighlights,
                    };
                    this.interactivityService.bind(slices, this.behavior, behaviorOptions);
                    if (this.tooltipsEnabled) {
                        visuals.TooltipManager.addTooltip(interactors, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    }
                }
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            FunnelChart.prototype.getUsableVerticalSpace = function () {
                var categoryLabels = this.data.categoryLabels;
                var margin = this.margin;
                var verticalSpace = this.currentViewport.height - (margin.top + margin.bottom);
                return verticalSpace - (FunnelChart.MinBarThickness * categoryLabels.length);
            };
            FunnelChart.prototype.isHidingPercentBars = function () {
                var data = this.data;
                if (data.percentBarLabelSettings.show) {
                    var percentBarTextHeight = this.getPercentBarTextHeight();
                    var verticalSpace = this.getUsableVerticalSpace() - (2 * FunnelChart.MinBarThickness * FunnelChart.PercentBarToBarRatio) - (2 * percentBarTextHeight);
                    return verticalSpace <= 0;
                }
                return true;
            };
            FunnelChart.prototype.isSparklines = function () {
                return this.getUsableVerticalSpace() <= 0;
            };
            FunnelChart.prototype.setUpAxis = function () {
                var data = this.data;
                var slices = data.slices;
                var categoryLabels = data.categoryLabels;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var isSparklines = this.isSparklines();
                var isHidingPercentBars = this.isHidingPercentBars();
                var percentBarTextHeight = isHidingPercentBars ? 0 : this.getPercentBarTextHeight();
                var horizontalRange = viewport.height - (margin.top + margin.bottom) - (2 * percentBarTextHeight);
                var maxMarginFactor = FunnelChart.MaxMarginFactor;
                if (categoryLabels.length > 0 && isSparklines) {
                    categoryLabels = [];
                    data.canShowDataLabels = false;
                }
                else if (this.showCategoryLabels()) {
                    var textProperties = FunnelChart.getTextProperties();
                    // Get the amount of space needed for the labels, then add the minimum level of padding for the axis.
                    var longestLabelLength = this.getMaxLabelLength(categoryLabels, textProperties);
                    var maxLabelLength = viewport.width * maxMarginFactor;
                    var labelLength = Math.min(longestLabelLength, maxLabelLength);
                    margin.left = labelLength + FunnelChart.YAxisPadding;
                }
                else {
                    categoryLabels = [];
                }
                var verticalRange = viewport.width - (margin.left + margin.right);
                var barToSpaceRatio = FunnelChart.BarToSpaceRatio;
                var maxScore = d3.max(slices.map(function (d) { return d.value; }));
                var minScore = 0;
                var rangeStart = 0;
                var rangeEnd = horizontalRange;
                var delta;
                if (isHidingPercentBars)
                    delta = horizontalRange - (categoryLabels.length * FunnelChart.MaxBarWidth);
                else
                    delta = horizontalRange - (categoryLabels.length * FunnelChart.MaxBarWidth) - (2 * FunnelChart.MaxBarWidth * FunnelChart.PercentBarToBarRatio);
                if (categoryLabels.length > 0 && delta > 0) {
                    rangeStart = Math.ceil(delta / 2);
                    rangeEnd = Math.ceil(horizontalRange - delta / 2);
                }
                // Offset funnel axis start and end by percent bar text height
                if (!isHidingPercentBars) {
                    rangeStart += percentBarTextHeight;
                    rangeEnd += percentBarTextHeight;
                }
                var yScale = d3.scale.linear()
                    .domain([minScore, maxScore])
                    .range([verticalRange, 0]);
                var xScale = d3.scale.ordinal()
                    .domain(d3.range(0, data.categoryLabels.length))
                    .rangeBands([rangeStart, rangeEnd], barToSpaceRatio, isHidingPercentBars ? barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
                return {
                    margin: margin,
                    xScale: xScale,
                    yScale: yScale,
                    maxScore: maxScore,
                    verticalRange: verticalRange,
                    rangeStart: rangeStart,
                    rangeEnd: rangeEnd,
                    barToSpaceRatio: barToSpaceRatio,
                    categoryLabels: categoryLabels,
                };
            };
            FunnelChart.prototype.getPercentBarTextHeight = function () {
                var percentBarTextProperties = FunnelChart.getTextProperties(this.data.percentBarLabelSettings.fontSize);
                return powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties);
            };
            FunnelChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            FunnelChart.getLayout = function (data, axisOptions) {
                var highlightsOverflow = data.highlightsOverflow;
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var maxScore = axisOptions.maxScore;
                var columnWidth = xScale.rangeBand();
                var halfColumnWidth = Math.ceil(columnWidth / 2);
                var percentBarTickHeight = halfColumnWidth;
                var overFlowHighlightColumnWidth = columnWidth * FunnelChart.OverflowingHighlightWidthRatio;
                var overFlowHighlightOffset = overFlowHighlightColumnWidth / 2;
                var lastCategoryIndex = axisOptions.categoryLabels.length - 1;
                var horizontalDistance = Math.abs(yScale(maxScore) - yScale(0));
                var emptyHorizontalSpace = function (value) { return (horizontalDistance - Math.abs(yScale(value) - yScale(0))) / 2; };
                var getMinimumShapeSize = function (value) { return Math.max(FunnelChart.MinimumInteractorSize, Math.abs(yScale(value) - yScale(0))); };
                var percentBarFontSize = PixelConverter.fromPoint(data.percentBarLabelSettings.fontSize);
                var percentBarTextProperties = FunnelChart.getTextProperties(data.percentBarLabelSettings.fontSize);
                var baselineDelta = powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(percentBarTextProperties);
                var percentBarYOffset = powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties) - baselineDelta;
                return {
                    percentBarLayout: {
                        mainLine: {
                            x2: function (d) { return Math.abs(yScale(d.value) - yScale(0)); },
                            transform: function (d) {
                                var xOffset = yScale(d.value) - emptyHorizontalSpace(d.value);
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth;
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            },
                        },
                        leftTick: {
                            y2: function (d) { return percentBarTickHeight; },
                            transform: function (d) {
                                var xOffset = yScale(d.value) - emptyHorizontalSpace(d.value);
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth - (percentBarTickHeight / 2)
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth - (percentBarTickHeight / 2);
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            },
                        },
                        rightTick: {
                            y2: function (d) { return percentBarTickHeight; },
                            transform: function (d) {
                                var columnOffset = yScale(d.value) - emptyHorizontalSpace(d.value);
                                var columnHeight = Math.abs(yScale(d.value) - yScale(0));
                                var xOffset = columnOffset + columnHeight;
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth - (percentBarTickHeight / 2)
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth - (percentBarTickHeight / 2);
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            },
                        },
                        text: {
                            x: function (d) { return Math.ceil((Math.abs(yScale(maxScore) - yScale(0)) / 2)); },
                            y: function (d) {
                                return d.isTop
                                    ? -percentBarTickHeight / 2 - baselineDelta
                                    : percentBarYOffset + (percentBarTickHeight / 2);
                            },
                            style: function () { return ("font-size: " + percentBarFontSize + ";"); },
                            transform: function (d) {
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth;
                                return visuals.SVGUtil.translate(0, yOffset);
                            },
                            fill: data.percentBarLabelSettings.labelColor,
                            maxWidth: horizontalDistance,
                        },
                    },
                    shapeLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) {
                            return Math.abs(yScale(FunnelChart.getFunnelSliceValue(d)) - yScale(0));
                        },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            var value = FunnelChart.getFunnelSliceValue(d);
                            return yScale(value) - emptyHorizontalSpace(value);
                        },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: (function (d) { return columnWidth; }),
                        height: function (d) {
                            return Math.abs(yScale(d.value) - yScale(0));
                        },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (0);
                        },
                        y: function (d) {
                            return yScale(d.value) - emptyHorizontalSpace(d.value);
                        },
                    },
                    zeroShapeLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) { return 0; },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            return yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);
                        },
                    },
                    interactorLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) { return getMinimumShapeSize(FunnelChart.getFunnelSliceValue(d)); },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            var size = getMinimumShapeSize(FunnelChart.getFunnelSliceValue(d));
                            return (horizontalDistance - size) / 2;
                        },
                    },
                };
            };
            FunnelChart.drawDefaultAxis = function (graphicsContext, axisOptions, isHidingPercentBars) {
                //Generate ordinal domain
                var indices = d3.range(0, axisOptions.categoryLabels.length);
                var xScaleForAxis = d3.scale.ordinal()
                    .domain(indices)
                    .rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
                var xAxis = d3.svg.axis()
                    .scale(xScaleForAxis)
                    .orient("right")
                    .tickPadding(FunnelChart.TickPadding)
                    .innerTickSize(FunnelChart.InnerTickSize)
                    .ticks(indices.length)
                    .tickValues(indices)
                    .tickFormat(function (i) { return axisOptions.categoryLabels[i]; }); //To output the category label
                graphicsContext.attr('class', 'axis hideLinesOnAxis')
                    .attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top))
                    .call(xAxis);
                graphicsContext.selectAll('.tick')
                    .call(visuals.tooltipUtils.tooltipUpdate, axisOptions.categoryLabels);
                // Subtract the padding from the margin since we can't have text there. Then shorten the labels if necessary.
                var leftRightMarginLimit = axisOptions.margin.left - FunnelChart.LabelFunnelPadding;
                graphicsContext.selectAll('.tick text')
                    .call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit, powerbi.TextMeasurementService.svgEllipsis);
            };
            FunnelChart.drawDefaultShapes = function (data, slices, graphicsContext, layout, hasSelection) {
                var hasHighlights = data.hasHighlights;
                var columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.bars.selector).data(slices, function (d) { return d.key; });
                columns.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? FunnelChart.FunnelBarHighlightClass : FunnelChart.Selectors.funnel.bars.class; });
                columns
                    .style("fill", function (d) {
                    return d.color;
                })
                    .style("fill-opacity", function (d) { return function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); }; })
                    .attr(layout.shapeLayout);
                columns.exit().remove();
                return columns;
            };
            FunnelChart.getFunnelSliceValue = function (slice, asOriginal) {
                if (asOriginal === void 0) { asOriginal = false; }
                if (asOriginal)
                    return slice.highlight ? slice.originalHighlightValue : slice.originalValue;
                else
                    return slice.highlight ? slice.highlightValue : slice.value;
            };
            FunnelChart.drawInteractorShapes = function (slices, graphicsContext, layout) {
                // Draw invsible ineractors for just data points which are below threshold
                var needInteractors = slices.filter(function (d) {
                    return !d.highlight && layout.interactorLayout.height(d) === FunnelChart.MinimumInteractorSize;
                });
                var columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.interactors.selector).data(needInteractors, function (d) { return d.key; });
                columns.enter()
                    .append('rect')
                    .attr("class", FunnelChart.Selectors.funnel.interactors.class);
                columns
                    .style("fill-opacity", 0)
                    .attr(layout.interactorLayout);
                columns.exit().remove();
                return columns;
            };
            FunnelChart.drawPercentBarComponents = function (graphicsContext, data, layout, percentLabelSettings) {
                // Main line
                var mainLine = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                mainLine.exit().remove();
                mainLine.enter()
                    .append('line')
                    .classed(FunnelChart.Selectors.percentBar.mainLine.class, true);
                mainLine
                    .attr(layout.percentBarLayout.mainLine);
                // Left tick
                var leftTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                leftTick.exit().remove();
                leftTick.enter()
                    .append('line')
                    .classed(FunnelChart.Selectors.percentBar.leftTick.class, true);
                leftTick
                    .attr(layout.percentBarLayout.leftTick);
                // Right tick
                var rightTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                rightTick.exit().remove();
                rightTick.enter()
                    .append('line')
                    .classed(FunnelChart.Selectors.percentBar.rightTick.class, true);
                rightTick
                    .attr(layout.percentBarLayout.rightTick);
                // Text
                var text = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.text.selector).data(data);
                var localizedString = visuals.valueFormatter.getLocalizedString("Percentage1");
                text.exit().remove();
                text.enter().append('text').classed(FunnelChart.Selectors.percentBar.text.class, true);
                text
                    .attr(layout.percentBarLayout.text)
                    .text(function (fp) {
                    return visuals.dataLabelUtils.getLabelFormattedText({
                        label: fp.percent,
                        format: localizedString,
                        fontSize: percentLabelSettings.fontSize,
                        maxWidth: layout.percentBarLayout.text.maxWidth,
                    });
                })
                    .append('title').text(function (d) { return powerbi.formattingService.formatValue(d.percent, localizedString); });
            };
            FunnelChart.drawPercentBars = function (data, graphicsContext, layout, isHidingPercentBars) {
                if (isHidingPercentBars || !data.slices || (data.hasHighlights ? data.slices.length / 2 : data.slices.length) < 2) {
                    FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                    return;
                }
                var slices = [data.slices[data.hasHighlights ? 1 : 0], data.slices[data.slices.length - 1]];
                var baseline = FunnelChart.getFunnelSliceValue(slices[0]);
                if (baseline <= 0) {
                    FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                    return;
                }
                var percentData = [
                    {
                        value: FunnelChart.getFunnelSliceValue(slices[0]),
                        percent: 1,
                        isTop: true,
                    },
                    {
                        value: FunnelChart.getFunnelSliceValue(slices[1]),
                        percent: FunnelChart.getFunnelSliceValue(slices[1]) / baseline,
                        isTop: false,
                    },
                ];
                FunnelChart.drawPercentBarComponents(graphicsContext, percentData, layout, data.percentBarLabelSettings);
            };
            FunnelChart.prototype.showCategoryLabels = function () {
                if (this.funnelSmallViewPortProperties) {
                    if ((this.funnelSmallViewPortProperties.hideFunnelCategoryLabelsOnSmallViewPort) && (this.currentViewport.height < this.funnelSmallViewPortProperties.minHeightFunnelCategoryLabelsVisible)) {
                        return false;
                    }
                }
                return true;
            };
            FunnelChart.addFunnelPercentsToTooltip = function (tooltipInfo, hostServices, percentOfFirst, percentOfPrevious, highlight) {
                if (percentOfFirst != null) {
                    tooltipInfo.push({
                        displayName: hostServices.getLocalizedString("Funnel_PercentOfFirst" + (highlight ? "_Highlight" : "")),
                        value: visuals.valueFormatter.format(percentOfFirst, '0.00 %;-0.00 %;0.00 %'),
                    });
                }
                if (percentOfPrevious != null) {
                    tooltipInfo.push({
                        displayName: hostServices.getLocalizedString("Funnel_PercentOfPrevious" + (highlight ? "_Highlight" : "")),
                        value: visuals.valueFormatter.format(percentOfPrevious, '0.00 %;-0.00 %;0.00 %'),
                    });
                }
            };
            FunnelChart.getTextProperties = function (fontSize) {
                return {
                    fontSize: PixelConverter.fromPoint(fontSize || visuals.dataLabelUtils.DefaultFontSizeInPt),
                    fontFamily: FunnelChart.DefaultFontFamily,
                };
            };
            FunnelChart.DefaultBarOpacity = 1;
            FunnelChart.DimmedBarOpacity = 0.4;
            FunnelChart.PercentBarToBarRatio = 0.75;
            FunnelChart.TickPadding = 0;
            FunnelChart.InnerTickSize = 0;
            FunnelChart.MinimumInteractorSize = 15;
            FunnelChart.InnerTextClassName = 'labelSeries';
            FunnelChart.Selectors = {
                funnel: {
                    bars: createClassAndSelector('funnelBar'),
                    highlights: createClassAndSelector('highlight'),
                    interactors: createClassAndSelector('funnelBarInteractor'),
                },
                percentBar: {
                    root: createClassAndSelector('percentBars'),
                    mainLine: createClassAndSelector('mainLine'),
                    leftTick: createClassAndSelector('leftTick'),
                    rightTick: createClassAndSelector('rightTick'),
                    text: createClassAndSelector('value'),
                },
            };
            FunnelChart.FunnelBarHighlightClass = [FunnelChart.Selectors.funnel.bars.class, FunnelChart.Selectors.funnel.highlights.class].join(' ');
            FunnelChart.YAxisPadding = 10;
            FunnelChart.VisualClassName = 'funnelChart';
            FunnelChart.DefaultFontFamily = 'wf_standard-font';
            FunnelChart.BarToSpaceRatio = 0.1;
            FunnelChart.MaxBarWidth = 40;
            FunnelChart.MinBarThickness = 12;
            FunnelChart.LabelFunnelPadding = 6;
            FunnelChart.InnerTextMinimumPadding = 10;
            FunnelChart.OverflowingHighlightWidthRatio = 0.5;
            FunnelChart.MaxMarginFactor = 0.25;
            return FunnelChart;
        }());
        visuals.FunnelChart = FunnelChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        /**
         * Renders a number that can be animate change in value.
         */
        var Gauge = (function () {
            function Gauge(options) {
                this.lastAngle = -Math.PI / 2;
                if (options) {
                    if (options.gaugeSmallViewPortProperties) {
                        this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties;
                    }
                    this.animator = options.animator;
                    this.tooltipsEnabled = options.tooltipsEnabled;
                }
            }
            Gauge.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'axis':
                        this.enumerateAxis(enumeration);
                        break;
                    case 'labels': {
                        var labelSettings = this.data ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                        break;
                    }
                    case 'calloutValue': {
                        var labelSettings = this.data ? this.data.calloutValueLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                        break;
                    }
                    case 'dataPoint': {
                        this.enumerateDataPoint(enumeration);
                        break;
                    }
                }
                return enumeration.complete();
            };
            Gauge.prototype.getDataLabelSettingsOptions = function (enumeration, labelSettings) {
                return {
                    dataLabelsSettings: labelSettings,
                    show: true,
                    precision: true,
                    displayUnits: true,
                    fontSize: true,
                    enumeration: enumeration,
                };
            };
            Gauge.prototype.enumerateAxis = function (enumeration) {
                var dataView = this.dataViews[0];
                if (dataView && dataView.metadata) {
                    var properties = Gauge.getGaugeObjectsProperties(dataView);
                    enumeration.pushInstance({
                        selector: null,
                        objectName: 'axis',
                        properties: properties,
                    });
                }
            };
            Gauge.prototype.enumerateDataPoint = function (enumeration) {
                var dataPointSettings = this.data ? this.data.dataPointSettings : Gauge.DefaultDataPointSettings;
                var properties = {};
                properties.fill = { solid: { color: dataPointSettings.fillColor } };
                if (dataPointSettings.targetColor != null) {
                    properties.target = { solid: { color: dataPointSettings.targetColor } };
                }
                enumeration.pushInstance({
                    selector: null,
                    objectName: visuals.gaugeProps.dataPoint.target.objectName,
                    properties: properties
                });
            };
            Gauge.getGaugeObjectsProperties = function (dataView) {
                var properties = {};
                var objects = dataView.metadata.objects;
                var hasAxisObject = !!objects && !!objects.axis;
                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.minValue))
                    properties.min = hasAxisObject ? objects.axis.min : undefined;
                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.maxValue))
                    properties.max = hasAxisObject ? objects.axis.max : undefined;
                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.targetValue))
                    properties.target = hasAxisObject ? objects.axis.target : undefined;
                return properties;
            };
            Gauge.prototype.init = function (options) {
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.options = options;
                this.settings = Gauge.DefaultStyleProperties;
                this.targetSettings = Gauge.DefaultTargetSettings;
                this.setMargins();
                this.color = d3.scale.ordinal().range(this.style.colorPalette.dataColors.getSentimentColors().map(function (color) { return color.value; }));
                this.hostService = options.host;
                var svg = this.svg = d3.select(this.element.get(0)).append('svg');
                svg.classed(Gauge.VisualClassName, true);
                var mainGraphicsContext = this.mainGraphicsContext = svg.append('g');
                mainGraphicsContext.attr('class', Gauge.MainGaugeGroupClassName);
                this.initKpiBands();
                var backgroundArc = this.backgroundArc = d3.svg.arc()
                    .innerRadius(0)
                    .outerRadius(0)
                    .startAngle(-Math.PI / 2)
                    .endAngle(Math.PI / 2);
                var foregroundArc = this.foregroundArc = d3.svg.arc()
                    .innerRadius(0)
                    .outerRadius(0)
                    .startAngle(-Math.PI / 2);
                this.backgroundArcPath = mainGraphicsContext.append('path')
                    .classed('backgroundArc', true)
                    .attr('d', backgroundArc);
                this.foregroundArcPath = mainGraphicsContext.append('path')
                    .datum({ endAngle: -Math.PI / 2 })
                    .classed('foregroundArc', true)
                    .attr('d', foregroundArc);
                var g = this.animatedNumberGrapicsContext = svg.append('g');
                this.animatedNumber = new visuals.AnimatedNumber(g);
                this.animatedNumber.init(options);
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties();
                var animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.animatedNumberGrapicsContext.attr('transform', animatedNumberProperties.transformString);
                this.animatedNumber.onResizing(animatedNumberProperties.viewport);
            };
            Gauge.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                this.data = Gauge.converter(dataViews[0], this.tooltipsEnabled);
                this.targetSettings = this.data.targetSettings;
                if (dataViews[0])
                    dataViews[0].single = { value: this.data.total };
                // Only show the target label if:
                //   1. There is a target
                //   2. The viewport width is big enough for a target
                //   3. We're showing label text for side numbers
                //   4. Data label settings specify to show
                this.showTargetLabel = this.targetSettings.target != null
                    && (this.currentViewport.width > Gauge.MinWidthForTargetLabel || !this.showMinMaxLabelsOnBottom())
                    && this.showSideNumbersLabelText()
                    && this.data.dataLabelsSettings.show;
                this.setMargins();
                this.gaugeVisualProperties = this.getGaugeVisualProperties();
                this.drawViewPort(this.gaugeVisualProperties);
                this.updateInternal(options.suppressAnimations);
                this.updateCalloutValue(options.suppressAnimations);
                var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                this.hostService.setWarnings(warnings);
            };
            Gauge.prototype.updateCalloutValue = function (suppressAnimations) {
                if (this.data.calloutValueLabelsSettings.show) {
                    var animatedNumberProperties = this.getAnimatedNumberProperties(this.gaugeVisualProperties.radius, this.gaugeVisualProperties.innerRadiusFactor, this.gaugeVisualProperties.top, this.gaugeVisualProperties.left);
                    this.animatedNumberGrapicsContext.attr('transform', animatedNumberProperties.transformString);
                    this.animatedNumber.setTextColor(this.data.calloutValueLabelsSettings.labelColor);
                    var calloutValue = this.data ? this.data.total : null;
                    var formatter = this.getFormatter(this.data.calloutValueLabelsSettings, calloutValue);
                    this.animatedNumber.setFormatter(formatter);
                    this.animatedNumber.update({
                        viewport: animatedNumberProperties.viewport,
                        dataViews: this.dataViews,
                        suppressAnimations: suppressAnimations,
                    });
                    this.animatedNumberGrapicsContext.selectAll('title').remove();
                    this.animatedNumberGrapicsContext.append('title').text([formatter.format(calloutValue)]);
                }
                else {
                    this.animatedNumber.clear();
                    this.animatedNumberGrapicsContext.selectAll('title').remove();
                }
            };
            Gauge.prototype.onDataChanged = function (options) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            };
            Gauge.prototype.onResizing = function (viewport) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewMode: 0 /* View */,
                    viewport: viewport
                });
            };
            Gauge.getValidSettings = function (targetData) {
                var maxVal = (targetData.max === Gauge.MAX_VALUE) ? Gauge.DEFAULT_MAX : targetData.max;
                var minVal = (targetData.min === Gauge.MIN_VALUE) ? Gauge.DEFAULT_MIN : targetData.min;
                var targetVal = targetData.target;
                return {
                    min: minVal,
                    max: maxVal,
                    target: targetVal
                };
            };
            Gauge.getGaugeData = function (dataView) {
                var settings = {
                    max: Gauge.MAX_VALUE,
                    min: Gauge.MIN_VALUE,
                    target: undefined,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
                    var values = dataView.categorical.values;
                    var metadataColumns = dataView.metadata.columns;
                    debug.assert(metadataColumns.length >= values.length, 'length');
                    for (var i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        if (col && col.roles) {
                            if (col.roles[visuals.gaugeRoleNames.y]) {
                                settings.total = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                            else if (col.roles[visuals.gaugeRoleNames.minValue]) {
                                settings.min = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.maxValue]) {
                                settings.max = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.targetValue]) {
                                settings.target = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                        }
                    }
                    // Override settings according to property pane axis values
                    var gaugeObjectsSettings = Gauge.getGaugeObjectsProperties(dataView);
                    if (gaugeObjectsSettings && !$.isEmptyObject(gaugeObjectsSettings))
                        Gauge.overrideGaugeSettings(settings, gaugeObjectsSettings);
                }
                return settings;
            };
            Gauge.overrideGaugeSettings = function (settings, gaugeObjectsSettings) {
                if ($.isNumeric(gaugeObjectsSettings.min))
                    settings.min = gaugeObjectsSettings.min;
                if ($.isNumeric(gaugeObjectsSettings.max))
                    settings.max = gaugeObjectsSettings.max;
                if ($.isNumeric(gaugeObjectsSettings.target))
                    settings.target = gaugeObjectsSettings.target;
            };
            /** Note: Made public for testability */
            Gauge.converter = function (dataView, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var gaugeData = Gauge.getGaugeData(dataView), total = gaugeData.total, formatString = null, hasPercent = false;
                if (dataView.metadata && !_.isEmpty(dataView.metadata.columns)) {
                    formatString = visuals.valueFormatter.getFormatString(dataView.metadata.columns[0], Gauge.formatStringProp, true);
                    if (formatString != null)
                        hasPercent = visuals.valueFormatter.getFormatMetadata(formatString).hasPercent;
                }
                if (total > 0 && gaugeData.max === Gauge.MAX_VALUE) {
                    gaugeData.max = hasPercent ? Gauge.DEFAULT_MAX : total * 2;
                }
                var settings = Gauge.getValidSettings(gaugeData);
                //Checking that the value is plotted inside the gauge boundaries
                var adjustedTotal = Math.max(total, settings.min);
                adjustedTotal = Math.min(adjustedTotal, settings.max);
                var percent = (settings.min !== settings.max)
                    ? (adjustedTotal - settings.min) / (settings.max - settings.min)
                    : 0;
                var tooltipInfo;
                if (tooltipsEnabled && dataView) {
                    if (gaugeData.tooltipItems.length > 0) {
                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, null, null, null, null, gaugeData.tooltipItems);
                    }
                    else {
                        var dataViewCat = dataView.categorical;
                        if (dataViewCat && dataViewCat.values && dataViewCat.values.length > 0) {
                            var categoryValue = dataViewCat.values[0];
                            var value = categoryValue.values[0];
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, dataViewCat, null, value);
                        }
                    }
                }
                return {
                    percent: percent,
                    adjustedTotal: adjustedTotal,
                    total: total,
                    metadataColumn: Gauge.getMetaDataColumn(dataView),
                    targetSettings: settings,
                    tooltipInfo: tooltipInfo,
                    dataLabelsSettings: Gauge.convertDataLabelSettings(dataView, "labels"),
                    calloutValueLabelsSettings: Gauge.convertDataLabelSettings(dataView, "calloutValue"),
                    dataPointSettings: Gauge.convertDataPointSettings(dataView, settings)
                };
            };
            Gauge.convertDataLabelSettings = function (dataview, objectName) {
                var dataViewMetadata = dataview.metadata;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                if (dataViewMetadata) {
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        // Handle label settings
                        var labelsObj = objects[objectName];
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    }
                }
                return dataLabelsSettings;
            };
            Gauge.convertDataPointSettings = function (dataView, targetSettings) {
                // Default the fill color the the default fill color. Default the target to undefined as it's only used if there's a target.
                var fillColor = Gauge.DefaultDataPointSettings.fillColor;
                var targetColor;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    // If there is saved metadata, use it for the colors
                    var objects = dataView.metadata.objects;
                    fillColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.fill, Gauge.DefaultDataPointSettings.fillColor);
                    if (targetSettings && (targetSettings.target != null)) {
                        targetColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.target, Gauge.DefaultDataPointSettings.targetColor);
                    }
                }
                else if (targetSettings && (targetSettings.target != null)) {
                    // If there isn't metadata, but a target is set, default to the default target color
                    targetColor = Gauge.DefaultDataPointSettings.targetColor;
                }
                return {
                    fillColor: fillColor,
                    targetColor: targetColor
                };
            };
            Gauge.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            return column;
                        }
                    }
                }
                return null;
            };
            Gauge.prototype.initKpiBands = function () {
                if (!this.settings.kpiBands.show)
                    return;
                var kpiArcs = this.kpiArcs = [];
                var kpiArcPaths = this.kpiArcPaths = [];
                var mainGraphicsContext = this.mainGraphicsContext;
                for (var i = 0; i < 3; i++) {
                    var arc = d3.svg.arc()
                        .innerRadius(0)
                        .outerRadius(0)
                        .startAngle(0)
                        .endAngle(0);
                    kpiArcs.push(arc);
                    var arcPath = mainGraphicsContext.append('path')
                        .attr("d", arc);
                    kpiArcPaths.push(arcPath);
                }
            };
            Gauge.prototype.updateKpiBands = function (radius, innerRadiusFactor, tString, kpiAngleAttr) {
                if (!this.settings.kpiBands.show)
                    return;
                for (var i = 0; i < kpiAngleAttr.length; i++) {
                    this.kpiArcs[i]
                        .innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness))
                        .outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc)
                        .startAngle(kpiAngleAttr[i].start)
                        .endAngle(kpiAngleAttr[i].end);
                    this.kpiArcPaths[i]
                        .attr('fill', kpiAngleAttr[i].fill)
                        .attr('d', this.kpiArcs[i])
                        .attr('transform', tString);
                }
            };
            Gauge.prototype.removeTargetElements = function () {
                if (this.targetLine) {
                    this.targetLine.remove();
                    this.targetText.remove();
                    this.targetConnector.remove();
                    this.targetLine = this.targetConnector = this.targetText = null;
                }
            };
            Gauge.prototype.getTargetRatio = function () {
                var targetSettings = this.targetSettings;
                var range = targetSettings.max - targetSettings.min;
                if (range !== 0)
                    return (targetSettings.target - targetSettings.min) / range;
                return 0;
            };
            Gauge.prototype.updateTargetLine = function (radius, innerRadius, left, top) {
                if (!this.targetLine) {
                    this.targetLine = this.mainGraphicsContext.append('line');
                }
                var angle = this.getTargetRatio() * Math.PI;
                var outY = top - radius * Math.sin(angle);
                var outX = left - radius * Math.cos(angle);
                var inY = top - innerRadius * Math.sin(angle);
                var inX = left - innerRadius * Math.cos(angle);
                this.targetLine.attr({
                    x1: inX,
                    y1: inY,
                    x2: outX,
                    y2: outY
                });
            };
            /** Note: public for testability */
            Gauge.prototype.getAnimatedNumberProperties = function (radius, innerRadiusFactor, top, left) {
                var boxAngle = Math.PI / 4;
                var scale = 1;
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var innerRadiusForTextBoundingBox = innerRadiusOfArc - (this.settings.kpiBands.show
                    ? (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)
                    : 0);
                var innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle);
                var innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle);
                var innerY = top - innerRSin;
                var innerX = left - innerRCos;
                innerY = innerY * scale;
                innerX = innerX * scale;
                var animatedNumberWidth = innerRCos * 2;
                var properties = {
                    transformString: visuals.SVGUtil.translate(innerX, innerY),
                    viewport: { height: innerRSin, width: animatedNumberWidth }
                };
                return properties;
            };
            /** Note: public for testability */
            Gauge.prototype.getGaugeVisualProperties = function () {
                var viewport = this.currentViewport;
                var margin = this.margin;
                var width = viewport.width - margin.right - margin.left;
                var halfWidth = width / 2;
                var height = viewport.height - margin.top - margin.bottom;
                var radius = Math.min(halfWidth, height);
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var left = margin.left + halfWidth;
                var top = radius + (height - radius) / 2 + margin.top;
                var tString = visuals.SVGUtil.translate(left, top);
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var gaugeData = {
                    radius: radius,
                    innerRadiusOfArc: innerRadiusOfArc,
                    left: left,
                    top: top,
                    height: height,
                    width: width,
                    margin: margin,
                    transformString: tString,
                    innerRadiusFactor: innerRadiusFactor
                };
                return gaugeData;
            };
            /** Note: public for testability */
            Gauge.prototype.drawViewPort = function (drawOptions) {
                debug.assertAnyValue(drawOptions, "Gauge options");
                var separation = this.settings.kpiBands.separationRadians;
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var backgroudArc = this.backgroundArc;
                var color = this.color;
                var attrs = [{
                        fill: color(0),
                        start: -Math.PI / 2,
                        end: -Math.PI / 2 + Math.PI / 4 - separation
                    }, {
                        fill: color(1),
                        start: -Math.PI / 2 + Math.PI * 1 / 4 + separation,
                        end: -Math.PI / 2 + Math.PI * 3 / 4 - separation
                    }, {
                        fill: color(2),
                        start: -Math.PI / 2 + Math.PI * 3 / 4 + separation,
                        end: Math.PI / 2
                    }];
                var radius = drawOptions.radius;
                var transformString = drawOptions.transformString;
                this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs);
                backgroudArc
                    .innerRadius(radius * innerRadiusFactor)
                    .outerRadius(radius)
                    .startAngle(-Math.PI / 2)
                    .endAngle(Math.PI / 2);
                this.backgroundArcPath
                    .attr("d", backgroudArc)
                    .attr("transform", transformString);
                var foregroundArc = this.foregroundArc;
                foregroundArc
                    .innerRadius(radius * innerRadiusFactor)
                    .outerRadius(radius)
                    .startAngle(-Math.PI / 2);
                this.foregroundArcPath
                    .datum({ endAngle: this.lastAngle })
                    .attr("transform", transformString)
                    .attr("d", foregroundArc);
                var innerRadiusOfArc = drawOptions.innerRadiusOfArc;
                var left = drawOptions.left;
                var top = drawOptions.top;
                var margin = drawOptions.margin;
                var height = drawOptions.height;
                var targetSettings = this.targetSettings;
                if (!this.settings.targetLine.show || targetSettings.target == null) {
                    this.removeTargetElements();
                }
                else {
                    if (targetSettings.min > targetSettings.target || targetSettings.max < targetSettings.target) {
                        this.removeTargetElements();
                    }
                    else {
                        this.updateTargetLine(radius, innerRadiusOfArc, left, top);
                        this.appendTargetTextAlongArc(radius, height, drawOptions.width, margin);
                    }
                }
                this.svg.attr('height', this.currentViewport.height).attr('width', this.currentViewport.width);
            };
            Gauge.prototype.createTicks = function () {
                var settings = this.settings;
                var targetSettings = this.targetSettings;
                var total = targetSettings.max - targetSettings.min;
                var numberOfLabels = settings.labels.count;
                var step = total / numberOfLabels;
                var arr = [];
                var formatter = this.getFormatter(this.data.dataLabelsSettings, targetSettings.max);
                for (var i = 0; i < numberOfLabels + 1; i++) {
                    arr.push(formatter.format(targetSettings.min + (i * step)));
                }
                return arr;
            };
            Gauge.prototype.updateInternal = function (suppressAnimations) {
                var height = this.gaugeVisualProperties.height;
                var width = this.gaugeVisualProperties.width;
                var radius = this.gaugeVisualProperties.radius;
                var margin = this.margin;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                var data = this.data;
                var lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * data.percent;
                var ticks = this.createTicks();
                this.foregroundArcPath
                    .transition()
                    .ease(this.settings.transition.ease)
                    .duration(duration)
                    .call(this.arcTween, [lastAngle, this.foregroundArc]);
                this.appendTextAlongArc(ticks, radius, height, width, margin);
                this.updateVisualConfigurations();
                this.updateVisualStyles();
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(this.foregroundArcPath, function (tooltipEvent) { return data.tooltipInfo; });
                    visuals.TooltipManager.addTooltip(this.backgroundArcPath, function (tooltipEvent) { return data.tooltipInfo; });
                }
            };
            Gauge.prototype.updateVisualStyles = function () {
                var fillColor = this.data.dataLabelsSettings.labelColor || this.style.labelText.color.value;
                this.mainGraphicsContext.selectAll('text')
                    .style({
                    'fill': fillColor,
                });
            };
            Gauge.prototype.updateVisualConfigurations = function () {
                var configOptions = this.settings;
                var dataPointSettings = this.data.dataPointSettings;
                this.mainGraphicsContext
                    .select('line')
                    .attr({
                    stroke: dataPointSettings.targetColor,
                    'stroke-width': configOptions.targetLine.thickness,
                });
                this.backgroundArcPath.style('fill', configOptions.arcColors.background);
                this.foregroundArcPath.style('fill', dataPointSettings.fillColor);
            };
            Gauge.prototype.appendTextAlongArc = function (ticks, radius, height, width, margin) {
                this.svg.selectAll(Gauge.LabelText.selector).remove();
                if (!this.data.dataLabelsSettings.show)
                    return;
                var total = ticks.length;
                var divisor = total - 1;
                var top = (radius + (height - radius) / 2 + margin.top);
                var showMinMaxLabelsOnBottom = this.showMinMaxLabelsOnBottom();
                var fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                var padding = this.settings.labels.padding;
                for (var count = 0; count < total; count++) {
                    if (Math.floor(total / 2) === count)
                        continue; // Skip Middle label, by design
                    if (this.showSideNumbersLabelText()) {
                        var x = (margin.left + width / 2) - (radius * Math.cos(Math.PI * count / divisor));
                        var y = top - (radius * Math.sin(Math.PI * count / divisor));
                        var anchor = void 0;
                        var onRight = count * 2 > total;
                        var onBottom = false;
                        if (showMinMaxLabelsOnBottom && (count === 0 || count === total - 1)) {
                            // If this is a min or max label and we're showing them on the bottom rather than the sides
                            // Adjust the label display properties to appear under the arc
                            onBottom = true;
                            y += padding / 2;
                            // Align the labels with the outer edge of the arc
                            anchor = onRight ? 'end' : 'start';
                        }
                        else {
                            // For all other labels, display around the arc
                            anchor = onRight ? 'start' : 'end';
                            x += padding * (onRight ? 1 : -1);
                        }
                        var text = this.mainGraphicsContext
                            .append('text')
                            .attr({
                            'x': x,
                            'y': y,
                            'dy': onBottom ? fontSize : 0,
                            'class': Gauge.LabelText.class
                        })
                            .style({
                            'text-anchor': anchor,
                            'font-size': fontSize
                        })
                            .text(ticks[count])
                            .append('title').text(ticks[count]);
                        if (!onBottom)
                            this.truncateTextIfNeeded(text, x, onRight);
                    }
                }
            };
            Gauge.prototype.truncateTextIfNeeded = function (text, positionX, onRight) {
                var availableSpace = (onRight ? this.currentViewport.width - positionX : positionX);
                text.call(visuals.AxisHelper.LabelLayoutStrategy.clip, availableSpace, powerbi.TextMeasurementService.svgEllipsis);
            };
            Gauge.prototype.getFormatter = function (dataLabelSettings, value2) {
                var realValue2 = dataLabelSettings.displayUnits === 0 ? value2 : null;
                var formatString = visuals.valueFormatter.getFormatString(this.data.metadataColumn, Gauge.formatStringProp);
                var precision = visuals.dataLabelUtils.getLabelPrecision(dataLabelSettings.precision, formatString);
                var valueFormatterOptions = visuals.dataLabelUtils.getOptionsForLabelFormatter(dataLabelSettings, formatString, realValue2, precision);
                valueFormatterOptions.formatSingleValues = dataLabelSettings.displayUnits > 0 ? false : true;
                return visuals.valueFormatter.create(valueFormatterOptions);
            };
            Gauge.prototype.appendTargetTextAlongArc = function (radius, height, width, margin) {
                var targetSettings = this.targetSettings;
                var target = targetSettings.target;
                var tRatio = this.getTargetRatio();
                var top = (radius + (height - radius) / 2 + margin.top);
                var flag = tRatio > 0.5;
                var padding = this.settings.labels.padding;
                var anchor = flag ? 'start' : 'end';
                var formatter = this.getFormatter(this.data.dataLabelsSettings, targetSettings.max);
                var maxRatio = Math.asin(Gauge.MinDistanceFromBottom / radius) / Math.PI;
                var finalRatio = tRatio < maxRatio || tRatio > (1 - maxRatio)
                    ? flag
                        ? 1 - maxRatio
                        : maxRatio
                    : tRatio;
                var targetX = (margin.left + width / 2) - ((radius + padding) * Math.cos(Math.PI * finalRatio));
                var targetY = top - ((radius + padding) * Math.sin(Math.PI * finalRatio));
                if (!this.targetText) {
                    this.targetText = this.mainGraphicsContext
                        .append('text')
                        .classed(Gauge.TargetText.class, true);
                }
                this.targetText
                    .attr({
                    'x': targetX,
                    'y': targetY,
                })
                    .style({
                    'text-anchor': anchor,
                    'display': this.showTargetLabel ? '' : 'none',
                    'font-size': this.style.labelText.fontSize
                })
                    .text(formatter.format(target));
                this.truncateTextIfNeeded(this.targetText, targetX, flag);
                this.targetText.call(visuals.tooltipUtils.tooltipUpdate, [formatter.format(target)]);
                if (!this.targetConnector) {
                    this.targetConnector = this.mainGraphicsContext
                        .append('line')
                        .classed(Gauge.TargetConnector.class, true);
                }
                // Hide the target connector if the text is going to align with the target line in the arc
                // It should only be shown if the target text is displaced (ex. when the target is very close to min/max)
                if (tRatio === finalRatio) {
                    this.targetConnector.style('display', 'none');
                }
                else {
                    this.targetConnector
                        .attr({
                        'x1': (margin.left + width / 2) - (radius * Math.cos(Math.PI * tRatio)),
                        'y1': top - (radius * Math.sin(Math.PI * tRatio)),
                        'x2': targetX,
                        'y2': targetY
                    })
                        .style({
                        'stroke-width': this.settings.targetLine.thickness,
                        'stroke': this.settings.targetLine.color,
                        'display': ''
                    });
                }
            };
            Gauge.prototype.arcTween = function (transition, arr) {
                transition.attrTween('d', function (d) {
                    var interpolate = d3.interpolate(d.endAngle, arr[0]);
                    return function (t) {
                        d.endAngle = interpolate(t);
                        return arr[1](d);
                    };
                });
            };
            Gauge.prototype.showMinMaxLabelsOnBottom = function () {
                // More vertical space, put labels on bottom
                if (this.currentViewport.height > this.currentViewport.width)
                    return true;
                // We want to show the start/end ticks on the bottom when there
                // is insufficient space for the left and right label text
                if (this.data && this.gaugeVisualProperties) {
                    var ticks = this.createTicks();
                    var visualWhitespace = (this.currentViewport.width - (this.gaugeVisualProperties.radius * 2)) / 2;
                    var maxLabelWidth = visualWhitespace - this.settings.labels.padding;
                    var textProperties = powerbi.TextMeasurementService.getMeasurementProperties($(this.svg.node()));
                    textProperties.fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                    var width = void 0;
                    for (var _i = 0, _a = [ticks[0], ticks[ticks.length - 1]]; _i < _a.length; _i++) {
                        var tickValue = _a[_i];
                        textProperties.text = tickValue;
                        width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                        if (width > maxLabelWidth)
                            return true;
                    }
                }
                return false;
            };
            Gauge.prototype.setMargins = function () {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible)) {
                        var margins = this.gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
                        this.margin = { top: margins, bottom: margins, left: margins, right: margins };
                        return;
                    }
                }
                this.margin = {
                    top: Gauge.DefaultTopBottomMargin,
                    bottom: Gauge.DefaultTopBottomMargin,
                    left: Gauge.DefaultLeftRightMargin,
                    right: Gauge.DefaultLeftRightMargin
                };
                // If we're not showing side labels, reduce the margin so that the gauge has more room to display
                if (!this.showSideNumbersLabelText() || this.showMinMaxLabelsOnBottom()) {
                    var targetSettings = this.targetSettings;
                    if (this.showTargetLabel) {
                        // If we're showing the target label, only reduce the margin on the side that doesn't have a target label
                        var tRatio = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                        if (tRatio > 0.5)
                            this.margin.left = Gauge.ReducedLeftRightMargin;
                        else
                            this.margin.right = Gauge.ReducedLeftRightMargin;
                    }
                    else {
                        // Otherwise, reduce both margins
                        this.margin.left = this.margin.right = Gauge.ReducedLeftRightMargin;
                    }
                }
                var fontSize = 0;
                if (this.data && this.data.dataLabelsSettings && this.data.dataLabelsSettings.fontSize && this.data.dataLabelsSettings.fontSize >= visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt) {
                    fontSize = PixelConverter.fromPointToPixel(this.data.dataLabelsSettings.fontSize - visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                }
                if (fontSize !== 0) {
                    this.margin.bottom += fontSize;
                    this.margin.left += fontSize;
                    this.margin.right += fontSize;
                }
            };
            Gauge.prototype.showSideNumbersLabelText = function () {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort) {
                        if (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Gauge.MIN_VALUE = -Infinity;
            Gauge.MAX_VALUE = +Infinity;
            Gauge.MinDistanceFromBottom = 10;
            Gauge.MinWidthForTargetLabel = 150;
            Gauge.DefaultTopBottomMargin = 20;
            Gauge.DefaultLeftRightMargin = 45;
            Gauge.ReducedLeftRightMargin = 15;
            Gauge.DEFAULT_MAX = 1;
            Gauge.DEFAULT_MIN = 0;
            Gauge.VisualClassName = 'gauge';
            Gauge.DefaultStyleProperties = {
                transition: {
                    ease: 'bounce'
                },
                arcColors: {
                    background: '#e9e9e9',
                    foreground: '#00B8AA'
                },
                targetLine: {
                    show: true,
                    color: '#666666',
                    thickness: 2
                },
                labels: {
                    count: 2,
                    padding: 5,
                    fontSize: visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                },
                kpiBands: {
                    show: false,
                    separationRadians: Math.PI / 128,
                    thickness: 5
                },
            };
            Gauge.DefaultTargetSettings = {
                min: 0,
                max: 1,
                target: undefined
            };
            Gauge.DefaultDataPointSettings = {
                fillColor: Gauge.DefaultStyleProperties.arcColors.foreground,
                targetColor: Gauge.DefaultStyleProperties.targetLine.color
            };
            Gauge.InnerRadiusFactor = 0.7;
            Gauge.KpiBandDistanceFromMainArc = 2;
            Gauge.MainGaugeGroupClassName = 'mainGroup';
            Gauge.LabelText = createClassAndSelector('labelText');
            Gauge.TargetConnector = createClassAndSelector('targetConnector');
            Gauge.TargetText = createClassAndSelector('targetText');
            /** Note: Public for testability */
            Gauge.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            return Gauge;
        }());
        visuals.Gauge = Gauge;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Utility = jsCommon.Utility;
        var ImageVisual = (function () {
            function ImageVisual() {
                this.scalingType = visuals.imageScalingType.normal;
            }
            ImageVisual.prototype.init = function (options) {
                this.element = options.element;
            };
            ImageVisual.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'imageScaling':
                        return this.enumerateImageScaling();
                }
                return null;
            };
            ImageVisual.prototype.enumerateImageScaling = function () {
                return [{
                        selector: null,
                        objectName: 'imageScaling',
                        properties: {
                            imageScalingType: this.scalingType,
                        }
                    }];
            };
            ImageVisual.prototype.update = function (options) {
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0)
                    return;
                var objects = dataViews[0].metadata.objects;
                if (!objects || !objects.general)
                    return;
                var div = this.imageBackgroundElement;
                if (!div) {
                    div = $("<div class='imageBackground' />");
                    this.imageBackgroundElement = div;
                    this.imageBackgroundElement.appendTo(this.element);
                }
                var viewport = options.viewport;
                div.css('height', viewport.height);
                if (objects.imageScaling)
                    this.scalingType = objects.imageScaling.imageScalingType.toString();
                else
                    this.scalingType = visuals.imageScalingType.normal;
                var imageUrl = objects.general.imageUrl;
                if (Utility.isValidImageDataUrl(imageUrl))
                    div.css("backgroundImage", "url(" + imageUrl + ")");
                if (this.scalingType === visuals.imageScalingType.fit)
                    div.css("background-size", "100% 100%");
                else if (this.scalingType === visuals.imageScalingType.fill)
                    div.css("background-size", "cover");
                else
                    div.css("background-size", "contain");
            };
            return ImageVisual;
        }());
        visuals.ImageVisual = ImageVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var KPIStatusWithHistory = (function () {
            function KPIStatusWithHistory() {
            }
            KPIStatusWithHistory.prototype.init = function (options) {
                KPIStatusWithHistory.getLocalizedString = options.host.getLocalizedString;
                this.rootElement = d3.select(options.element.get(0)).append('div').attr('text-align', 'center').classed('kpiVisual', true);
                this.svg = this.rootElement.append('svg');
                var mainGroupElement = this.mainGroupElement = this.svg.append('g');
                this.areaFill = mainGroupElement.append("path");
                this.textContainer = this.rootElement.append("div").classed('textContainer', true);
                this.indicatorTextContainer = this.textContainer.append("div").classed('indicatorText', true);
                this.absoluteGoalDistanceText = this.textContainer.append("div").classed('goalText', true);
                this.kpiActualText = this.indicatorTextContainer.append("div").attr('id', 'indicatorText');
                this.initIcons();
                this.host = options.host;
            };
            KPIStatusWithHistory.prototype.update = function (options) {
                if (!options.dataViews || !options.dataViews[0])
                    return;
                var dataView = this.dataView = options.dataViews[0];
                var viewport = options.viewport;
                // We must have at least one measure
                if ((!dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1) &&
                    (!dataView.categorical || !dataView.categorical.categories || dataView.categorical.categories.length < 1)) {
                    this.svg.attr("visibility", "hidden");
                    this.textContainer.attr("style", "display:none");
                    return;
                }
                this.svg.attr("visibility", "visible");
                var kpiViewModel = KPIStatusWithHistory.converter(dataView, viewport, KPIStatusWithHistory.getProp_KPIDirection(dataView));
                this.render(kpiViewModel, viewport);
            };
            KPIStatusWithHistory.prototype.initIcons = function () {
                this.successMarkIcon = this.indicatorTextContainer.append("div").classed('powervisuals-glyph checkmark kpi-visual-green', true);
                this.betweenIcon = this.indicatorTextContainer.append('div').classed('powervisuals-glyph circle-small kpi-visual-yellow', true);
                this.exclamationMarkIcon = this.indicatorTextContainer.append("div").classed('powervisuals-glyph exclamation kpi-visual-red', true);
                this.successMarkIcon.attr('style', 'display:none');
                this.betweenIcon.attr('style', 'display:none');
                this.exclamationMarkIcon.attr('style', 'display:none');
            };
            KPIStatusWithHistory.prototype.render = function (kpiViewModel, viewport) {
                this.setShowDataMissingWarning(!(kpiViewModel.indicatorExists && kpiViewModel.trendExists));
                if (kpiViewModel.dataPoints.length === 0 || !kpiViewModel.historyExists || !kpiViewModel.indicatorExists || !kpiViewModel.trendExists) {
                    this.areaFill.attr("visibility", "hidden");
                    this.svg.attr("visibility", "hidden");
                    this.textContainer.attr("style", "display:none");
                    return;
                }
                this.svg.attr({
                    'height': viewport.height,
                    'width': viewport.width,
                });
                var status = KPIStatusWithHistory.status.NOGOAL;
                if (kpiViewModel.targetExists && kpiViewModel.indicatorExists && kpiViewModel.trendExists) {
                    status = GetStatus(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType);
                }
                var actualText = kpiViewModel.formattedValue;
                var calculatedHeight = KPIStatusWithHistory.indicatorTextSizeInPx;
                this.textContainer
                    .attr('style', "width:" + viewport.width + "px;" +
                    "top:" + ((viewport.height - calculatedHeight) / 2) + "px");
                this.kpiActualText
                    .classed(KPIStatusWithHistory.allColorClasses, false)
                    .classed(GetTextColorClassByStatus(status), true)
                    .attr("text-anchor", "middle")
                    .text(actualText);
                var icon = null;
                switch (status) {
                    case KPIStatusWithHistory.status.INCREASE:
                        icon = this.successMarkIcon;
                        this.exclamationMarkIcon.attr("style", "display:none");
                        this.betweenIcon.attr("style", "display:none");
                        break;
                    case KPIStatusWithHistory.status.IN_BETWEEN:
                        icon = this.betweenIcon;
                        this.exclamationMarkIcon.attr("style", "display:none");
                        this.successMarkIcon.attr("style", "display:none");
                        break;
                    case KPIStatusWithHistory.status.DROP:
                        icon = this.exclamationMarkIcon;
                        this.successMarkIcon.attr("style", "display:none");
                        this.betweenIcon.attr("style", "display:none");
                        break;
                    default:
                        this.exclamationMarkIcon.attr("style", "display:none");
                        this.successMarkIcon.attr("style", "display:none");
                        this.betweenIcon.attr("style", "display:none");
                }
                if (icon) {
                    icon.attr('style', 'font-size:12px');
                }
                var shownGoalString = kpiViewModel.showGoal ? kpiViewModel.formattedGoalString + " " : "";
                var shownDistanceFromGoalString = kpiViewModel.showDistanceFromGoal ? getDistanceFromGoalInPercentageString(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType) : "";
                this.absoluteGoalDistanceText
                    .attr("text-anchor", "middle")
                    .text(shownGoalString + shownDistanceFromGoalString);
                if (kpiViewModel.showTrendLine) {
                    var area = d3.svg.area()
                        .x(function (d) { return d.x; })
                        .y0(viewport.height)
                        .y1(function (d) { return d.y; });
                    this.areaFill
                        .classed(KPIStatusWithHistory.allColorClasses, false)
                        .classed(GetGraphColorClassByStatus(status), true)
                        .attr("d", area(kpiViewModel.dataPoints))
                        .attr("stroke", "none")
                        .attr("visibility", "visible")
                        .attr('fill-opacity', 0.2);
                }
                else {
                    this.areaFill.attr("visibility", "hidden");
                }
            };
            KPIStatusWithHistory.prototype.setShowDataMissingWarning = function (show) {
                this.host.setWarnings(show ? [new visuals.VisualKPIDataMissingWarning()] : []);
            };
            KPIStatusWithHistory.getDefaultFormatSettings = function () {
                return {
                    labelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, visuals.Card.DefaultStyle.value.color),
                    textSize: 27,
                    wordWrap: false
                };
            };
            KPIStatusWithHistory.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                        var column = _a[_i];
                        if (column.isMeasure) {
                            return column;
                        }
                    }
                }
            };
            KPIStatusWithHistory.getFormatString = function (column) {
                debug.assertAnyValue(column, 'column');
                return visuals.valueFormatter.getFormatString(column, visuals.AnimatedText.formatStringProp);
            };
            KPIStatusWithHistory.getProp_Show_KPIGoal = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIGoal, true);
                }
                return true;
            };
            KPIStatusWithHistory.getProp_Show_KPITrendLine = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPITrendLine, true);
                }
                return true;
            };
            KPIStatusWithHistory.getProp_Show_KPIDistance = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIDistance, true);
                }
                return true;
            };
            KPIStatusWithHistory.getProp_KPIDirection = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.directionTypeStringProp, visuals.kpiDirection.positive);
                }
                return visuals.kpiDirection.positive;
            };
            KPIStatusWithHistory.getProp_Indicator_DisplayUnits = function (dataView) {
                KPIStatusWithHistory.initDefaultLabelSettings();
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorDisplayUnitsProp, KPIStatusWithHistory.defaultLabelSettings.displayUnits);
                }
                return KPIStatusWithHistory.defaultLabelSettings.displayUnits;
            };
            KPIStatusWithHistory.getProp_Indicator_Precision = function (dataView) {
                KPIStatusWithHistory.initDefaultLabelSettings();
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorPrecisionProp, KPIStatusWithHistory.defaultLabelSettings.precision);
                }
                return KPIStatusWithHistory.defaultLabelSettings.precision;
            };
            KPIStatusWithHistory.initDefaultLabelSettings = function () {
                if (!KPIStatusWithHistory.defaultCardFormatSetting) {
                    KPIStatusWithHistory.defaultCardFormatSetting = KPIStatusWithHistory.getDefaultFormatSettings();
                    KPIStatusWithHistory.defaultLabelSettings = KPIStatusWithHistory.defaultCardFormatSetting.labelSettings;
                }
            };
            KPIStatusWithHistory.getFormattedValue = function (metaDataColumn, theValue, precision, displayUnits) {
                var isDefaultDisplayUnit = displayUnits === 0;
                var formatter = visuals.valueFormatter.create({
                    format: KPIStatusWithHistory.getFormatString(metaDataColumn),
                    value: displayUnits,
                    precision: precision,
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.WholeUnits,
                    formatSingleValues: isDefaultDisplayUnit ? true : false,
                    allowFormatBeautification: true,
                    columnType: metaDataColumn ? metaDataColumn.type : undefined
                });
                return formatter.format(theValue);
            };
            KPIStatusWithHistory.getFormattedGoalString = function (metaDataColumn, goals, precision, displayUnits) {
                if (!goals || goals.length === 0) {
                    return "";
                }
                var goalsString = KPIStatusWithHistory.getLocalizedString('Visual_KPI_Goal_Title') + ": " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[0], precision, displayUnits);
                if (goals.length === 2) {
                    goalsString += ", " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[1], precision, displayUnits);
                }
                return goalsString;
            };
            KPIStatusWithHistory.converter = function (dataView, viewPort, directionType) {
                var dataPoints = [];
                var catDv = dataView.categorical;
                var metaDataColumn = KPIStatusWithHistory.getMetaDataColumn(dataView);
                var formattedGoalString = "";
                var formattedValue = "";
                var targetExists = false;
                var indicatorExists = false;
                var trendExists = false;
                var historyExists = true;
                if (!dataView.categorical.categories) {
                    historyExists = false;
                }
                var values = catDv.values;
                var columns = dataView.metadata.columns;
                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var column = columns_1[_i];
                    if (DataRoleHelper.hasRole(column, 'Indicator')) {
                        indicatorExists = true;
                    }
                    if (DataRoleHelper.hasRole(column, 'TrendLine')) {
                        trendExists = true;
                    }
                }
                if (!indicatorExists || !trendExists || !values || values.length === 0 || !values[0].values || !dataView.categorical.values) {
                    return {
                        dataPoints: dataPoints,
                        directionType: directionType,
                        actual: 0,
                        goals: [],
                        formattedGoalString: formattedGoalString,
                        targetExists: targetExists,
                        historyExists: historyExists,
                        indicatorExists: indicatorExists,
                        trendExists: trendExists,
                        formattedValue: formattedValue,
                        showGoal: false,
                        showDistanceFromGoal: false,
                        showTrendLine: false
                    };
                }
                var category, categoryValues;
                if (historyExists) {
                    category = catDv.categories[0]; // This only works if we have a category axis
                    categoryValues = category.values;
                }
                var historyActualData = [];
                var historyGoalData = [];
                var indicatorColumns = KPIStatusWithHistory.getColumnsByRole(values, "Indicator");
                var goalColumns = KPIStatusWithHistory.getColumnsByRole(values, "Goal");
                if (goalColumns.length > 0) {
                    targetExists = true;
                }
                var actualValue;
                for (var i = 0, len = values[0].values.length; i < len; i++) {
                    actualValue = indicatorColumns[0].values[i];
                    var goals_1 = [];
                    for (var goalCnt = 0; goalCnt < goalColumns.length; goalCnt++) {
                        goals_1.push(goalColumns[goalCnt].values[i]);
                    }
                    historyGoalData.push(goals_1);
                    historyActualData.push(actualValue);
                }
                var maxActualData = Math.max.apply(Math, historyActualData);
                var minActualData = Math.min.apply(Math, historyActualData);
                var areaMaxHight = viewPort.height * KPIStatusWithHistory.trendAreaFilePercentage;
                var precision = KPIStatusWithHistory.getProp_Indicator_Precision(dataView);
                var displayUnits = KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView);
                for (var i = 0; i < historyActualData.length; i++) {
                    var yPos = areaMaxHight * (historyActualData[i] - minActualData) / (maxActualData - minActualData);
                    var selectorId = null;
                    if (historyExists) {
                        selectorId = visuals.SelectionId.createWithId(category.identity[i]).getSelector();
                    }
                    dataPoints.push({
                        x: i * viewPort.width / (historyActualData.length - 1),
                        y: viewPort.height - yPos,
                        actual: historyActualData[i],
                        goals: historyGoalData[i],
                    });
                }
                var actual, goals;
                if (dataPoints.length > 0) {
                    actual = dataPoints[dataPoints.length - 1].actual;
                    goals = dataPoints[dataPoints.length - 1].goals;
                }
                if (dataPoints.length === 1) {
                    historyExists = false;
                }
                formattedValue = KPIStatusWithHistory.getFormattedValue(metaDataColumn, actual, precision, displayUnits);
                formattedGoalString = KPIStatusWithHistory.getFormattedGoalString(metaDataColumn, goals, precision, displayUnits);
                var showGoal = KPIStatusWithHistory.getProp_Show_KPIGoal(dataView);
                var showDistanceFromGoal = KPIStatusWithHistory.getProp_Show_KPIDistance(dataView);
                var showTrendLine = KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView);
                return {
                    dataPoints: dataPoints,
                    directionType: directionType,
                    actual: actual,
                    goals: goals,
                    formattedGoalString: formattedGoalString,
                    targetExists: targetExists,
                    historyExists: historyExists,
                    indicatorExists: indicatorExists,
                    trendExists: trendExists,
                    formattedValue: formattedValue,
                    showGoal: showGoal,
                    showDistanceFromGoal: showDistanceFromGoal,
                    showTrendLine: showTrendLine
                };
            };
            KPIStatusWithHistory.getColumnsByRole = function (values, roleString) {
                var retval = [];
                for (var i = 0; i < values.length; i++) {
                    if (DataRoleHelper.hasRole(values[i].source, roleString)) {
                        retval.push(values[i]);
                    }
                }
                return retval;
            };
            KPIStatusWithHistory.prototype.enumerateObjectInstances = function (options) {
                var instances = [];
                var dataView = this.dataView;
                switch (options.objectName) {
                    case 'indicator':
                        instances.push({
                            selector: null,
                            objectName: 'indicator',
                            properties: {
                                indicatorDisplayUnits: KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView),
                                indicatorPrecision: KPIStatusWithHistory.getProp_Indicator_Precision(dataView)
                            }
                        });
                    case 'trendline':
                        instances.push({
                            selector: null,
                            objectName: 'trendline',
                            properties: {
                                show: KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView)
                            }
                        });
                    case 'goals':
                        instances.push({
                            selector: null,
                            objectName: 'goals',
                            properties: {
                                showGoal: KPIStatusWithHistory.getProp_Show_KPIGoal(dataView),
                                showDistance: KPIStatusWithHistory.getProp_Show_KPIDistance(dataView)
                            }
                        });
                    case 'status':
                        instances.push({
                            selector: null,
                            objectName: 'status',
                            properties: {
                                direction: KPIStatusWithHistory.getProp_KPIDirection(dataView)
                            }
                        });
                }
                return instances;
            };
            KPIStatusWithHistory.prototype.destroy = function () {
                this.svg = null;
            };
            KPIStatusWithHistory.directionTypeStringProp = { objectName: 'status', propertyName: 'direction' };
            KPIStatusWithHistory.showKPIGoal = { objectName: 'goals', propertyName: 'showGoal' };
            KPIStatusWithHistory.showKPIDistance = { objectName: 'goals', propertyName: 'showDistance' };
            KPIStatusWithHistory.showKPITrendLine = { objectName: 'trendline', propertyName: 'show' };
            KPIStatusWithHistory.indicatorDisplayUnitsProp = { objectName: 'indicator', propertyName: 'indicatorDisplayUnits' };
            KPIStatusWithHistory.indicatorPrecisionProp = { objectName: 'indicator', propertyName: 'indicatorPrecision' };
            KPIStatusWithHistory.status = { INCREASE: "increase", DROP: "drop", IN_BETWEEN: "in-between", NOGOAL: "no-goal" };
            KPIStatusWithHistory.statusBandingType = { Below: "BELOW", Above: "ABOVE" };
            KPIStatusWithHistory.actualTextConsts = { VERTICAL_OFFSET_FROM_HALF_HEIGHT: 20, FONT_WIDTH_FACTOR: 14, RIGHT_MARGIN: 10 };
            KPIStatusWithHistory.kpiRedClass = 'kpi-visual-red';
            KPIStatusWithHistory.kpiYellowClass = 'kpi-visual-yellow';
            KPIStatusWithHistory.kpiGreenClass = 'kpi-visual-green';
            KPIStatusWithHistory.kpiTextGreyClass = 'kpi-visual-text-grey';
            KPIStatusWithHistory.kpiGraphGreyClass = 'kpi-visual-graph-grey';
            KPIStatusWithHistory.allColorClasses = KPIStatusWithHistory.kpiRedClass + ' ' + KPIStatusWithHistory.kpiYellowClass + ' ' + KPIStatusWithHistory.kpiGreenClass + ' ' + KPIStatusWithHistory.kpiTextGreyClass + ' ' + KPIStatusWithHistory.kpiGraphGreyClass;
            KPIStatusWithHistory.trendAreaFilePercentage = 1;
            KPIStatusWithHistory.estimatedIconHeightInPx = 9;
            KPIStatusWithHistory.indicatorTextSizeInPx = 60;
            return KPIStatusWithHistory;
        }());
        visuals.KPIStatusWithHistory = KPIStatusWithHistory;
        function GetStatus(actual, goals, directionType) {
            if (!goals || goals.length === 0) {
                return KPIStatusWithHistory.status.NOGOAL;
            }
            var maxGoal, minGoal;
            if (goals.length === 2) {
                maxGoal = Math.max.apply(Math, goals);
                minGoal = Math.min.apply(Math, goals);
                if (actual >= minGoal && actual <= maxGoal) {
                    return KPIStatusWithHistory.status.IN_BETWEEN;
                }
            }
            else {
                maxGoal = goals[0];
                minGoal = goals[0];
            }
            switch (directionType) {
                case visuals.kpiDirection.positive:
                    if (actual < minGoal) {
                        return KPIStatusWithHistory.status.DROP;
                    }
                    break;
                case visuals.kpiDirection.negative:
                    if (actual > maxGoal) {
                        return KPIStatusWithHistory.status.DROP;
                    }
                    break;
                default:
                    break;
            }
            return KPIStatusWithHistory.status.INCREASE;
        }
        function getDistanceFromGoalInPercentageString(actual, goals, directionType) {
            if (!goals || goals.length !== 1 || goals[0] === 0) {
                return "";
            }
            var sign = "+";
            var distance;
            var goal = goals[0];
            distance = Math.abs(actual - goal);
            switch (directionType) {
                case visuals.kpiDirection.positive:
                    if (actual < goal) {
                        sign = "-";
                    }
                    break;
                case visuals.kpiDirection.negative:
                    if (actual > goal) {
                        sign = "-";
                    }
                    break;
            }
            var percent = Number((100 * distance / goal).toFixed(2));
            return "(" + sign + percent + "%)";
        }
        function GetTextColorClassByStatus(status) {
            switch (status) {
                case KPIStatusWithHistory.status.NOGOAL:
                    return KPIStatusWithHistory.kpiTextGreyClass;
                case KPIStatusWithHistory.status.INCREASE:
                    return KPIStatusWithHistory.kpiGreenClass;
                case KPIStatusWithHistory.status.IN_BETWEEN:
                    return KPIStatusWithHistory.kpiYellowClass;
                case KPIStatusWithHistory.status.DROP:
                    return KPIStatusWithHistory.kpiRedClass;
            }
        }
        function GetGraphColorClassByStatus(status) {
            switch (status) {
                case KPIStatusWithHistory.status.NOGOAL:
                    return KPIStatusWithHistory.kpiGraphGreyClass;
                case KPIStatusWithHistory.status.INCREASE:
                    return KPIStatusWithHistory.kpiGreenClass;
                case KPIStatusWithHistory.status.IN_BETWEEN:
                    return KPIStatusWithHistory.kpiYellowClass;
                case KPIStatusWithHistory.status.DROP:
                    return KPIStatusWithHistory.kpiRedClass;
            }
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        ;
        /**
         * Renders a data series as a line visual.
         */
        var LineChart = (function () {
            function LineChart(options) {
                var _this = this;
                this.deferDragMoveOperation = jsCommon.DeferUtility.deferUntilNextFrame(function () {
                    if (_this.lastDragMoveXPosition) {
                        var index = _this.findIndex(_this.lastDragMoveXPosition - _this.margin.left);
                        _this.selectColumn(index);
                        _this.lastDragMoveXPosition = undefined;
                    }
                });
                this.isScrollable = options.isScrollable ? options.isScrollable : false;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.lineType = options.chartType ? options.chartType : 1 /* default */;
                this.interactivityService = options.interactivityService;
                this.animator = options.animator;
                this.lineChartLabelDensityEnabled = options.lineChartLabelDensityEnabled;
                this.lineClassAndSelector = LineChart.LineClassSelector;
            }
            LineChart.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                dataViewMapping.categorical.dataVolume = 4;
                if (visuals.CartesianChart.detectScalarMapping(dataViewMapping)) {
                    var dataViewCategories = dataViewMapping.categorical.categories;
                    dataViewCategories.dataReductionAlgorithm = { sample: {} };
                }
            };
            LineChart.getSortableRoles = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!_.isEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects = void 0;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    //TODO: line chart should be sortable by X if it has scalar axis
                    // But currently it doesn't support this. Always return 'category'
                    // once it is supported.
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType))
                        return ['Category', 'Y'];
                }
                return null;
            };
            LineChart.converter = function (dataView, blankCategoryValue, colors, isScalar, interactivityService, shouldCalculateStacked, isComboChart, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0
                    ? categorical.categories[0]
                    : {
                        source: undefined,
                        values: [blankCategoryValue],
                        identity: undefined,
                    };
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source, isScalar);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                var categoryData = [];
                var series = [];
                var seriesLen = categorical.values ? categorical.values.length : 0;
                var hasDynamicSeries = !!(categorical.values && categorical.values.source);
                var values = categorical.values;
                var defaultLabelSettings = visuals.dataLabelUtils.getDefaultLineChartLabelSettings(isComboChart);
                var defaultSeriesColor;
                if (dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    // If the line layer is in a combo chart, the "Default Column Color" slice's value (lineChartProps.dataPoint.defaultColor) will not affect the line series as well
                    defaultSeriesColor = isComboChart ? undefined : powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.dataPoint.defaultColor);
                    var labelsObj = objects['labels'];
                    visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelsObj, defaultLabelSettings);
                }
                var colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultSeriesColor);
                var grouped;
                if (dataView.categorical.values)
                    grouped = dataView.categorical.values.grouped();
                var stackedValues;
                if (shouldCalculateStacked) {
                    //initialize array with zeros
                    stackedValues = categorical.values && categorical.values.length > 0 ? _.times(categorical.values[0].values.length, function () { return 0; }) : [];
                }
                for (var seriesIndex = 0; seriesIndex < seriesLen; seriesIndex++) {
                    var column = categorical.values[seriesIndex];
                    var valuesMetadata = column.source;
                    var dataPoints = [];
                    var groupedIdentity = grouped[seriesIndex];
                    var identity = hasDynamicSeries && groupedIdentity
                        ? visuals.SelectionId.createWithIdAndMeasure(groupedIdentity.identity, column.source.queryName)
                        : visuals.SelectionId.createWithMeasure(column.source.queryName);
                    var key = identity.getKey();
                    var color = this.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity);
                    var seriesLabelSettings = void 0;
                    if (!hasDynamicSeries) {
                        var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
                        var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
                        if (labelObjects) {
                            seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
                            visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
                        }
                    }
                    var dataPointLabelSettings = (seriesLabelSettings) ? seriesLabelSettings : defaultLabelSettings;
                    var useHighlightValues = column.highlights && column.highlights.length > 0;
                    // NOTE: line capabilities don't allow highlights, but comboChart does - so only use highlight values if we are in "combo" mode
                    var valuesArray = useHighlightValues ? column.highlights : column.values;
                    for (var categoryIndex = 0, len = valuesArray.length; categoryIndex < len; categoryIndex++) {
                        var categoryValue = categoryValues[categoryIndex];
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(valuesArray[categoryIndex]);
                        // When Scalar, skip null categories and null values so we draw connected lines and never draw isolated dots.
                        if (isScalar && (categoryValue == null || value == null))
                            continue;
                        // ignore variant measures
                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
                            continue;
                        var categorical_1 = dataView.categorical;
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical_1, categoryValue, value, null, null, seriesIndex);
                        }
                        var categoryKey = category && !_.isEmpty(category.identity) && category.identity[categoryIndex] ? category.identity[categoryIndex].key : categoryIndex;
                        var dataPoint = {
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: value,
                            categoryIndex: categoryIndex,
                            seriesIndex: seriesIndex,
                            tooltipInfo: tooltipInfo,
                            selected: false,
                            identity: identity,
                            key: JSON.stringify({ series: key, category: categoryKey }),
                            labelFill: dataPointLabelSettings.labelColor,
                            labelFormatString: valuesMetadata.format,
                            labelSettings: dataPointLabelSettings
                        };
                        if (shouldCalculateStacked) {
                            stackedValues[categoryIndex] += value;
                            dataPoint.stackedValue = stackedValues[categoryIndex];
                        }
                        if (category.objects && category.objects[categoryIndex]) {
                            dataPoint['pointColor'] = powerbi.DataViewObjects.getFillColor(category.objects[categoryIndex], visuals.lineChartProps.dataPoint.fill);
                        }
                        dataPoints.push(dataPoint);
                        if (!categoryData[categoryIndex]) {
                            categoryData[categoryIndex] = dataPoint;
                        }
                    }
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(dataPoints);
                    }
                    if (dataPoints.length > 0) {
                        series.push({
                            displayName: valuesMetadata.displayName,
                            key: key,
                            lineIndex: seriesIndex,
                            color: color,
                            xCol: category.source,
                            yCol: column.source,
                            data: dataPoints,
                            identity: identity,
                            selected: false,
                            labelSettings: seriesLabelSettings,
                        });
                    }
                }
                xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
                // Convert to DataViewMetadataColumn
                var valuesMetadataArray = [];
                if (values) {
                    for (var i = 0; i < values.length; i++) {
                        if (values[i] && values[i].source && values[i].source.displayName) {
                            valuesMetadataArray.push({ displayName: values[i].source.displayName });
                        }
                    }
                }
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(series);
                }
                return {
                    series: series,
                    isScalar: isScalar,
                    dataLabelsSettings: defaultLabelSettings,
                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
                    hasDynamicSeries: hasDynamicSeries,
                    categoryMetadata: category.source,
                    categories: categoryValues,
                    categoryData: categoryData,
                };
            };
            LineChart.getInteractiveLineChartDomElement = function (element) {
                return element.children("svg").get(0);
            };
            LineChart.getColor = function (colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
                var objects;
                if (hasDynamicSeries) {
                    if (grouped && grouped[seriesIndex])
                        objects = grouped[seriesIndex].objects;
                }
                else if (values[seriesIndex]) {
                    objects = values[seriesIndex].source.objects;
                }
                return hasDynamicSeries && groupedIdentity
                    ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name)
                    : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
            };
            LineChart.createStackedValueDomain = function (data) {
                debug.assertValue(data, 'data');
                if (data.length === 0)
                    return null;
                var minY = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.stackedValue; }); });
                var maxY = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.stackedValue; }); });
                return [minY, maxY];
            };
            LineChart.prototype.init = function (options) {
                var _this = this;
                this.options = options;
                this.element = options.element;
                this.cartesainSVG = options.svg;
                this.host = options.host;
                this.currentViewport = options.viewport;
                this.colors = options.style.colorPalette.dataColors;
                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                this.cartesianVisualHost = options.cartesianHost;
                var chartType = options.chartType;
                this.isComboChart = chartType === 10 /* ComboChart */ || chartType === 13 /* LineClusteredColumnCombo */ || chartType === 14 /* LineStackedColumnCombo */;
                var svg = options.svg;
                svg.classed(LineChart.ClassName, true);
                var graphicsContextParent = this.mainGraphicsSVG = svg.append('svg')
                    .classed('lineChartSVG', true);
                if (!this.isComboChart && !this.isInteractiveChart) {
                    this.overlayRect = graphicsContextParent
                        .append(LineChart.RectOverlayName)
                        .style("opacity", visuals.SVGUtil.AlmostZero);
                }
                this.mainGraphicsContext = graphicsContextParent
                    .append('g')
                    .classed(LineChart.MainGraphicsContextClassName, true);
                this.hoverLineContext = svg.append('g')
                    .classed('hover-line', true);
                this.hoverLineContext.append(LineChart.LineElementName)
                    .attr("x1", 0).attr("x2", 0)
                    .attr("y1", 0).attr("y2", 0);
                var hoverLine = this.hoverLine = this.hoverLineContext.select(LineChart.LineElementName);
                if (this.isInteractiveChart) {
                    hoverLine.classed('interactive', true);
                }
                hoverLine.style('opacity', visuals.SVGUtil.AlmostZero);
                // define circles object - which will hold the handle circles.
                // this object will be populated on render() function, with number of circles which matches the nubmer of lines.
                this.selectionCircles = [];
                this.xAxisProperties = {
                    axis: null,
                    scale: null,
                    axisType: null,
                    formatter: null,
                    graphicsContext: null,
                    values: null,
                    axisLabel: null,
                    isCategoryAxis: true
                };
                if (this.isInteractiveChart) {
                    var rootSvg_1 = LineChart.getInteractiveLineChartDomElement(this.element);
                    var dragMove = function () {
                        _this.lastDragMoveXPosition = d3.mouse(rootSvg_1)[0];
                        _this.deferDragMoveOperation();
                    };
                    // assign drag and onClick events
                    var drag = d3.behavior.drag()
                        .origin(Object)
                        .on("drag", dragMove);
                    d3.select(rootSvg_1)
                        .style('touch-action', 'none')
                        .call(drag)
                        .on('click', dragMove);
                }
                // Internet Explorer and Edge use the stroke edge, not the path edge for the mouse coordinate's origin.
                //   We need to adjust mouse events on the interactivity lines to account for this.
                this.shouldAdjustMouseCoordsOnPathsForStroke = !jsCommon.BrowserUtils.isChrome();
            };
            LineChart.prototype.setData = function (dataViews) {
                this.data = {
                    series: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLineChartLabelSettings(this.isComboChart),
                    axesLabels: { x: null, y: null },
                    hasDynamicSeries: false,
                    categories: [],
                    categoryMetadata: undefined,
                    categoryData: [],
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        if (dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical;
                            var dvCategories = dataViewCat.categories;
                            var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                            if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                                categoryType = dvCategories[0].source.type;
                            var convertedData = LineChart.converter(dataView, visuals.valueFormatter.format(null), this.cartesianVisualHost.getSharedColors(), visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.lineChartProps.categoryAxis.axisType, categoryType), this.interactivityService, EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */), this.isComboChart);
                            this.data = convertedData;
                        }
                    }
                }
            };
            LineChart.prototype.calculateLegend = function () {
                return this.createLegendDataPoints(0); // start with index 0
            };
            LineChart.prototype.hasLegend = function () {
                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
            };
            LineChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var catgSize = endIndex - startIndex;
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = LineChart.sliceSeries(data.series, catgSize, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            LineChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                var data = this.data;
                var viewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0;
                var categoryWidth = visuals.CartesianChart.MinOrdinalRectThickness;
                var isScalar = this.data.isScalar;
                var trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow;
                var preferredPlotArea = this.getPreferredPlotArea(isScalar, origCatgSize, categoryWidth);
                this.clippedData = undefined;
                if (data && !isScalar && !this.isScrollable && trimOrdinalDataOnOverflow) {
                    // trim data that doesn't fit on dashboard
                    var categoryCount = this.getCategoryCount(origCatgSize);
                    var catgSize = Math.min(origCatgSize, categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = this.clippedData = powerbi.Prototype.inherit(data);
                        this.clippedData.series = LineChart.sliceSeries(data.series, catgSize);
                    }
                }
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (data.series && data.series.length > 0) {
                    xMetaDataColumn = data.series[0].xCol;
                    yMetaDataColumn = data.series[0].yCol;
                }
                var valueDomain = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */) ? LineChart.createStackedValueDomain(data.series) : visuals.AxisHelper.createValueDomain(data.series, false);
                var hasZeroValueInYDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(valueDomain);
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, valueDomain, options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, visuals.lineChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: options.valueAxisScaleType,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision,
                    shouldClamp: false,
                });
                var xDomain = visuals.AxisHelper.createDomain(data.series, this.xAxisProperties.axisType, this.data.isScalar, options.forcedXDomain, options.ensureXDomain);
                var hasZeroValueInXDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(xDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, visuals.lineChartProps.general.formatString),
                    outerPadding: this.data.isScalar ? LineChart.ScalarOuterPadding : 0,
                    isScalar: this.data.isScalar,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function (index, type) { return visuals.CartesianHelper.lookupXValue(_this.data, index, type, _this.data.isScalar); },
                    categoryThickness: visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.getAvailableWidth(), xDomain, isScalar, trimOrdinalDataOnOverflow),
                    isCategoryAxis: true,
                    scaleType: options.categoryAxisScaleType,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                });
                this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null;
                this.xAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInXDomain;
                this.yAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInYDomain;
                return [this.xAxisProperties, this.yAxisProperties];
            };
            LineChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        this.enumerateDataPoints(enumeration);
                        break;
                    case 'labels':
                        this.enumerateDataLabels(enumeration);
                        break;
                }
            };
            LineChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data || !data.series || data.series.length === 0)
                    return;
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var singleSeriesData = data.series;
                var seriesLength = singleSeriesData.length;
                for (var i = 0; i < seriesLength; i++) {
                    var selector = visuals.ColorHelper.normalizeSelector(singleSeriesData[i].identity.getSelector());
                    var label = visuals.converterHelper.getFormattedLegendLabel(singleSeriesData[i].yCol, this.dataViewCat.values, formatStringProp);
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        displayName: label,
                        selector: selector,
                        properties: {
                            fill: { solid: { color: data.defaultSeriesColor || singleSeriesData[i].color } }
                        },
                    });
                }
            };
            LineChart.prototype.enumerateDataLabels = function (enumeration) {
                var data = this.data, labelSettings = this.data.dataLabelsSettings, seriesCount = data.series.length, showLabelPerSeries = this.showLabelPerSeries();
                //Draw default settings
                visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries));
                if (seriesCount === 0)
                    return;
                //Draw series settings
                if (showLabelPerSeries && labelSettings.showLabelPerSeries) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i], labelSettings_2 = (series.labelSettings) ? series.labelSettings : this.data.dataLabelsSettings;
                        enumeration.pushContainer({ displayName: series.displayName });
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_2, series));
                        enumeration.popContainer();
                    }
                }
            };
            LineChart.prototype.supportsTrendLine = function () {
                var data = this.data;
                if (!data)
                    return false;
                return data.isScalar && data.series.length === 1;
            };
            LineChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, series, showAll) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: true,
                    displayUnits: true,
                    precision: true,
                    selector: series && series.identity ? series.identity.getSelector() : null,
                    showAll: showAll,
                    fontSize: true,
                    labelDensity: this.lineChartLabelDensityEnabled,
                };
            };
            LineChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            LineChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            LineChart.prototype.render = function (suppressAnimations) {
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (this.data.categoryData.length !== this.previousCategoryCount) {
                    duration = 0;
                }
                this.previousCategoryCount = this.data.categoryData.length;
                var result;
                if (!this.isInteractiveChart)
                    result = this.renderNew(duration);
                else
                    result = this.renderOld(duration);
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return result;
            };
            LineChart.prototype.renderNew = function (duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data)
                    return;
                var dataPointCount = data.categories.length * data.series.length;
                if (dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate) {
                    // Too many data points to animate.
                    duration = 0;
                }
                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var width = viewport.width - (margin.left + margin.right);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var horizontalOffset = this.getXOfFirstCategory();
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var renderAreas = EnumExtensions.hasFlag(this.lineType, 2 /* area */) || EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var xPosition = function (d) { return xScale(_this.getXValue(d)) + horizontalOffset; };
                var y0Position, yPosition;
                if (isStackedArea) {
                    y0Position = function (d) { return yScale(d.stackedValue - d.value); };
                    yPosition = function (d) { return yScale(d.stackedValue); };
                }
                else {
                    y0Position = yScale(0);
                    yPosition = function (d) { return yScale(d.value); };
                }
                var area;
                if (renderAreas) {
                    area = d3.svg.area()
                        .x(xPosition)
                        .y0(y0Position)
                        .y1(yPosition)
                        .defined(function (d) { return d.value !== null; });
                }
                var line = d3.svg.line()
                    .x(xPosition)
                    .y(yPosition)
                    .defined(function (d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
                    line.interpolate('basis');
                    if (area) {
                        area.interpolate('basis');
                    }
                }
                this.mainGraphicsSVG
                    .attr('height', height)
                    .attr('width', width);
                var areas = undefined;
                // Render Areas
                if (renderAreas) {
                    areas = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector).data(data.series, function (d) { return d.identity.getKey(); });
                    areas.enter()
                        .append(LineChart.PathElementName)
                        .classed(LineChart.CategoryAreaSelector.class, true);
                    areas
                        .style('fill', function (d) { return d.color; })
                        .style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; })
                        .transition()
                        .ease('linear')
                        .duration(duration)
                        .attr('d', function (d) { return area(d.data); });
                    areas.exit()
                        .remove();
                }
                // Render Lines
                var lines = this.mainGraphicsContext.selectAll(this.lineClassAndSelector.selector).data(data.series, function (d) { return d.identity.getKey(); });
                lines.enter()
                    .append(LineChart.PathElementName)
                    .classed(this.lineClassAndSelector.class, true);
                lines
                    .style('stroke', function (d) { return d.color; })
                    .style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .transition()
                    .ease('linear')
                    .duration(duration)
                    .attr('d', function (d) {
                    return line(d.data);
                });
                lines.exit()
                    .remove();
                // Render extra lines that are wider and invisible used for better interactivity
                var interactivityLines;
                if (this.interactivityService) {
                    interactivityLines = this.mainGraphicsContext.selectAll(".interactivity-line").data(data.series, function (d) { return d.identity.getKey(); });
                    interactivityLines.enter()
                        .append(LineChart.PathElementName)
                        .classed('interactivity-line', true)
                        .style('stroke-width', LineChart.interactivityStrokeWidth);
                    interactivityLines
                        .attr('d', function (d) {
                        return line(d.data);
                    });
                    interactivityLines.exit()
                        .remove();
                }
                // Prepare grouping for dots
                var dotGroups = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector)
                    .data(data.series, function (d) { return d.identity.getKey(); });
                dotGroups.enter()
                    .append('g')
                    .classed(LineChart.CategorySelector.class, true);
                dotGroups.exit()
                    .remove();
                // Render dots
                var dots = dotGroups.selectAll(LineChart.CategoryValuePoint.selector)
                    .data(function (series) {
                    return series.data.filter(function (value, i) {
                        return _this.shouldDrawCircle(series, i);
                    });
                }, function (d) { return d.key; });
                dots.enter()
                    .append(LineChart.CircleElementName)
                    .classed(LineChart.CategoryValuePoint.class, true);
                dots
                    .style('fill', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                })
                    .style('fill-opacity', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                })
                    .transition()
                    .duration(duration)
                    .attr({
                    cx: function (d, i) { return xScale(_this.getXValue(d)) + horizontalOffset; },
                    cy: function (d, i) { return yScale(isStackedArea ? d.stackedValue : d.value); },
                    r: LineChart.CircleRadius
                });
                dots.exit()
                    .remove();
                // Render explicit dots
                var explicitDots;
                if (!this.isComboChart) {
                    explicitDots = dotGroups.selectAll(LineChart.CategoryPointSelector.selector)
                        .data(function (series) {
                        return _.filter(series.data, function (value) { return value.pointColor != null; });
                    }, function (d) { return d.key; });
                    explicitDots.enter()
                        .append(LineChart.CircleElementName)
                        .classed(LineChart.CategoryPointSelector.class, true);
                    explicitDots
                        .style('fill', function (d) { return d.pointColor; })
                        .transition()
                        .duration(duration)
                        .attr({
                        cx: function (d) { return xScale(_this.getXValue(d)); },
                        cy: function (d) { return yScale(isStackedArea ? d.stackedValue : d.value); },
                        r: LineChart.PointRadius
                    });
                    explicitDots.exit()
                        .remove();
                }
                // Add data labels
                var labelDataPointsGroups;
                if (data.dataLabelsSettings.show)
                    labelDataPointsGroups = this.createLabelDataPoints();
                if (this.tooltipsEnabled) {
                    if (!this.isComboChart) {
                        this.overlayRect
                            .attr({
                            x: 0,
                            width: width,
                            height: height
                        });
                        var seriesTooltipApplier = function (tooltipEvent) {
                            var pointX = tooltipEvent.elementCoordinates[0];
                            var index = _this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX);
                            var categoryData = _this.selectColumnForTooltip(index);
                            return _this.getSeriesTooltipInfo(categoryData);
                        };
                        var clearHoverLine = function () {
                            _this.hoverLine.style('opacity', visuals.SVGUtil.AlmostZero);
                            _this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).remove();
                        };
                        visuals.TooltipManager.addTooltip(this.mainGraphicsSVG, seriesTooltipApplier, true, clearHoverLine);
                    }
                    else {
                        var seriesTooltipApplier = function (tooltipEvent) {
                            var pointX = tooltipEvent.elementCoordinates[0];
                            return _this.getTooltipInfoForCombo(tooltipEvent, pointX);
                        };
                        if (interactivityLines)
                            visuals.TooltipManager.addTooltip(interactivityLines, seriesTooltipApplier, true);
                        visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                        if (explicitDots)
                            visuals.TooltipManager.addTooltip(explicitDots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    }
                }
                var dataPointsToBind = undefined;
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    // Register interactivity
                    dataPointsToBind = data.series.slice();
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                    }
                    behaviorOptions = {
                        lines: lines,
                        interactivityLines: interactivityLines,
                        dots: dots,
                        areas: areas,
                        tooltipOverlay: this.overlayRect,
                    };
                }
                return {
                    dataPoints: dataPointsToBind,
                    behaviorOptions: behaviorOptions,
                    labelDataPoints: [],
                    labelsAreNumeric: true,
                    labelDataPointGroups: labelDataPointsGroups,
                };
            };
            LineChart.prototype.renderOld = function (duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data)
                    return;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var area;
                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
                    area = d3.svg.area()
                        .x(function (d) { return xScale(_this.getXValue(d)); })
                        .y0(height)
                        .y1(function (d) { return yScale(d.value); })
                        .defined(function (d) { return d.value !== null; });
                }
                var line = d3.svg.line()
                    .x(function (d) {
                    return xScale(_this.getXValue(d));
                })
                    .y(function (d) {
                    return yScale(d.value);
                })
                    .defined(function (d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
                    line.interpolate('basis');
                    if (area) {
                        area.interpolate('basis');
                    }
                }
                var firstCategoryOffset = this.getXOfFirstCategory();
                this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(firstCategoryOffset, 0));
                this.mainGraphicsSVG.attr('height', this.getAvailableHeight())
                    .attr('width', this.getAvailableWidth());
                this.hoverLineContext.attr('transform', visuals.SVGUtil.translate(firstCategoryOffset, 0));
                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
                    var catAreaSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector)
                        .data(data.series, function (d) { return d.identity.getKey(); });
                    var catAreaEnter = catAreaSelect
                        .enter().append('g')
                        .classed(LineChart.CategoryAreaSelector.class, true);
                    catAreaEnter.append(LineChart.PathElementName);
                    var catAreaUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector);
                    catAreaUpdate.select(LineChart.PathElementName)
                        .transition()
                        .ease('linear')
                        .duration(duration)
                        .attr('d', function (d) { return area(d.data); })
                        .style('fill', function (d) { return d.color; })
                        .style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; });
                    catAreaSelect.exit().remove();
                }
                var catSelect = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector)
                    .data(data.series, function (d) { return d.identity.getKey(); });
                var catEnter = catSelect
                    .enter()
                    .append('g')
                    .classed(LineChart.CategorySelector.class, true);
                catEnter.append(LineChart.PathElementName);
                catEnter.selectAll(LineChart.CategoryValuePoint.selector)
                    .data(function (d) { return d.data; })
                    .enter()
                    .append(LineChart.CircleElementName)
                    .classed(LineChart.CategoryValuePoint.class, true);
                // moving this up to avoid using the svg path generator with NaN values
                // do not move this without validating that no errors are thrown in the browser console
                catSelect.exit().remove();
                // add the drag handle, if needed
                if (this.isInteractiveChart && !this.dragHandle) {
                    var handleTop = this.getAvailableHeight();
                    this.dragHandle = this.hoverLineContext.append('circle')
                        .attr('cx', 0)
                        .attr('cy', handleTop)
                        .attr('r', '6px')
                        .classed('drag-handle', true);
                }
                // Create the selection circles
                var linesCount = catSelect.data().length; // number of lines plotted
                while (this.selectionCircles.length < linesCount) {
                    var addedCircle = this.hoverLineContext.append(LineChart.CircleElementName)
                        .classed(LineChart.CircleClassName, true)
                        .attr('r', LineChart.CircleRadius).style('opacity', 0);
                    this.selectionCircles.push(addedCircle);
                }
                while (this.selectionCircles.length > linesCount) {
                    this.selectionCircles.pop().remove();
                }
                var catUpdate = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector);
                var lineSelection = catUpdate.select(LineChart.PathElementName)
                    .classed(this.lineClassAndSelector.class, true)
                    .style('stroke', function (d) { return d.color; })
                    .style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                lineSelection
                    .transition()
                    .ease('linear')
                    .duration(duration)
                    .attr('d', function (d) {
                    return line(d.data);
                });
                var that = this;
                var updateSelection = catUpdate.selectAll(LineChart.CategoryValuePoint.selector);
                var transitions = updateSelection
                    .style('fill', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                })
                    .style('fill-opacity', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                })
                    .transition()
                    .duration(duration)
                    .attr({
                    'cx': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? xScale(that.getXValue(d)) : 0;
                    },
                    'cy': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? yScale(d.value) : 0;
                    },
                    'r': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? LineChart.CircleRadius : 0;
                    }
                });
                if (this.isInteractiveChart && this.hasDataPoint(data.series)) {
                    var selectionSize_1 = updateSelection.size();
                    var endedTransitionCount_1 = 0;
                    transitions.each('end', function () {
                        // When transitions finish, and it's an interactive chart - select the last column (draw the legend and the handle)
                        endedTransitionCount_1++;
                        if (endedTransitionCount_1 === selectionSize_1) {
                            _this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(data.series), true);
                        }
                    });
                }
                var dataPoints = null;
                if (data.dataLabelsSettings.show) {
                    dataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        Array.prototype.push.apply(dataPoints, data.series[i].data);
                    }
                }
                catSelect.exit().remove();
                // # Code from here is taken from renderNew:
                // Add data labels
                var labelDataPointsGroups;
                if (data.dataLabelsSettings.show)
                    labelDataPointsGroups = this.createLabelDataPoints();
                return dataPoints == null ? null : {
                    dataPoints: dataPoints,
                    behaviorOptions: null,
                    labelDataPoints: null,
                    labelsAreNumeric: null,
                    labelDataPointGroups: labelDataPointsGroups
                };
            };
            /**
             * Note: Public for tests.
             */
            LineChart.prototype.getSeriesTooltipInfo = function (pointData) {
                var tooltipinfo = [];
                var maxNumberOfItems = 10; // to limit the number of rows we display
                // count to the maximum number of rows we can display
                var count = 0;
                for (var _i = 0, pointData_1 = pointData; _i < pointData_1.length; _i++) {
                    var point = pointData_1[_i];
                    if (count >= maxNumberOfItems)
                        break;
                    if (point.value != null) {
                        tooltipinfo.push({
                            header: point.category,
                            color: point.color,
                            displayName: point.label,
                            value: point.measure
                        });
                        count++;
                    }
                }
                if (tooltipinfo.length === 0)
                    return null; //don't draw an empty tooltip container
                return tooltipinfo;
            };
            /**
             * Note: Public for tests.
             */
            LineChart.prototype.getTooltipInfoForCombo = function (tooltipEvent, pointX) {
                // update pointX, the mouse coordinate, with the left-offset of the SVGRect from the x-scale space so we can use the d3.scale to get the index.
                var categoryIndex = this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX);
                var seriesData = tooltipEvent.data;
                var dataPoint;
                if (seriesData && seriesData.data && seriesData.data.length) {
                    dataPoint = _.find(seriesData.data, function (dp) { return dp.categoryIndex === categoryIndex; });
                }
                if (dataPoint)
                    return dataPoint.tooltipInfo;
                // return undefined so we don't show an empty tooltip
            };
            /**
             * Note: Public for tests.
             */
            LineChart.prototype.getCategoryIndexFromTooltipEvent = function (tooltipEvent, pointX) {
                if (tooltipEvent.data && tooltipEvent.data.categoryIndex != null) {
                    // Tooltip originated with a dot; simply return the categoryIndex from the dot's bound data
                    return tooltipEvent.data.categoryIndex;
                }
                var seriesData = tooltipEvent.data;
                var offsetX = 0; // Offset based on the firstCategoryOffset (since lines don't start at x = 0) as well as the offset due to lines that may not start at the first category
                if (seriesData && !_.isEmpty(seriesData.data) && this.xAxisProperties) {
                    // Tooltip originated from a path; determine series offset from the first point that is part of a path
                    pointX = this.adjustPathXCoordinate(pointX);
                    var firstPathPoint = _.find(seriesData.data, function (dataPoint, index, dataPoints) {
                        var nextDataPoint = dataPoints[index + 1];
                        return dataPoint.value != null && nextDataPoint && nextDataPoint.value != null;
                    });
                    debug.assertValue(firstPathPoint, "If there is data on the tooltipEvent but no categoryIndex, there should always be two consecutive non-null values");
                    offsetX = this.xAxisProperties.scale(this.getXValue(firstPathPoint)) + this.getXOfFirstCategory();
                }
                // else: Tooltip originated from the background; no offsetX is needed
                return this.findIndex(pointX, offsetX);
            };
            LineChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return this.data ? this.data.isScalar : false;
            };
            LineChart.prototype.getSupportedCategoryAxisType = function () {
                var dvCategories = this.dataViewCat ? this.dataViewCat.categories : undefined;
                var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                    categoryType = dvCategories[0].source.type;
                var isOrdinal = visuals.AxisHelper.isOrdinal(categoryType);
                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
            };
            LineChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin, true);
            };
            LineChart.prototype.getCategoryCount = function (origCatgSize) {
                var availableWidth = this.getAvailableWidth();
                var categoryThickness = visuals.CartesianChart.MinOrdinalRectThickness;
                return Math.min(Math.round((availableWidth - categoryThickness * visuals.CartesianChart.OuterPaddingRatio * 2) / categoryThickness), origCatgSize);
            };
            LineChart.prototype.getAvailableWidth = function () {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            LineChart.prototype.getAvailableHeight = function () {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            LineChart.sliceSeries = function (series, newLength, startIndex) {
                if (startIndex === void 0) { startIndex = 0; }
                var newSeries = [];
                if (series && series.length > 0) {
                    debug.assert(series[0].data.length >= newLength, "invalid newLength");
                    for (var i = 0, len = series.length; i < len; i++) {
                        newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        newSeries[i].data = series[i].data.slice(startIndex, startIndex + newLength);
                    }
                }
                return newSeries;
            };
            LineChart.prototype.getXOfFirstCategory = function () {
                if (!this.data.isScalar) {
                    // This will place the line points in the middle of the bands
                    // So they center with Labels when scale is ordinal.
                    var xScale = this.xAxisProperties.scale;
                    if (xScale.rangeBand) {
                        return xScale.rangeBand() / 2;
                    }
                }
                return 0;
            };
            LineChart.prototype.hasDataPoint = function (series) {
                if (series.length === 0)
                    return false;
                for (var i = 0, len = series.length; i < len; i++) {
                    if (series[i].data.length > 0)
                        return true;
                }
                return false;
            };
            LineChart.prototype.getXValue = function (d) {
                return this.data.isScalar ? d.categoryValue : d.categoryIndex;
            };
            /**
              * This checks to see if a data point is isolated, which means
              * the previous and next data point are both null.
              */
            LineChart.prototype.shouldDrawCircle = function (d, i) {
                var dataLength = d.data.length;
                var isLastPoint = i === (dataLength - 1);
                var isFirstPoint = i === 0;
                if (i > dataLength - 1 || d.data[i] === null || d.data[i].value === null)
                    return false;
                if (isFirstPoint && isLastPoint)
                    return true;
                if (isFirstPoint && dataLength > 1 && d.data[i + 1].value === null)
                    return true;
                if (!isFirstPoint && isLastPoint && d.data[i - 1].value === null)
                    return true;
                if (!isFirstPoint && !isLastPoint && d.data[i - 1].value === null && d.data[i + 1].value === null)
                    return true;
                return false;
            };
            LineChart.prototype.selectColumnForTooltip = function (columnIndex, force) {
                if (force === void 0) { force = false; }
                var x = this.getChartX(columnIndex) + this.getXOfFirstCategory();
                var dataPoints = this.createTooltipDataPoints(columnIndex);
                if (dataPoints.length > 0) {
                    this.setHoverLineForTooltip(x);
                }
                this.setDotsForTooltip(x, dataPoints);
                return dataPoints;
            };
            LineChart.prototype.setHoverLineForTooltip = function (chartX) {
                chartX = chartX || 0;
                this.hoverLine
                    .attr('x1', chartX)
                    .attr('x2', chartX)
                    .attr("y1", 0)
                    .attr("y2", this.getAvailableHeight())
                    .style('opacity', 1);
            };
            LineChart.prototype.setDotsForTooltip = function (chartX, dataPoints) {
                var _this = this;
                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var dotYPosition = isStackedArea ? function (d) { return _this.yAxisProperties.scale(d.stackedValue); } : function (d) { return _this.yAxisProperties.scale(d.value); };
                var tooltipDots = this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).data(dataPoints);
                tooltipDots
                    .enter()
                    .append(LineChart.CircleElementName)
                    .classed(LineChart.HoverLineCircleDot.class, true);
                tooltipDots
                    .filter(function (d) { return d.value; })
                    .attr('fill', function (d) { return d.color; })
                    .attr("r", 3)
                    .attr("cx", chartX)
                    .attr("cy", dotYPosition);
                tooltipDots.exit().remove();
            };
            /**
             * Updates the hover line and the legend with the selected colums (given by columnIndex).
             * This is for the Mobile renderer with InteractiveLegend
             */
            LineChart.prototype.selectColumn = function (columnIndex, force) {
                if (force === void 0) { force = false; }
                if (!force && this.lastInteractiveSelectedColumnIndex === columnIndex)
                    return; // same column, nothing to do here
                this.lastInteractiveSelectedColumnIndex = columnIndex;
                var x = this.getChartX(columnIndex);
                this.setHoverLine(x, columnIndex);
                var legendItems = this.createLegendDataPoints(columnIndex);
                if (legendItems)
                    this.options.cartesianHost.updateLegend(legendItems);
            };
            LineChart.prototype.setHoverLine = function (chartX, columnIndex) {
                this.hoverLine
                    .attr('x1', chartX)
                    .attr('x2', chartX)
                    .attr("y1", 0).attr("y2", this.getAvailableHeight())
                    .style('opacity', 1);
                var that = this;
                this.mainGraphicsContext
                    .selectAll(LineChart.CategorySelector.selector)
                    .selectAll(LineChart.PathElementName)
                    .each(function (series) {
                    var _this = this;
                    // Get the item color for the handle dots
                    var color = series.color;
                    var circleToChange = that.selectionCircles[series.lineIndex];
                    circleToChange
                        .attr({
                        'cx': chartX,
                        'cy': function () {
                            var pathElement = d3.select(_this).node();
                            var pos = that.getPosition(chartX, pathElement);
                            return pos.y;
                        }
                    })
                        .style({
                        'opacity': function () { return _.some(series.data, function (value) { return value.categoryIndex === columnIndex; }) ? 1 : 0; },
                        'fill': color
                    });
                    if (that.dragHandle)
                        that.dragHandle.attr('cx', chartX);
                });
            };
            LineChart.prototype.getChartX = function (columnIndex) {
                var x = 0;
                if (this.data.isScalar) {
                    if (columnIndex >= 0 && columnIndex < this.data.categoryData.length)
                        x = Math.max(0, this.xAxisProperties.scale(this.data.categoryData[columnIndex].categoryValue));
                }
                else {
                    x = Math.max(0, this.xAxisProperties.scale(columnIndex));
                }
                var rangeEnd = powerbi.visuals.AxisHelper.extent(this.xAxisProperties.scale)[1];
                x = Math.min(x, rangeEnd);
                if (!isNaN(x))
                    return x;
                return 0;
            };
            /**
             * Finds the index of the category of the given x coordinate given.
             * pointX is in non-scaled screen-space, and offsetX is in render-space.
             * offsetX does not need any scaling adjustment.
             * @param {number} pointX The mouse coordinate in screen-space, without scaling applied
             * @param {number} offsetX Any left offset in d3.scale render-space
             * @return {number}
             */
            LineChart.prototype.findIndex = function (pointX, offsetX) {
                // we are using mouse coordinates that do not know about any potential CSS transform scale
                var svgNode = (this.mainGraphicsSVG.node());
                var ratios = visuals.SVGUtil.getTransformScaleRatios(svgNode);
                if (!powerbi.Double.equalWithPrecision(ratios.x, 1.0, 0.00001)) {
                    pointX = pointX / ratios.x;
                }
                if (offsetX) {
                    pointX += offsetX;
                }
                var scaleX = powerbi.visuals.AxisHelper.invertScale(this.xAxisProperties.scale, pointX);
                if (this.data.isScalar) {
                    scaleX = visuals.AxisHelper.findClosestXAxisIndex(scaleX, this.data.categoryData);
                }
                return scaleX;
            };
            LineChart.prototype.getPosition = function (x, pathElement) {
                var pathLength = pathElement.getTotalLength();
                var pos;
                var beginning = 0, end = pathLength, target;
                while (true) {
                    target = Math.floor((beginning + end) / 2);
                    pos = pathElement.getPointAtLength(target);
                    visuals.SVGUtil.ensureValidSVGPoint(pos);
                    if ((target === end || target === beginning) && pos.x !== x)
                        break;
                    if (pos.x > x)
                        end = target;
                    else if (pos.x < x)
                        beginning = target;
                    else
                        break;
                }
                return pos;
            };
            LineChart.prototype.createTooltipDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data || data.series.length === 0 || !data.categoryData)
                    return [];
                var dataPoints = [];
                var category;
                debug.assert(columnIndex < data.categoryData.length, 'category index out of range');
                var categoryDataPoint = data.categoryData[columnIndex];
                if (this.data.isScalar) {
                    if (categoryDataPoint) {
                        if (visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType)) {
                            category = visuals.CartesianHelper.lookupXValue(this.data, categoryDataPoint.categoryValue, this.xAxisProperties.axisType, this.data.isScalar);
                        }
                        else {
                            category = categoryDataPoint.categoryValue;
                        }
                    }
                }
                else {
                    category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                for (var _i = 0, _a = data.series; _i < _a.length; _i++) {
                    var series = _a[_i];
                    var lineData = series.data;
                    var lineDataPoint = void 0;
                    if (this.data.isScalar) {
                        if (categoryDataPoint) {
                            lineDataPoint = lineData.filter(function (data) {
                                return data.categoryValue === categoryDataPoint.categoryValue;
                            })[0];
                        }
                    }
                    else {
                        lineDataPoint = lineData[columnIndex];
                    }
                    var value = lineDataPoint && lineDataPoint.value;
                    if (value != null) {
                        var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                        dataPoints.push({
                            color: series.color,
                            label: label,
                            category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                            measure: visuals.valueFormatter.format(value, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                            value: value,
                            stackedValue: lineDataPoint.stackedValue
                        });
                    }
                }
                return dataPoints;
            };
            LineChart.prototype.createLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data || !data.series || data.series.length < 1)
                    return;
                var legendDataPoints = [];
                var category;
                // 'category' and 'measure' are only for Mobile interactive legend, Minerva legend does not need them
                var categoryDataPoint = data.categoryData[columnIndex];
                if (this.isInteractiveChart && categoryDataPoint) {
                    if (this.data.isScalar) {
                        category = categoryDataPoint.categoryValue;
                        if (visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType))
                            category = new Date(category);
                    }
                    else {
                        category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
                    }
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var seriesYCol = null;
                // iterating over the line data (i is for a line)
                for (var i = 0, len = data.series.length; i < len; i++) {
                    var series = data.series[i];
                    var lineData = series.data;
                    // 'category' and 'measure' are only for Mobile interactive legend, Minerva legend does not need them
                    var measure = void 0;
                    if (this.isInteractiveChart) {
                        var lineDataPoint = void 0;
                        if (this.data.isScalar) {
                            // Scalar series skip null values, and therefore do not share the same category index
                            // Search this series for the categoryValue - it may not exist
                            if (categoryDataPoint) {
                                var targetCategoryValue = categoryDataPoint.categoryValue;
                                for (var i_1 = 0; i_1 < lineData.length; i_1++) {
                                    if (lineData[i_1].categoryValue === targetCategoryValue) {
                                        lineDataPoint = lineData[i_1];
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            // ordinal series all share the same x-indicies
                            lineDataPoint = lineData[columnIndex];
                        }
                        measure = lineDataPoint && lineDataPoint.value;
                    }
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                    seriesYCol = series.yCol;
                    legendDataPoints.push({
                        color: series.color,
                        icon: visuals.LegendIcon.Line,
                        label: label,
                        // TODO: category: CartesianChartInteractiveLegend only needs one category value for part of the Title, we don't need to put it on each point.
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: series.identity,
                        selected: series.selected,
                    });
                }
                var dvValues = this.dataViewCat ? this.dataViewCat.values : null;
                var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                return {
                    title: title,
                    dataPoints: legendDataPoints
                };
            };
            LineChart.prototype.createLabelDataPoints = function () {
                var _this = this;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var lineshift = this.getXOfFirstCategory();
                var bandRange = lineshift * 2;
                var innerPaddingRatio = visuals.CartesianChart.InnerPaddingRatio;
                var horizontalInnerPadding = innerPaddingRatio * bandRange / (1 - innerPaddingRatio); //get inner padding from bandRange value 
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var dataLabelsSettings = data.dataLabelsSettings;
                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var labelDataPointsGroups = [];
                var labelSettings;
                var axisFormatter;
                var seriesLabelDataPoints;
                var seriesDataPointsCandidates;
                var seriesIndex;
                var seriesCount;
                for (seriesIndex = 0, seriesCount = series.length; seriesIndex < seriesCount; seriesIndex++) {
                    var currentSeries = series[seriesIndex];
                    labelSettings = (currentSeries.labelSettings) ? currentSeries.labelSettings : dataLabelsSettings;
                    if (!labelSettings.show)
                        continue;
                    axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, labelSettings);
                    var dataPoints = currentSeries.data;
                    seriesLabelDataPoints = [];
                    seriesDataPointsCandidates = [];
                    var createLabelDataPoint = function (dataPoint) {
                        if (dataPoint.value == null)
                            return null;
                        var formatString = "";
                        formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties) + visuals.NewDataLabelUtils.LabelDensityPadding;
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        var parentShape;
                        var isParentRect = false;
                        if (isStackedArea) {
                            var bottomPos = Math.max(dataPoint.stackedValue - dataPoint.value, yScale.domain()[0]); //this is to make sure the bottom position doesn't go below the domain
                            parentShape = {
                                rect: {
                                    left: xScale(_this.getXValue(dataPoint)) - horizontalInnerPadding,
                                    top: yScale(Math.max(dataPoint.stackedValue, dataPoint.stackedValue - dataPoint.value)),
                                    width: bandRange + (2 * horizontalInnerPadding),
                                    height: Math.abs(yScale(dataPoint.stackedValue) - yScale(bottomPos))
                                },
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: LineChart.validStackedLabelPositions,
                            };
                            isParentRect = true;
                        }
                        else {
                            parentShape = {
                                point: {
                                    x: xScale(_this.getXValue(dataPoint)) + lineshift,
                                    y: yScale(dataPoint.value),
                                },
                                radius: 0,
                                validPositions: _this.lineChartLabelDensityEnabled ? LineChart.validLabelPositions : [1 /* Above */],
                            };
                        }
                        var labelDataPoint = {
                            isPreferred: false,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                            insideFill: labelSettings.labelColor && isStackedArea ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            parentType: isParentRect ? 1 /* Rectangle */ : 0 /* Point */,
                            parentShape: parentShape,
                            fontSize: labelSettings.fontSize,
                            identity: dataPoint.identity,
                            key: dataPoint.key,
                        };
                        return labelDataPoint;
                    };
                    if (!_.isEmpty(dataPoints)) {
                        var categoryCount = dataPoints.length;
                        var lastDataPoint = dataPoints[categoryCount - 1];
                        var lastLabelDataPoint = createLabelDataPoint(lastDataPoint, seriesIndex);
                        if (lastLabelDataPoint)
                            seriesLabelDataPoints.push(lastLabelDataPoint);
                        for (var categoryIndex = 0; categoryIndex < categoryCount - 1; categoryIndex++) {
                            var labelDataPoint = createLabelDataPoint(dataPoints[categoryIndex], seriesIndex);
                            if (labelDataPoint)
                                seriesLabelDataPoints.push(labelDataPoint);
                        }
                    }
                    var maxLabelsToRender = dataPoints.length;
                    labelDataPointsGroups[seriesIndex] = {
                        labelDataPoints: seriesLabelDataPoints,
                        maxNumberOfLabels: maxLabelsToRender,
                    };
                }
                return labelDataPointsGroups;
            };
            /**
             * Adjust a mouse coordinate originating from a path; used to fix
             * an inconsistency between Internet Explorer and other browsers.
             *
             * Internet explorer places the origin for the coordinate system of
             * mouse events based on the stroke, so that the very edge of the stroke
             * is zoro.  Chrome places the 0 on the edge of the path so that the
             * edge of the stroke is -(strokeWidth / 2).  We adjust coordinates
             * to match Chrome.
             *
             * TODO: Firefox is similar to IE, but does a very poor job at it, so
             * the edge is inacurate.
             *
             * @param value The x coordinate to be adjusted
             */
            LineChart.prototype.adjustPathXCoordinate = function (x) {
                if (this.shouldAdjustMouseCoordsOnPathsForStroke) {
                    var svgNode = (this.mainGraphicsSVG.node());
                    var ratios = visuals.SVGUtil.getTransformScaleRatios(svgNode);
                    if (!powerbi.Double.equalWithPrecision(ratios.x, 1.0, 0.00001)) {
                        x -= LineChart.pathXAdjustment * ratios.x;
                    }
                    else {
                        x -= LineChart.pathXAdjustment;
                    }
                }
                return x;
            };
            //private isMinMax(index: number, dataPoints: LineChartDataPoint[]): boolean {
            //    // Check if the point is the start/end point
            //    if (!dataPoints[index - 1] || !dataPoints[index + 1])
            //        return true;
            //    let currentValue = dataPoints[index].value;
            //    let prevValue = dataPoints[index - 1].value;
            //    let nextValue = dataPoints[index + 1].value;
            //    return (prevValue > currentValue && currentValue < nextValue) // Min point
            //        || (prevValue < currentValue && currentValue > nextValue); // Max point
            //}
            //private calculatePointsWeight(labelDataPoints: LabelDataPoint[], dataPointsCandidates: LineChartDataPoint[], minIndex: number, maxIndex: number) {
            //    let previousMinMaxIndex = 0;
            //    labelDataPoints[0].weight = dataPointsCandidates[0].weight = 0;
            //    let previousMinMax: LineChartDataPoint = dataPointsCandidates[0];
            //    let dataPointCount = labelDataPoints.length;
            //    let yScale = this.yAxisProperties.scale;
            //    let totalValueDelta = yScale(dataPointsCandidates[maxIndex].value) - yScale(dataPointsCandidates[minIndex].value);
            //    for (let i = 1; i < dataPointCount; i++) {
            //        let dataPoint = dataPointsCandidates[i];
            //        let weight = (Math.abs(yScale(previousMinMax.value) - yScale(dataPoint.value))) / totalValueDelta + (i - previousMinMaxIndex) / dataPointCount;
            //        labelDataPoints[i].weight = weight;
            //        if (this.isMinMax(i, dataPointsCandidates)) {
            //            previousMinMax.weight += weight;
            //            previousMinMax = dataPoint;
            //            previousMinMaxIndex = i;
            //        }
            //    }
            //}
            //private sortByWeightAndPreferrance(a: LabelDataPoint, b: LabelDataPoint): number {
            //    // Compare by prederrance first
            //    if (!a.isPreferred && b.isPreferred) return 1;
            //    if (a.isPreferred && !b.isPreferred) return -1;
            //    // Compare by weight
            //    if ((!a.weight && b.weight) || (a.weight < b.weight)) return 1;
            //    if ((a.weight && !b.weight) || (a.weight > b.weight)) return -1;
            //    return 0;
            //}
            LineChart.prototype.showLabelPerSeries = function () {
                var data = this.data;
                return !data.hasDynamicSeries && (data.series.length > 1 || !data.categoryMetadata);
            };
            LineChart.ClassName = 'lineChart';
            LineChart.MainGraphicsContextClassName = 'mainGraphicsContext';
            LineChart.CategorySelector = createClassAndSelector('cat');
            LineChart.CategoryValuePoint = createClassAndSelector('dot');
            LineChart.CategoryPointSelector = createClassAndSelector('point');
            LineChart.CategoryAreaSelector = createClassAndSelector('catArea');
            LineChart.HoverLineCircleDot = createClassAndSelector('circle-item');
            LineChart.LineClassSelector = createClassAndSelector('line');
            LineChart.PointRadius = 5;
            LineChart.CircleRadius = 4;
            LineChart.PathElementName = 'path';
            LineChart.CircleElementName = 'circle';
            LineChart.CircleClassName = 'selection-circle';
            LineChart.LineElementName = 'line';
            LineChart.RectOverlayName = 'rect';
            LineChart.ScalarOuterPadding = 10;
            LineChart.interactivityStrokeWidth = 10;
            LineChart.pathXAdjustment = 5; // Based on half the stroke width for taking stroke into account in coordinate transforms
            LineChart.AreaFillOpacity = 0.4;
            LineChart.DimmedAreaFillOpacity = 0.2;
            LineChart.validLabelPositions = [
                1 /* Above */,
                2 /* Below */,
                8 /* Right */,
                4 /* Left */,
                64 /* AboveRight */,
                128 /* AboveLeft */,
                16 /* BelowRight */,
                32 /* BelowLeft */
            ];
            LineChart.validStackedLabelPositions = [1 /* InsideCenter */, 4 /* InsideEnd */, 2 /* InsideBase */];
            return LineChart;
        }());
        visuals.LineChart = LineChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Color = jsCommon.Color;
        var PixelConverter = jsCommon.PixelConverter;
        var Polygon = visuals.shapes.Polygon;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        visuals.MaxLevelOfDetail = 23;
        visuals.MinLevelOfDetail = 1;
        visuals.DefaultFillOpacity = 0.5;
        visuals.DefaultBackgroundColor = "#000000";
        visuals.LeaderLineColor = "#000000";
        var MapBubbleDataPointRenderer = (function () {
            function MapBubbleDataPointRenderer(tooltipsEnabled) {
                this.tooltipsEnabled = tooltipsEnabled;
            }
            MapBubbleDataPointRenderer.prototype.init = function (mapControl, mapDiv, addClearCatcher) {
                /*
                    The layout of the visual would look like :
                    <div class="visual mapControl">
                        <div class="MicrosoftMap">
                            <!-- Bing maps stuff -->
                            <svg>
                                <rect class="clearCatcher"></rect>
                            </svg>
                        </div>
                        <svg>
                            <g class="mapBubbles>
                                <!-- our geometry -->
                            </g>
                            <g class="mapSlices>
                                <!-- our geometry -->
                            </g>
                        </svg>
                    </div>
    
                */
                this.mapControl = mapControl;
                this.root = mapDiv;
                var root = d3.select(mapDiv[0]);
                root.attr("drag-resize-disabled", "true"); // Enable panning within the maps in IE
                var svg = this.svg = root
                    .append('svg')
                    .style("position", "absolute") // Absolute position so that the svg will overlap with the canvas.
                    .style("pointer-events", "none");
                if (addClearCatcher) {
                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement())
                        .append('svg')
                        .style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                }
                this.bubbleGraphicsContext = svg
                    .append("g")
                    .classed("mapBubbles", true);
                this.sliceGraphicsContext = svg
                    .append("g")
                    .classed("mapSlices", true);
                this.labelBackgroundGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
                this.labelGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                this.sliceLayout = d3.layout.pie()
                    .sort(null)
                    .value(function (d) {
                    return d.value;
                });
                this.arc = d3.svg.arc();
                this.clearMaxDataPointRadius();
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
            };
            MapBubbleDataPointRenderer.prototype.setData = function (data) {
                this.mapData = data;
            };
            MapBubbleDataPointRenderer.prototype.clearDataPoints = function () {
                this.mapData = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: false,
                    hasSize: false,
                };
            };
            MapBubbleDataPointRenderer.prototype.getDataPointCount = function () {
                if (!this.mapData)
                    return 0;
                // Filter out any data points without a location since those aren't actually being drawn
                return _.filter(this.mapData.dataPoints, function (value) { return !!value.location; }).length;
            };
            MapBubbleDataPointRenderer.prototype.getDataPointPadding = function () {
                return this.maxDataPointRadius * 2;
            };
            MapBubbleDataPointRenderer.prototype.clearMaxDataPointRadius = function () {
                this.maxDataPointRadius = 0;
            };
            MapBubbleDataPointRenderer.prototype.setMaxDataPointRadius = function (dataPointRadius) {
                this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
            };
            MapBubbleDataPointRenderer.prototype.getDefaultMap = function (geocodingCategory, dataPointCount) {
                this.clearDataPoints();
            };
            MapBubbleDataPointRenderer.prototype.converter = function (viewport, dataView, labelSettings, interactivityService, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var mapControl = this.mapControl;
                var widthOverTwo = viewport.width / 2;
                var heightOverTwo = viewport.height / 2;
                var strokeWidth = 1;
                //update data label settings
                this.dataLabelsSettings = labelSettings;
                // See MapSeriesPresenter::GetDataPointRadius for the PV behavior
                var radiusScale = Math.min(viewport.width, viewport.height) / 384;
                this.clearMaxDataPointRadius();
                var bubbleData = [];
                var sliceData = [];
                var categorical = dataView ? dataView.categorical : null;
                var grouped;
                var sizeIndex = -1;
                var dataValuesSource;
                if (categorical && categorical.values) {
                    grouped = categorical.values.grouped();
                    sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
                    dataValuesSource = categorical.values.source;
                }
                var dataPoints = this.mapData ? this.mapData.dataPoints : [];
                var hasSize = this.mapData.hasSize;
                for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
                    var dataPoint = dataPoints[categoryIndex];
                    var categoryValue = dataPoint.categoryValue;
                    var location_2 = dataPoint.location;
                    if (location_2) {
                        var xy = mapControl.tryLocationToPixel(new Microsoft.Maps.Location(location_2.latitude, location_2.longitude));
                        var x = xy.x + widthOverTwo;
                        var y = xy.y + heightOverTwo;
                        var radius = dataPoint.radius * radiusScale;
                        this.setMaxDataPointRadius(radius);
                        var subDataPoints = dataPoint.subDataPoints;
                        var seriesCount = subDataPoints.length;
                        if (seriesCount === 1) {
                            var subDataPoint = subDataPoints[0];
                            bubbleData.push({
                                x: x,
                                y: y,
                                labeltext: categoryValue,
                                radius: radius,
                                fill: subDataPoint.fill,
                                stroke: subDataPoint.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: subDataPoint.tooltipInfo,
                                identity: subDataPoint.identity,
                                selected: false,
                                labelFill: labelSettings.labelColor,
                            });
                        }
                        else {
                            var slices = [];
                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                                var subDataPoint = subDataPoints[seriesIndex];
                                var value = hasSize ? subDataPoint.value : 1; // Normalize values if there is no size in the data
                                slices.push({
                                    x: x,
                                    y: y,
                                    labeltext: categoryValue,
                                    radius: radius,
                                    fill: subDataPoint.fill,
                                    stroke: subDataPoint.stroke,
                                    strokeWidth: strokeWidth,
                                    value: value,
                                    tooltipInfo: subDataPoint.tooltipInfo,
                                    identity: subDataPoint.identity,
                                    selected: false,
                                    labelFill: labelSettings.labelColor,
                                });
                            }
                            if (interactivityService) {
                                interactivityService.applySelectionStateToData(slices);
                            }
                            sliceData.push(slices);
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(bubbleData);
                }
                return { bubbleData: bubbleData, sliceData: sliceData };
            };
            MapBubbleDataPointRenderer.prototype.updateInternal = function (data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                debug.assertValue(viewport, "viewport");
                Map.removeTransform3d(this.root);
                this.mapRendererData = data;
                if (this.svg) {
                    this.svg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                if (this.clearSvg) {
                    this.clearSvg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                var arc = this.arc;
                var hasSelection = interactivityService && interactivityService.hasSelection();
                var bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function (d) { return d.identity.getKey(); });
                bubbles.enter()
                    .append("circle")
                    .classed("bubble", true);
                bubbles
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })
                    .attr("r", function (d) { return d.radius; })
                    .style("fill", function (d) { return d.fill; })
                    .style("stroke", function (d) { return d.stroke; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .style("strokeWidth", function (d) { return d.strokeWidth; })
                    .style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .style("cursor", "default");
                bubbles.exit().remove();
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(bubbles, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    bubbles.style("pointer-events", "all");
                }
                var sliceData = data.sliceData;
                var sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
                sliceContainers.enter()
                    .append("g")
                    .classed("sliceContainer", true);
                sliceContainers.exit().remove();
                var sliceLayout = this.sliceLayout;
                var slices = sliceContainers.selectAll(".slice")
                    .data(function (d) {
                    return sliceLayout(d);
                }, function (d) { return d.data.identity.getKey(); });
                slices.enter()
                    .append("path")
                    .classed("slice", true);
                slices
                    .style("fill", function (t) { return t.data.fill; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); })
                    .style("stroke", function (t) { return t.data.stroke; })
                    .style("strokeWidth", function (t) { return t.data.strokeWidth; })
                    .style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); })
                    .style("cursor", "default")
                    .attr("transform", function (t) { return visuals.SVGUtil.translate(t.data.x, t.data.y); })
                    .attr('d', function (t) {
                    return arc.innerRadius(0).outerRadius(function (t) { return t.data.radius; })(t);
                });
                slices.exit().remove();
                this.updateInternalDataLabels(viewport, redrawDataLabels);
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(slices, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    slices.style("pointer-events", "all");
                }
                var allData = data.bubbleData.slice();
                for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                    allData.push.apply(allData, sliceData[i]);
                }
                var behaviorOptions = {
                    bubbles: bubbles,
                    slices: this.sliceGraphicsContext.selectAll("path"),
                    clearCatcher: this.clearCatcher,
                    dataPoints: allData,
                };
                return behaviorOptions;
            };
            MapBubbleDataPointRenderer.prototype.updateInternalDataLabels = function (viewport, redrawDataLabels) {
                var labelSettings = this.dataLabelsSettings;
                var dataLabels = [];
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints();
                    var labelLayout = new powerbi.LabelLayout({
                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                    });
                    var labelDataPointsGroup = {
                        labelDataPoints: labelDataPoints,
                        maxNumberOfLabels: labelDataPoints.length
                    };
                    dataLabels = labelLayout.layout([labelDataPointsGroup], { width: viewport.width, height: viewport.height });
                }
                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, dataLabels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity);
                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, dataLabels, false); // Once we properly split up and handle show and showCategory, the false here should change to !labelSettings.showCategory
            };
            MapBubbleDataPointRenderer.prototype.createLabelDataPoints = function () {
                var data = this.mapRendererData;
                var labelDataPoints = [];
                var dataPoints = data.bubbleData;
                dataPoints = dataPoints.concat(_.map(data.sliceData, function (value) { return value[0]; }));
                var labelSettings = this.dataLabelsSettings;
                for (var _i = 0, dataPoints_3 = dataPoints; _i < dataPoints_3.length; _i++) {
                    var dataPoint = dataPoints_3[_i];
                    debug.assertValue(dataPoint, 'dataPoint should never be null/undefined');
                    var text = dataPoint.labeltext;
                    var properties = {
                        text: text,
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    labelDataPoints.push({
                        isPreferred: true,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight,
                        },
                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 0 /* Point */,
                        parentShape: {
                            point: {
                                x: dataPoint.x,
                                y: dataPoint.y,
                            },
                            radius: dataPoint.radius,
                            validPositions: MapBubbleDataPointRenderer.validLabelPositions,
                        },
                        fontSize: labelSettings.fontSize,
                        identity: undefined,
                        hasBackground: true,
                    });
                }
                return labelDataPoints;
            };
            MapBubbleDataPointRenderer.validLabelPositions = [1 /* Above */, 2 /* Below */, 4 /* Left */, 8 /* Right */];
            return MapBubbleDataPointRenderer;
        }());
        visuals.MapBubbleDataPointRenderer = MapBubbleDataPointRenderer;
        var MapShapeDataPointRenderer = (function () {
            function MapShapeDataPointRenderer(fillMapDataLabelsEnabled, tooltipsEnabled) {
                this.filledMapDataLabelsEnabled = fillMapDataLabelsEnabled;
                this.tooltipsEnabled = tooltipsEnabled;
            }
            MapShapeDataPointRenderer.getFilledMapParams = function (category, dataCount) {
                switch (category) {
                    case visuals.MapUtil.CategoryTypes.Continent:
                    case visuals.MapUtil.CategoryTypes.CountryRegion:
                        if (dataCount < 10) {
                            return { level: 2, maxPolygons: 50, strokeWidth: 0 };
                        }
                        else if (dataCount < 30) {
                            return { level: 2, maxPolygons: 20, strokeWidth: 0 };
                        }
                        return { level: 1, maxPolygons: 3, strokeWidth: 0 };
                    default:
                        if (dataCount < 100) {
                            return { level: 1, maxPolygons: 5, strokeWidth: 6 };
                        }
                        if (dataCount < 200) {
                            return { level: 0, maxPolygons: 5, strokeWidth: 6 };
                        }
                        return { level: 0, maxPolygons: 5, strokeWidth: 0 };
                }
            };
            MapShapeDataPointRenderer.buildPaths = function (locations) {
                var paths = [];
                for (var i = 0; i < locations.length; i++) {
                    var location_3 = locations[i];
                    var polygon = location_3.geographic;
                    if (polygon.length > 2) {
                        paths.push(location_3);
                    }
                }
                return paths;
            };
            MapShapeDataPointRenderer.prototype.init = function (mapControl, mapDiv, addClearCatcher) {
                /*
                    The layout of the visual would look like :
                    <div class="visual mapControl">
                        <div class="MicrosoftMap">
                            <!-- Bing maps stuff -->
                            <svg>
                                <rect class="clearCatcher"></rect>
                            </svg>
                        </div>
                        <svg>
                            <g class="mapShapes>
                                <!-- our geometry -->
                            </g>
                        </svg>
                    </div>
    
                */
                this.mapControl = mapControl;
                this.polygonInfo = new visuals.MapPolygonInfo();
                this.root = mapDiv;
                var root = d3.select(mapDiv[0]);
                root.attr('drag-resize-disabled', 'true'); // Enable panning within the maps in IE
                var svg = this.svg = root
                    .append('svg')
                    .style('position', 'absolute') // Absolute position so that the svg will overlap with the canvas.
                    .style("pointer-events", "none");
                if (addClearCatcher) {
                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement())
                        .append('svg')
                        .style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                }
                this.shapeGraphicsContext = svg
                    .append('g')
                    .classed('mapShapes', true);
                this.labelBackgroundGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
                this.labelGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                this.clearMaxShapeDimension();
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
            };
            MapShapeDataPointRenderer.prototype.setData = function (data) {
                this.mapData = data;
            };
            MapShapeDataPointRenderer.prototype.clearDataPoints = function () {
                this.mapData = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: false,
                    hasSize: false,
                };
            };
            MapShapeDataPointRenderer.prototype.getDataPointCount = function () {
                if (!this.mapData)
                    return 0;
                // Filter out any data points without a location since those aren't actually being drawn
                return _.filter(this.mapData.dataPoints, function (value) { return !!value.paths; }).length;
            };
            MapShapeDataPointRenderer.prototype.converter = function (viewport, dataView, labelSettings, interactivityService) {
                this.clearMaxShapeDimension();
                this.dataLabelsSettings = labelSettings;
                var strokeWidth = 1;
                var shapeData = [];
                var dataPoints = this.mapData ? this.mapData.dataPoints : [];
                for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
                    var categorical = dataView ? dataView.categorical : null;
                    var dataPoint = dataPoints[categoryIndex];
                    var subDataPoint = dataPoint.subDataPoints[0];
                    var paths = dataPoint.paths;
                    var grouped = void 0;
                    var sizeIndex = -1;
                    var dataValuesSource = void 0;
                    if (categorical && categorical.values) {
                        grouped = categorical.values.grouped();
                        sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
                        dataValuesSource = categorical.values.source;
                    }
                    if (paths) {
                        var value = dataPoint.value;
                        var categoryValue = dataPoint.categoryValue;
                        var identity = subDataPoint.identity;
                        var idKey = identity.getKey();
                        var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                        //Determine Largest Shape
                        var mainShapeIndex = MapShapeDataPointRenderer.getIndexOfLargestShape(paths);
                        for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                            var path = paths[pathIndex];
                            var labelFormatString = (dataView && dataView.categorical && !_.isEmpty(dataView.categorical.values)) ? visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, visuals.filledMapProps.general.formatString) : undefined;
                            this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
                            var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings);
                            shapeData.push({
                                absolutePointArray: path.absolute,
                                path: path.absoluteString,
                                fill: subDataPoint.fill,
                                stroke: subDataPoint.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: subDataPoint.tooltipInfo,
                                identity: identity,
                                selected: false,
                                key: JSON.stringify({ id: idKey, pIdx: pathIndex }),
                                displayLabel: pathIndex === mainShapeIndex,
                                labeltext: categoryValue,
                                catagoryLabeltext: (value != null) ? visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(value)) : undefined,
                                labelFormatString: labelFormatString,
                            });
                        }
                    }
                }
                if (interactivityService)
                    interactivityService.applySelectionStateToData(shapeData);
                return { shapeData: shapeData };
            };
            MapShapeDataPointRenderer.prototype.updateInternal = function (data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                debug.assertValue(viewport, "viewport");
                Map.removeTransform3d(this.root);
                this.mapRendererData = data;
                if (this.svg) {
                    this.svg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                if (this.clearSvg) {
                    this.clearSvg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height);
                this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));
                var hasSelection = interactivityService && interactivityService.hasSelection();
                var shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, function (d) { return d.key; });
                shapes.enter()
                    .append("polygon")
                    .classed("shape", true)
                    .attr("points", function (d) {
                    return d.path;
                });
                shapes
                    .style("fill", function (d) { return d.fill; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .style("cursor", "default");
                if (dataChanged) {
                    // We only update the paths of existing shapes if we have a change in the data.  Updating the lengthy path
                    // strings every update during resize or zooming/panning is extremely bad for performance.
                    shapes
                        .attr("points", function (d) {
                        return d.path;
                    });
                }
                shapes.exit()
                    .remove();
                this.updateInternalDataLabels(viewport, redrawDataLabels);
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    shapes.style("pointer-events", "all");
                }
                var behaviorOptions = {
                    shapes: shapes,
                    clearCatcher: this.clearCatcher,
                    dataPoints: data.shapeData,
                };
                return behaviorOptions;
            };
            MapShapeDataPointRenderer.prototype.getDataPointPadding = function () {
                return 12;
            };
            MapShapeDataPointRenderer.getIndexOfLargestShape = function (paths) {
                var largestShapeIndex = 0;
                var largestShapeArea = 0;
                for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                    var path = paths[pathIndex];
                    // Using the area of the polygon (and taking the largest)
                    var polygon = new Polygon(path.absolute);
                    var currentShapeArea = Math.abs(Polygon.calculateAbsolutePolygonArea(polygon.polygonPoints));
                    if (currentShapeArea > largestShapeArea) {
                        largestShapeIndex = pathIndex;
                        largestShapeArea = currentShapeArea;
                    }
                }
                return largestShapeIndex;
            };
            MapShapeDataPointRenderer.prototype.updateInternalDataLabels = function (viewport, redrawDataLabels) {
                var labelSettings = this.dataLabelsSettings;
                var labels;
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints();
                    if (this.labelLayout === undefined) {
                        this.labelLayout = new powerbi.FilledMapLabelLayout();
                    }
                    labels = this.labelLayout.layout(labelDataPoints, { width: viewport.width, height: viewport.height }, this.polygonInfo.transform, redrawDataLabels);
                }
                this.drawLabelStems(this.labelGraphicsContext, labels, labelSettings.show, labelSettings.showCategory);
                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, labels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity);
                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, labelSettings.show && labelSettings.showCategory);
            };
            MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function () {
                this.maxShapeDimension = 0;
            };
            MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function (width, height) {
                this.maxShapeDimension = Math.max(width, this.maxShapeDimension);
                this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
            };
            MapShapeDataPointRenderer.prototype.createLabelDataPoints = function () {
                var data = this.mapRendererData;
                var labelDataPoints = [];
                if (this.filledMapDataLabelsEnabled) {
                    var dataShapes = data.shapeData;
                    var labelSettings = this.dataLabelsSettings;
                    for (var _i = 0, dataShapes_1 = dataShapes; _i < dataShapes_1.length; _i++) {
                        var dataShape = dataShapes_1[_i];
                        if (!dataShape.displayLabel) {
                            continue;
                        }
                        var text = void 0, secondRowText = void 0;
                        var secondRowTextWidth = 0;
                        var hasSecondRow = false;
                        if (this.dataLabelsSettings.show && !this.dataLabelsSettings.showCategory) {
                            text = dataShape.catagoryLabeltext;
                            if (text === undefined)
                                continue;
                        }
                        else if (this.dataLabelsSettings.showCategory && !this.dataLabelsSettings.show) {
                            text = dataShape.labeltext;
                            if (text === undefined)
                                continue;
                        }
                        else if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show) {
                            text = dataShape.catagoryLabeltext;
                            secondRowText = dataShape.labeltext;
                            if (text === undefined && secondRowText === undefined)
                                continue;
                            hasSecondRow = true;
                        }
                        if (hasSecondRow) {
                            var secondRowProperties = {
                                text: secondRowText,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            secondRowTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(secondRowProperties);
                        }
                        var firstRowProperties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(firstRowProperties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(firstRowProperties);
                        if (secondRowText && dataShape.labeltext !== undefined && dataShape.catagoryLabeltext !== undefined) {
                            textHeight = textHeight * 2;
                        }
                        var labelDataPoint = {
                            parentType: 2 /* Polygon */,
                            parentShape: {
                                polygon: new Polygon(dataShape.absolutePointArray),
                                validPositions: MapShapeDataPointRenderer.validLabelPolygonPositions,
                            },
                            text: text,
                            secondRowText: secondRowText,
                            textSize: {
                                width: Math.max(textWidth, secondRowTextWidth),
                                height: textHeight,
                            },
                            insideFill: labelSettings.labelColor,
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            isPreferred: false,
                            identity: undefined,
                            hasBackground: true,
                        };
                        labelDataPoints.push(labelDataPoint);
                    }
                }
                return labelDataPoints;
            };
            MapShapeDataPointRenderer.prototype.drawLabelStems = function (labelsContext, dataLabels, showText, showCategory) {
                var filteredLabels = _.filter(dataLabels, function (d) { return d.isVisible; });
                var key = function (d, index) { return d.identity ? d.identity.getKeyWithoutHighlight() : index; };
                visuals.NewDataLabelUtils.drawLabelLeaderLines(labelsContext, filteredLabels, key, visuals.LeaderLineColor);
            };
            MapShapeDataPointRenderer.validLabelPolygonPositions = [256 /* Center */, 2 /* Below */, 1 /* Above */, 8 /* Right */, 4 /* Left */, 16 /* BelowRight */, 32 /* BelowLeft */, 64 /* AboveRight */, 128 /* AboveLeft */];
            return MapShapeDataPointRenderer;
        }());
        visuals.MapShapeDataPointRenderer = MapShapeDataPointRenderer;
        var DefaultLocationZoomLevel = 11;
        var Map = (function () {
            function Map(options) {
                this.receivedExternalViewChange = false;
                this.executingInternalViewChange = false;
                if (options.filledMap) {
                    this.dataPointRenderer = new MapShapeDataPointRenderer(options.filledMapDataLabelsEnabled, options.tooltipsEnabled);
                    this.filledMapDataLabelsEnabled = options.filledMapDataLabelsEnabled;
                    this.enableGeoShaping = true;
                }
                else {
                    this.dataPointRenderer = new MapBubbleDataPointRenderer(options.tooltipsEnabled);
                    this.enableGeoShaping = false;
                }
                this.mapControlFactory = options.mapControlFactory ? options.mapControlFactory : this.getDefaultMapControlFactory();
                this.behavior = options.behavior;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.disableZooming = options.disableZooming;
                this.disablePanning = options.disablePanning;
                this.isLegendScrollable = !!options.behavior;
                this.viewChangeThrottleInterval = options.viewChangeThrottleInterval;
                this.enableCurrentLocation = options.enableCurrentLocation;
            }
            Map.prototype.init = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                var element = this.element = options.element;
                this.pendingGeocodingRender = false;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                if (this.behavior)
                    this.interactivityService = visuals.createInteractivityService(options.host);
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
                this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isLegendScrollable);
                this.legendHeight = 0;
                this.legendData = { dataPoints: [] };
                this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString);
                this.host = options.host;
                if (options.host.locale)
                    this.locale = options.host.locale();
                this.geocoder = options.host.geocoder();
                this.resetBounds();
                this.mapControlFactory.ensureMap(this.locale, function () {
                    Microsoft.Maps.loadModule('Microsoft.Maps.Overlays.Style', {
                        callback: function () {
                            _this.initialize(element[0]);
                            if (_this.enableCurrentLocation) {
                                _this.createCurrentLocation(element);
                            }
                        }
                    });
                });
            };
            Map.prototype.createCurrentLocation = function (element) {
                var _this = this;
                var myLocBtn = InJs.DomFactory.div().addClass("mapCurrentLocation").appendTo(element);
                var pushpin;
                myLocBtn.on('click', function () {
                    if (_this.isCurrentLocation) {
                        // Restore previous map view and remove pushpin
                        if (pushpin) {
                            _this.mapControl.entities.remove(pushpin);
                        }
                        _this.updateInternal(false, false);
                        _this.isCurrentLocation = false;
                    }
                    else {
                        _this.host.geolocation().getCurrentPosition(function (position) {
                            var location = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude);
                            if (pushpin) {
                                _this.mapControl.entities.remove(pushpin);
                            }
                            pushpin = visuals.MapUtil.CurrentLocation.createPushpin(location);
                            _this.mapControl.entities.push(pushpin);
                            _this.updateMapView(location, DefaultLocationZoomLevel);
                            _this.isCurrentLocation = true;
                        });
                    }
                });
            };
            Map.prototype.addDataPoint = function (dataPoint) {
                var location = dataPoint.location;
                this.updateBounds(location.latitude, location.longitude);
                this.scheduleRedraw();
            };
            Map.prototype.scheduleRedraw = function () {
                var _this = this;
                if (!this.pendingGeocodingRender && this.mapControl) {
                    this.pendingGeocodingRender = true;
                    // Maintain a 3 second delay between redraws from geocoded geometry
                    setTimeout(function () {
                        _this.updateInternal(true, true);
                        _this.pendingGeocodingRender = false;
                    }, 3000);
                }
            };
            Map.prototype.enqueueGeoCode = function (dataPoint) {
                var _this = this;
                this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function (location) {
                    if (location) {
                        dataPoint.location = location;
                        _this.addDataPoint(dataPoint);
                    }
                });
            };
            Map.prototype.enqueueGeoCodeAndGeoShape = function (dataPoint, params) {
                var _this = this;
                this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function (location) {
                    if (location) {
                        dataPoint.location = location;
                        _this.enqueueGeoShape(dataPoint, params);
                    }
                });
            };
            Map.prototype.enqueueGeoShape = function (dataPoint, params) {
                var _this = this;
                debug.assertValue(dataPoint.location, "cachedLocation");
                this.geocoder.geocodeBoundary(dataPoint.location.latitude, dataPoint.location.longitude, this.geocodingCategory, params.level, params.maxPolygons)
                    .then(function (result) {
                    var paths;
                    if (result.locations.length === 0 || result.locations[0].geographic) {
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    }
                    else {
                        visuals.MapUtil.calcGeoData(result);
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    }
                    dataPoint.paths = paths;
                    _this.addDataPoint(dataPoint);
                });
            };
            Map.prototype.getOptimumLevelOfDetail = function (width, height) {
                var dataPointCount = this.dataPointRenderer.getDataPointCount();
                if (dataPointCount === 0)
                    return visuals.MapUtil.MinLevelOfDetail;
                var threshold = this.dataPointRenderer.getDataPointPadding();
                for (var levelOfDetail = visuals.MapUtil.MaxLevelOfDetail; levelOfDetail >= visuals.MapUtil.MinLevelOfDetail; levelOfDetail--) {
                    var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                    var maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                    if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) {
                        // if we have less than 2 data points we should not zoom in "too much"
                        if (dataPointCount < 2)
                            levelOfDetail = Math.min(visuals.MapUtil.MaxAutoZoomLevel, levelOfDetail);
                        return levelOfDetail;
                    }
                }
                return visuals.MapUtil.MinLevelOfDetail;
            };
            Map.prototype.getViewCenter = function (levelOfDetail) {
                var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                var maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                return visuals.MapUtil.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2.0, (maxXminY.y + minXmaxY.y) / 2.0, levelOfDetail);
            };
            Map.prototype.resetBounds = function () {
                this.minLongitude = visuals.MapUtil.MaxAllowedLongitude;
                this.maxLongitude = visuals.MapUtil.MinAllowedLongitude;
                this.minLatitude = visuals.MapUtil.MaxAllowedLatitude;
                this.maxLatitude = visuals.MapUtil.MinAllowedLatitude;
            };
            Map.prototype.updateBounds = function (latitude, longitude) {
                if (longitude < this.minLongitude) {
                    this.minLongitude = longitude;
                }
                if (longitude > this.maxLongitude) {
                    this.maxLongitude = longitude;
                }
                if (latitude < this.minLatitude) {
                    this.minLatitude = latitude;
                }
                if (latitude > this.maxLatitude) {
                    this.maxLatitude = latitude;
                }
            };
            Map.legendObject = function (dataView) {
                return dataView &&
                    dataView.metadata &&
                    dataView.metadata.objects &&
                    dataView.metadata.objects['legend'];
            };
            Map.isLegendHidden = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject != null && legendObject[visuals.legendProps.show] === false;
            };
            Map.legendPosition = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && visuals.LegendPosition[legendObject[visuals.legendProps.position]];
            };
            Map.getLegendFontSize = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return (legendObject && legendObject[visuals.legendProps.fontSize]) || visuals.SVGLegend.DefaultFontSizeInPt;
            };
            Map.isShowLegendTitle = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && legendObject[visuals.legendProps.showTitle];
            };
            Map.prototype.legendTitle = function () {
                var legendObject = Map.legendObject(this.dataView);
                return (legendObject && legendObject[visuals.legendProps.titleText]) || this.legendData.title;
            };
            Map.prototype.renderLegend = function (legendData) {
                var hideLegend = Map.isLegendHidden(this.dataView);
                var showTitle = Map.isShowLegendTitle(this.dataView);
                var title = this.legendTitle();
                // Update the legendData based on the hide flag.  Cartesian passes in no-datapoints. OnResize reuses the legendData, so this can't mutate.
                var clonedLegendData = {
                    dataPoints: hideLegend ? [] : legendData.dataPoints,
                    grouped: legendData.grouped,
                    title: showTitle ? title : "",
                    fontSize: Map.getLegendFontSize(this.dataView)
                };
                // Update the orientation to match what's in the dataView
                var targetOrientation = Map.legendPosition(this.dataView);
                if (targetOrientation !== undefined) {
                    this.legend.changeOrientation(targetOrientation);
                }
                else {
                    this.legend.changeOrientation(visuals.LegendPosition.Top);
                }
                this.legend.drawLegend(clonedLegendData, this.currentViewport);
            };
            /** Note: public for UnitTest */
            Map.calculateGroupSizes = function (categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
                var categoryCount = categorical.values[0].values.length;
                var seriesCount = grouped.length;
                for (var i = 0, len = categoryCount; i < len; ++i) {
                    var groupTotal = null;
                    if (sizeMeasureIndex >= 0) {
                        for (var j = 0; j < seriesCount; ++j) {
                            var value = grouped[j].values[sizeMeasureIndex].values[i];
                            if (value) {
                                if (groupTotal === null) {
                                    groupTotal = value;
                                }
                                else {
                                    groupTotal += value;
                                }
                            }
                        }
                    }
                    groupSizeTotals.push(groupTotal);
                    if (groupTotal) {
                        if (!currentValueScale) {
                            currentValueScale = {
                                min: groupTotal,
                                max: groupTotal
                            };
                        }
                        else {
                            currentValueScale.min = Math.min(currentValueScale.min, groupTotal);
                            currentValueScale.max = Math.max(currentValueScale.max, groupTotal);
                        }
                    }
                }
                return currentValueScale;
            };
            /** Note: public for UnitTest */
            Map.calculateRadius = function (range, value) {
                var rangeDiff = range ? range.max - range.min : 0;
                var radius = 6;
                if (range != null && value != null && rangeDiff !== 0) {
                    radius = (14 * ((value - range.min) / rangeDiff)) + 6;
                }
                return radius;
            };
            /** Note: public for UnitTest */
            Map.getGeocodingCategory = function (categorical, geoTaggingAnalyzerService) {
                if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
                    // Check categoryString for manually specified information in the model
                    var type = categorical.categories[0].source.type;
                    if (type && type.categoryString) {
                        return geoTaggingAnalyzerService.getFieldType(type.categoryString);
                    }
                    // Check the category name
                    var categoryName = categorical.categories[0].source.displayName;
                    var geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
                    if (geotaggedResult)
                        return geotaggedResult;
                    // Checking roles for VRM backwards compatibility
                    var roles = categorical.categories[0].source.roles;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var i = 0, len = roleNames.length; i < len; ++i) {
                            var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                            if (typeFromRoleName)
                                return typeFromRoleName;
                        }
                    }
                }
                return undefined;
            };
            /** Note: public for UnitTest */
            Map.hasSizeField = function (values, defaultIndexIfNoRole) {
                if (_.isEmpty(values))
                    return false;
                for (var i = 0, ilen = values.length; i < ilen; i++) {
                    var roles = values[i].source.roles;
                    // case for Power Q&A since Power Q&A does not assign role to measures.
                    if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric)
                        return true;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var j = 0, jlen = roleNames.length; j < jlen; j++) {
                            var role = roleNames[j];
                            if (role === "Size")
                                return true;
                        }
                    }
                }
                return false;
            };
            Map.shouldEnumerateDataPoints = function (dataView, usesSizeForGradient) {
                var hasSeries = DataRoleHelper.hasRoleInDataView(dataView, 'Series');
                var gradientRole = usesSizeForGradient ? 'Size' : 'Gradient';
                var hasGradientRole = DataRoleHelper.hasRoleInDataView(dataView, gradientRole);
                return hasSeries || !hasGradientRole;
            };
            Map.shouldEnumerateCategoryLabels = function (enableGeoShaping, filledMapDataLabelsEnabled) {
                return (!enableGeoShaping || filledMapDataLabelsEnabled);
            };
            Map.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'dataPoint':
                        if (Map.shouldEnumerateDataPoints(this.dataView, this.enableGeoShaping)) {
                            var bubbleData = [];
                            //TODO: better way of getting this data
                            var hasDynamicSeries = this.hasDynamicSeries;
                            if (!hasDynamicSeries) {
                                var mapData = this.dataPointRenderer.converter(this.getMapViewPort(), this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
                                bubbleData = mapData.bubbleData;
                            }
                            Map.enumerateDataPoints(enumeration, this.dataPointsToEnumerate, this.colors, hasDynamicSeries, this.defaultDataPointColor, this.showAllDataPoints, bubbleData);
                        }
                        break;
                    case 'categoryLabels':
                        if (Map.shouldEnumerateCategoryLabels(this.enableGeoShaping, this.filledMapDataLabelsEnabled)) {
                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.dataLabelsSettings, true, true);
                        }
                        break;
                    case 'legend':
                        if (this.hasDynamicSeries) {
                            Map.enumerateLegend(enumeration, this.dataView, this.legend, this.legendTitle());
                        }
                        break;
                    case 'labels':
                        if (this.filledMapDataLabelsEnabled) {
                            this.dataLabelsSettings = this.dataLabelsSettings ? this.dataLabelsSettings : visuals.dataLabelUtils.getDefaultMapLabelSettings();
                            var labelSettingOptions = {
                                enumeration: enumeration,
                                dataLabelsSettings: this.dataLabelsSettings,
                                show: true,
                                displayUnits: true,
                                precision: true,
                            };
                            visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        }
                        break;
                }
                return enumeration.complete();
            };
            Map.enumerateDataPoints = function (enumeration, dataPoints, colors, hasDynamicSeries, defaultDataPointColor, showAllDataPoints, bubbleData) {
                var seriesLength = dataPoints && dataPoints.length;
                if (hasDynamicSeries) {
                    for (var i = 0; i < seriesLength; i++) {
                        var dataPoint = dataPoints[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: dataPoint.label,
                            selector: dataPoint.identity.getSelector(),
                            properties: {
                                fill: { solid: { color: dataPoint.color } }
                            },
                        });
                    }
                }
                else {
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: defaultDataPointColor || colors.getColorByIndex(0).value } }
                        },
                    }).pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: !!showAllDataPoints
                        },
                    });
                    if (bubbleData) {
                        for (var i = 0; i < bubbleData.length; i++) {
                            var bubbleDataPoint = bubbleData[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: bubbleDataPoint.labeltext,
                                selector: bubbleDataPoint.identity.getSelector(),
                                properties: {
                                    fill: { solid: { color: Color.normalizeToHexString(bubbleDataPoint.fill) } }
                                },
                            });
                        }
                    }
                }
            };
            Map.enumerateLegend = function (enumeration, dataView, legend, legendTitle) {
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: !Map.isLegendHidden(dataView),
                        position: visuals.LegendPosition[legend.getOrientation()],
                        showTitle: Map.isShowLegendTitle(dataView),
                        titleText: legendTitle,
                        fontSize: Map.getLegendFontSize(dataView)
                    },
                    objectName: 'legend'
                });
            };
            Map.prototype.onDataChanged = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                this.resetBounds();
                this.receivedExternalViewChange = false;
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
                this.defaultDataPointColor = null;
                this.showAllDataPoints = null;
                var dataView = this.dataView = options.dataViews[0];
                var enableGeoShaping = this.enableGeoShaping;
                var warnings = [];
                var data = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: false,
                    hasSize: false,
                };
                if (dataView) {
                    // Handle object-based settings
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        this.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.mapProps.dataPoint.defaultColor);
                        this.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.mapProps.dataPoint.showAllDataPoints);
                        this.dataLabelsSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.categoryLabels.show, this.dataLabelsSettings.showCategory);
                        if (enableGeoShaping) {
                            this.dataLabelsSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelPrecision, this.dataLabelsSettings.precision);
                            this.dataLabelsSettings.precision = (this.dataLabelsSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && this.dataLabelsSettings.precision < 0) ? 0 : this.dataLabelsSettings.precision;
                            this.dataLabelsSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelDisplayUnits, this.dataLabelsSettings.displayUnits);
                            var datalabelsObj = objects['labels'];
                            if (datalabelsObj) {
                                this.dataLabelsSettings.show = (datalabelsObj['show'] !== undefined) ? datalabelsObj['show'] : this.dataLabelsSettings.show;
                                if (datalabelsObj['color'] !== undefined) {
                                    this.dataLabelsSettings.labelColor = datalabelsObj['color'].solid.color;
                                }
                            }
                        }
                        else {
                            var categoryLabelsObj = objects['categoryLabels'];
                            if (categoryLabelsObj)
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelsObj, this.dataLabelsSettings);
                        }
                    }
                    // Convert data
                    var colorHelper = new visuals.ColorHelper(this.colors, visuals.mapProps.dataPoint.fill, this.defaultDataPointColor);
                    data = Map.converter(dataView, colorHelper, this.geoTaggingAnalyzerService);
                    this.hasDynamicSeries = data.hasDynamicSeries;
                    // Create legend
                    this.legendData = Map.createLegendData(dataView, colorHelper);
                    this.dataPointsToEnumerate = this.legendData.dataPoints;
                    this.renderLegend(this.legendData);
                    // Start geocoding or geoshaping
                    if (data != null) {
                        this.geocodingCategory = data.geocodingCategory;
                        this.mapControlFactory.ensureMap(this.locale, function () {
                            var params;
                            if (enableGeoShaping) {
                                params = MapShapeDataPointRenderer.getFilledMapParams(_this.geocodingCategory, data.dataPoints.length);
                            }
                            for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                                var dataPoint = _a[_i];
                                if (!dataPoint.location) {
                                    if (!_.isEmpty(dataPoint.categoryValue)) {
                                        if (enableGeoShaping)
                                            _this.enqueueGeoCodeAndGeoShape(dataPoint, params);
                                        else
                                            _this.enqueueGeoCode(dataPoint);
                                    }
                                }
                                else if (enableGeoShaping && !dataPoint.paths) {
                                    _this.enqueueGeoShape(dataPoint, params);
                                }
                                else {
                                    _this.addDataPoint(dataPoint);
                                }
                            }
                        });
                    }
                    else {
                        // No data from conversion, so clear data points
                        this.clearDataPoints();
                    }
                    if (enableGeoShaping) {
                        if (!this.geocodingCategory || !this.geoTaggingAnalyzerService.isGeoshapable(this.geocodingCategory)) {
                            warnings.push(new visuals.FilledMapWithoutValidGeotagCategoryWarning());
                        }
                    }
                }
                else {
                    this.clearDataPoints();
                    this.renderLegend({
                        dataPoints: [],
                        title: undefined,
                    });
                    this.dataPointsToEnumerate = [];
                }
                if (!_.isEmpty(warnings))
                    this.host.setWarnings(warnings);
                this.dataPointRenderer.setData(data);
                this.updateInternal(true /* dataChanged */, true /* redrawDataLabels */);
            };
            Map.converter = function (dataView, colorHelper, geoTaggingAnalyzerService) {
                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
                var dataPoints = [];
                var hasDynamicSeries = reader.hasDynamicSeries();
                var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields();
                var sizeQueryName = reader.getMeasureQueryName('Size');
                if (sizeQueryName == null)
                    sizeQueryName = '';
                var hasSize = reader.hasValues('Size');
                var geocodingCategory = null;
                var formatStringProp = visuals.mapProps.general.formatString;
                if (reader.hasCategories()) {
                    // Calculate category totals and range for radius calculation
                    var categoryTotals = [];
                    var categoryTotalRange = void 0;
                    if (hasSize) {
                        var categoryMin = undefined;
                        var categoryMax = undefined;
                        for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                            var categoryTotal = 0;
                            for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                                categoryTotal += reader.getValue('Size', categoryIndex, seriesIndex);
                            }
                            categoryTotals.push(categoryTotal);
                            if (categoryMin === undefined || categoryTotal < categoryMin)
                                categoryMin = categoryTotal;
                            if (categoryMax === undefined || categoryTotal > categoryMax)
                                categoryMax = categoryTotal;
                        }
                        categoryTotalRange = (categoryMin !== undefined && categoryMax !== undefined) ? {
                            max: categoryMax,
                            min: categoryMin,
                        } : undefined;
                    }
                    var hasLatLongGroup = reader.hasCompositeCategories() && reader.hasCategoryWithRole('X') && reader.hasCategoryWithRole('Y');
                    var hasCategoryGroup = reader.hasCategoryWithRole('Category');
                    geocodingCategory = Map.getGeocodingCategory(dataView.categorical, geoTaggingAnalyzerService);
                    if (hasLatLongGroup || hasCategoryGroup) {
                        // Create data points
                        for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                            // Get category information
                            var categoryValue = undefined;
                            var categoryObjects = reader.getCategoryObjects('Category', categoryIndex);
                            var location_4 = void 0;
                            var categoryTooltipItem = void 0;
                            var latitudeTooltipItem = void 0;
                            var longitudeTooltipItem = void 0;
                            var seriesTooltipItem = void 0;
                            var sizeTooltipItem = void 0;
                            var gradientTooltipItem = void 0;
                            if (hasCategoryGroup) {
                                // Set category value
                                categoryValue = reader.getCategoryValue('Category', categoryIndex);
                                categoryTooltipItem = {
                                    displayName: reader.getCategoryDisplayName('Category'),
                                    value: visuals.converterHelper.formatFromMetadataColumn(categoryValue, reader.getCategoryMetadataColumn('Category'), formatStringProp),
                                };
                                // Create location from latitude and longitude if they exist as values
                                if (reader.hasValues('Y') && reader.hasValues('X')) {
                                    var latitude = reader.getFirstNonNullValueForCategory('Y', categoryIndex);
                                    var longitude = reader.getFirstNonNullValueForCategory('X', categoryIndex);
                                    if (latitude != null && longitude != null) {
                                        location_4 = { latitude: latitude, longitude: longitude };
                                    }
                                    latitudeTooltipItem = {
                                        displayName: reader.getValueDisplayName('Y'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getValueMetadataColumn('Y'), formatStringProp),
                                    };
                                    longitudeTooltipItem = {
                                        displayName: reader.getValueDisplayName('X'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getValueMetadataColumn('X'), formatStringProp),
                                    };
                                }
                            }
                            else {
                                var latitude = reader.getCategoryValue('Y', categoryIndex);
                                var longitude = reader.getCategoryValue('X', categoryIndex);
                                if (latitude != null && longitude != null) {
                                    // Combine latitude and longitude to create the category value
                                    categoryValue = latitude + ', ' + longitude;
                                    // Create location from latitude and longitude
                                    location_4 = { latitude: latitude, longitude: longitude };
                                    latitudeTooltipItem = {
                                        displayName: reader.getCategoryDisplayName('Y'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getCategoryMetadataColumn('Y'), formatStringProp),
                                    };
                                    longitudeTooltipItem = {
                                        displayName: reader.getCategoryDisplayName('X'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getCategoryMetadataColumn('X'), formatStringProp),
                                    };
                                }
                            }
                            var value = hasSize ? categoryTotals[categoryIndex] : undefined;
                            // Calculate sub data points by series
                            var subDataPoints = [];
                            var seriesCount = reader.getSeriesCount();
                            if (!hasSize && !hasDynamicSeries) {
                                seriesCount = 1;
                            }
                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                                var color = void 0;
                                if (hasDynamicSeries) {
                                    color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, (reader.getSeriesName(seriesIndex)));
                                }
                                else if (reader.hasCategoryWithRole('Series')) {
                                    color = colorHelper.getColorForSeriesValue(reader.getCategoryObjects('Series', categoryIndex), reader.getCategoryColumnIdentityFields('Series'), categoryValue);
                                }
                                else {
                                    color = colorHelper.getColorForMeasure(categoryObjects, sizeQueryName);
                                }
                                var colorRgb = Color.parseColorString(color);
                                var stroke = Color.hexString(Color.darken(colorRgb, Map.StrokeDarkenColorValue));
                                colorRgb.A = 0.6;
                                var fill = Color.rgbString(colorRgb);
                                var identityBuilder = new visuals.SelectionIdBuilder()
                                    .withCategory(reader.getCategoryColumn(hasCategoryGroup ? 'Category' : 'Y'), categoryIndex)
                                    .withMeasure(sizeQueryName);
                                if (hasDynamicSeries) {
                                    identityBuilder = identityBuilder.withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex));
                                }
                                if (hasDynamicSeries) {
                                    seriesTooltipItem = {
                                        displayName: reader.getSeriesDisplayName(),
                                        value: visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp),
                                    };
                                }
                                var subsliceValue = void 0;
                                if (hasSize) {
                                    subsliceValue = reader.getValue('Size', categoryIndex, seriesIndex);
                                    sizeTooltipItem = {
                                        displayName: reader.getValueDisplayName('Size'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(subsliceValue, reader.getValueMetadataColumn('Size', seriesIndex), formatStringProp),
                                    };
                                }
                                if (reader.hasValues('Gradient')) {
                                    gradientTooltipItem = {
                                        displayName: reader.getValueDisplayName('Gradient'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(reader.getValue('Gradient', categoryIndex, seriesIndex), reader.getValueMetadataColumn('Gradient', seriesIndex), formatStringProp),
                                    };
                                }
                                // Combine any existing tooltip items
                                var tooltipInfo = [];
                                if (categoryTooltipItem)
                                    tooltipInfo.push(categoryTooltipItem);
                                if (seriesTooltipItem)
                                    tooltipInfo.push(seriesTooltipItem);
                                if (latitudeTooltipItem)
                                    tooltipInfo.push(latitudeTooltipItem);
                                if (longitudeTooltipItem)
                                    tooltipInfo.push(longitudeTooltipItem);
                                if (sizeTooltipItem)
                                    tooltipInfo.push(sizeTooltipItem);
                                if (gradientTooltipItem)
                                    tooltipInfo.push(gradientTooltipItem);
                                // Do not create subslices for data points with 0 or null
                                if (subsliceValue || !hasSize) {
                                    subDataPoints.push({
                                        value: subsliceValue,
                                        fill: fill,
                                        stroke: stroke,
                                        identity: identityBuilder.createSelectionId(),
                                        tooltipInfo: tooltipInfo,
                                    });
                                }
                            }
                            // Skip data points that have a total value of 0 or null
                            if (value || !hasSize) {
                                dataPoints.push({
                                    geocodingQuery: categoryValue,
                                    value: value,
                                    categoryValue: categoryValue,
                                    subDataPoints: subDataPoints,
                                    radius: Map.calculateRadius(categoryTotalRange, value),
                                    location: location_4,
                                });
                            }
                        }
                    }
                }
                var mapData = {
                    dataPoints: dataPoints,
                    geocodingCategory: geocodingCategory,
                    hasDynamicSeries: hasDynamicSeries,
                    hasSize: hasSize,
                };
                return mapData;
            };
            Map.createLegendData = function (dataView, colorHelper) {
                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
                var legendDataPoints = [];
                var legendTitle;
                if (reader.hasDynamicSeries()) {
                    legendTitle = reader.getSeriesDisplayName();
                    var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields();
                    for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                        var color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, reader.getSeriesName(seriesIndex));
                        var identity = new visuals.SelectionIdBuilder().withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex)).createSelectionId();
                        legendDataPoints.push({
                            color: color,
                            label: visuals.valueFormatter.format(reader.getSeriesName(seriesIndex)),
                            icon: visuals.LegendIcon.Circle,
                            identity: identity,
                            selected: false,
                        });
                    }
                }
                var legendData = {
                    dataPoints: legendDataPoints,
                    title: legendTitle,
                };
                return legendData;
            };
            Map.prototype.swapLogoContainerChildElement = function () {
                // This is a workaround that allow maps to be printed from the IE and Edge browsers.
                // For some unknown reason, the presence of an <a> child element in the .LogoContainer
                // prevents dashboard map visuals from showing up when printed.
                // The trick is to swap out the <a> element with a <div> container.
                // There are no user impacts or visual changes.
                var logoContainer = this.element.find('.LogoContainer');
                if (logoContainer) {
                    var aNode = logoContainer.find('a');
                    if (aNode == null)
                        return;
                    var divNode = $('<div>');
                    aNode.children().clone().appendTo(divNode);
                    aNode.remove();
                    divNode.appendTo(logoContainer);
                }
            };
            Map.prototype.onResizing = function (viewport) {
                if (this.currentViewport.width !== viewport.width || this.currentViewport.height !== viewport.height) {
                    this.currentViewport = viewport;
                    this.renderLegend(this.legendData);
                    this.updateInternal(false /* dataChanged */, false);
                }
            };
            Map.prototype.initialize = function (container) {
                var _this = this;
                var mapOptions = {
                    credentials: visuals.MapUtil.Settings.BingKey,
                    showMapTypeSelector: false,
                    enableClickableLogo: false,
                    enableSearchLogo: false,
                    mapTypeId: Microsoft.Maps.MapTypeId.road,
                    customizeOverlays: true,
                    showDashboard: false,
                    showScalebar: false,
                    disableKeyboardInput: true,
                    disableZooming: this.disableZooming,
                    disablePanning: this.disablePanning,
                };
                var divQuery = this.root = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
                this.mapControl = this.mapControlFactory.createMapControl(divQuery[0], mapOptions);
                if (this.viewChangeThrottleInterval !== undefined) {
                    Microsoft.Maps.Events.addThrottledHandler(this.mapControl, 'viewchange', function () { _this.onViewChanged(); }, this.viewChangeThrottleInterval);
                }
                else {
                    Microsoft.Maps.Events.addHandler(this.mapControl, 'viewchange', function () { _this.onViewChanged(); });
                }
                Microsoft.Maps.Events.addHandler(this.mapControl, "viewchangeend", function () { _this.onViewChangeEnded(); });
                this.dataPointRenderer.init(this.mapControl, divQuery, !!this.behavior);
                if (!this.pendingGeocodingRender) {
                    this.updateInternal(true /* dataChanged */, true);
                }
            };
            Map.prototype.onViewChanged = function () {
                if (!this.executingInternalViewChange)
                    this.receivedExternalViewChange = true;
                else
                    this.executingInternalViewChange = false;
                this.updateOffsets(false, false /* dataChanged */);
                if (this.behavior)
                    this.behavior.viewChanged();
                this.swapLogoContainerChildElement();
            };
            Map.prototype.onViewChangeEnded = function () {
                this.dataPointRenderer.updateInternalDataLabels(this.currentViewport, true);
            };
            Map.prototype.getMapViewPort = function () {
                var currentViewport = this.currentViewport;
                var legendMargins = this.legend.getMargins();
                var mapViewport = {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height,
                };
                return mapViewport;
            };
            Map.removeTransform3d = function (mapRoot) {
                // don't remove transform3d from bing maps images in safari (using applewebkit engine)
                var userAgent = window.navigator.userAgent.toLowerCase();
                if (mapRoot && userAgent.indexOf('applewebkit') === -1) {
                    var imageTiles = mapRoot.find('img');
                    imageTiles.css('transform', '');
                }
            };
            Map.prototype.updateInternal = function (dataChanged, redrawDataLabels) {
                if (this.mapControl) {
                    var isLegendVisible = this.legend.isVisible();
                    if (!isLegendVisible)
                        this.legendData = { dataPoints: [] };
                    var mapDiv = this.element.children(Map.MapContainer.selector);
                    var mapViewport = this.getMapViewPort();
                    mapDiv.height(mapViewport.height);
                    mapDiv.width(mapViewport.width);
                    // With the risk of double drawing, if the position updates to nearly the same, the map control won't call viewchange, so explicitly update the points
                    this.updateOffsets(dataChanged, redrawDataLabels);
                    // Set zoom level after we rendered that map as we need the max size of the bubbles/ pie slices to calculate it
                    var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height);
                    var center = this.getViewCenter(levelOfDetail);
                    this.updateMapView(center, levelOfDetail);
                }
            };
            Map.prototype.updateMapView = function (center, levelOfDetail) {
                if (!this.receivedExternalViewChange || !this.interactivityService) {
                    this.executingInternalViewChange = true;
                    this.mapControl.setView({ center: center, zoom: levelOfDetail, animate: true });
                }
            };
            Map.prototype.updateOffsets = function (dataChanged, redrawDataLabels) {
                var dataView = this.dataView;
                var data;
                var viewport = this.getMapViewPort();
                if (dataView && dataView.categorical) {
                    // currentViewport may not exist in UnitTests
                    data = this.dataPointRenderer.converter(viewport, this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
                }
                else {
                    data = {
                        bubbleData: [],
                        shapeData: [],
                        sliceData: [],
                    };
                }
                var behaviorOptions = this.dataPointRenderer.updateInternal(data, viewport, dataChanged, this.interactivityService, redrawDataLabels);
                visuals.Legend.positionChartArea(d3.select(this.root[0]), this.legend);
                if (this.interactivityService && behaviorOptions) {
                    this.interactivityService.bind(behaviorOptions.dataPoints, this.behavior, behaviorOptions);
                }
            };
            Map.prototype.onClearSelection = function () {
                this.interactivityService.clearSelection();
                this.updateOffsets(false, false /* dataChanged */);
            };
            Map.prototype.clearDataPoints = function () {
                this.dataPointRenderer.clearDataPoints();
                this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
            };
            Map.prototype.getDefaultMapControlFactory = function () {
                return {
                    createMapControl: function (element, options) { return new Microsoft.Maps.Map(element, options); },
                    ensureMap: jsCommon.ensureMap,
                };
            };
            Map.MapContainer = {
                cssClass: 'mapControl',
                selector: '.mapControl'
            };
            Map.StrokeDarkenColorValue = 255 * 0.25;
            return Map;
        }());
        visuals.Map = Map;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var UrlUtils = jsCommon.UrlUtils;
        var TitleFontFamily = 'wf_segoe-ui_semibold';
        var DefaultFontFamily = 'wf_segoe-ui_normal';
        var DefaultCaptionFontSizeInPt = 10;
        var DefaultTitleFontSizeInPt = 13;
        var DefaultDetailFontSizeInPt = 9;
        var DefaultTitleColor = '#767676';
        var DefaultTextColor = '#333333';
        var MultiRowCard = (function () {
            function MultiRowCard() {
                this.isInteractivityOverflowHidden = false;
            }
            MultiRowCard.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.options = options;
                this.style = options.style;
                var viewport = this.currentViewport = options.viewport;
                var interactivity = this.interactivity = options.interactivity;
                if (interactivity && interactivity.overflow === 'hidden')
                    this.isInteractivityOverflowHidden = true;
                var multiRowCardDiv = this.element = $('<div/>')
                    .addClass(MultiRowCard.MultiRowCardRoot.class)
                    .css({
                    'height': getPixelString(viewport.height),
                });
                options.element.append(multiRowCardDiv);
                this.initializeCardRowSelection();
            };
            MultiRowCard.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var dataView = this.dataView = dataViews[0];
                    var columnMetadata = dataView.table.columns;
                    var tableRows = dataView.table.rows;
                    var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append;
                    var data_2 = this.data = MultiRowCard.converter(dataView, columnMetadata.length, tableRows.length, this.isInteractivityOverflowHidden);
                    this.setCardDimensions();
                    this.listView.data(data_2.dataModel, function (d) { return data_2.dataModel.indexOf(d); }, resetScrollbarPosition);
                }
                else {
                    this.data = {
                        dataModel: [],
                        cardTitleSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTitleColor, DefaultTitleFontSizeInPt),
                        categoryLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultDetailFontSizeInPt),
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultCaptionFontSizeInPt),
                    };
                }
                this.waitingForData = false;
            };
            MultiRowCard.prototype.onResizing = function (viewport) {
                var heightNotChanged = (this.currentViewport.height === viewport.height);
                this.currentViewport = viewport;
                this.element.css('height', getPixelString(viewport.height));
                if (!this.dataView)
                    return;
                var previousMaxColPerRow = this.maxColPerRow;
                this.maxColPerRow = this.getMaxColPerRow();
                var widthNotChanged = (previousMaxColPerRow === this.maxColPerRow);
                if (heightNotChanged && widthNotChanged)
                    return;
                this.listView.viewport(viewport);
            };
            MultiRowCard.converter = function (dataView, columnCount, maxCards, isDashboardVisual) {
                if (isDashboardVisual === void 0) { isDashboardVisual = false; }
                var details = [];
                var tableDataRows = dataView.table.rows;
                var columnMetadata = dataView.table.columns;
                var cardTitleSettings, dataLabelsSettings, categoryLabelsSettings;
                cardTitleSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTitleColor, DefaultTitleFontSizeInPt);
                dataLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultCaptionFontSizeInPt);
                categoryLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultDetailFontSizeInPt);
                if (dataView.metadata && dataView.metadata.objects) {
                    var cardTitleLabelObjects = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'cardTitle');
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(cardTitleLabelObjects, cardTitleSettings);
                    var dataLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'dataLabels');
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(dataLabelObject, dataLabelsSettings);
                    var categoryLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'categoryLabels');
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelObject, categoryLabelsSettings);
                }
                for (var i = 0, len = maxCards; i < len; i++) {
                    var row = tableDataRows[i];
                    var isValuePromoted = undefined;
                    var title = undefined;
                    var showTitleAsURL = false;
                    var showTitleAsImage = false;
                    var showTitleAsKPI = false;
                    var cardData = [];
                    for (var j = 0; j < columnCount; j++) {
                        var column = columnMetadata[j];
                        var statusGraphicInfo = getKpiImageMetadata(column, row[j]);
                        var columnCaption = void 0;
                        var statusGraphic = void 0;
                        if (statusGraphicInfo) {
                            columnCaption = statusGraphicInfo.class;
                            statusGraphic = statusGraphicInfo.statusGraphic;
                        }
                        //TODO: seems we are duplicating this logic in many places. Consider putting it in KPIUtil
                        if (!columnCaption)
                            columnCaption = visuals.valueFormatter.format(row[j], visuals.valueFormatter.getFormatString(column, MultiRowCard.formatStringProp));
                        var showKPI = statusGraphicInfo !== undefined && statusGraphicInfo.caption !== undefined;
                        // The columnDetail represents column name. In card the column name is shown as details
                        var columnDetail = columnMetadata[j].displayName;
                        //Title is shown only on Canvas and only if there is one Category field.
                        if (!isDashboardVisual && !column.type.numeric) {
                            if (isValuePromoted === undefined) {
                                isValuePromoted = true;
                                title = columnCaption;
                                showTitleAsURL = visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(title);
                                showTitleAsImage = visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption);
                                showTitleAsKPI = showKPI;
                            }
                            else if (isValuePromoted) {
                                isValuePromoted = false;
                            }
                        }
                        cardData.push({
                            caption: columnCaption,
                            details: columnDetail,
                            showURL: visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(columnCaption),
                            showImage: visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption),
                            showKPI: showKPI,
                            columnIndex: j
                        });
                    }
                    details.push({
                        title: isValuePromoted ? title : undefined,
                        showTitleAsURL: showTitleAsURL,
                        showTitleAsImage: showTitleAsImage,
                        showTitleAsKPI: showTitleAsKPI,
                        cardItemsData: isValuePromoted ? cardData.filter(function (d) { return d.caption !== title; }) : cardData
                    });
                }
                return {
                    dataModel: details,
                    cardTitleSettings: cardTitleSettings,
                    categoryLabelsSettings: categoryLabelsSettings,
                    dataLabelsSettings: dataLabelsSettings,
                };
            };
            MultiRowCard.prototype.initializeCardRowSelection = function () {
                var _this = this;
                var isDashboardVisual = this.isInteractivityOverflowHidden;
                var rowEnter = function (rowSelection) {
                    var cardRow = rowSelection
                        .append("div")
                        .classed(MultiRowCard.Card.class, true);
                    // The card top padding is not needed when card items are wrapped as top padding is added to each carditemcontainer when wrapped
                    if (isDashboardVisual) {
                        cardRow.classed('mrtile', true);
                    }
                    else {
                        if (_this.cardHasTitle) {
                            cardRow.append("div").classed(MultiRowCard.Title.class, true)
                                .each(function (d) {
                                if (d.showTitleAsImage)
                                    appendImage(d3.select(this));
                                else if (d.showTitleAsURL)
                                    d3.select(this).append('a');
                                else if (d.showTitleAsKPI)
                                    d3.select(this).append('div')
                                        .classed(MultiRowCard.KPITitle.class, true)
                                        .classed(d.title, true)
                                        .style({
                                        display: 'inline-block',
                                        verticalAlign: 'sub'
                                    });
                            });
                        }
                    }
                    var cardItem = cardRow
                        .selectAll(MultiRowCard.CardItemContainer.selector)
                        .data(function (d) { return d.cardItemsData; })
                        .enter()
                        .append('div')
                        .classed(MultiRowCard.CardItemContainer.class, true);
                    cardItem
                        .append('div')
                        .classed(MultiRowCard.Caption.class, true)
                        .each(function (d) {
                        if (d.showURL) {
                            d3.select(this).append('a');
                        }
                        else if (d.showImage) {
                            appendImage(d3.select(this));
                        }
                        else if (d.showKPI) {
                            d3.select(this).append('div')
                                .classed(d.caption, true)
                                .style({
                                display: 'inline-block',
                                verticalAlign: 'sub'
                            });
                        }
                    });
                    cardItem
                        .append('div')
                        .classed(MultiRowCard.Details.class, true);
                };
                /**
                * Row update should:
                * 1. bind Data
                * 2. Manipulate DOM (likely just updating CSS properties) affected by data
                */
                var rowUpdate = function (rowSelection) {
                    var style = _this.getStyle();
                    var dataLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(false, style.caption.fontSize));
                    var categoryLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(false, style.details.fontSize));
                    var titleLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(true, style.title.fontSize));
                    if (!isDashboardVisual && _this.cardHasTitle) {
                        rowSelection.selectAll(MultiRowCard.Title.selector)
                            .filter(function (d) { return !d.showTitleAsImage && !d.showTitleAsKPI; })
                            .style({
                            'font-size': PixelConverter.fromPoint(style.title.fontSize),
                            'line-height': PixelConverter.toString(titleLabelHeight),
                            'color': style.title.color,
                        });
                        rowSelection.selectAll(MultiRowCard.Title.selector)
                            .filter(function (d) { return !d.showTitleAsURL && !d.showTitleAsImage && !d.showTitleAsKPI; })
                            .text(function (d) { return d.title; })
                            .attr('title', function (d) { return d.title; });
                        rowSelection
                            .selectAll(MultiRowCard.TitleUrlSelector)
                            .text(function (d) { return d.title; })
                            .attr({
                            'href': function (d) { return d.title; },
                            'target': '_blank',
                        });
                        rowSelection
                            .selectAll(MultiRowCard.TitleImageSelector)
                            .attr('src', function (d) { return d.title; });
                        setImageStyle(rowSelection.selectAll(MultiRowCard.Title.selector), style.imageTitle);
                        rowSelection
                            .selectAll(MultiRowCard.KPITitle.selector)
                            .each(function (d) {
                            var element = d3.select(this);
                            element.classed(d.title);
                        });
                    }
                    var cardSelection = rowSelection.selectAll(MultiRowCard.Card.selector);
                    cardSelection
                        .selectAll(MultiRowCard.Caption.selector)
                        .filter(function (d) { return !d.showImage; })
                        .style({
                        'line-height': PixelConverter.toString(dataLabelHeight),
                        'font-size': PixelConverter.fromPoint(style.caption.fontSize),
                    })
                        .filter(function (d) { return !d.showKPI; })
                        .style({
                        'color': style.caption.color,
                    })
                        .filter(function (d) { return !d.showURL; })
                        .text(function (d) { return d.caption; })
                        .attr('title', function (d) { return d.caption; });
                    cardSelection
                        .selectAll(MultiRowCard.CaptionImageSelector)
                        .attr('src', function (d) { return d.caption; })
                        .style(style.imageCaption);
                    cardSelection
                        .selectAll(MultiRowCard.CardItemContainer.selector)
                        .style({
                        'padding-right': function (d) {
                            return _this.isLastRowItem(d.columnIndex, _this.dataView.metadata.columns.length) ? '0px' : getPixelString(style.cardItemContainer.paddingRight);
                        },
                        'width': function (d) {
                            return _this.getColumnWidth(d.columnIndex, _this.dataView.metadata.columns.length);
                        },
                        'display': function (d) {
                            return (_this.hideColumn(d.columnIndex) ? 'none' : 'inline-block');
                        },
                    });
                    setImageStyle(cardSelection.selectAll(MultiRowCard.Caption.selector), style.imageCaption);
                    cardSelection
                        .selectAll(MultiRowCard.CaptionUrlSelector)
                        .attr({
                        'href': function (d) { return d.caption; },
                        'target': '_blank',
                    })
                        .text(function (d) { return d.caption; });
                    if (style.details.isVisible) {
                        cardSelection
                            .selectAll(MultiRowCard.Details.selector)
                            .text(function (d) { return d.details; })
                            .style({
                            'font-size': PixelConverter.fromPoint(style.details.fontSize),
                            'line-height': PixelConverter.toString(categoryLabelHeight),
                            'color': style.details.color
                        })
                            .attr('title', function (d) { return d.details; });
                    }
                    cardSelection
                        .style('margin-bottom', isDashboardVisual ? '0px' : (_this.isSingleRowCard ? '0px' : getPixelString(style.card.marginBottom)));
                };
                var rowExit = function (rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: undefined,
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function () { return _this.onLoadMoreData(); },
                    viewport: this.currentViewport,
                    baseContainer: d3.select(this.element.get(0)),
                    scrollEnabled: !this.isInteractivityOverflowHidden,
                    isReadMode: function () {
                        return (_this.options.host.getViewMode() !== 1 /* Edit */);
                    }
                };
                this.listView = visuals.ListViewFactory.createListView(listViewOptions);
            };
            MultiRowCard.prototype.getMaxColPerRow = function () {
                var rowWidth = this.currentViewport.width;
                var minColumnWidth = this.getStyle().cardItemContainer.minWidth;
                var columnCount = this.dataView.metadata.columns.length;
                //atleast one column fits in a row
                var maxColumnPerRow = Math.floor(rowWidth / minColumnWidth) || 1;
                return Math.min(columnCount, maxColumnPerRow);
            };
            MultiRowCard.prototype.getRowIndex = function (fieldIndex) {
                return Math.floor((fieldIndex * 1.0) / this.getMaxColPerRow());
            };
            MultiRowCard.prototype.getStyle = function () {
                var defaultStyle = this.getOverridenStyle();
                if (!this.isInteractivityOverflowHidden)
                    return $.extend(true, {}, defaultStyle);
                var viewportWidth = this.currentViewport.width;
                var overrideStyle = {};
                for (var _i = 0, _a = MultiRowCard.tileMediaQueries; _i < _a.length; _i++) {
                    var currentQuery = _a[_i];
                    if (viewportWidth <= currentQuery.maxWidth) {
                        overrideStyle = currentQuery.style;
                        break;
                    }
                }
                return $.extend(true, {}, defaultStyle, overrideStyle);
            };
            MultiRowCard.prototype.getOverridenStyle = function () {
                var defaultStyle = MultiRowCard.DefaultStyle;
                var dataLabelsSettings = this.data.dataLabelsSettings;
                var categoryLabelSettings = this.data.categoryLabelsSettings;
                var titleLabelSettings = this.data.cardTitleSettings;
                var overrideStyle = {
                    caption: {
                        fontSize: dataLabelsSettings.fontSize,
                        color: dataLabelsSettings.labelColor,
                    },
                    title: {
                        fontSize: titleLabelSettings.fontSize,
                        color: titleLabelSettings.labelColor,
                    },
                    details: {
                        fontSize: categoryLabelSettings.fontSize,
                        color: categoryLabelSettings.labelColor,
                        isVisible: categoryLabelSettings.show,
                    }
                };
                return $.extend(true, overrideStyle, defaultStyle);
            };
            MultiRowCard.getTextProperties = function (isTitle, fontSizeInPt) {
                return {
                    fontFamily: isTitle ? TitleFontFamily : DefaultFontFamily,
                    fontSize: PixelConverter.fromPoint(fontSizeInPt),
                };
            };
            MultiRowCard.prototype.hideColumn = function (fieldIndex) {
                //calculate the number of items apearing in the same row as the columnIndex
                var rowIndex = this.getRowIndex(fieldIndex);
                // when interactivity is disabled (pinned tile), don't wrap the row
                var maxRows = this.getStyle().card.maxRows;
                return (maxRows && rowIndex >= maxRows);
            };
            MultiRowCard.prototype.getColumnWidth = function (fieldIndex, columnCount) {
                //atleast one column fits in a row
                var maxColumnPerRow = this.getMaxColPerRow();
                if (maxColumnPerRow >= columnCount)
                    //all columns fit in the same row, divide the space equaly
                    return (100.0 / columnCount) + '%';
                //calculate the number of items apearing in the same row as the columnIndex
                var rowIndex = this.getRowIndex(fieldIndex);
                var totalRows = Math.ceil((columnCount * 1.0) / maxColumnPerRow);
                var lastRowCount = columnCount % maxColumnPerRow;
                if (rowIndex < totalRows || lastRowCount === 0)
                    // items is not on the last row or last row contains max columns allowed per row
                    return (100.0 / maxColumnPerRow) + '%';
                // items is on the last row
                return (100.0 / lastRowCount) + '%';
            };
            MultiRowCard.prototype.isLastRowItem = function (fieldIndex, columnCount) {
                if (fieldIndex + 1 === columnCount)
                    return true;
                var maxColumnPerRow = this.getMaxColPerRow();
                if (maxColumnPerRow - (fieldIndex % maxColumnPerRow) === 1)
                    return true;
                return false;
            };
            /**
             * This contains the card column wrapping logic.
             * Determines how many columns can be shown per each row inside a Card.
             * To place the fields evenly along the card,
             * the width of each card item is calculated based on the available viewport width.
             */
            MultiRowCard.prototype.setCardDimensions = function () {
                this.cardHasTitle = false;
                var dataModel = this.data.dataModel;
                if (!this.isInteractivityOverflowHidden && dataModel && dataModel.length > 0) {
                    this.cardHasTitle = dataModel[0].title !== undefined;
                    this.isSingleRowCard = dataModel.length === 1 ? true : false;
                }
            };
            MultiRowCard.prototype.onLoadMoreData = function () {
                if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                    this.options.host.loadMoreData();
                    this.waitingForData = true;
                }
            };
            MultiRowCard.getDataLabelSettingsOptions = function (enumeration, labelSettings, show) {
                if (show === void 0) { show = false; }
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: show,
                    fontSize: true,
                };
            };
            MultiRowCard.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                var cardTitleSettings = this.data.cardTitleSettings;
                var dataLabelsSettings = this.data.dataLabelsSettings;
                var categoryLabelsSettings = this.data.categoryLabelsSettings;
                switch (options.objectName) {
                    case 'cardTitle':
                        //display title options only if title visible
                        if (!this.isInteractivityOverflowHidden && this.cardHasTitle)
                            visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, cardTitleSettings));
                        break;
                    case 'dataLabels':
                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, dataLabelsSettings));
                        break;
                    case 'categoryLabels':
                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, categoryLabelsSettings, true));
                        break;
                }
                return enumeration.complete();
            };
            /**
             * Note: Public for testability.
             */
            MultiRowCard.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            MultiRowCard.MultiRowCardRoot = createClassAndSelector('multiRowCard');
            MultiRowCard.Card = createClassAndSelector('card');
            MultiRowCard.Title = createClassAndSelector('title');
            MultiRowCard.CardItemContainer = createClassAndSelector('cardItemContainer');
            MultiRowCard.Caption = createClassAndSelector('caption');
            MultiRowCard.Details = createClassAndSelector('details');
            MultiRowCard.TitleUrlSelector = MultiRowCard.Title.selector + ' a';
            MultiRowCard.CaptionUrlSelector = MultiRowCard.Caption.selector + ' a';
            MultiRowCard.TitleImageSelector = MultiRowCard.Title.selector + ' img';
            MultiRowCard.CaptionImageSelector = MultiRowCard.Caption.selector + ' img';
            MultiRowCard.KPITitle = createClassAndSelector('kpiTitle');
            /**
             * Cards have specific styling so defined inline styles and also to support theming and improve performance.
             */
            MultiRowCard.DefaultStyle = {
                card: {
                    marginBottom: 20
                },
                cardItemContainer: {
                    paddingRight: 20,
                    minWidth: 120,
                },
                imageCaption: {
                    maxHeight: 75,
                    maxWidth: 100,
                },
                imageTitle: {
                    maxHeight: 75,
                    maxWidth: 100,
                }
            };
            // queries should be ordered by maxWidth in ascending order
            MultiRowCard.tileMediaQueries = [
                {
                    maxWidth: 250,
                    style: {
                        card: {
                            maxRows: 2,
                        },
                        cardItemContainer: {
                            minWidth: 110,
                        },
                        imageCaption: {
                            maxHeight: 45,
                        }
                    }
                },
                {
                    maxWidth: 490,
                    style: {
                        card: {
                            maxRows: 2,
                        },
                        cardItemContainer: {
                            minWidth: 130,
                        },
                        imageCaption: {
                            maxHeight: 52,
                        }
                    }
                },
                {
                    maxWidth: 750,
                    style: {
                        card: {
                            maxRows: 1,
                        },
                        cardItemContainer: {
                            minWidth: 120,
                        },
                        imageCaption: {
                            maxHeight: 53,
                        }
                    }
                }
            ];
            return MultiRowCard;
        }());
        visuals.MultiRowCard = MultiRowCard;
        function appendImage(selection) {
            selection
                .append('div')
                .classed('imgCon', true)
                .append('img');
        }
        function setImageStyle(selection, imageStyle) {
            selection
                .selectAll('.imgCon')
                .style({
                'height': getPixelString(imageStyle.maxHeight),
            })
                .selectAll('img')
                .style({
                'max-height': getPixelString(imageStyle.maxHeight),
                'max-width': getPixelString(imageStyle.maxWidth),
            });
        }
        function getPixelString(value) {
            return value + "px";
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var StringExtensions = jsCommon.StringExtensions;
        var UrlUtils = jsCommon.UrlUtils;
        /** Represents a rich text box that supports view & edit mode. */
        var Textbox = (function () {
            function Textbox() {
            }
            Textbox.prototype.init = function (options) {
                this.element = options.element;
                this.host = options.host;
                this.viewport = options.viewport;
                this.readOnly = (this.host.getViewMode() === 0 /* View */);
                this.paragraphs = [];
                this.refreshView();
            };
            Textbox.prototype.onResizing = function (viewport) {
                this.viewport = viewport;
                this.updateSize();
            };
            Textbox.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                this.paragraphs = [];
                if (dataViews && dataViews.length > 0) {
                    var objects = dataViews[0].metadata.objects;
                    if (objects && objects.general)
                        this.paragraphs = objects.general.paragraphs;
                }
                this.refreshView();
            };
            Textbox.prototype.destroy = function () {
            };
            Textbox.prototype.focus = function () {
                if (!this.editor)
                    return;
                this.editor.focus();
                return true;
            };
            Textbox.prototype.onViewModeChanged = function (viewMode) {
                this.readOnly = (viewMode === 0 /* View */);
                this.refreshView();
            };
            Textbox.prototype.setSelection = function (start, end) {
                debug.assertValue(this.editor, 'editor');
                if (this.editor)
                    this.editor.setSelection(start, end);
            };
            Textbox.prototype.refreshView = function () {
                var _this = this;
                if (this.readOnly) {
                    // Showing just HTML, no editor.
                    // If we are in view-mode and we have an editor, we can remove it (after saving).
                    if (this.editor) {
                        this.editor.formatUrls();
                        this.saveContents();
                        this.editor.destroy();
                        this.editor = null;
                    }
                    this.element.empty();
                    var htmlContent = RichTextConversion.convertParagraphsToHtml(this.paragraphs);
                    htmlContent.addClass(Textbox.ClassName);
                    htmlContent.css({
                        'font-family': RichText.defaultFont,
                        'font-size': RichText.defaultFontSize,
                    });
                    this.element.append(htmlContent);
                }
                else {
                    // Showing the Quill editor.
                    // If we are in edit-mode and we don't have an editor we need to create it.
                    if (!this.editor) {
                        this.editor = new RichText.QuillWrapper(this.readOnly, this.host);
                        this.editor.textChanged = function (delta, source) { return _this.saveContents(); };
                        this.element.empty();
                        var editorElement = this.editor.getElement();
                        editorElement.addClass(Textbox.ClassName);
                        editorElement.css({
                            'font-family': RichText.defaultFont,
                            'font-size': RichText.defaultFontSize,
                        });
                        this.element.append(editorElement);
                    }
                    this.editor.setContents(RichTextConversion.convertParagraphsToOps(this.paragraphs));
                }
                this.updateSize();
            };
            Textbox.prototype.saveContents = function () {
                // It's possible to get here via a throttled text-changed event after a view-mode change has occured and
                // we are now in view mode. Since we save changes on view-mode change it is safe to ignore this call.
                if (!this.editor)
                    return;
                var contents = this.editor.getContents();
                this.paragraphs = RichTextConversion.convertDeltaToParagraphs(contents);
                var changes = [{
                        objectName: 'general',
                        properties: {
                            paragraphs: this.paragraphs
                        },
                        selector: null,
                    }];
                this.host.persistProperties(changes);
            };
            Textbox.prototype.updateSize = function () {
                if (this.editor)
                    this.editor.resize(this.viewport);
            };
            Textbox.ClassName = 'textbox';
            return Textbox;
        }());
        visuals.Textbox = Textbox;
        var RichTextConversion;
        (function (RichTextConversion) {
            function convertDeltaToParagraphs(contents) {
                var paragraphs = [];
                var paragraph = { textRuns: [] };
                for (var i = 0, len = contents.ops.length; i < len; i++) {
                    var insertOp = contents.ops[i];
                    debug.assertValue(insertOp, "operation should be an insert");
                    if (typeof insertOp.insert === "string") {
                        // string insert values represent text.
                        var text = insertOp.insert;
                        var attributes = insertOp.attributes;
                        if (attributes && attributes.align) {
                            // Sometimes horizontal alignment is set after the first "insert" of the paragraph, which is likely a bug
                            // in Quill. In any case we should never see different horizontal alignments in a single paragraph.
                            debug.assert(paragraph.horizontalTextAlignment === undefined || paragraph.horizontalTextAlignment === attributes.align, 'paragraph should not have more than one horizontal alignment');
                            paragraph.horizontalTextAlignment = attributes.align;
                        }
                        // Quill gives us back text runs that may have \n's in them. We want to create a new paragraph for each \n we see.
                        var start = 0;
                        var end = 0;
                        var newParagraph = void 0;
                        do {
                            end = text.indexOf('\n', start);
                            if (end < 0) {
                                newParagraph = false;
                                end = text.length;
                            }
                            else {
                                newParagraph = true;
                            }
                            if (end - start > 0) {
                                var span = text.substring(start, end);
                                var textRun = { value: span };
                                if (attributes) {
                                    if (attributes.link !== undefined && UrlUtils.isValidUrl(attributes.link))
                                        textRun.url = attributes.link;
                                    var textStyle = convertFormatAttributesToTextStyle(attributes);
                                    if (textStyle)
                                        textRun.textStyle = textStyle;
                                }
                                paragraph.textRuns.push(textRun);
                            }
                            // If we actually saw a '\n' then create a new paragraph
                            if (newParagraph) {
                                if (paragraph.textRuns.length === 0)
                                    paragraph.textRuns.push({ value: '' });
                                paragraphs.push(paragraph);
                                paragraph = { textRuns: [] };
                            }
                            start = end + 1;
                        } while (start < text.length);
                    }
                    else {
                        // numeric insert values represent embeds.
                        debug.assertFail("embeds not supported");
                    }
                }
                if (paragraph.textRuns.length > 0) {
                    // Quill appears to always insert an extra '\n' at the end of the text, skip it
                    if (paragraph.textRuns[0].value.length > 0)
                        paragraphs.push(paragraph);
                }
                return paragraphs;
            }
            RichTextConversion.convertDeltaToParagraphs = convertDeltaToParagraphs;
            function convertParagraphsToHtml(paragraphs) {
                var $paragraphs = $();
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    var isParagraphEmpty = true;
                    var $paragraph = $('<div>');
                    if (paragraphDef.horizontalTextAlignment)
                        $paragraph.css('text-align', paragraphDef.horizontalTextAlignment);
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var $textRun = $('<span>');
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            var css = {};
                            if (styleDef.fontFamily) {
                                css['font-family'] = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily));
                            }
                            if (styleDef.fontSize) {
                                css['font-size'] = styleDef.fontSize;
                            }
                            if (styleDef.fontStyle) {
                                css['font-style'] = styleDef.fontStyle;
                            }
                            if (styleDef.fontWeight) {
                                css['font-weight'] = styleDef.fontWeight;
                            }
                            if (styleDef.textDecoration) {
                                css['text-decoration'] = styleDef.textDecoration;
                            }
                            $textRun.css(css);
                        }
                        var text = textRunDef.value;
                        if (!_.isEmpty(text))
                            isParagraphEmpty = false;
                        if (textRunDef.url !== undefined) {
                            var $link = void 0;
                            if (UrlUtils.isValidUrl(textRunDef.url)) {
                                $link = $('<a>')
                                    .attr('href', textRunDef.url)
                                    .attr('target', '_blank')
                                    .text(text);
                            }
                            else {
                                $link = $('<span>').text(text);
                            }
                            $textRun.append($link);
                        }
                        else {
                            $textRun.text(text);
                        }
                        $paragraph.append($textRun);
                    }
                    // If the entire paragraph is empty we need to make sure we enforce a line-break.
                    if (isParagraphEmpty)
                        $paragraph.append($('<br>'));
                    $paragraphs = $paragraphs.add($paragraph);
                }
                return $paragraphs;
            }
            RichTextConversion.convertParagraphsToHtml = convertParagraphsToHtml;
            function convertParagraphsToOps(paragraphs) {
                var ops = [];
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var formats = {};
                        if (paragraphDef.horizontalTextAlignment)
                            formats.align = paragraphDef.horizontalTextAlignment;
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            if (styleDef.fontFamily) {
                                formats.font = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily));
                            }
                            if (styleDef.fontSize) {
                                formats.size = styleDef.fontSize;
                            }
                            formats.italic = (styleDef.fontStyle === 'italic');
                            formats.bold = (styleDef.fontWeight === 'bold');
                            formats.underline = (styleDef.textDecoration === 'underline');
                        }
                        var text = textRunDef.value;
                        if (textRunDef.url && UrlUtils.isValidUrl(textRunDef.url))
                            formats.link = textRunDef.url;
                        var op = {
                            insert: text,
                            attributes: formats,
                        };
                        ops.push(op);
                        // The last text run of the paragraph needs to end with '\n' to get Quill to handle the text alignment correctly.
                        if (textRunIndex === (jlen - 1) && !StringExtensions.endsWith(text, '\n')) {
                            ops.push({
                                insert: '\n',
                                attributes: formats,
                            });
                        }
                    }
                }
                return ops;
            }
            RichTextConversion.convertParagraphsToOps = convertParagraphsToOps;
            function convertFormatAttributesToTextStyle(attributes) {
                var style = {};
                // NOTE: Align is taken care of when converting to paragraphs.
                if (attributes.bold) {
                    style.fontWeight = 'bold';
                }
                if (attributes.font) {
                    // We should always save font names without any quotes.
                    var font = removeQuotes(attributes.font);
                    // Convert built-in font families back into their proper font families (e.g. wf_segoe-ui_normal -> Segoe UI)
                    font = RichText.getFontFamilyForBuiltInFont(font);
                    style.fontFamily = font;
                }
                if (attributes.italic) {
                    style.fontStyle = 'italic';
                }
                if (attributes.size) {
                    style.fontSize = attributes.size;
                }
                if (attributes.underline) {
                    style.textDecoration = 'underline';
                }
                /*
                TODO:
                if (attributes.background) {
                }
                if (attributes.color) {
                }
                */
                return style;
            }
            function removeQuotes(text) {
                if (!StringExtensions.startsWith(text, "'"))
                    return text;
                debug.assert(StringExtensions.endsWith(text, "'"), "mismatched quotes");
                return text.slice(1, text.length - 1);
            }
        })(RichTextConversion || (RichTextConversion = {}));
        var RichText;
        (function (RichText) {
            /**
             * These fonts are embedded using CSS, or are aliases to other fonts.
             */
            var fontMap = {
                'Segoe (Bold)': 'wf_segoe-ui_bold',
                'Segoe UI': 'wf_segoe-ui_normal',
                'Segoe UI Light': 'wf_segoe-ui_light',
                'Heading': 'wf_segoe-ui_light',
                'Body': 'wf_segoe-ui_normal',
            };
            var fonts = [
                'Arial',
                'Arial Black',
                'Arial Unicode MS',
                'Calibri',
                'Cambria',
                'Cambria Math',
                'Candara',
                'Comic Sans MS',
                'Consolas',
                'Constantia',
                'Corbel',
                'Courier New',
                'Georgia',
                'Lucida Sans Unicode',
                'Segoe (Bold)',
                'Segoe UI',
                'Segoe UI Light',
                'Symbol',
                'Tahoma',
                'Times New Roman',
                'Trebuchet MS',
                'Verdana',
                'Wingdings',
            ].map(function (font) { return { label: font, value: getCssFontFamily(font) }; });
            RichText.defaultFont = getCssFontFamily('Segoe UI Light');
            var fontSizes = [
                '8', '9', '10', '10.5', '11', '12', '14', '16', '18', '20', '24', '28', '32', '36', '40', '42', '44', '54', '60', '66', '72', '80', '88', '96'
            ].map(function (size) { return { label: size, value: size + 'px' }; });
            RichText.defaultFontSize = '14px';
            var textAlignments = [
                'Left',
                'Center',
                'Right',
            ].map(function (alignment) { return { label: alignment, value: alignment.toLowerCase() }; });
            /**
             * Given a font family returns the value we should use for the font-family css property.
             */
            function getCssFontFamily(font) {
                var family = fontMap[font];
                if (family == null)
                    family = font;
                return family;
            }
            RichText.getCssFontFamily = getCssFontFamily;
            /**
             * Convert built-in font families back into their proper font families (e.g. wf_segoe-ui_normal -> Segoe UI)
             */
            function getFontFamilyForBuiltInFont(font) {
                var fontFamily = _.findKey(fontMap, function (value) { return value === font; });
                return fontFamily || font;
            }
            RichText.getFontFamilyForBuiltInFont = getFontFamilyForBuiltInFont;
            var QuillWrapper = (function () {
                /**
                 * JavaScript and CSS resources are typically resolved asynchronously.
                 * This means we potentially defer certain events which typically occur
                 * synchronously until resources are loaded.
                 * Setting the global loadQuillResources flag to true will override
                 * this behavior and cause the wrapper to assume these resources are already loaded
                 * and not try to load them asynchronously (e.g. for use in unit tests).
                 */
                function QuillWrapper(readOnly, host) {
                    var _this = this;
                    this.QuillPackage = {
                        javaScriptFiles: QuillWrapper.quillJsFiles,
                        cssFiles: QuillWrapper.quillCssFiles,
                    };
                    this.textChanged = function (d, s) { };
                    this.host = host;
                    this.$container = $('<div>');
                    this.readOnly = readOnly;
                    this.localizationProvider = {
                        get: function (stringId) { return _this.host.getLocalizedString(stringId); }
                    };
                    this.dependenciesLoaded = $.Deferred();
                    if (QuillWrapper.loadQuillResources) {
                        // Defer creation of the editor until after resources are loaded.
                        this.initialized = false;
                        // Note that these are called in the order registered so this will always be called before other callbacks.
                        this.dependenciesLoaded.done(function () {
                            _this.rebuildQuillEditor();
                            _this.initialized = true;
                        });
                        jsCommon.requires(this.QuillPackage, function () { return _this.dependenciesLoaded.resolve(); });
                    }
                    else {
                        this.rebuildQuillEditor();
                        this.initialized = true;
                        this.dependenciesLoaded.resolve();
                    }
                }
                QuillWrapper.prototype.addModule = function (name, options) {
                    if (this.editor)
                        return this.editor.addModule(name, options);
                };
                QuillWrapper.prototype.getElement = function () {
                    return this.$container;
                };
                QuillWrapper.prototype.getContents = function () {
                    if (this.initialized)
                        return this.editor.getContents();
                };
                QuillWrapper.prototype.setContents = function (contents) {
                    var _this = this;
                    // If we haven't loaded the editor yet, defer this call until we do
                    // TODO: prevent these from stacking up?
                    if (!this.initialized) {
                        this.dependenciesLoaded.done(function () { return _this.setContents(contents); });
                        return;
                    }
                    this.editor.setHTML('', 'api'); // Clear contents
                    if (contents)
                        this.editor.setContents(contents, 'api');
                    this.formatUrls();
                };
                QuillWrapper.prototype.resize = function (viewport) {
                    this.$container.width(viewport.width);
                    this.$container.height(viewport.height);
                };
                QuillWrapper.prototype.setReadOnly = function (readOnly) {
                    var readOnlyChanged = readOnly !== this.readOnly;
                    this.readOnly = readOnly;
                    if (this.initialized && readOnlyChanged) {
                        this.rebuildQuillEditor();
                    }
                };
                QuillWrapper.prototype.formatUrls = function () {
                    if (this.editor == null)
                        return;
                    var text = this.editor.getText();
                    var urlMatches = UrlUtils.findAllValidUrls(text);
                    for (var _i = 0, urlMatches_1 = urlMatches; _i < urlMatches_1.length; _i++) {
                        var match = urlMatches_1[_i];
                        // Remove existing link
                        this.editor.formatText(match.start, match.end, 'link', false, 'api');
                        // Format as link
                        this.editor.formatText(match.start, match.end, 'link', match.text, 'api');
                    }
                    // Force link tooltip to update on URL change
                    this.editor.emit(Quill.events.SELECTION_CHANGE, this.getSelection(), 'api');
                };
                QuillWrapper.prototype.setSelection = function (start, end) {
                    if (this.editor)
                        this.editor.setSelection(start, end, 'api');
                };
                QuillWrapper.prototype.getSelection = function () {
                    if (this.editor)
                        return this.editor.getSelection();
                };
                QuillWrapper.prototype.focus = function () {
                    if (!this.editor)
                        return;
                    if ($(document.activeElement).closest(this.$container).length === 0)
                        this.editor.focus();
                };
                QuillWrapper.prototype.destroy = function () {
                    this.host.setToolbar(null);
                    this.$container.remove();
                    this.$container = null;
                    this.$toolbarDiv = null;
                    this.$editorDiv = null;
                    this.editor = null;
                };
                QuillWrapper.prototype.getSelectionAtCursor = function () {
                    var text = this.getTextWithoutTrailingBreak();
                    // Ensure editor has focus before selection interactions
                    this.editor.focus();
                    var selection = this.getSelection();
                    if (selection && selection.start === selection.end) {
                        return jsCommon.WordBreaker.find(selection.start, text);
                    }
                    return selection;
                };
                QuillWrapper.prototype.getWord = function () {
                    var selection = this.getSelectionAtCursor();
                    return this.getTextWithoutTrailingBreak().slice(selection.start, selection.end);
                };
                QuillWrapper.prototype.insertLinkAtCursor = function (link, index) {
                    var endIndex = index + link.length;
                    this.editor.insertText(index, link, 'api');
                    this.editor.formatText(index, endIndex, 'link', link, 'api');
                    this.setSelection(index, endIndex);
                    return endIndex;
                };
                QuillWrapper.prototype.getEditorContainer = function () {
                    if (this.editor)
                        return $(this.editor.container);
                };
                ;
                QuillWrapper.prototype.getTextWithoutTrailingBreak = function () {
                    return this.editor.getText().slice(0, -1);
                };
                QuillWrapper.prototype.rebuildQuillEditor = function () {
                    var _this = this;
                    // Preserve contents if we already have an editor.
                    var contents = null;
                    if (this.editor) {
                        this.editor.removeAllListeners();
                        contents = this.editor.getContents();
                    }
                    this.$container.empty();
                    // Prevent parent elements from handling keyboard shortcuts (e.g. ctrl+a) that have special meaning for textboxes.
                    // Quill will also capture and prevent bubbling of some keyboard shortcuts, such as ctrl+c, ctrl+b, etc.
                    this.$container.keydown(function (e) {
                        if (e.ctrlKey && _.contains(QuillWrapper.preventDefaultKeys, e.which))
                            e.stopPropagation();
                    });
                    var $editorDiv = this.$editorDiv = $('<div>');
                    // HACK: Quill does not apply the correct default styling if you clear all the content and add new content.
                    $editorDiv.css('font-family', RichText.defaultFont);
                    $editorDiv.css('font-size', RichText.defaultFontSize);
                    var configs = {
                        readOnly: this.readOnly,
                        formats: ['bold', 'italic', 'underline', 'font', 'size', 'link', 'align',],
                        styles: false,
                    };
                    this.editor = new Quill($editorDiv.get(0), configs);
                    // If not readonly we add a toolbar and disable drag/resize
                    if (!this.readOnly) {
                        var $toolbarDiv = this.$toolbarDiv;
                        if (!$toolbarDiv) {
                            this.$toolbarDiv = $toolbarDiv = Toolbar.buildToolbar(this, this.localizationProvider);
                        }
                        $toolbarDiv.addClass('unselectable');
                        this.host.setToolbar($toolbarDiv);
                        this.editor.addModule('toolbar', { container: $toolbarDiv.get(0) });
                        // Disable this so we can select text in the editor.
                        $editorDiv.attr('drag-resize-disabled', 'true');
                    }
                    this.$container.append($editorDiv);
                    if (contents)
                        this.setContents(contents);
                    // Throttle text-changed events to not more frequent than once per 200ms
                    var textChangeThrottler = new jsCommon.ThrottleUtility(QuillWrapper.textChangeThrottle);
                    this.editor.on('text-change', function (delta, source) {
                        if (source !== 'api')
                            textChangeThrottler.run(function () { return _this.onTextChanged(delta, source); });
                    });
                    // TODO: Actually, probably want something that continually defers until you stop typing, this is probably fine for now though.
                    var formatUrlThrottler = new jsCommon.ThrottleUtility(QuillWrapper.formatUrlThrottle);
                    this.editor.on('text-change', function (delta, source) {
                        if (source !== 'api')
                            formatUrlThrottler.run(function () { return _this.formatUrls(); });
                    });
                    /*
                        Webkit browsers have a bug with regard to focus on div elements
                        with the contenteditable attribute:
    
                        https://bugs.webkit.org/show_bug.cgi?id=38696
    
                        When we blur our rich text box editor the focus remains with the selection
                        instead of the focused element. This allows the user to continue typing as
                        if focus remains within the RichTextbox.
    
                        To fix this issue we add an event listener to the contenteditable div
                        which listens for the 'blur' event and will properly blur our quill
                        editor as well.
    
                        http://quilljs.com/docs/api/#quillprototypesetselection
    
                        Verified in Chrome 43.0.2357.130 m
    
                        In IE10+ the setSelection method explicitly sets focus to the body which
                        causes a bug where the user must click twice when attempting to interact
                        with a <select> element. To prevent this issue we explicitly do not call
                        setSelection to blur if the user is changing focus to a <select> element.
                        This issue is also present for link tooltips from the Quill module which
                        will cause a blur onto the tooltip.
                    */
                    this.editor.root.addEventListener('blur', function (event) {
                        var target = (event.relatedTarget || document.activeElement);
                        // The browser will handle moving the cursor and setting focus properly for these types of elements.
                        if (target &&
                            target.tagName === 'SELECT' || target.tagName === 'INPUT' || target.getAttribute('contentEditable')) {
                            return;
                        }
                        _this.setSelection(null, null);
                    }, false);
                };
                QuillWrapper.prototype.onTextChanged = function (delta, source) {
                    this.textChanged(delta, source);
                };
                QuillWrapper.textChangeThrottle = 200; // ms
                QuillWrapper.formatUrlThrottle = 1000; // ms
                QuillWrapper.preventDefaultKeys = [
                    jsCommon.DOMConstants.aKeyCode,
                    jsCommon.DOMConstants.cKeyCode,
                    jsCommon.DOMConstants.xKeyCode,
                    jsCommon.DOMConstants.vKeyCode,
                ];
                QuillWrapper.loadQuillResources = true;
                // TODO: How to choose between minified/unminified?
                // TODO: Consider loading this from the CDN.
                QuillWrapper.quillJsFiles = [powerbi.build + '/externals/quill.min.js'];
                QuillWrapper.quillCssFiles = [powerbi.build + '/externals/quill.base.css'];
                return QuillWrapper;
            }());
            RichText.QuillWrapper = QuillWrapper;
            var Toolbar;
            (function (Toolbar) {
                var DefaultLinkInputValue = 'http://';
                Toolbar.selectors = {
                    linkTooltip: createClassAndSelector('ql-link-tooltip'),
                    toolbarUrlInput: createClassAndSelector('toolbar-url-input'),
                };
                function buildToolbar(quillWrapper, localizationProvider) {
                    // Module for adding custom hyperlinks
                    var linkTooltipTemplate = buildToolbarLinkInputTemplate(localizationProvider);
                    quillWrapper.addModule('link-tooltip', { template: linkTooltipTemplate });
                    var toolbarLinkInput = buildToolbarLinkInput(quillWrapper, getTooltip('Link', localizationProvider), localizationProvider.get('RichTextbox_Link_DefaultText'));
                    var fontPicker = picker(getTooltip('Font', localizationProvider), fonts, 'font', RichText.defaultFont, 
                    // Show the fonts in their own font face.
                    function ($option, option) { $option.css('font-family', option.value); return $option; });
                    var $container = div()
                        .addClass('toolbar ql-toolbar')
                        .append(formatGroup()
                        .append(label(localizationProvider.get('RichTextbox_Font_Label')))
                        .append(fontPicker)
                        .append(picker(getTooltip('Size', localizationProvider), fontSizes, 'size', RichText.defaultFontSize)))
                        .append(formatGroup()
                        .append(formatButton(getTooltip('Bold', localizationProvider), 'bold'))
                        .append(formatButton(getTooltip('Italic', localizationProvider), 'italic'))
                        .append(formatButton(getTooltip('Underline', localizationProvider), 'underline')))
                        .append(formatGroup()
                        .append(toggleGroup('Text Alignment', textAlignments, 'align', 'Left', localizationProvider)))
                        .append(toolbarLinkInput);
                    // Prevent mousedown from triggering subsequent blur on editor
                    $container.on('mousedown', function (event) {
                        var target = (event.target || document.activeElement);
                        if (target.tagName !== 'INPUT' && target.tagName !== 'SELECT')
                            event.preventDefault();
                    });
                    return $container;
                }
                Toolbar.buildToolbar = buildToolbar;
                function setSelectValue($select, value) {
                    $select.val(value);
                    // NOTE: The 'change' event is not raised when the value of the SELECT element is changed programatically,
                    // and Quill uses it's own, non-JQuery, method to hook up to the 'change' event, therefore, we need to dispatch
                    // this event manually on the SELECT element.
                    var evt = document.createEvent('UIEvent');
                    evt.initUIEvent('change', false, false, null, 0);
                    $select.get(0).dispatchEvent(evt);
                }
                Toolbar.setSelectValue = setSelectValue;
                function linkTooltipTemplateGenerator(removeText, doneText) {
                    return $("\n                        <a href=\"#\" class=\"url\" target=\"_blank\"></a>\n                        <input class=\"input\" type=\"text\">\n                        <span class=\"bar\">&nbsp;|&nbsp;</span>\n                        <a class=\"change\"></a>\n                        <a class=\"remove\">" + removeText + "</a>\n                        <a class=\"done\">" + doneText + "</a>\n                    ");
                }
                ;
                function buildToolbarLinkInputTemplate(localizationProvider) {
                    var template = div();
                    var doneText = localizationProvider.get('RichTextbox_Link_Done');
                    var removeText = localizationProvider.get('RichTextbox_Link_Remove');
                    template.append(linkTooltipTemplateGenerator(removeText, doneText));
                    return template.html();
                }
                function formatGroup() {
                    return span()
                        .addClass('ql-format-group')
                        .attr('drag-resize-disabled', 'true');
                }
                function label(text) {
                    return $('<label>').text(text);
                }
                function div() {
                    return $('<div>');
                }
                function span() {
                    return $('<span>');
                }
                function toggleGroup(title, list, format, defaultValue, localizationProvider) {
                    var tooltip = getTooltip(title, localizationProvider);
                    var $group = span()
                        .attr('title', tooltip)
                        .addClass('ql-toggle-group');
                    // Hidden selector that Quill will use to hook up change listeners.
                    var $select = selector(tooltip, list, defaultValue)
                        .addClass('ql-picker ql-' + format)
                        .css('display', 'none');
                    var $buttons = list.map(function (option) {
                        var $button = formatButton(getTooltip(option.label, localizationProvider), 'align' + option.value)
                            .attr('data-value', option.value)
                            .click(function (e) { return setSelectValue($select, option.value); });
                        return $button;
                    });
                    // Quill will change the value of the selector when the text selection changes, so we need to set the state of the buttons to match.
                    $select.change(function (e) {
                        var newValue = $select.val();
                        for (var i = 0; i < $buttons.length; i++) {
                            $buttons[i].toggleClass('ql-active', $buttons[i].attr('data-value') === newValue);
                        }
                    });
                    $group.append($select);
                    $group.append($buttons);
                    return $group;
                }
                function picker(tooltip, list, format, defaultValue, optionModifier) {
                    var $selector = selector(tooltip, list, defaultValue, optionModifier)
                        .addClass('ql-picker ql-' + format);
                    return $selector;
                }
                function selector(tooltip, list, defaultValue, optionModifier) {
                    var $selector = $('<select>')
                        .attr('title', tooltip);
                    for (var i = 0; i < list.length; i++) {
                        var option = list[i];
                        var $option = $('<option>')
                            .attr('value', option.value)
                            .text(option.label);
                        if (option.value === defaultValue)
                            $option.attr('selected', 'selected');
                        if (optionModifier !== undefined)
                            $option = optionModifier($option, option);
                        $selector.append($option);
                    }
                    return $selector;
                }
                function formatButton(tooltip, format) {
                    var $button = span()
                        .addClass('ql-format-button');
                    if (tooltip != null)
                        $button.attr('title', tooltip);
                    if (format != null) {
                        $button.addClass('ql-' + format);
                        $button.addClass('powervisuals-glyph ' + format);
                    }
                    return $button;
                }
                function getTooltip(name, localizationProvider) {
                    return localizationProvider.get('RichTextbox_' + name + '_ToolTip');
                }
                function clearLinkInput(linkTooltip) {
                    linkTooltip.removeClass('editing');
                    linkTooltip.removeClass('blank-editing');
                    linkTooltip.find('.input').val(DefaultLinkInputValue);
                }
                function buildToolbarLinkInput(quillWrapper, buttonTooltip, defaultLinkText) {
                    // Pull out link tooltip
                    var linkTooltip = quillWrapper.getEditorContainer().find(Toolbar.selectors.linkTooltip.selector);
                    // Append link tooltip to a new toolbar format group
                    var toolbarLinkInput = formatGroup()
                        .addClass(Toolbar.selectors.toolbarUrlInput.class)
                        .append(formatButton(buttonTooltip, 'link').append('<div>'))
                        .append(linkTooltip);
                    // Special case for blank selection (no text near cursor) when enter key or done button clicked
                    toolbarLinkInput.on('keydown mousedown', function (event) {
                        if (event.keyCode === jsCommon.DOMConstants.enterKeyCode || event.target.classList.contains('done')) {
                            if (!linkTooltip.hasClass('blank-editing'))
                                return true;
                            // Only perform these steps if tooltip was not in editing mode (special case for blank)
                            var link = toolbarLinkInput.find('.input').val();
                            var selection = quillWrapper.getSelectionAtCursor();
                            var word = quillWrapper.getWord();
                            if (!word) {
                                // Insert the input text as a link
                                var endCursor = quillWrapper.insertLinkAtCursor(link, selection.start);
                                clearLinkInput(linkTooltip);
                                quillWrapper.setSelection(endCursor, endCursor);
                                return false;
                            }
                        }
                    });
                    toolbarLinkInput.find('.input').blur(function (event) {
                        var blurTarget = event.relatedTarget;
                        // Remove editing class from insert link tooltip (to hide via CSS)
                        // only when we are not blurring to the 'done' button (tab from input field)
                        if (blurTarget === null || blurTarget && !blurTarget.classList.contains('done'))
                            clearLinkInput(linkTooltip);
                    });
                    toolbarLinkInput.find('.ql-link div')
                        .click(function (event) {
                        // Handle click on button before Quill removes link (default behavior)
                        var target = event.target.parentElement;
                        if (target && target.classList.contains('ql-active')) {
                            toolbarLinkInput.find('.change')[0].click();
                            return false;
                        }
                        // If blank selection (no text near cursor), special case for link button
                        var word = quillWrapper.getWord();
                        if (!word) {
                            linkTooltip.addClass('editing blank-editing');
                            var inputElem = toolbarLinkInput.find('.input').get(0);
                            inputElem.value = DefaultLinkInputValue;
                            inputElem.selectionStart = inputElem.selectionEnd = DefaultLinkInputValue.length;
                            inputElem.focus();
                            return false;
                        }
                    })
                        .mousedown(function (event) {
                        // Properly set selection before we handle the click
                        var linkButton = event.target.parentElement;
                        if (linkButton && !linkButton.classList.contains('ql-active')) {
                            var selection = quillWrapper.getSelectionAtCursor();
                            quillWrapper.setSelection(selection.start, selection.end);
                        }
                    });
                    return toolbarLinkInput;
                }
            })(Toolbar || (Toolbar = {}));
        })(RichText = visuals.RichText || (visuals.RichText = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SelectionManager = visuals.utility.SelectionManager;
        visuals.cheerMeterProps = {
            dataPoint: {
                defaultColor: {
                    objectName: 'dataPoint',
                    propertyName: 'defaultColor'
                },
                fill: {
                    objectName: 'dataPoint',
                    propertyName: 'fill'
                },
            },
        };
        var CheerMeter = (function () {
            function CheerMeter() {
                this.isFirstTime = true;
            }
            CheerMeter.converter = function (dataView) {
                if (!dataView.categorical || !dataView.categorical.categories)
                    return null;
                var cat = dataView.categorical.categories[0];
                if (!cat)
                    return null;
                var catValues = cat.values;
                if (!catValues || _.isEmpty(dataView.categorical.values))
                    return null;
                var values = dataView.categorical.values[0].values;
                var objects = dataView.categorical.categories[0].objects;
                var object1 = objects && objects.length > 0 ? objects[0] : undefined;
                var object2 = objects && objects.length > 1 ? objects[1] : undefined;
                var metadataObjects = dataView.metadata.objects;
                var backgroundColor = CheerMeter.DefaultBackgroundColor;
                if (metadataObjects) {
                    var general = metadataObjects['general'];
                    if (general) {
                        var fill = general['fill'];
                        if (fill) {
                            backgroundColor = fill.solid.color;
                        }
                    }
                }
                var color1 = powerbi.DataViewObjects.getFillColor(object1, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var color2 = powerbi.DataViewObjects.getFillColor(object2, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var idn1 = visuals.SelectionIdBuilder.builder()
                    .withCategory(cat, 0)
                    .createSelectionId();
                var idn2 = visuals.SelectionIdBuilder.builder()
                    .withCategory(cat, 1)
                    .createSelectionId();
                var data = {
                    teamA: {
                        name: catValues[0],
                        value: values[0],
                        color: color1,
                        identity: idn1
                    },
                    teamB: {
                        name: catValues[1],
                        value: values[1],
                        color: color2,
                        identity: idn2
                    },
                    background: backgroundColor
                };
                return data;
            };
            CheerMeter.prototype.init = function (options) {
                this.selectionManager = new SelectionManager({ hostServices: options.host });
                var svg = this.svg = d3.select(options.element.get(0)).append('svg');
                this.textOne = svg.append('text')
                    .style('font-family', CheerMeter.DefaultFontFamily);
                this.textTwo = svg.append('text')
                    .style('font-family', CheerMeter.DefaultFontFamily);
            };
            CheerMeter.prototype.update = function (options) {
                if (!options.dataViews[0]) {
                    return;
                }
                var data = this.data = CheerMeter.converter(options.dataViews[0]);
                if (!data)
                    return;
                var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                this.draw(data, duration, options.viewport);
            };
            CheerMeter.prototype.getRecomendedFontProperties = function (text1, text2, parentViewport) {
                var textProperties = {
                    fontSize: '',
                    fontFamily: CheerMeter.DefaultFontFamily,
                    text: text1 + text2
                };
                var min = 1;
                var max = 1000;
                var i;
                var maxWidth = parentViewport.width;
                var width = 0;
                while (min <= max) {
                    i = (min + max) / 2 | 0;
                    textProperties.fontSize = i + 'px';
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (maxWidth > width)
                        min = i + 1;
                    else if (maxWidth < width)
                        max = i - 1;
                    else
                        break;
                }
                textProperties.fontSize = i + 'px';
                width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                if (width > maxWidth) {
                    i--;
                    textProperties.fontSize = i + 'px';
                }
                return textProperties;
            };
            CheerMeter.prototype.calculateLayout = function (data, viewport) {
                var text1 = data.teamA.name;
                var text2 = data.teamB.name;
                var avaliableViewport = {
                    height: viewport.height,
                    width: viewport.width - CheerMeter.PaddingBetweenText
                };
                var recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
                recomendedFontProperties.text = text1;
                var width1 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                recomendedFontProperties.text = text2;
                var width2 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                var padding = ((viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2) | 0;
                recomendedFontProperties.text = text1 + text2;
                var offsetHeight = (powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties)) | 0;
                var max = data.teamA.value + data.teamB.value;
                var availableHeight = viewport.height - offsetHeight;
                var y1 = (((max - data.teamA.value) / max) * availableHeight + offsetHeight / 2) | 0;
                var y2 = (((max - data.teamB.value) / max) * availableHeight + offsetHeight / 2) | 0;
                return {
                    x1: padding,
                    x2: padding + width1 + CheerMeter.PaddingBetweenText,
                    y1: y1,
                    y2: y2,
                    fontSize: recomendedFontProperties.fontSize
                };
            };
            CheerMeter.prototype.ensureStartState = function (layout, viewport) {
                if (this.isFirstTime) {
                    this.isFirstTime = false;
                    var startY = viewport.height / 2;
                    this.textOne.attr({
                        'x': layout.x1,
                        'y': startY
                    });
                    this.textTwo.attr({
                        'x': layout.x2,
                        'y': startY
                    });
                }
            };
            CheerMeter.prototype.clearSelection = function () {
                var _this = this;
                this.selectionManager.clear().then(function () {
                    _this.clearSelectionUI();
                });
            };
            CheerMeter.prototype.clearSelectionUI = function () {
                this.textOne.style('stroke', '#FFF').style('stroke-width', 0);
                this.textTwo.style('stroke', '#FFF').style('stroke-width', 0);
            };
            CheerMeter.prototype.updateSelectionUI = function (ids) {
                this.textOne.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamA.identity) ? '2px' : '0px');
                this.textTwo.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamB.identity) ? '2px' : '0px');
            };
            CheerMeter.prototype.draw = function (data, duration, viewport) {
                var _this = this;
                var easeName = 'back';
                var textOne = this.textOne;
                var textTwo = this.textTwo;
                this.svg
                    .attr({
                    'height': viewport.height,
                    'width': viewport.width
                })
                    .on('click', function () {
                    _this.clearSelection();
                })
                    .style('background-color', data.background);
                var layout = this.calculateLayout(data, viewport);
                this.ensureStartState(layout, viewport);
                textOne
                    .style('font-size', layout.fontSize)
                    .style('fill', data.teamA.color)
                    .on('click', function () {
                    _this.selectionManager.select(data.teamA.identity, d3.event.ctrlKey).then(function (ids) {
                        _this.updateSelectionUI(ids);
                    });
                    d3.event.stopPropagation();
                })
                    .text(data.teamA.name);
                textTwo
                    .style('font-size', layout.fontSize)
                    .style('fill', data.teamB.color)
                    .on('click', function () {
                    _this.selectionManager.select(data.teamB.identity, d3.event.ctrlKey).then(function (ids) {
                        _this.updateSelectionUI(ids);
                    });
                    d3.event.stopPropagation();
                })
                    .text(data.teamB.name);
                textOne.transition()
                    .duration(duration)
                    .ease(easeName)
                    .attr({
                    y: layout.y1,
                    x: layout.x1
                });
                textTwo.transition()
                    .duration(duration)
                    .ease(easeName)
                    .attr({
                    y: layout.y2,
                    x: layout.x2
                });
            };
            CheerMeter.prototype.destroy = function () {
                this.svg = null;
                this.textOne = this.textTwo = null;
            };
            CheerMeter.prototype.enumerateObjectInstances = function (options) {
                var instances = [];
                var data = this.data;
                switch (options.objectName) {
                    case 'dataPoint':
                        if (data) {
                            var teams = [data.teamA, data.teamB];
                            for (var i = 0; i < teams.length; i++) {
                                var slice = teams[i];
                                var color = slice.color;
                                var selector = slice.identity;
                                var dataPointInstance = {
                                    objectName: 'dataPoint',
                                    displayName: slice.name,
                                    selector: selector,
                                    properties: {
                                        fill: { solid: { color: color } }
                                    },
                                };
                                instances.push(dataPointInstance);
                            }
                            ;
                        }
                        break;
                    case 'general':
                        var general = {
                            objectName: 'general',
                            displayName: 'General',
                            selector: null,
                            properties: {
                                fill: { solid: { color: data ? data.background : CheerMeter.DefaultBackgroundColor } }
                            }
                        };
                        instances.push(general);
                        break;
                }
                return instances;
            };
            CheerMeter.capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                    },
                    {
                        displayName: 'Noise Measure',
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                    },
                ],
                dataViewMappings: [{
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                            },
                            values: {
                                select: [{ bind: { to: 'Y' } }]
                            },
                        },
                    }],
                objects: {
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            width: {
                                displayName: '',
                                type: { numeric: true }
                            }
                        }
                    },
                    general: {
                        displayName: 'General',
                        properties: {
                            fill: {
                                displayName: 'Background color',
                                type: { fill: { solid: { color: true } } }
                            },
                        }
                    }
                }
            };
            CheerMeter.DefaultFontFamily = 'cursive';
            CheerMeter.DefaultFontColor = 'rgb(165, 172, 175)';
            CheerMeter.DefaultBackgroundColor = '#243C18';
            CheerMeter.PaddingBetweenText = 15;
            return CheerMeter;
        }());
        visuals.CheerMeter = CheerMeter;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Color = jsCommon.Color;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var ScatterChart = (function () {
            function ScatterChart(options) {
                if (options) {
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    this.interactivityService = options.interactivityService;
                    this.animator = options.animator;
                }
                this.renderer = new SvgRenderer();
            }
            ScatterChart.prototype.init = function (options) {
                this.options = options;
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.host = options.host;
                this.colors = this.style.colorPalette.dataColors;
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
                var svg = this.svg = options.svg;
                // TODO: should we always be adding the playchart class name?
                svg.classed(ScatterChart.ClassName + ' ' + visuals.PlayChart.ClassName, true);
                this.renderer.init(svg, options.labelsContext, this.isMobileChart, this.tooltipsEnabled);
            };
            ScatterChart.getAdditionalTelemetry = function (dataView) {
                var telemetry = {
                    hasSize: DataRoleHelper.hasRoleInDataView(dataView, 'Size'),
                    hasPlayAxis: DataRoleHelper.hasRoleInDataView(dataView, 'Play'),
                };
                return telemetry;
            };
            ScatterChart.getObjectProperties = function (dataView, dataLabelsSettings) {
                var objects;
                if (dataView && dataView.metadata && dataView.metadata.objects)
                    objects = dataView.metadata.objects;
                else
                    objects = {};
                var objectProperties = {};
                objectProperties.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                objectProperties.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints, false);
                var labelsObj = objects['categoryLabels'];
                if (labelsObj && dataLabelsSettings)
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                // NOTE: "fill point" defaults to on when we have a gradient role.
                var hasGradient = dataView && visuals.GradientUtils.hasGradientRole(dataView.categorical);
                objectProperties.fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, hasGradient);
                objectProperties.colorBorder = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorBorder.show, false);
                objectProperties.colorByCategory = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorByCategory.show, false);
                return objectProperties;
            };
            ScatterChart.converter = function (dataView, options, playFrameInfo, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName;
                var currentViewport = options.viewport;
                var colorPalette = options.colors;
                var interactivityService = options.interactivityService;
                var categoryAxisProperties = options.categoryAxisProperties;
                var valueAxisProperties = options.valueAxisProperties;
                var dataViewCategorical = dataView.categorical;
                var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCategorical);
                if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                    categoryValues = dataViewCategorical.categories[0].values;
                    categoryFormatter = visuals.valueFormatter.create({ format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });
                    categoryIdentities = dataViewCategorical.categories[0].identity;
                    categoryObjects = dataViewCategorical.categories[0].objects;
                    categoryQueryName = dataViewCategorical.categories[0].source.queryName;
                }
                else {
                    categoryValues = [null];
                    // creating default formatter for null value (to get the right string of empty value from the locale)
                    categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null);
                }
                var categories = dataViewCategorical.categories;
                var dataValues = dataViewCategorical.values;
                var hasDynamicSeries = !!dataValues.source;
                var grouped = dataValues.grouped();
                var dvSource = dataValues.source;
                var scatterMetadata = ScatterChart.getMetadata(grouped, dvSource);
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                var sizeRange = ScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                var objProps = ScatterChart.getObjectProperties(dataView, dataLabelsSettings);
                var dataPointSeries = ScatterChart.createDataPointSeries(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, currentViewport, hasDynamicSeries, dataLabelsSettings, gradientValueColumn, objProps.defaultDataPointColor, categoryQueryName, objProps.colorByCategory, playFrameInfo, tooltipsEnabled);
                var dataPoints = _.reduce(dataPointSeries, function (a, s) { return a.concat(s.dataPoints); }, []);
                var legendItems = hasDynamicSeries
                    ? ScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), objProps.defaultDataPointColor)
                    : [];
                var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                if (!legendTitle) {
                    legendTitle = categories && categories.length > 0 && categories[0].source.displayName ? categories[0].source.displayName : "";
                }
                if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.x = null;
                }
                if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.y = null;
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(dataPoints);
                    interactivityService.applySelectionStateToData(legendItems);
                }
                return {
                    xCol: scatterMetadata.cols.x,
                    yCol: scatterMetadata.cols.y,
                    dataPoints: dataPoints,
                    dataPointSeries: dataPointSeries,
                    legendData: { title: legendTitle, dataPoints: legendItems },
                    axesLabels: scatterMetadata.axesLabels,
                    size: scatterMetadata.cols.size,
                    sizeRange: sizeRange,
                    dataLabelsSettings: dataLabelsSettings,
                    defaultDataPointColor: objProps.defaultDataPointColor,
                    hasDynamicSeries: hasDynamicSeries,
                    showAllDataPoints: objProps.showAllDataPoints,
                    fillPoint: objProps.fillPoint,
                    colorBorder: objProps.colorBorder,
                    colorByCategory: objProps.colorByCategory,
                };
            };
            ScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {
                var result = {};
                if (dataViewValueGroups) {
                    dataViewValueGroups.forEach(function (group) {
                        var sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values);
                        var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                        if (result.min == null || result.min > currentRange.min) {
                            result.min = currentRange.min;
                        }
                        if (result.max == null || result.max < currentRange.max) {
                            result.max = currentRange.max;
                        }
                    });
                }
                return result;
            };
            ScatterChart.createDataPointSeries = function (dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, viewport, hasDynamicSeries, labelSettings, gradientValueColumn, defaultDataPointColor, categoryQueryName, colorByCategory, playFrameInfo, tooltipsEnabled) {
                var dataPointSeries = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
                    var grouping = grouped[seriesIdx];
                    var seriesValues = grouping.values;
                    var measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues);
                    var measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues);
                    var measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues);
                    var seriesColor = void 0;
                    if (hasDynamicSeries) {
                        seriesColor = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                    }
                    else if (!colorByCategory && !categoryObjects) {
                        // If we have no Size measure then use a blank query name
                        var measureSource = (measureSize != null)
                            ? measureSize.source.queryName
                            : '';
                        seriesColor = colorHelper.getColorForMeasure(null, measureSource);
                    }
                    var series = {
                        identityKey: (grouping && grouping.identity && grouping.identity.key) || "",
                        dataPoints: [],
                        hasSize: !!(measureSize && measureSize.values),
                        fill: seriesColor,
                    };
                    dataPointSeries.push(series);
                    for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {
                        var categoryValue = categoryValues[categoryIdx];
                        var xVal = visuals.AxisHelper.normalizeNonFiniteNumber(measureX && measureX.values ? measureX.values[categoryIdx] : null);
                        var yVal = visuals.AxisHelper.normalizeNonFiniteNumber(measureY && measureY.values ? measureY.values[categoryIdx] : 0);
                        var size = visuals.AxisHelper.normalizeNonFiniteNumber(measureSize && measureSize.values ? measureSize.values[categoryIdx] : null);
                        var hasNullValue = (xVal == null) || (yVal == null);
                        if (hasNullValue)
                            continue;
                        var color = void 0;
                        if (hasDynamicSeries) {
                            color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                        }
                        else if (colorByCategory) {
                            color = colorHelper.getColorForSeriesValue(categoryObjects && categoryObjects[categoryIdx], dataValues.identityFields, categoryValue);
                        }
                        else {
                            // If we have no Size measure then use a blank query name
                            var measureSource = (measureSize != null)
                                ? measureSize.source.queryName
                                : '';
                            color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                        }
                        var category = categories && categories.length > 0 ? categories[0] : null;
                        var identity = visuals.SelectionIdBuilder.builder()
                            .withCategory(category, categoryIdx)
                            .withSeries(dataValues, grouping)
                            .createSelectionId();
                        var seriesData = [];
                        if (dataValueSource) {
                            // Dynamic series
                            seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });
                        }
                        if (measureX) {
                            seriesData.push({ value: xVal, metadata: measureX });
                        }
                        if (measureY) {
                            seriesData.push({ value: yVal, metadata: measureY });
                        }
                        if (measureSize && measureSize.values && measureSize.values.length > 0) {
                            seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });
                        }
                        if (playFrameInfo) {
                            seriesData.push({ value: playFrameInfo.label, metadata: { source: playFrameInfo.column, values: [] } });
                        }
                        // check for gradient tooltip data 
                        var gradientToolTipData = visuals.TooltipBuilder.createGradientToolTipData(gradientValueColumn, categoryIdx);
                        if (gradientToolTipData != null)
                            seriesData.push(gradientToolTipData);
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData);
                        }
                        var dataPoint = {
                            x: xVal,
                            y: yVal,
                            size: size,
                            radius: { sizeMeasure: measureSize, index: categoryIdx },
                            fill: color,
                            formattedCategory: ScatterChart.createLazyFormattedCategory(categoryFormatter, categories != null ? categoryValue : grouping.name),
                            selected: false,
                            identity: identity,
                            tooltipInfo: tooltipInfo,
                            labelFill: labelSettings.labelColor,
                        };
                        series.dataPoints.push(dataPoint);
                    }
                }
                return dataPointSeries;
            };
            ScatterChart.createLazyFormattedCategory = function (formatter, value) {
                return new jsCommon.Lazy(function () { return formatter.format(value); });
            };
            ScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                var grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                var legendItems = [];
                for (var i = 0, len = grouped.length; i < len; i++) {
                    var grouping = grouped[i];
                    var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                    legendItems.push({
                        color: color,
                        icon: visuals.LegendIcon.Circle,
                        label: visuals.valueFormatter.format(grouping.name, formatString),
                        identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return legendItems;
            };
            ScatterChart.getBubbleRadius = function (radiusData, sizeRange, viewport) {
                var actualSizeDataRange = null;
                var bubblePixelAreaSizeRange = null;
                var measureSize = radiusData.sizeMeasure;
                if (!measureSize)
                    return ScatterChart.BubbleRadius;
                var minSize = sizeRange.min ? sizeRange.min : 0;
                var maxSize = sizeRange.max ? sizeRange.max : 0;
                var min = Math.min(minSize, 0);
                var max = Math.max(maxSize, 0);
                actualSizeDataRange = {
                    minRange: min,
                    maxRange: max,
                    delta: max - min
                };
                bubblePixelAreaSizeRange = ScatterChart.getBubblePixelAreaSizeRange(viewport, ScatterChart.MinSizeRange, ScatterChart.MaxSizeRange);
                if (measureSize.values) {
                    var sizeValue = measureSize.values[radiusData.index];
                    if (sizeValue != null) {
                        return ScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
                    }
                }
                return ScatterChart.BubbleRadius;
            };
            ScatterChart.getMeasureValue = function (measureIndex, seriesValues) {
                if (measureIndex >= 0)
                    return seriesValues[measureIndex];
                return null;
            };
            ScatterChart.getMetadata = function (grouped, source) {
                var xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');
                var yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');
                var sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');
                var xCol;
                var yCol;
                var sizeCol;
                var xAxisLabel = "";
                var yAxisLabel = "";
                if (grouped && grouped.length) {
                    var firstGroup = grouped[0];
                    if (xIndex >= 0) {
                        xCol = firstGroup.values[xIndex].source;
                        xAxisLabel = firstGroup.values[xIndex].source.displayName;
                    }
                    if (yIndex >= 0) {
                        yCol = firstGroup.values[yIndex].source;
                        yAxisLabel = firstGroup.values[yIndex].source.displayName;
                    }
                    if (sizeIndex >= 0) {
                        sizeCol = firstGroup.values[sizeIndex].source;
                    }
                }
                return {
                    idx: {
                        x: xIndex,
                        y: yIndex,
                        size: sizeIndex,
                    },
                    cols: {
                        x: xCol,
                        y: yCol,
                        size: sizeCol,
                    },
                    axesLabels: {
                        x: xAxisLabel,
                        y: yAxisLabel
                    }
                };
            };
            /** Create a new viewmodel with default data. */
            ScatterChart.getDefaultData = function () {
                return {
                    xCol: undefined,
                    yCol: undefined,
                    dataPoints: [],
                    dataPointSeries: [],
                    legendData: { dataPoints: [] },
                    axesLabels: { x: '', y: '' },
                    sizeRange: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                    defaultDataPointColor: null,
                    hasDynamicSeries: false,
                };
            };
            ScatterChart.prototype.renderAtFrame = function (data) {
                this.data = data;
                this.cartesianVisualHost.triggerRender(false);
            };
            ScatterChart.prototype.setData = function (dataViews) {
                var _this = this;
                this.data = ScatterChart.getDefaultData();
                if (dataViews.length > 0) {
                    var dataView = dataViews[0] || dataViews[1];
                    if (dataView) {
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata, true);
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata, true);
                        this.dataView = dataView;
                        var converterOptions_1 = {
                            viewport: this.currentViewport,
                            colors: this.colors,
                            interactivityService: this.interactivityService,
                            categoryAxisProperties: this.categoryAxisProperties,
                            valueAxisProperties: this.valueAxisProperties,
                        };
                        if (visuals.PlayChart.isDataViewPlayable(dataView)) {
                            if (!this.playAxis) {
                                this.playAxis = new visuals.PlayAxis({
                                    animator: this.animator,
                                    interactivityService: this.interactivityService,
                                    isScrollable: false,
                                });
                                this.playAxis.init(this.options);
                            }
                            var playData = this.playAxis.setData(dataView, function (dataView, playFrameInfo) {
                                return ScatterChart.converter(dataView, converterOptions_1, playFrameInfo, _this.tooltipsEnabled);
                            });
                            this.mergeSizeRanges(playData);
                            this.data = playData.currentViewModel;
                            this.playAxis.setRenderFunction(function (data) { return _this.renderAtFrame(data); });
                        }
                        else {
                            if (this.playAxis) {
                                this.playAxis.remove();
                                this.playAxis = null;
                            }
                            if (dataView.categorical && dataView.categorical.values) {
                                this.data = ScatterChart.converter(dataView, converterOptions_1, undefined, this.tooltipsEnabled);
                            }
                        }
                    }
                }
                else if (this.playAxis) {
                    this.playAxis.remove();
                    this.playAxis = null;
                }
            };
            ScatterChart.prototype.mergeSizeRanges = function (playData) {
                if (playData && playData.currentViewModel) {
                    var mergedSizeRange = playData.currentViewModel.sizeRange;
                    for (var _i = 0, _a = playData.allViewModels; _i < _a.length; _i++) {
                        var data_3 = _a[_i];
                        var sizeRange = data_3.sizeRange;
                        if (sizeRange.min != null)
                            mergedSizeRange.min = Math.min(mergedSizeRange.min, sizeRange.min);
                        if (sizeRange.max != null)
                            mergedSizeRange.max = Math.max(mergedSizeRange.max, sizeRange.max);
                    }
                    for (var _b = 0, _c = playData.allViewModels; _b < _c.length; _b++) {
                        var data_4 = _c[_b];
                        data_4.sizeRange = mergedSizeRange;
                    }
                }
            };
            ScatterChart.prototype.calculateLegend = function () {
                return this.data && this.data.legendData;
            };
            ScatterChart.prototype.hasLegend = function () {
                return this.data && this.data.hasDynamicSeries;
            };
            ScatterChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'colorByCategory':
                        if (this.data) {
                            // Color by Legend takes precedent during render. Hide the slice but keep the colorByCategory value unchanged in case they remove the Legend field.
                            if (!this.data.hasDynamicSeries) {
                                enumeration.pushInstance({
                                    objectName: 'colorByCategory',
                                    selector: null,
                                    properties: {
                                        show: this.data.colorByCategory,
                                    },
                                });
                            }
                        }
                        break;
                    case 'dataPoint':
                        // TODO: DataViewMatix (for PlayAxis) doesn't support category- or series-specific properties yet.
                        if (!this.playAxis) {
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            if (!visuals.GradientUtils.hasGradientRole(categoricalDataView))
                                return this.enumerateDataPoints(enumeration);
                        }
                        break;
                    case 'categoryAxis':
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                showAxisTitle: !this.categoryAxisProperties || this.categoryAxisProperties["showAxisTitle"] == null ? true : this.categoryAxisProperties["showAxisTitle"]
                            },
                            objectName: 'categoryAxis'
                        });
                        break;
                    case 'valueAxis':
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                showAxisTitle: !this.valueAxisProperties || this.valueAxisProperties["showAxisTitle"] == null ? true : this.valueAxisProperties["showAxisTitle"]
                            },
                            objectName: 'valueAxis'
                        });
                        break;
                    case 'categoryLabels':
                        if (this.data)
                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);
                        else
                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);
                        break;
                    case 'fillPoint':
                        // Check if the card should be shown or not based on the existence of size measure
                        if (this.hasSizeMeasure())
                            return;
                        enumeration.pushInstance({
                            objectName: 'fillPoint',
                            selector: null,
                            properties: {
                                show: this.data.fillPoint,
                            },
                        });
                        break;
                    case 'colorBorder':
                        // Check if the card should be shown or not based on the existence of size measure
                        if (this.hasSizeMeasure())
                            enumeration.pushInstance({
                                objectName: 'colorBorder',
                                selector: null,
                                properties: {
                                    show: this.data.colorBorder,
                                },
                            });
                        break;
                }
            };
            ScatterChart.prototype.hasSizeMeasure = function () {
                var sizeRange = this.data.sizeRange;
                return sizeRange && sizeRange.min !== undefined;
            };
            ScatterChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var seriesCount = data.dataPoints.length;
                if (!data.hasDynamicSeries) {
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                        }
                    }).pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: !!data.showAllDataPoints
                        }
                    });
                    for (var i = 0; i < seriesCount; i++) {
                        var seriesDataPoints = data.dataPoints[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: seriesDataPoints.formattedCategory.getValue(),
                            selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                            properties: {
                                fill: { solid: { color: seriesDataPoints.fill } }
                            },
                        });
                    }
                }
                else {
                    var legendDataPointLength = data.legendData.dataPoints.length;
                    for (var i = 0; i < legendDataPointLength; i++) {
                        var series = data.legendData.dataPoints[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: series.label,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: { solid: { color: series.color } }
                            },
                        });
                    }
                }
            };
            ScatterChart.prototype.supportsTrendLine = function () {
                var data = this.data;
                if (!data)
                    return false;
                // TODO: should support regression on bubble as well
                return !this.hasSizeMeasure() && data.dataPointSeries.length === 1;
            };
            ScatterChart.getExtents = function (data) {
                var dps = data.dataPoints;
                if (_.isEmpty(dps)) {
                    return {
                        minY: 0,
                        maxY: 0,
                        minX: 0,
                        maxX: 0,
                    };
                }
                return {
                    minY: d3.min(dps, function (d) { return d.y; }),
                    maxY: d3.max(dps, function (d) { return d.y; }),
                    minX: d3.min(dps, function (d) { return d.x; }),
                    maxX: d3.max(dps, function (d) { return d.x; }),
                };
            };
            ScatterChart.prototype.calculateAxesProperties = function (options) {
                var data = this.data;
                var viewport = this.currentViewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var extents = {
                    minY: 0,
                    maxY: 10,
                    minX: 0,
                    maxX: 10
                };
                if (this.playAxis) {
                    extents = this.playAxis.getCartesianExtents(extents, ScatterChart.getExtents);
                    this.playAxis.setPlayControlPosition(options.playAxisControlLayout);
                }
                else if (!_.isEmpty(data.dataPoints)) {
                    extents = ScatterChart.getExtents(data);
                }
                var xDomain = [extents.minX, extents.maxX];
                var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain, options.ensureXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedXDomain,
                    metaDataColumn: data.xCol,
                    formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: true,
                    scaleType: options.categoryAxisScaleType,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                });
                this.xAxisProperties.axis.tickSize(-height, 0);
                this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [extents.minY, extents.maxY], options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: data.yCol,
                    formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: options.valueAxisScaleType,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision
                });
                this.yAxisProperties.axisLabel = this.data.axesLabels.y;
                // TODO: these should be passed into the render method.
                return [this.xAxisProperties, this.yAxisProperties];
            };
            ScatterChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            ScatterChart.prototype.render = function (suppressAnimations, resizeMode) {
                if (!this.data)
                    return;
                var data = this.data;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var plotArea = {
                    width: viewport.width - (margin.left + margin.right),
                    height: viewport.height - (margin.top + margin.bottom)
                };
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (this.playAxis && (this.isMobileChart || duration > 0)) {
                    duration = visuals.PlayChart.FrameAnimationDuration;
                }
                var easeType = this.playAxis ? 'linear' : 'cubic-in-out'; // cubic-in-out is the d3.ease default
                var fillMarkers = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint;
                var drawBubbles = this.hasSizeMeasure();
                var suppressDataPointRendering = resizeMode === 1 /* Resizing */ && data.dataPoints && data.dataPoints.length > ScatterChart.NoRenderResizeThreshold;
                var viewModel = {
                    data: data,
                    drawBubbles: drawBubbles,
                    isPlay: !!this.playAxis,
                    xAxisProperties: this.xAxisProperties,
                    yAxisProperties: this.yAxisProperties,
                    viewport: plotArea,
                    hasSelection: hasSelection,
                    animationDuration: duration,
                    animationOptions: this.options.animation,
                    fillMarkers: fillMarkers,
                    easeType: easeType,
                    suppressDataPointRendering: suppressDataPointRendering,
                };
                if (drawBubbles) {
                    // Bubbles must be drawn from largest to smallest.
                    var sortedData = data.dataPoints.sort(ScatterChart.sortBubbles);
                    viewModel.data = powerbi.Prototype.inherit(viewModel.data);
                    viewModel.data.dataPoints = sortedData;
                }
                var labelDataPoints = [];
                if (data.dataLabelsSettings && data.dataLabelsSettings.show || data.dataLabelsSettings.showCategory) {
                    labelDataPoints = ScatterChartDataLabels.createLabelDataPoints(viewModel);
                }
                var behaviorOptions = this.renderer.render(viewModel, this.interactivityService);
                if (this.isMobileChart) {
                    behaviorOptions = {
                        data: behaviorOptions.data,
                        dataPointsSelection: behaviorOptions.dataPointsSelection,
                        eventGroup: behaviorOptions.eventGroup,
                        plotContext: behaviorOptions.plotContext,
                        host: this.cartesianVisualHost,
                        root: this.svg,
                        visualInitOptions: this.options,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        background: d3.select(this.element.get(0)),
                    };
                }
                var playRenderResult;
                if (this.playAxis) {
                    playRenderResult = this.playAxis.render(suppressAnimations, viewModel, viewport, margin);
                    if (this.interactivityService) {
                        var playBehaviorOptions = {
                            traceLineRenderer: this.renderer.createTraceLineRenderer(playRenderResult.viewModel),
                        };
                        if (hasSelection) {
                            visuals.PlayChart.renderTraceLines(playRenderResult.allDataPoints, playBehaviorOptions.traceLineRenderer, !suppressAnimations);
                        }
                        behaviorOptions.playOptions = playBehaviorOptions;
                    }
                }
                return {
                    dataPoints: playRenderResult ? playRenderResult.allDataPoints : data.dataPoints,
                    behaviorOptions: behaviorOptions,
                    labelDataPoints: labelDataPoints,
                    labelsAreNumeric: false,
                };
            };
            ScatterChart.getStrokeFill = function (d, colorBorder) {
                if (d.size != null && colorBorder) {
                    var colorRgb = Color.parseColorString(d.fill);
                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                }
                return d.fill;
            };
            ScatterChart.getBubblePixelAreaSizeRange = function (viewPort, minSizeRange, maxSizeRange) {
                var ratio = 1.0;
                if (viewPort.height > 0 && viewPort.width > 0) {
                    var minSize = Math.min(viewPort.height, viewPort.width);
                    ratio = (minSize * minSize) / ScatterChart.AreaOf300By300Chart;
                }
                var minRange = Math.round(minSizeRange * ratio);
                var maxRange = Math.round(maxSizeRange * ratio);
                return {
                    minRange: minRange,
                    maxRange: maxRange,
                    delta: maxRange - minRange
                };
            };
            ScatterChart.project = function (value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                if (actualSizeDataRange.delta === 0 || bubblePixelAreaSizeRange.delta === 0) {
                    return (ScatterChart.rangeContains(actualSizeDataRange, value)) ? bubblePixelAreaSizeRange.minRange : null;
                }
                var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
            };
            ScatterChart.projectSizeToPixels = function (size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                var projectedSize = 0;
                if (actualSizeDataRange) {
                    // Project value on the required range of bubble area sizes
                    projectedSize = bubblePixelAreaSizeRange.maxRange;
                    if (actualSizeDataRange.delta !== 0) {
                        var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                        projectedSize = ScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                    }
                    projectedSize = Math.sqrt(projectedSize / Math.PI) * 2;
                }
                return Math.round(projectedSize);
            };
            ScatterChart.rangeContains = function (range, value) {
                return range.minRange <= value && value <= range.maxRange;
            };
            ScatterChart.getMarkerFillOpacity = function (hasSize, shouldEnableFill, hasSelection, isSelected) {
                if (hasSize || shouldEnableFill) {
                    if (hasSelection && !isSelected) {
                        return ScatterChart.DimmedBubbleOpacity;
                    }
                    return ScatterChart.DefaultBubbleOpacity;
                }
                else {
                    return 0;
                }
            };
            ScatterChart.getMarkerStrokeOpacity = function (hasSize, colorBorder, hasSelection, isSelected) {
                if (hasSize && colorBorder) {
                    return 1;
                }
                else {
                    if (hasSelection && !isSelected) {
                        return ScatterChart.DimmedBubbleOpacity;
                    }
                    return ScatterChart.DefaultBubbleOpacity;
                }
            };
            ScatterChart.getMarkerStrokeFill = function (hasSize, colorBorder, fill) {
                if (hasSize && colorBorder) {
                    var colorRgb = Color.parseColorString(fill);
                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                }
                return fill;
            };
            ScatterChart.getMarkerStyle = function (d, colorBorder, hasSelection, fillMarkers) {
                return {
                    'stroke-opacity': ScatterChart.getMarkerStrokeOpacity(d.size != null, colorBorder, hasSelection, d.selected),
                    'stroke-width': '1',
                    stroke: ScatterChart.getMarkerStrokeFill(d.size != null, colorBorder, d.fill),
                    fill: d.fill,
                    'fill-opacity': ScatterChart.getMarkerFillOpacity(d.size != null, fillMarkers, hasSelection, d.selected),
                };
            };
            ScatterChart.getSeriesStyle = function (hasSize, colorBorder, hasSelection, fillMarkers, fill) {
                return {
                    'stroke-opacity': ScatterChart.getMarkerStrokeOpacity(hasSize, colorBorder, hasSelection, false),
                    'stroke-width': '1',
                    stroke: ScatterChart.getMarkerStrokeFill(hasSize, colorBorder, fill),
                    fill: fill,
                    'fill-opacity': ScatterChart.getMarkerFillOpacity(hasSize, fillMarkers, hasSelection, false),
                };
            };
            ScatterChart.getBubbleOpacity = function (d, hasSelection) {
                if (hasSelection && !d.selected) {
                    return ScatterChart.DimmedBubbleOpacity;
                }
                return ScatterChart.DefaultBubbleOpacity;
            };
            ScatterChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            ScatterChart.prototype.getSupportedCategoryAxisType = function () {
                return visuals.axisType.scalar;
            };
            ScatterChart.sortBubbles = function (a, b) {
                var diff = (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]);
                if (diff !== 0)
                    return diff;
                // Tie-break equal size bubbles using identity.
                return b.identity.getKey().localeCompare(a.identity.getKey());
            };
            ScatterChart.BubbleRadius = 3 * 2;
            ScatterChart.DefaultBubbleOpacity = 0.85;
            ScatterChart.DimmedBubbleOpacity = 0.4;
            ScatterChart.StrokeDarkenColorValue = 255 * 0.25;
            //label layout settings
            ScatterChart.dataLabelLayoutStartingOffset = 2;
            ScatterChart.dataLabelLayoutOffsetIterationDelta = 6;
            ScatterChart.dataLabelLayoutMaximumOffset = ScatterChart.dataLabelLayoutStartingOffset + (2 * ScatterChart.dataLabelLayoutOffsetIterationDelta);
            // Chart Area and size range values as defined by PV charts
            ScatterChart.AreaOf300By300Chart = 90000;
            ScatterChart.MinSizeRange = 200;
            ScatterChart.MaxSizeRange = 3000;
            ScatterChart.ClassName = 'scatterChart';
            // Animated rendering threshold - if more than this number of data points, rendering is grouped by series and not animated
            ScatterChart.NoAnimationThreshold = 1000;
            // No render resize threshold - if more than this number of data points, rendering is suppressed during resize
            ScatterChart.NoRenderResizeThreshold = 1000;
            return ScatterChart;
        }());
        visuals.ScatterChart = ScatterChart;
        var SvgRenderer = (function () {
            function SvgRenderer() {
            }
            SvgRenderer.prototype.init = function (element, labelsContext, isMobileChart, tooltipsEnabled) {
                this.mainGraphicsG = element.append('g')
                    .classed(SvgRenderer.MainGraphicsContext.class, true);
                this.isMobileChart = isMobileChart;
                if (isMobileChart) {
                    // The backgroundRect catch user interactions when clicking/dragging on the background of the chart.
                    this.mainGraphicsBackgroundRect = this.mainGraphicsG
                        .append("rect")
                        .classed("backgroundRect", true)
                        .attr({ width: "100%", height: "100%" });
                }
                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                this.labelGraphicsContext = labelsContext;
                this.tooltipsEnabled = tooltipsEnabled;
            };
            SvgRenderer.prototype.render = function (viewModel, interactivityService) {
                var viewport = viewModel.viewport;
                this.mainGraphicsContext
                    .attr({
                    'width': viewport.width,
                    'height': viewport.height
                });
                var scatterMarkers;
                if (viewModel.suppressDataPointRendering) {
                    scatterMarkers = this.removeScatterMarkers();
                }
                else if (viewModel.animationDuration > 0 && viewModel.data.dataPoints.length <= ScatterChart.NoAnimationThreshold) {
                    scatterMarkers = this.drawScatterMarkers(viewModel);
                }
                else {
                    scatterMarkers = this.drawScatterMarkersNoAnimation(viewModel, viewModel.drawBubbles);
                }
                if (viewModel.drawBubbles)
                    scatterMarkers.order();
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(this.mainGraphicsContext, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(viewModel.animationOptions);
                return {
                    dataPointsSelection: scatterMarkers,
                    eventGroup: this.mainGraphicsG,
                    data: viewModel.data,
                    plotContext: this.mainGraphicsContext,
                };
            };
            SvgRenderer.prototype.createTraceLineRenderer = function (viewModel) {
                return new ScatterTraceLineRenderer(viewModel, this.mainGraphicsContext, this.tooltipsEnabled);
            };
            SvgRenderer.prototype.removeScatterMarkers = function () {
                this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
                    .remove();
                return this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
            };
            SvgRenderer.prototype.drawScatterMarkers = function (viewModel) {
                var data = viewModel.data;
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                // put all the markers in a single fake group. keeps the dom structure consistent between
                // drawScatterMarkers and drawScatterMarkersGrouped.
                var fakeDataPointSeries = [
                    {
                        identityKey: "",
                        dataPoints: data.dataPoints,
                    },
                ];
                var fakeSeriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
                    .data(fakeDataPointSeries, function (s) { return s.identityKey; });
                fakeSeriesGroups.enter()
                    .append('g')
                    .classed(SvgRenderer.ScatterMarkerSeriesGroup.class, true);
                // groups for real series may have been inserted by drawScatterMarkersGrouped, remove them
                fakeSeriesGroups.exit()
                    .remove();
                var markers = fakeSeriesGroups.selectAll(SvgRenderer.DotClass.selector)
                    .data(function (s) { return s.dataPoints; }, function (d) { return d.identity.getKey(); });
                markers.enter().append('circle')
                    .classed(SvgRenderer.DotClass.class, true)
                    .style('opacity', 0) // Fade new bubbles into visibility
                    .attr('r', 0);
                markers
                    .style({
                    'stroke-opacity': function (d) { return ScatterChart.getMarkerStrokeOpacity(d.size != null, data.colorBorder, viewModel.hasSelection, d.selected); },
                    'stroke-width': '1px',
                    'stroke': function (d) { return ScatterChart.getStrokeFill(d, data.colorBorder); },
                    'fill': function (d) { return d.fill; },
                    'fill-opacity': function (d) { return ScatterChart.getMarkerFillOpacity(d.size != null, viewModel.fillMarkers, viewModel.hasSelection, d.selected); },
                })
                    .transition()
                    .ease(viewModel.easeType)
                    .duration(viewModel.animationDuration)
                    .style('opacity', 1) // Fill-opacity is used for selected / highlight changes, opacity is for enter/exit fadein/fadeout
                    .attr({
                    r: function (d) { return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport); },
                    cx: function (d) { return xScale(d.x); },
                    cy: function (d) { return yScale(d.y); },
                });
                markers
                    .exit()
                    .transition()
                    .ease(viewModel.easeType)
                    .duration(viewModel.animationDuration)
                    .style('opacity', 0) // Fade out bubbles that are removed
                    .attr('r', 0)
                    .remove();
                return markers;
            };
            SvgRenderer.prototype.drawScatterMarkersNoAnimation = function (viewModel, isBubble) {
                var data = viewModel.data;
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                var seriesGroups;
                if (isBubble) {
                    var fakeDataPointSeries = [
                        {
                            identityKey: "",
                            dataPoints: data.dataPoints,
                        },
                    ];
                    seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
                        .data(fakeDataPointSeries, function (s) { return s.identityKey; });
                }
                else {
                    seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(data.dataPointSeries, function (s) { return s.identityKey; });
                }
                // a group for each series
                seriesGroups.enter()
                    .append('g')
                    .classed(SvgRenderer.ScatterMarkerSeriesGroup.class, true);
                // this will also remove the fake group that might have been created by drawScatterMarkers
                seriesGroups.exit()
                    .remove();
                seriesGroups
                    .each(function (s) {
                    var seriesStyle = ScatterChart.getSeriesStyle(s.hasSize, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers, s.fill);
                    var g = d3.select(this);
                    SvgRenderer.applyStyle(this, seriesStyle);
                    var markers = g.selectAll(SvgRenderer.DotClass.selector).data(s.dataPoints, function (m) { return m.identity.getKey(); });
                    markers.enter()
                        .append('circle')
                        .classed(SvgRenderer.DotClass.class, true);
                    markers.exit()
                        .remove();
                    markers.each(function (d) {
                        var style = ScatterChart.getMarkerStyle(d, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers);
                        SvgRenderer.styleException(style, seriesStyle);
                        SvgRenderer.applyStyle(this, style);
                    });
                    markers.attr({
                        r: function (d) { return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport); },
                        cx: function (d) { return xScale(d.x); },
                        cy: function (d) { return yScale(d.y); },
                    });
                });
                return this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
            };
            SvgRenderer.styleException = function (elementStyle, seriesStyle) {
                if (seriesStyle) {
                    for (var name_1 in elementStyle) {
                        if (elementStyle[name_1] === seriesStyle[name_1]) {
                            elementStyle[name_1] = null;
                        }
                    }
                }
            };
            SvgRenderer.applyStyle = function (element, style) {
                for (var name_2 in style) {
                    var elementValue = element.style[name_2];
                    var styleValue = style[name_2];
                    if (styleValue == null) {
                        if (elementValue === "")
                            continue;
                    }
                    else {
                        styleValue = styleValue.toString();
                        if (styleValue === elementValue)
                            continue;
                    }
                    element.style[name_2] = styleValue;
                }
            };
            SvgRenderer.DotClass = createClassAndSelector('dot');
            SvgRenderer.MainGraphicsContext = createClassAndSelector('mainGraphicsContext');
            SvgRenderer.ScatterMarkerSeriesGroup = createClassAndSelector('scatterMarkerSeriesGroup');
            return SvgRenderer;
        }());
        var ScatterChartDataLabels;
        (function (ScatterChartDataLabels) {
            var validLabelPositions = [
                2 /* Below */,
                1 /* Above */,
                8 /* Right */,
                4 /* Left */,
                16 /* BelowRight */,
                32 /* BelowLeft */,
                64 /* AboveRight */,
                128 /* AboveLeft */
            ];
            function createLabelDataPoints(viewModel) {
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                var sizeRange = viewModel.data.sizeRange;
                var labelDataPoints = [];
                var dataPoints = viewModel.data.dataPoints;
                var labelSettings = viewModel.data.dataLabelsSettings;
                var preferredLabelsKeys = getPreferredLabelsKeys(viewModel);
                for (var _i = 0, dataPoints_4 = dataPoints; _i < dataPoints_4.length; _i++) {
                    var dataPoint = dataPoints_4[_i];
                    var text = dataPoint.formattedCategory.getValue();
                    var properties = {
                        text: text,
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    labelDataPoints.push({
                        isPreferred: preferredLabelsKeys ? isLabelPreferred(dataPoint.identity.getKey(), preferredLabelsKeys) : false,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight,
                        },
                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 0 /* Point */,
                        parentShape: {
                            point: {
                                x: xScale(dataPoint.x),
                                y: yScale(dataPoint.y),
                            },
                            radius: ScatterChart.getBubbleRadius(dataPoint.radius, sizeRange, viewModel.viewport),
                            validPositions: validLabelPositions,
                        },
                        identity: dataPoint.identity,
                        fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                    });
                }
                return labelDataPoints;
            }
            ScatterChartDataLabels.createLabelDataPoints = createLabelDataPoints;
            function getPreferredLabelsKeys(viewModel) {
                var width = viewModel.viewport.width;
                var height = viewModel.viewport.height;
                var visualCenter = new visuals.Point(width / 2, height / 2);
                var quadrantsCenters = getQuadrantsCenters(width, height);
                return getCandidateLabels(visualCenter, quadrantsCenters, viewModel);
            }
            function getQuadrantsCenters(visualWidth, visualHeight) {
                var quadrantsCenters = [];
                var quarterWidth = visualWidth / 4;
                var quarterHeight = visualHeight / 4;
                quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight));
                quadrantsCenters.push(new visuals.Point(quarterWidth * 3, quarterHeight));
                quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight * 3));
                quadrantsCenters.push(new visuals.Point(quarterWidth * 3, quarterHeight * 3));
                return quadrantsCenters;
            }
            function getCandidateLabels(visualCenter, quadrantsCenters, viewModel) {
                var minDistances = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
                var ids = [];
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                var distance;
                for (var _i = 0, _a = viewModel.data.dataPoints; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    var x = xScale(dp.x);
                    var y = yScale(dp.y);
                    var quadrantNumber = getPointQuadrantNumber(x, y, visualCenter);
                    if (viewModel.drawBubbles) {
                        // Since the array is sorted by size the preferred label will be the first label in the quadrant
                        if (!ids[quadrantNumber])
                            ids[quadrantNumber] = dp.identity;
                    }
                    else {
                        distance = getDistanceBetweenPoints(quadrantsCenters[quadrantNumber].x, quadrantsCenters[quadrantNumber].y, x, y);
                        if (distance < minDistances[quadrantNumber]) {
                            ids[quadrantNumber] = dp.identity;
                            minDistances[quadrantNumber] = distance;
                        }
                    }
                }
                var preferredLabelsKeys = [];
                for (var _b = 0, ids_1 = ids; _b < ids_1.length; _b++) {
                    var id = ids_1[_b];
                    if (id)
                        preferredLabelsKeys.push(id.getKey());
                }
                return preferredLabelsKeys;
            }
            function getPointQuadrantNumber(x, y, centerPoint) {
                if (x > centerPoint.x && y <= centerPoint.y)
                    return 0 /* First */;
                if (x <= centerPoint.x && y <= centerPoint.y)
                    return 1 /* Second */;
                if (x <= centerPoint.x && y > centerPoint.y)
                    return 2 /* Third */;
                else
                    return 3 /* Fourth */;
            }
            function getDistanceBetweenPoints(x1, y1, x2, y2) {
                return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            }
            function isLabelPreferred(key, preferredLabelsKeys) {
                for (var _i = 0, preferredLabelsKeys_1 = preferredLabelsKeys; _i < preferredLabelsKeys_1.length; _i++) {
                    var preferredLabel = preferredLabelsKeys_1[_i];
                    if (key.localeCompare(preferredLabel) === 0)
                        return true;
                }
                return false;
            }
        })(ScatterChartDataLabels || (ScatterChartDataLabels = {}));
        var ScatterTraceLineRenderer = (function () {
            function ScatterTraceLineRenderer(viewModel, element, tooltipsEnabled) {
                this.viewModel = viewModel;
                this.element = element;
                this.tooltipsEnabled = tooltipsEnabled;
            }
            ScatterTraceLineRenderer.prototype.remove = function () {
                this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector).remove();
                this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector).remove();
            };
            ScatterTraceLineRenderer.prototype.render = function (selectedPoints, shouldAnimate) {
                var viewModel = this.viewModel;
                var scatterViewModel = viewModel.viewModel;
                var seriesPoints = [];
                if (!_.isEmpty(selectedPoints) && !scatterViewModel.suppressDataPointRendering) {
                    var currentFrameIndex_1 = viewModel.data.currentFrameIndex;
                    // filter to the selected identity, only up to and including the current frame. Add frames during play.
                    var hasBubbleAtCurrentFrame = [];
                    for (var selectedIndex = 0, selectedLen = selectedPoints.length; selectedIndex < selectedLen; selectedIndex++) {
                        seriesPoints[selectedIndex] = [];
                        hasBubbleAtCurrentFrame[selectedIndex] = false;
                        for (var frameIndex = 0, frameLen = viewModel.data.allViewModels.length; frameIndex < frameLen && frameIndex <= currentFrameIndex_1; frameIndex++) {
                            var value = _.find(viewModel.data.allViewModels[frameIndex].dataPoints, function (value, index) {
                                return value.identity.getKey() === selectedPoints[selectedIndex].identity.getKey();
                            });
                            if (value != null) {
                                // TODO: Revisit this, we should be able to keep track without modifying Scatter's data points.
                                value.frameIndex = frameIndex;
                                seriesPoints[selectedIndex].push(value);
                                if (frameIndex === currentFrameIndex_1)
                                    hasBubbleAtCurrentFrame[selectedIndex] = true;
                            }
                        }
                    }
                    var xScale_1 = scatterViewModel.xAxisProperties.scale;
                    var yScale_1 = scatterViewModel.yAxisProperties.scale;
                    var line_1 = d3.svg.line()
                        .x(function (d) { return xScale_1(d.x); })
                        .y(function (d) { return yScale_1(d.y); })
                        .defined(function (d) { return d.x !== null && d.y !== null; });
                    // Render Lines
                    var traceLines = this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector)
                        .data(selectedPoints, function (sp) { return sp.identity.getKey(); });
                    traceLines.enter()
                        .append('path')
                        .classed(ScatterTraceLineRenderer.TraceLine.class, true);
                    // prepare array of new/previous lengths
                    // NOTE: can't use lambda because we need the "this" context to be the DOM Element associated with the .each()
                    var previousLengths_1 = [], newLengths_1 = [];
                    var reverse_1 = false;
                    traceLines.each(function (d, i) {
                        var existingPath = this;
                        var previousLength = existingPath.hasAttribute('d') ? existingPath.getTotalLength() : 0;
                        previousLengths_1.push(previousLength);
                        // create offline SVG for new path measurement
                        var tempSvgPath = $('<svg><path></path></svg>');
                        var tempPath = $('path', tempSvgPath);
                        tempPath.attr('d', line_1(seriesPoints[i]));
                        var newLength = seriesPoints[i].length > 0 ? tempPath.get()[0].getTotalLength() : 0;
                        newLengths_1.push(newLength);
                        reverse_1 = reverse_1 || (newLength < previousLength);
                    });
                    // animate using stroke-dash* trick
                    if (!reverse_1) {
                        // growing line
                        traceLines
                            .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
                            .attr({
                            'd': function (d, i) {
                                return line_1(seriesPoints[i]);
                            },
                            'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
                            'stroke-dashoffset': function (d, i) { return newLengths_1[i] - previousLengths_1[i]; },
                        });
                        if (shouldAnimate) {
                            traceLines
                                .transition()
                                .ease('linear')
                                .duration(visuals.PlayChart.FrameAnimationDuration)
                                .attr('stroke-dashoffset', 0);
                        }
                        else {
                            traceLines.attr('stroke-dashoffset', 0);
                        }
                    }
                    else {
                        // shrinking line
                        if (shouldAnimate) {
                            traceLines
                                .transition()
                                .ease('linear')
                                .duration(visuals.PlayChart.FrameAnimationDuration)
                                .attr('stroke-dashoffset', function (d, i) { return previousLengths_1[i] - newLengths_1[i]; })
                                .transition()
                                .ease('linear')
                                .duration(1) // animate the shrink first, then update with new line properties
                                .delay(visuals.PlayChart.FrameAnimationDuration)
                                .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
                                .attr({
                                'd': function (d, i) {
                                    return line_1(seriesPoints[i]);
                                },
                                'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
                                'stroke-dashoffset': 0,
                            });
                        }
                        else {
                            traceLines
                                .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
                                .attr({
                                'd': function (d, i) {
                                    return line_1(seriesPoints[i]);
                                },
                                'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
                                'stroke-dashoffset': 0,
                            });
                        }
                    }
                    traceLines.exit()
                        .remove();
                    // Render circles
                    var circlePoints = [];
                    for (var selectedIndex_1 = 0; selectedIndex_1 < seriesPoints.length; selectedIndex_1++) {
                        var points = seriesPoints[selectedIndex_1];
                        // slice to length-1 because we draw lines to the current bubble but we don't need to draw the current frame's bubble
                        var newPoints = hasBubbleAtCurrentFrame[selectedIndex_1] ? points.slice(0, points.length - 1) : points;
                        circlePoints = circlePoints.concat(newPoints);
                    }
                    var circles = this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector)
                        .data(circlePoints, function (d) { return d.identity.getKey() + d.x + d.y + d.size; });
                    circles.enter()
                        .append('circle')
                        .style('opacity', 0) //fade new bubbles into visibility
                        .classed(ScatterTraceLineRenderer.TraceBubble.class, true);
                    circles
                        .attr('cx', function (d) { return xScale_1(d.x); })
                        .attr('cy', function (d) { return yScale_1(d.y); })
                        .attr('r', function (d) { return ScatterChart.getBubbleRadius(d.radius, viewModel.data.currentViewModel.sizeRange, viewModel.viewport); })
                        .style({
                        'stroke-opacity': function (d) { return ScatterChart.getBubbleOpacity(d, true); },
                        'stroke-width': '1px',
                        'stroke': function (d) { return ScatterChart.getStrokeFill(d, viewModel.data.currentViewModel.colorBorder); },
                        'fill': function (d) { return d.fill; },
                        // vary the opacity along the traceline from 0.20 to 0.80, with 0.85 left for the circle already drawn by scatterChart
                        'fill-opacity': function (d) { return d.size != null ? 0.20 + (d.frameIndex / currentFrameIndex_1) * 0.60 : 0; },
                    })
                        .transition()
                        .ease('linear')
                        .duration(visuals.PlayChart.FrameAnimationDuration)
                        .style('opacity', 1);
                    circles.exit()
                        .transition()
                        .ease('linear')
                        .duration(visuals.PlayChart.FrameAnimationDuration)
                        .style('opacity', 0) // fade exiting bubbles out
                        .remove();
                    if (this.tooltipsEnabled) {
                        visuals.TooltipManager.addTooltip(circles, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    }
                    // sort the z-order, smallest size on top
                    circles.sort(function (d1, d2) { return d2.size - d1.size; });
                }
                else {
                    this.remove();
                }
            };
            ScatterTraceLineRenderer.TraceLine = createClassAndSelector('traceLine');
            ScatterTraceLineRenderer.TraceBubble = createClassAndSelector('traceBubble');
            return ScatterTraceLineRenderer;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var DataViewMatrixUtils = powerbi.data.utils.DataViewMatrixUtils;
        ;
        var PlayAxis = (function () {
            function PlayAxis(options) {
                if (options) {
                    this.interactivityService = options.interactivityService;
                }
            }
            PlayAxis.prototype.init = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                this.element = options.element;
                this.svg = options.svg;
                this.host = options.host;
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
                if (this.interactivityService) {
                    this.playControl = new PlayControl(this.element, function (frameIndex) { return _this.moveToFrameAndRender(frameIndex); }, this.isMobileChart);
                    this.playControl.onPlay(function () { return _this.play(); });
                }
            };
            PlayAxis.prototype.setData = function (dataView, visualConverter) {
                if (dataView) {
                    if (this.ridiculousFlagForPersistProperties && dataView.metadata) {
                        // BUG FIX: customer feedback has been strong that we should always default to show the last frame.
                        // This is essential for dashboard tiles to refresh properly.
                        //  Only copy frameIndex since it is the only property using persistProperties
                        //let objectProps = getObjectProperties(dataView.metadata);
                        //playData.currentFrameIndex = objectProps.currentFrameIndex;
                        //  Turn off the flag that was set by our persistProperties call
                        this.ridiculousFlagForPersistProperties = false;
                        return this.playData;
                    }
                    else if (dataView.matrix || dataView.categorical) {
                        this.playData = PlayChart.converter(dataView, visualConverter);
                    }
                    else {
                        this.playData = PlayChart.getDefaultPlayData();
                    }
                }
                else {
                    this.playData = PlayChart.getDefaultPlayData();
                }
                // Next render should be a full one.
                this.lastViewport = undefined;
                return this.playData;
            };
            PlayAxis.prototype.render = function (suppressAnimations, viewModel, viewport, margin) {
                var playData = this.playData;
                var resized = !this.lastViewport || (this.lastViewport.height !== viewport.height || this.lastViewport.width !== viewport.width);
                this.lastViewport = viewport;
                if (resized)
                    this.stop();
                if (!playData)
                    return;
                var playViewModel = {
                    data: this.playData,
                    viewModel: viewModel,
                    viewport: viewport,
                };
                var hasSelection = false;
                if (this.interactivityService) {
                    var data_5 = playData.currentViewModel;
                    this.interactivityService.applySelectionStateToData(data_5.dataPoints);
                    hasSelection = this.interactivityService.hasSelection();
                }
                this.updateCallout(viewport, margin);
                if (this.playControl && resized) {
                    this.playControl.rebuild(playData, viewport);
                }
                var allDataPoints = playData.allViewModels.map(function (vm) { return vm.dataPoints; });
                var flatAllDataPoints = _.flatten(allDataPoints);
                // NOTE: Return data points to keep track of current selected bubble even if it drops out for a few frames
                return {
                    allDataPoints: flatAllDataPoints,
                    viewModel: playViewModel,
                };
            };
            PlayAxis.prototype.updateCallout = function (viewport, margin) {
                var playData = this.playData;
                var frameKeys = playData.frameKeys;
                var currentFrameIndex = playData.currentFrameIndex;
                var height = viewport.height;
                var plotAreaHeight = height - margin.top - margin.bottom;
                var width = viewport.width;
                var plotAreaWidth = width - margin.left - margin.right;
                var calloutDimension = Math.min(height, width * 1.3); //1.3 to compensate for tall, narrow-width viewport
                var fontSize = Math.max(12, Math.round(calloutDimension / 7));
                fontSize = Math.min(fontSize, 70);
                var textProperties = {
                    fontSize: jsCommon.PixelConverter.toString(fontSize),
                    text: frameKeys[currentFrameIndex] || "",
                    fontFamily: "wf_segoe-ui_normal",
                };
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties);
                var calloutData = [];
                if (currentFrameIndex < frameKeys.length && currentFrameIndex >= 0 && textHeight < plotAreaHeight) {
                    var maxTextWidth = plotAreaWidth - (2 * PlayAxis.calloutOffsetMultiplier * textHeight);
                    var calloutText = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextWidth);
                    calloutData = [calloutText];
                }
                var callout = this.svg.selectAll(PlayAxis.PlayCallout.selector).data(calloutData);
                callout.enter()
                    .append('text')
                    .classed(PlayAxis.PlayCallout.class, true);
                callout
                    .text(function (d) { return d; })
                    .attr({
                    x: plotAreaWidth - PlayAxis.calloutOffsetMultiplier * textHeight,
                    y: function () { return textHeight; },
                })
                    .style({
                    'font-size': fontSize + 'px',
                    'text-anchor': 'end',
                });
                callout.exit().remove();
            };
            PlayAxis.prototype.play = function () {
                var playData = this.playData;
                if (this.isPlaying) {
                    this.stop();
                }
                else if (this.playControl) {
                    this.isPlaying = true;
                    this.playControl.play();
                    var indexToShow = Math.round(this.playControl.getCurrentIndex());
                    if (indexToShow >= playData.allViewModels.length - 1) {
                        playData.currentFrameIndex = -1;
                    }
                    else {
                        playData.currentFrameIndex = indexToShow - 1;
                    }
                    this.playNextFrame(playData);
                }
            };
            PlayAxis.prototype.playNextFrame = function (playData, startFrame, endFrame) {
                var _this = this;
                if (!this.isPlaying) {
                    this.stop();
                    return;
                }
                var nextFrame = playData.currentFrameIndex + 1;
                if (startFrame != null && endFrame != null) {
                    nextFrame = Math.abs(endFrame - startFrame + 1);
                    startFrame = nextFrame;
                }
                if (nextFrame < playData.allViewModels.length && nextFrame > -1) {
                    playData.currentFrameIndex = nextFrame;
                    playData.currentViewModel = playData.allViewModels[nextFrame];
                    this.renderDelegate(playData.currentViewModel);
                    this.playControl.setFrame(nextFrame);
                    if (nextFrame < playData.allViewModels.length) {
                        window.setTimeout(function () {
                            _this.playNextFrame(playData, startFrame, endFrame);
                        }, PlayChart.FrameStepDuration);
                    }
                }
                else {
                    this.stop();
                }
            };
            PlayAxis.prototype.stop = function () {
                if (this.playControl)
                    this.playControl.pause();
                this.isPlaying = false;
            };
            PlayAxis.prototype.remove = function () {
                if (this.playControl)
                    this.playControl.remove();
                d3.selectAll(PlayAxis.PlayCallout.selector).remove();
                // TODO: remove any tracelines
            };
            PlayAxis.prototype.setRenderFunction = function (fn) {
                this.renderDelegate = fn;
            };
            PlayAxis.prototype.getCartesianExtents = function (existingExtents, getExtents) {
                if (this.playData && this.playData.allViewModels && this.playData.allViewModels.length > 0) {
                    return PlayChart.getMinMaxForAllFrames(this.playData, getExtents);
                }
                return existingExtents;
            };
            PlayAxis.prototype.setPlayControlPosition = function (playControlLayout) {
                if (this.playControl) {
                    var container = this.playControl.getContainer();
                    container.css('left', playControlLayout.left ? playControlLayout.left + 'px' : '');
                    container.css('top', playControlLayout.top ? playControlLayout.top + 'px' : '');
                }
            };
            PlayAxis.prototype.moveToFrameAndRender = function (frameIndex) {
                var playData = this.playData;
                this.isPlaying = false;
                if (playData && frameIndex >= 0 && frameIndex < playData.allViewModels.length && frameIndex !== playData.currentFrameIndex) {
                    playData.currentFrameIndex = frameIndex;
                    var data_6 = playData.allViewModels[frameIndex];
                    playData.currentViewModel = data_6;
                    this.renderDelegate(data_6);
                }
            };
            PlayAxis.PlayCallout = createClassAndSelector('play-callout');
            PlayAxis.calloutOffsetMultiplier = 0.3;
            return PlayAxis;
        }());
        visuals.PlayAxis = PlayAxis;
        var PlayControl = (function () {
            function PlayControl(element, renderDelegate, isMobileChart) {
                this.isMobileChart = isMobileChart;
                this.createSliderDOM(element);
                this.renderDelegate = renderDelegate;
            }
            PlayControl.prototype.getContainer = function () {
                return this.playAxisContainer;
            };
            PlayControl.prototype.remove = function () {
                if (this.playAxisContainer)
                    this.playAxisContainer.remove();
            };
            PlayControl.prototype.pause = function () {
                this.playButton.removeClass('pause').addClass('play');
            };
            PlayControl.prototype.play = function () {
                this.playButton.removeClass('play').addClass('pause');
            };
            PlayControl.prototype.getCurrentIndex = function () {
                // TODO: round() necessary?
                return Math.round(this.noUiSlider.get());
            };
            PlayControl.prototype.onPlay = function (handler) {
                this.playButtonCircle.off('click');
                this.playButtonCircle.on('click', handler);
            };
            PlayControl.calculateSliderWidth = function (labelData, viewportWidth) {
                var leftMargin = 0, rightMargin = 0;
                if (!_.isEmpty(labelData.labelInfo)) {
                    leftMargin = _.first(labelData.labelInfo).labelWidth / 2;
                    rightMargin = _.last(labelData.labelInfo).labelWidth / 2;
                }
                var sliderLeftMargin = Math.max(leftMargin, PlayControl.SliderMarginLeft);
                var sliderRightMargin = Math.max(rightMargin, PlayControl.SliderMarginRight);
                sliderLeftMargin = Math.min(PlayControl.SliderMaxMargin, sliderLeftMargin);
                sliderRightMargin = Math.min(PlayControl.SliderMaxMargin, sliderRightMargin);
                var sliderWidth = Math.max((viewportWidth - sliderLeftMargin - sliderRightMargin), 1);
                return sliderWidth;
            };
            PlayControl.prototype.createSliderDOM = function (element) {
                this.playAxisContainer = $('<div class="play-axis-container"></div>')
                    .appendTo(element)
                    .css('height', PlayControl.PlayControlHeight + 'px');
                this.playButtonCircle = $('<div class="button-container"></div>')
                    .appendTo(this.playAxisContainer);
                if (this.isMobileChart) {
                    this.playButtonCircle.addClass('mobile-button-container');
                }
                this.playButton = $('<div class="play"></div>')
                    .appendTo(this.playButtonCircle);
                this.slider = $('<div class="sliders"></div>')
                    .appendTo(this.playAxisContainer);
            };
            PlayControl.prototype.rebuild = function (playData, viewport) {
                var _this = this;
                var slider = this.slider;
                // re-create the slider
                if (this.noUiSlider)
                    this.noUiSlider.destroy();
                var sliderElement = this.slider.get(0);
                var labelData = playData.labelData;
                var sliderWidth = PlayControl.calculateSliderWidth(labelData, viewport.width);
                this.slider.css('width', sliderWidth + 'px');
                var numFrames = playData.frameKeys.length;
                if (numFrames > 0) {
                    var filterPipLabels = PlayChart.createPipsFilterFn(playData, sliderWidth, labelData);
                    var lastIndex = numFrames - 1;
                    noUiSlider.create(sliderElement, {
                        step: 1,
                        start: [playData.currentFrameIndex],
                        range: {
                            min: [0],
                            max: [lastIndex],
                        },
                        pips: {
                            mode: 'steps',
                            density: Math.round(100 / numFrames),
                            format: {
                                to: function (index) { return playData.frameKeys[index]; },
                                from: function (value) { return playData.frameKeys.indexOf(value); },
                            },
                            filter: filterPipLabels,
                        },
                    });
                }
                else {
                    noUiSlider.create(sliderElement, {
                        step: 1,
                        start: [0],
                        range: {
                            min: [0],
                            max: [0],
                        },
                    });
                }
                this.noUiSlider = sliderElement.noUiSlider;
                this.noUiSlider.on('slide', function () {
                    var indexToShow = _this.getCurrentIndex();
                    _this.renderDelegate(indexToShow);
                });
                // update the width and margin-left to center up each label
                $('.noUi-value', slider).each(function (idx, elem) {
                    // TODO: better way to get the label info for an element?
                    var actualWidth = labelData.labelInfo.filter(function (l) { return l.label === $(elem).text(); })[0].labelWidth;
                    $(elem).width(actualWidth);
                    $(elem).css('margin-left', -actualWidth / 2 + 'px');
                });
                if (this.isMobileChart) {
                    $('.noUi-handle').addClass('mobile-noUi-handle');
                }
            };
            PlayControl.prototype.setFrame = function (frameIndex) {
                this.noUiSlider.set([frameIndex]);
            };
            ;
            PlayControl.SliderMarginLeft = 24 + 10 * 2; // playButton width + playButton margin * 2
            PlayControl.SliderMarginRight = 20;
            PlayControl.SliderMaxMargin = 100;
            PlayControl.PlayControlHeight = 80; //tuned for two rows of label text to be perfectly clipped before the third row. Dependent on current font sizes in noui-pips.css
            return PlayControl;
        }());
        var PlayChart;
        (function (PlayChart) {
            // TODO: add speed control to property pane
            // NOTE: current noUiSlider speed is a CSS property of the class .noUi-state-tap, and also is hard-coded in noUiSlider.js. We'll need to add a new create param for transition time.
            // 800ms matches Silverlight frame speed
            PlayChart.FrameStepDuration = 800;
            PlayChart.FrameAnimationDuration = 750; //leave 50ms for the traceline animation - to avoid being cancelled. TODO: add a proper wait impl.
            PlayChart.ClassName = 'playChart';
            function convertMatrixToCategorical(matrix, frame) {
                var categorical = {
                    categories: [],
                    values: powerbi.data.DataViewTransform.createValueColumns()
                };
                // If we don't have enough fields, just return early. We need at least:
                // 2 rows and 1 column:  (play->category, measures)
                // or:
                // 1 row and 2 columns:  (play, series->measures)
                if ((_.isEmpty(matrix.columns.levels)) || (matrix.rows.levels.length < 2 && matrix.columns.levels.length < 2))
                    return categorical;
                // Ignore the play field (first row), we use either the second row group (play->category) or we don't use this variable (category)
                // Note related to VSTS 6986788: use the leaf node for category as there can be multiple levels for category during drilldown.
                var categorySource = matrix.rows.levels.length > 1 && !_.isEmpty(_.last(matrix.rows.levels).sources)
                    ? _.last(matrix.rows.levels).sources[0]
                    : null;
                var category = {
                    source: categorySource,
                    values: [],
                    objects: undefined,
                    identity: []
                };
                // Matrix shape for Play:
                //
                //                   Series1 | Series2 | ...
                //                  --------- --------  
                // Play1 | Category1 | values  | values
                //       | Category2 | values  | values
                //       | ...
                // Play2 | Category1 | values  | values
                //       | Category2 | values  | values
                // ...
                // we are guaranteed at least one row (it will be the Play field)
                var hasRowChildren = !_.isEmpty(matrix.rows.root.children);
                var hasColChildren = !_.isEmpty(matrix.columns.root.children);
                var hasSeries = matrix.columns.levels.length > 1 && hasColChildren;
                var hasPlayAndCategory = matrix.rows.levels.length > 1 && hasRowChildren;
                if (hasSeries && !hasPlayAndCategory) {
                    // set categories to undefined
                    categorical.categories = undefined;
                    var node_1 = matrix.columns.root;
                    categorical.values.source = matrix.columns.levels[0].sources[0];
                    var columnLength_1 = matrix.valueSources.length;
                    for (var i = 0, len = node_1.children.length; i < len; i++) {
                        // add all the value sources for each series
                        var columnNode = node_1.children[i];
                        for (var j = 0; j < columnLength_1; j++) {
                            // DEFECT 6547170: groupName must be null to turn into (Blank), undefined will use the field name
                            var source = _.create(matrix.valueSources[j], { groupName: columnNode.value === undefined ? null : columnNode.value });
                            var dataViewColumn = {
                                identity: columnNode.identity,
                                values: [],
                                source: source
                            };
                            categorical.values.push(dataViewColumn);
                        }
                    }
                    var categoryFrameRootNode = matrix.rows.root.children[frame];
                    DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function (leafNode, leafNodeIndex) {
                        debug.assert(leafNodeIndex === 0, 'expecting only one leafNode under categoryFrameRootNode in this case');
                        for (var i = 0, len = node_1.children.length; i < len; i++) {
                            for (var j = 0; j < columnLength_1; j++) {
                                categorical.values[i * columnLength_1 + j].values.push(leafNode.values[i * columnLength_1 + j].value);
                            }
                        }
                    });
                }
                else if (hasSeries && hasRowChildren) {
                    // series and categories
                    var categoryFrameRootNode = matrix.rows.root.children[frame];
                    // create the categories first
                    DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function (leafNode) {
                        category.identity.push(leafNode.identity);
                        category.values.push(leafNode.value);
                    });
                    categorical.categories.push(category);
                    // now add the series info
                    categorical.values.source = matrix.columns.levels[0].sources[0];
                    var nodeQueue = [];
                    var columnNode = matrix.columns.root;
                    var seriesIndex_1 = -1;
                    while (columnNode) {
                        if (columnNode.children && columnNode.children[0].children) {
                            for (var j = 0, jlen = columnNode.children.length; j < jlen; j++) {
                                // each of these is a "series"
                                nodeQueue.push(columnNode.children[j]);
                            }
                        }
                        else if (columnNode.children && categoryFrameRootNode.children) {
                            // Processing a single series under here, push all the value sources for every series.
                            var columnLength = columnNode.children.length;
                            for (var j = 0; j < columnLength; j++) {
                                var source = _.create(matrix.valueSources[j], { groupName: columnNode.value });
                                var dataViewColumn = {
                                    identity: columnNode.identity,
                                    values: [],
                                    source: source,
                                };
                                categorical.values.push(dataViewColumn);
                            }
                            DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function (leafNode) {
                                for (var j = 0; j < columnLength; j++) {
                                    categorical.values[seriesIndex_1 * columnLength + j].values.push(leafNode.values[seriesIndex_1 * columnLength + j].value);
                                }
                            });
                        }
                        if (nodeQueue.length > 0) {
                            columnNode = nodeQueue[0];
                            nodeQueue = nodeQueue.splice(1);
                            seriesIndex_1++;
                        }
                        else
                            columnNode = undefined;
                    }
                }
                else if (hasPlayAndCategory) {
                    // no series, just play and category
                    var categoryFrameRootNode = matrix.rows.root.children[frame];
                    var measureLength_1 = matrix.valueSources.length;
                    for (var j = 0; j < measureLength_1; j++) {
                        var dataViewColumn = {
                            identity: undefined,
                            values: [],
                            source: matrix.valueSources[j]
                        };
                        categorical.values.push(dataViewColumn);
                    }
                    DataViewMatrixUtils.forEachLeafNode(categoryFrameRootNode, function (leafNode) {
                        category.identity.push(leafNode.identity);
                        category.values.push(leafNode.value);
                        for (var j = 0; j < measureLength_1; j++) {
                            categorical.values[j].values.push(leafNode.values[j].value);
                        }
                    });
                    categorical.categories.push(category);
                }
                return categorical;
            }
            PlayChart.convertMatrixToCategorical = convertMatrixToCategorical;
            function getObjectProperties(dataViewMetadata, dataLabelsSettings) {
                var objectProperties = {};
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    // TODO: remove?
                    objectProperties.currentFrameIndex = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.currentFrameIndex.index, null);
                }
                return objectProperties;
            }
            function buildDataViewForFrame(metadata, categorical) {
                return {
                    metadata: metadata,
                    categorical: categorical,
                };
            }
            function converter(dataView, visualConverter) {
                var dataViewMetadata = dataView.metadata;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                var objectProperties = getObjectProperties(dataViewMetadata, dataLabelsSettings);
                var allViewModels = [];
                var frameKeys = [];
                var convertedData = undefined;
                var matrixRows = dataView.matrix.rows;
                var rowChildrenLength = matrixRows.root.children ? matrixRows.root.children.length : 0;
                var keySourceColumn;
                if (dataView.matrix && rowChildrenLength > 0 && !_.isEmpty(matrixRows.levels) && !_.isEmpty(matrixRows.levels[0].sources)) {
                    keySourceColumn = matrixRows.levels[0].sources[0];
                    // TODO: this should probably defer to the visual which knows how to format the categories.
                    var formatString = visuals.valueFormatter.getFormatString(keySourceColumn, visuals.scatterChartProps.general.formatString);
                    var keyFormatter = void 0;
                    if (keySourceColumn.type.numeric) {
                        // use value range, not actual values
                        var valueRange = Math.abs(matrixRows.root.children[rowChildrenLength - 1].value - matrixRows.root.children[0].value);
                        keyFormatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: valueRange,
                            value2: 0,
                        });
                    }
                    else {
                        keyFormatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                    for (var i = 0, len = rowChildrenLength; i < len; i++) {
                        var key = matrixRows.root.children[i];
                        var frameLabel = keyFormatter.format(key.value);
                        frameKeys.push(frameLabel);
                        var dataViewCategorical = convertMatrixToCategorical(dataView.matrix, i);
                        var frameInfo = { label: frameLabel, column: keySourceColumn };
                        convertedData = visualConverter(buildDataViewForFrame(dataView.metadata, dataViewCategorical), frameInfo);
                        allViewModels.push(convertedData);
                    }
                }
                else {
                    var dataViewCategorical = convertMatrixToCategorical(dataView.matrix, 0);
                    convertedData = visualConverter(buildDataViewForFrame(dataView.metadata, dataViewCategorical));
                    allViewModels.push(convertedData);
                }
                // NOTE: currentViewModel is already set to the last frame
                objectProperties.currentFrameIndex = frameKeys.length - 1;
                return {
                    allViewModels: allViewModels,
                    currentViewModel: convertedData,
                    frameKeys: frameKeys,
                    currentFrameIndex: objectProperties.currentFrameIndex,
                    labelData: getLabelData(frameKeys, keySourceColumn),
                };
            }
            PlayChart.converter = converter;
            function getDefaultPlayData() {
                var defaultData = {
                    frameKeys: [],
                    allViewModels: [],
                    currentFrameIndex: 0,
                    currentViewModel: undefined,
                    labelData: {
                        anyWordBreaks: false,
                        labelInfo: [],
                    },
                };
                return defaultData;
            }
            PlayChart.getDefaultPlayData = getDefaultPlayData;
            function getMinMaxForAllFrames(playData, getExtents) {
                var extents = {
                    minY: 0,
                    maxY: 10,
                    minX: 0,
                    maxX: 10,
                };
                if (playData.allViewModels && playData.allViewModels.length > 0) {
                    extents.minY = extents.minX = Number.MAX_VALUE;
                    extents.maxY = extents.maxX = Number.MIN_VALUE;
                    for (var i = 0, len = playData.allViewModels.length; i < len; i++) {
                        var data_7 = playData.allViewModels[i];
                        var e = getExtents(data_7);
                        // NOTE: D3.min/max handle undefined and NaN nicely, as opposed to Math.min/max
                        extents = {
                            minY: d3.min([e.minY, extents.minY]),
                            maxY: d3.max([e.maxY, extents.maxY]),
                            minX: d3.min([e.minX, extents.minX]),
                            maxX: d3.max([e.maxX, extents.maxX]),
                        };
                    }
                }
                return extents;
            }
            PlayChart.getMinMaxForAllFrames = getMinMaxForAllFrames;
            function getLabelData(keys, keyColumn) {
                var textProperties = {
                    fontFamily: 'wf_segoe-ui_normal',
                    fontSize: jsCommon.PixelConverter.toString(14),
                };
                var labelInfo = [];
                var anyWordBreaks = false;
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    var labelWidth = jsCommon.WordBreaker.getMaxWordWidth(key, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    anyWordBreaks = anyWordBreaks || jsCommon.WordBreaker.hasBreakers(key) || (key).indexOf('-') > -1; // TODO: Why isn't this last part included in hasBreakers()?
                    labelInfo.push({ label: key, labelWidth: labelWidth });
                }
                return {
                    labelInfo: labelInfo,
                    anyWordBreaks: anyWordBreaks,
                    labelFieldName: keyColumn && keyColumn.displayName,
                };
            }
            function createPipsFilterFn(playData, sliderWidth, labelData) {
                var maxLabelWidth = _.max(_.map(labelData.labelInfo, function (l) { return l.labelWidth; }));
                var pipSize = 1; //0=hide, 1=large, 2=small
                var skipMod = 1;
                var maxAllowedLabelWidth = playData.frameKeys.length > 1 ? sliderWidth / (playData.frameKeys.length - 1) : sliderWidth;
                var widthRatio = maxLabelWidth / maxAllowedLabelWidth;
                if (widthRatio > 1.25) {
                    skipMod = Math.ceil(widthRatio);
                    pipSize = 2;
                }
                else if (widthRatio > 1.0 || labelData.anyWordBreaks) {
                    // wordbreak line wrapping is automatic, and we don't reserve enough space to show two lines of text with the larger font
                    pipSize = 2;
                }
                var filterPipLabels = function (index, type) {
                    // noUiSlider will word break / wrap to new lines, so max width is the max word length
                    if (index % skipMod === 0) {
                        return pipSize;
                    }
                    return 0; //hide
                };
                return filterPipLabels;
            }
            PlayChart.createPipsFilterFn = createPipsFilterFn;
            function isDataViewPlayable(dataView, playRole) {
                if (playRole === void 0) { playRole = 'Play'; }
                debug.assertValue(dataView, 'dataView');
                var firstRowSourceRoles = dataView.matrix &&
                    dataView.matrix.rows &&
                    dataView.matrix.rows.levels &&
                    dataView.matrix.rows.levels[0] &&
                    dataView.matrix.rows.levels[0].sources &&
                    dataView.matrix.rows.levels[0].sources[0] &&
                    dataView.matrix.rows.levels[0].sources[0].roles;
                return firstRowSourceRoles && firstRowSourceRoles[playRole];
            }
            PlayChart.isDataViewPlayable = isDataViewPlayable;
            /** Render trace-lines for selected data points. */
            function renderTraceLines(allDataPoints, traceLineRenderer, shouldAnimate) {
                var selectedDataPoints = _.filter(allDataPoints, function (d) { return d.selected; });
                selectedDataPoints = _.uniq(selectedDataPoints, function (d) { return d.identity.getKey(); });
                traceLineRenderer.render(selectedDataPoints, shouldAnimate);
            }
            PlayChart.renderTraceLines = renderTraceLines;
        })(PlayChart = visuals.PlayChart || (visuals.PlayChart = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var VerticalSlicerRenderer = (function () {
            function VerticalSlicerRenderer(options) {
                this.textProperties = {
                    'fontFamily': 'wf_segoe-ui_normal, helvetica, arial, sans-serif',
                    'fontSize': '14px',
                };
                if (options) {
                    this.behavior = options.behavior;
                }
                this.domHelper = options.domHelper;
            }
            // SlicerDefaultValueHandler
            VerticalSlicerRenderer.prototype.getDefaultValue = function () {
                if (this.data && this.data.defaultValue)
                    return this.data.defaultValue.value;
            };
            VerticalSlicerRenderer.prototype.getIdentityFields = function () {
                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
            };
            VerticalSlicerRenderer.prototype.init = function (slicerInitOptions) {
                var _this = this;
                this.element = slicerInitOptions.visualInitOptions.element;
                this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                var settings = this.settings = visuals.Slicer.DefaultStyleProperties();
                var domHelper = this.domHelper;
                var bodyViewport = domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties);
                var interactivityService;
                if (this.behavior)
                    interactivityService = visuals.createInteractivityService(hostServices);
                var containerDiv = document.createElement('div');
                containerDiv.className = Selectors.Container.class;
                var container = this.container = d3.select(containerDiv);
                var header = domHelper.createSlicerHeader(hostServices);
                containerDiv.appendChild(header);
                this.header = d3.select(header);
                this.body = container.append('div').classed(visuals.SlicerUtil.Selectors.Body.class, true)
                    .style({
                    'height': PixelConverter.toString(bodyViewport.height),
                    'width': PixelConverter.toString(bodyViewport.width),
                });
                var rowEnter = function (rowSelection) {
                    _this.onEnterSelection(rowSelection);
                };
                var rowUpdate = function (rowSelection) {
                    _this.onUpdateSelection(rowSelection, interactivityService);
                };
                var rowExit = function (rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: domHelper.getRowHeight(settings, this.textProperties),
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function () { return slicerInitOptions.loadMoreData(); },
                    scrollEnabled: true,
                    viewport: domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties),
                    baseContainer: this.body,
                    isReadMode: function () {
                        return (_this.hostServices.getViewMode() !== 1 /* Edit */);
                    }
                };
                this.listView = visuals.ListViewFactory.createListView(listViewOptions);
                // Append container to DOM
                this.element.get(0).appendChild(containerDiv);
                return interactivityService;
            };
            VerticalSlicerRenderer.prototype.render = function (options) {
                var data = this.data = options.data;
                this.currentViewport = options.viewport;
                var dataView = options.dataView;
                if (!dataView || !data) {
                    this.listView.empty();
                    return;
                }
                this.dataView = dataView;
                var settings = this.settings = data.slicerSettings;
                var domHelper = this.domHelper;
                domHelper.updateSlicerBodyDimensions(this.currentViewport, this.body, settings);
                this.updateSelectionStyle();
                this.listView
                    .viewport(domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties))
                    .rowHeight(domHelper.getRowHeight(settings, this.textProperties))
                    .data(data.slicerDataPoints, function (d) { return $.inArray(d, data.slicerDataPoints); }, options.resetScrollbarPosition);
            };
            VerticalSlicerRenderer.prototype.updateSelectionStyle = function () {
                var settings = this.settings;
                this.container.classed('isMultiSelectEnabled', settings && settings.selection && !settings.selection.singleSelect);
            };
            VerticalSlicerRenderer.prototype.onEnterSelection = function (rowSelection) {
                var settings = this.settings;
                var listItemElement = rowSelection.append('li')
                    .classed(Selectors.ItemContainer.class, true);
                var labelElement = listItemElement.append('div')
                    .classed(Selectors.Input.class, true);
                labelElement.append('input')
                    .attr('type', 'checkbox');
                labelElement.append('span')
                    .classed(Selectors.Checkbox.class, true);
                listItemElement.each(function (d, i) {
                    var item = d3.select(this);
                    if (d.isImage) {
                        item.append('img')
                            .classed(visuals.SlicerUtil.Selectors.LabelImage.class, true);
                    }
                    else {
                        item.append('span')
                            .classed(visuals.SlicerUtil.Selectors.LabelText.class, true);
                    }
                    if (d.count != null) {
                        item.append('span')
                            .classed(visuals.SlicerUtil.Selectors.CountText.class, true)
                            .style('font-size', PixelConverter.fromPoint(settings.slicerText.textSize));
                    }
                });
            };
            VerticalSlicerRenderer.prototype.onUpdateSelection = function (rowSelection, interactivityService) {
                var settings = this.settings;
                var data = this.data;
                if (data && settings) {
                    // Style Slicer Header
                    var domHelper = this.domHelper;
                    domHelper.styleSlicerHeader(this.header, settings, data.categorySourceName);
                    this.header.attr('title', data.categorySourceName);
                    var labelText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                    labelText.text(function (d) {
                        return d.value;
                    }).attr('title', function (d) {
                        return d.tooltip;
                    });
                    domHelper.setSlicerTextStyle(labelText, settings);
                    var labelImage = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelImage.selector);
                    if (!labelImage.empty()) {
                        labelImage.attr('src', function (d) {
                            return d.value;
                        });
                    }
                    var countText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.CountText.selector);
                    if (!countText.empty()) {
                        countText.text(function (d) { return d.count; });
                        domHelper.setSlicerTextStyle(countText, settings);
                    }
                    if (interactivityService && this.body) {
                        var body = this.body.attr('width', this.currentViewport.width);
                        var slicerItemContainers = body.selectAll(Selectors.ItemContainer.selector);
                        var slicerItemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                        var slicerItemInputs = body.selectAll(Selectors.Input.selector);
                        var slicerClear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector);
                        var behaviorOptions = {
                            dataPoints: data.slicerDataPoints,
                            slicerContainer: this.container,
                            itemContainers: slicerItemContainers,
                            itemLabels: slicerItemLabels,
                            itemInputs: slicerItemInputs,
                            clear: slicerClear,
                            interactivityService: interactivityService,
                            settings: data.slicerSettings,
                        };
                        var orientationBehaviorOptions = {
                            behaviorOptions: behaviorOptions,
                            orientation: 0 /* Vertical */,
                        };
                        interactivityService.bind(data.slicerDataPoints, this.behavior, orientationBehaviorOptions, { overrideSelectionFromData: true, hasSelectionOverride: data.hasSelectionOverride, slicerDefaultValueHandler: this });
                        visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), data.hasSelectionOverride, interactivityService.isSelectionModeInverted());
                    }
                    else {
                        visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), false, false);
                    }
                }
            };
            return VerticalSlicerRenderer;
        }());
        visuals.VerticalSlicerRenderer = VerticalSlicerRenderer;
        var Selectors;
        (function (Selectors) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            Selectors.Container = createClassAndSelector('slicerContainer');
            Selectors.ItemContainer = createClassAndSelector('slicerItemContainer');
            Selectors.Input = createClassAndSelector('slicerCheckbox');
            Selectors.Checkbox = createClassAndSelector('checkbox');
        })(Selectors || (Selectors = {}));
        var CheckboxSprite;
        (function (CheckboxSprite) {
            CheckboxSprite.MinimumSize = 8;
            CheckboxSprite.Size = 13;
            CheckboxSprite.SizeRange = CheckboxSprite.Size - CheckboxSprite.MinimumSize;
        })(CheckboxSprite || (CheckboxSprite = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var ItemWidthSampleSize = 50;
        var MinTextWidth = 80;
        var LoadMoreDataThreshold = 0.8; // The value indicates the percentage of data already shown that triggers a loadMoreData call.
        var DefaultStyleProperties = {
            labelText: {
                marginRight: 2,
                paddingLeft: 8,
                paddingRight: 8,
            },
        };
        var HorizontalSlicerRenderer = (function () {
            function HorizontalSlicerRenderer(options) {
                this.textProperties = {
                    fontFamily: 'wf_segoe-ui_normal',
                    fontSize: '14px'
                };
                if (options) {
                    this.behavior = options.behavior;
                }
                this.domHelper = options.domHelper;
                this.dataStartIndex = 0;
            }
            // SlicerDefaultValueHandler
            HorizontalSlicerRenderer.prototype.getDefaultValue = function () {
                if (this.data && this.data.defaultValue)
                    return this.data.defaultValue.value;
            };
            HorizontalSlicerRenderer.prototype.getIdentityFields = function () {
                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
            };
            HorizontalSlicerRenderer.prototype.init = function (slicerInitOptions) {
                this.element = slicerInitOptions.visualInitOptions.element;
                this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(hostServices);
                }
                this.loadMoreData = function () { return slicerInitOptions.loadMoreData(); };
                var containerDiv = document.createElement('div');
                containerDiv.className = Selectors.container.class;
                var container = this.container = d3.select(containerDiv);
                var header = this.domHelper.createSlicerHeader(this.hostServices);
                containerDiv.appendChild(header);
                this.header = d3.select(header);
                var body = this.body = container.append('div').classed(visuals.SlicerUtil.Selectors.Body.class + " " + Selectors.FlexDisplay.class, true);
                this.leftNavigationArrow = body.append("button")
                    .classed(Selectors.NavigationArrow.class + " " + Selectors.LeftNavigationArrow.class, true);
                this.itemsContainer = body.append("div")
                    .classed(Selectors.ItemsContainer.class + " " + Selectors.FlexDisplay.class, true);
                this.rightNavigationArrow = body.append("button")
                    .classed(Selectors.NavigationArrow.class + " " + Selectors.RightNavigationArrow.class, true);
                // Append container to DOM
                this.element.get(0).appendChild(containerDiv);
                this.bindNavigationEvents();
                return this.interactivityService;
            };
            HorizontalSlicerRenderer.prototype.render = function (options) {
                var data = options.data;
                var dataView = options.dataView;
                if (!dataView || !data) {
                    this.itemsContainer.selectAll("*").remove();
                    return;
                }
                this.data = data;
                this.dataView = dataView;
                var resized = this.currentViewport && options.viewport
                    && (this.currentViewport.height !== options.viewport.height || this.currentViewport.width !== options.viewport.width);
                if (!(this.isMaxWidthCalculated() && resized)) {
                    // Max width calculation is not required during resize, but required on data changes like changes to formatting properties fontSize, outline, outline weight, etc...
                    // So calculating only on data updates
                    this.calculateAndSetMaxItemWidth();
                    this.calculateAndSetTotalItemWidth();
                }
                this.currentViewport = options.viewport;
                this.updateStyle();
                var availableWidthForItemsContainer = this.element.find(Selectors.ItemsContainer.selector).width();
                this.itemsToDisplay = this.getNumberOfItemsToDisplay(availableWidthForItemsContainer);
                if (this.itemsToDisplay === 0)
                    return;
                this.renderCore();
            };
            HorizontalSlicerRenderer.prototype.renderCore = function () {
                var data = this.data;
                if (!data || !data.slicerDataPoints)
                    return;
                this.normalizePosition(data.slicerDataPoints);
                var itemsToDisplay = this.itemsToDisplay;
                var dataStartIndex = this.dataStartIndex;
                // Update Navigation Arrows
                this.container.classed(Selectors.CanScrollRight.class, dataStartIndex + this.itemsToDisplay <= data.slicerDataPoints.length - 1);
                this.container.classed(Selectors.CanScrollLeft.class, dataStartIndex > 0);
                // Manipulate DOM
                this.renderItems(data.slicerSettings);
                // Bind Interactivity Service
                this.bindInteractivityService();
                // Load More Data
                if (dataStartIndex + itemsToDisplay >= data.slicerDataPoints.length * LoadMoreDataThreshold) {
                    this.loadMoreData();
                }
            };
            HorizontalSlicerRenderer.prototype.updateStyle = function () {
                var viewport = this.currentViewport;
                var data = this.data;
                var defaultSettings = data.slicerSettings;
                var domHelper = this.domHelper;
                this.container
                    .classed(Selectors.MultiSelectEnabled.class, !defaultSettings.selection.singleSelect)
                    .style({
                    "width": PixelConverter.toString(viewport.width),
                    "height": PixelConverter.toString(viewport.height),
                });
                // Style Slicer Header
                domHelper.styleSlicerHeader(this.header, defaultSettings, data.categorySourceName);
                var headerTextProperties = domHelper.getHeaderTextProperties(defaultSettings);
                this.header.attr('title', data.categorySourceName);
                // Update body width and height
                var bodyViewport = this.bodyViewport = domHelper.getSlicerBodyViewport(viewport, defaultSettings, headerTextProperties);
                this.body.style({
                    "height": PixelConverter.toString(bodyViewport.height),
                    "width": PixelConverter.toString(bodyViewport.width),
                });
            };
            HorizontalSlicerRenderer.prototype.renderItems = function (defaultSettings) {
                var _this = this;
                var itemsToDisplay = this.itemsToDisplay;
                debug.assert(itemsToDisplay > 0, 'items to display should be greater than zero');
                var dataStartIndex = this.dataStartIndex;
                var materializedDataPoints = this.data.slicerDataPoints.slice(dataStartIndex, dataStartIndex + itemsToDisplay);
                var items = this.itemsContainer
                    .selectAll(visuals.SlicerUtil.Selectors.LabelText.selector)
                    .data(materializedDataPoints, function (d) { return _.indexOf(_this.data.slicerDataPoints, d); });
                items
                    .enter()
                    .append("div")
                    .classed(visuals.SlicerUtil.Selectors.LabelText.class + " " + Selectors.FlexDisplay.class, true);
                items.order();
                items
                    .style({
                    "font-family": this.textProperties.fontFamily,
                    "padding-left": PixelConverter.toString(DefaultStyleProperties.labelText.paddingLeft),
                    "padding-right": PixelConverter.toString(DefaultStyleProperties.labelText.paddingRight),
                    "margin-right": function (d, i) { return _this.isLastRowItem(i, itemsToDisplay) ? "0px" : PixelConverter.toString(DefaultStyleProperties.labelText.marginRight); },
                });
                // Default style settings from formatting pane settings
                this.domHelper.setSlicerTextStyle(items, defaultSettings);
                items.exit().remove();
                window.setTimeout(function () {
                    items
                        .attr("title", function (d) { return d.tooltip; })
                        .text(function (d) { return d.value; });
                    // Wrap long text into multiple columns based on height availbale
                    var labels = _this.element.find(visuals.SlicerUtil.Selectors.LabelText.selector);
                    var item = labels.first();
                    var itemWidth = item.width();
                    var itemHeight = item.height();
                    labels.each(function (i, element) {
                        powerbi.TextMeasurementService.wordBreakOverflowingText(element, itemWidth, itemHeight);
                    });
                });
            };
            HorizontalSlicerRenderer.prototype.bindInteractivityService = function () {
                if (this.interactivityService && this.body) {
                    var body = this.body;
                    var itemsContainer = body.selectAll(Selectors.ItemsContainer.selector);
                    var itemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                    var clear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector);
                    var data_8 = this.data;
                    var behaviorOptions = {
                        dataPoints: data_8.slicerDataPoints,
                        slicerContainer: this.container,
                        itemsContainer: itemsContainer,
                        itemLabels: itemLabels,
                        clear: clear,
                        interactivityService: this.interactivityService,
                        settings: data_8.slicerSettings,
                    };
                    var orientationBehaviorOptions = {
                        behaviorOptions: behaviorOptions,
                        orientation: 1 /* Horizontal */,
                    };
                    this.interactivityService.bind(data_8.slicerDataPoints, this.behavior, orientationBehaviorOptions, { overrideSelectionFromData: true, hasSelectionOverride: data_8.hasSelectionOverride });
                    visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), this.interactivityService.hasSelection(), this.interactivityService.isSelectionModeInverted());
                }
                else {
                    visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), false, false);
                }
            };
            HorizontalSlicerRenderer.prototype.normalizePosition = function (points) {
                var dataStartIndex = this.dataStartIndex;
                // if dataStartIndex >= points.length
                dataStartIndex = Math.min(dataStartIndex, points.length - 1);
                // if dataStartIndex < 0 
                this.dataStartIndex = Math.max(dataStartIndex, 0);
            };
            HorizontalSlicerRenderer.prototype.bindNavigationEvents = function () {
                this.registerMouseWheelScrollEvents();
                this.registerMouseClickEvents();
            };
            HorizontalSlicerRenderer.prototype.registerMouseClickEvents = function () {
                var _this = this;
                var rightNavigationArrow = this.container.selectAll(Selectors.RightNavigationArrow.selector);
                var leftNavigationArrow = this.container.selectAll(Selectors.LeftNavigationArrow.selector);
                rightNavigationArrow
                    .on("click", function () {
                    _this.scrollRight();
                });
                leftNavigationArrow
                    .on("click", function () {
                    _this.scrollLeft();
                });
            };
            // Register for mouse wheel scroll events
            HorizontalSlicerRenderer.prototype.registerMouseWheelScrollEvents = function () {
                var _this = this;
                var scrollableElement = this.body.node();
                scrollableElement.addEventListener("mousewheel", function (e) {
                    _this.onMouseWheel(e.wheelDelta);
                });
                scrollableElement.addEventListener("DOMMouseScroll", function (e) {
                    _this.onMouseWheel(e.detail);
                });
            };
            HorizontalSlicerRenderer.prototype.onMouseWheel = function (wheelDelta) {
                if (wheelDelta < 0) {
                    this.scrollRight();
                }
                else if (wheelDelta > 0) {
                    this.scrollLeft();
                }
            };
            /* If there is only one item being displayed, we show the next item when navigation arrows are clicked
            * But when there are more than 1 item, n-1 items are shown say we have 10 items in total , in initial page if we show 1 to 5 items when right button is clicked we will show items from 5 to 10
            */
            HorizontalSlicerRenderer.prototype.scrollRight = function () {
                var itemsToDisplay = this.itemsToDisplay;
                var startIndex = this.dataStartIndex;
                var dataPointsLength = this.data.slicerDataPoints.length;
                var lastItemIndex = dataPointsLength - 1;
                // If it is the last page stay on the same page and don't navigate
                if (itemsToDisplay + startIndex > lastItemIndex) {
                    return;
                }
                if (itemsToDisplay === 1) {
                    startIndex += itemsToDisplay;
                }
                else {
                    startIndex += itemsToDisplay - 1;
                }
                // Adjust the startIndex to show last n items if startIndex + itemsToDisplay is greater than total datapoints
                if (itemsToDisplay + startIndex > lastItemIndex) {
                    startIndex = lastItemIndex - itemsToDisplay + 1;
                }
                this.dataStartIndex = startIndex;
                this.renderCore();
            };
            /* If there is only one item being displayed, we show the next item when navigation arrows are clicked
            * But when there are more than 1 item, n-1 items are shown
            */
            HorizontalSlicerRenderer.prototype.scrollLeft = function () {
                var itemsToDisplay = this.itemsToDisplay;
                var startIndex = this.dataStartIndex;
                var firstItemIndex = 0;
                // If it is the first page stay on the same page and don't navigate
                if (startIndex === 0) {
                    return;
                }
                // If there is only item shown when left navigation button is clicked we want to navigate back to show previous item
                if (itemsToDisplay === 1) {
                    startIndex -= itemsToDisplay;
                }
                if (startIndex - itemsToDisplay < firstItemIndex) {
                    startIndex = firstItemIndex;
                }
                else {
                    startIndex = startIndex - itemsToDisplay + 1;
                }
                this.dataStartIndex = startIndex;
                this.renderCore();
            };
            HorizontalSlicerRenderer.prototype.isLastRowItem = function (fieldIndex, columnsToDisplay) {
                return fieldIndex === columnsToDisplay - 1;
            };
            HorizontalSlicerRenderer.prototype.getScaledTextWidth = function (textSize) {
                return (textSize / jsCommon.TextSizeDefaults.TextSizeMin) * MinTextWidth;
            };
            HorizontalSlicerRenderer.prototype.isMaxWidthCalculated = function () {
                return this.maxItemWidth !== undefined;
            };
            // Sampling a subset of total datapoints to calculate max item width
            HorizontalSlicerRenderer.prototype.calculateAndSetMaxItemWidth = function () {
                var dataPointsLength = this.getDataPointsCount();
                var maxItemWidth = 0;
                if (dataPointsLength === 0) {
                    this.maxItemWidth = maxItemWidth;
                    return;
                }
                var data = this.data;
                var dataPoints = data.slicerDataPoints;
                var sampleSize = Math.min(dataPointsLength, ItemWidthSampleSize);
                var properties = jQuery.extend(true, {}, this.textProperties);
                var textSize = data.slicerSettings.slicerText.textSize;
                // Update text properties from formatting pane values
                properties.fontSize = PixelConverter.fromPoint(textSize);
                var getMaxWordWidth = jsCommon.WordBreaker.getMaxWordWidth;
                for (var i = 0; i < sampleSize; i++) {
                    var itemText = dataPoints[i].value;
                    properties.text = itemText;
                    maxItemWidth = Math.max(maxItemWidth, getMaxWordWidth(itemText, powerbi.TextMeasurementService.measureSvgTextWidth, properties));
                }
                this.maxItemWidth = Math.min(maxItemWidth, this.getScaledTextWidth(textSize));
            };
            HorizontalSlicerRenderer.prototype.calculateAndSetTotalItemWidth = function () {
                var data = this.data;
                var itemPadding = DefaultStyleProperties.labelText.paddingLeft + DefaultStyleProperties.labelText.paddingRight + DefaultStyleProperties.labelText.marginRight;
                var borderWidth = this.domHelper.getRowsOutlineWidth(data.slicerSettings.slicerText.outline, data.slicerSettings.general.outlineWeight);
                this.totalItemWidth = this.maxItemWidth + itemPadding + borderWidth;
            };
            HorizontalSlicerRenderer.prototype.getNumberOfItemsToDisplay = function (widthAvailable) {
                var totalItemWidth = this.totalItemWidth;
                if (totalItemWidth === 0)
                    return 0;
                var dataPointsLength = this.getDataPointsCount();
                var numberOfItems = Math.min(dataPointsLength, Math.round(widthAvailable / totalItemWidth));
                // Show atleast 1 item by default 
                return Math.max(numberOfItems, 1);
            };
            HorizontalSlicerRenderer.prototype.getDataPointsCount = function () {
                return _.size(this.data.slicerDataPoints);
            };
            return HorizontalSlicerRenderer;
        }());
        visuals.HorizontalSlicerRenderer = HorizontalSlicerRenderer;
        var Selectors;
        (function (Selectors) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            Selectors.container = createClassAndSelector('horizontalSlicerContainer');
            Selectors.ItemsContainer = createClassAndSelector('slicerItemsContainer');
            Selectors.NavigationArrow = createClassAndSelector('navigationArrow');
            Selectors.LeftNavigationArrow = createClassAndSelector('left');
            Selectors.RightNavigationArrow = createClassAndSelector('right');
            Selectors.MultiSelectEnabled = createClassAndSelector('isMultiSelectEnabled');
            Selectors.FlexDisplay = createClassAndSelector('flexDisplay');
            Selectors.CanScrollRight = createClassAndSelector('canScrollRight');
            Selectors.CanScrollLeft = createClassAndSelector('canScrollLeft');
        })(Selectors || (Selectors = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DisplayNameKeys = visuals.SlicerUtil.DisplayNameKeys;
        var DOMHelper = visuals.SlicerUtil.DOMHelper;
        var SettingsHelper = visuals.SlicerUtil.SettingsHelper;
        var Slicer = (function () {
            function Slicer(options) {
                if (options) {
                    this.behavior = options.behavior;
                }
                this.domHelper = new DOMHelper();
            }
            Slicer.DefaultStyleProperties = function () {
                return {
                    general: {
                        outlineColor: '#808080',
                        outlineWeight: 1,
                        orientation: 0 /* Vertical */,
                    },
                    header: {
                        borderBottomWidth: 1,
                        show: true,
                        outline: visuals.outline.bottomOnly,
                        fontColor: '#000000',
                        textSize: 10,
                    },
                    slicerText: {
                        color: '#666666',
                        outline: visuals.outline.none,
                        textSize: 10,
                    },
                    selection: {
                        selectAllCheckboxEnabled: false,
                        singleSelect: true,
                    },
                };
            };
            Slicer.prototype.init = function (options) {
                this.initOptions = options;
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                var settings = this.settings = Slicer.DefaultStyleProperties();
                this.slicerOrientation = settings.general.orientation;
                this.waitingForData = false;
                this.initializeSlicerRenderer(this.slicerOrientation);
            };
            Slicer.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                debug.assertValue(dataViews, 'dataViews');
                if (_.isEmpty(dataViews)) {
                    return;
                }
                var existingDataView = this.dataView;
                this.dataView = dataViews[0];
                // Reset scrollbar by default, unless it's an Append operation or Selecting an item
                var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append
                    && !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                this.render(resetScrollbarPosition, true);
            };
            Slicer.prototype.onResizing = function (finalViewport) {
                this.currentViewport = finalViewport;
                this.render(false /* resetScrollbarPosition */);
            };
            Slicer.prototype.enumerateObjectInstances = function (options) {
                return ObjectEnumerator.enumerateObjectInstances(options, this.slicerData, this.settings, this.dataView);
            };
            // public for testability
            Slicer.prototype.loadMoreData = function () {
                var dataView = this.dataView;
                if (!dataView)
                    return;
                var dataViewMetadata = dataView.metadata;
                // Making sure that hostservices.loadMoreData is not invoked when waiting for server to load the next segment of data
                if (!this.waitingForData && dataViewMetadata && dataViewMetadata.segment) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Slicer.prototype.onClearSelection = function () {
                if (this.interactivityService) {
                    this.interactivityService.clearSelection();
                    // calls render so that default behavior can be applied after clear selection.
                    this.render(false /* resetScrollbarPosition */);
                }
            };
            Slicer.prototype.render = function (resetScrollbarPosition, stopWaitingForData) {
                var localizedSelectAllText = this.hostServices.getLocalizedString(DisplayNameKeys.SelectAll);
                this.slicerData = visuals.DataConversion.convert(this.dataView, localizedSelectAllText, this.interactivityService, this.hostServices);
                if (this.slicerData) {
                    this.slicerData.slicerSettings.general.outlineWeight = Math.max(this.slicerData.slicerSettings.general.outlineWeight, 0);
                    this.settings = this.slicerData.slicerSettings;
                    // TODO: Do we need to check SettingsHelper.areSettingsDefined(), etc. here? Can we just do value validation and coercion in the same place that we create the slicerSettings?
                    var slicerOrientation_1 = SettingsHelper.areSettingsDefined(this.slicerData) && this.slicerData.slicerSettings.general && this.slicerData.slicerSettings.general.orientation ?
                        this.slicerData.slicerSettings.general.orientation : Slicer.DefaultStyleProperties().general.orientation;
                    var orientationHasChanged = this.orientationHasChanged(slicerOrientation_1);
                    if (orientationHasChanged) {
                        this.slicerOrientation = slicerOrientation_1;
                        // Clear the previous slicer type when rendering the new slicer type
                        this.element.empty();
                        this.initializeSlicerRenderer(slicerOrientation_1);
                    }
                }
                this.slicerRenderer.render({ dataView: this.dataView, data: this.slicerData, viewport: this.currentViewport, resetScrollbarPosition: resetScrollbarPosition });
                if (stopWaitingForData)
                    this.waitingForData = false;
            };
            Slicer.prototype.orientationHasChanged = function (slicerOrientation) {
                return this.slicerOrientation !== slicerOrientation;
            };
            Slicer.prototype.initializeSlicerRenderer = function (slicerOrientation) {
                switch (slicerOrientation) {
                    case 1 /* Horizontal */:
                        this.initializeHorizontalSlicer();
                        break;
                    case 0 /* Vertical */:
                        this.initializeVerticalSlicer();
                        break;
                }
            };
            Slicer.prototype.initializeVerticalSlicer = function () {
                var verticalSlicerRenderer = this.slicerRenderer = new visuals.VerticalSlicerRenderer({ domHelper: this.domHelper, behavior: this.behavior });
                var options = this.createInitOptions();
                this.interactivityService = verticalSlicerRenderer.init(options);
            };
            Slicer.prototype.initializeHorizontalSlicer = function () {
                var horizontalSlicerRenderer = this.slicerRenderer = new visuals.HorizontalSlicerRenderer({ domHelper: this.domHelper, behavior: this.behavior });
                var options = this.createInitOptions();
                this.interactivityService = horizontalSlicerRenderer.init(options);
            };
            Slicer.prototype.createInitOptions = function () {
                var _this = this;
                return {
                    visualInitOptions: this.initOptions,
                    loadMoreData: function () { return _this.loadMoreData(); }
                };
            };
            return Slicer;
        }());
        visuals.Slicer = Slicer;
        /** Helper class for calculating the current slicer settings. */
        var ObjectEnumerator;
        (function (ObjectEnumerator) {
            function enumerateObjectInstances(options, data, settings, dataView) {
                if (!data)
                    return;
                switch (options.objectName) {
                    case 'items':
                        return enumerateItems(data, settings);
                    case 'header':
                        return enumerateHeader(data, settings);
                    case 'general':
                        return enumerateGeneral(data, settings);
                    case 'selection':
                        if (shouldShowSelectionOption(dataView))
                            return enumerateSelection(data, settings);
                }
            }
            ObjectEnumerator.enumerateObjectInstances = enumerateObjectInstances;
            function shouldShowSelectionOption(dataView) {
                return !(dataView &&
                    dataView.metadata &&
                    dataView.metadata.columns &&
                    _.some(dataView.metadata.columns, function (column) { return column.discourageAggregationAcrossGroups; }));
            }
            function enumerateSelection(data, settings) {
                var slicerSettings = settings;
                var areSelectionSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.selection;
                var selectAllCheckboxEnabled = areSelectionSettingsDefined && data.slicerSettings.selection.selectAllCheckboxEnabled ?
                    data.slicerSettings.selection.selectAllCheckboxEnabled : slicerSettings.selection.selectAllCheckboxEnabled;
                var singleSelect = data && data.slicerSettings && data.slicerSettings.selection && data.slicerSettings.selection.singleSelect !== undefined ?
                    data.slicerSettings.selection.singleSelect : slicerSettings.selection.singleSelect;
                return [{
                        selector: null,
                        objectName: 'selection',
                        properties: {
                            selectAllCheckboxEnabled: selectAllCheckboxEnabled,
                            singleSelect: singleSelect,
                        }
                    }];
            }
            function enumerateHeader(data, settings) {
                var slicerSettings = settings;
                var areHeaderSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.header;
                var fontColor = areHeaderSettingsDefined && data.slicerSettings.header.fontColor ?
                    data.slicerSettings.header.fontColor : slicerSettings.header.fontColor;
                var background = areHeaderSettingsDefined && data.slicerSettings.header.background ?
                    data.slicerSettings.header.background : slicerSettings.header.background;
                return [{
                        selector: null,
                        objectName: 'header',
                        properties: {
                            show: slicerSettings.header.show,
                            fontColor: fontColor,
                            background: background,
                            outline: slicerSettings.header.outline,
                            textSize: slicerSettings.header.textSize,
                        }
                    }];
            }
            function enumerateItems(data, settings) {
                var slicerSettings = settings;
                var areTextSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.slicerText;
                var fontColor = areTextSettingsDefined && data.slicerSettings.slicerText.color ?
                    data.slicerSettings.slicerText.color : slicerSettings.slicerText.color;
                var background = areTextSettingsDefined && data.slicerSettings.slicerText.background ?
                    data.slicerSettings.slicerText.background : slicerSettings.slicerText.background;
                return [{
                        selector: null,
                        objectName: 'items',
                        properties: {
                            fontColor: fontColor,
                            background: background,
                            outline: slicerSettings.slicerText.outline,
                            textSize: slicerSettings.slicerText.textSize,
                        }
                    }];
            }
            function enumerateGeneral(data, settings) {
                var slicerSettings = settings;
                var areGeneralSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.general != null;
                var outlineColor = areGeneralSettingsDefined && data.slicerSettings.general.outlineColor ?
                    data.slicerSettings.general.outlineColor : slicerSettings.general.outlineColor;
                var outlineWeight = areGeneralSettingsDefined && data.slicerSettings.general.outlineWeight ?
                    data.slicerSettings.general.outlineWeight : slicerSettings.general.outlineWeight;
                var orientation = areGeneralSettingsDefined && data.slicerSettings.general.orientation != null ?
                    data.slicerSettings.general.orientation : slicerSettings.general.orientation;
                return [{
                        selector: null,
                        objectName: 'general',
                        properties: {
                            outlineColor: outlineColor,
                            outlineWeight: outlineWeight,
                            orientation: orientation,
                        }
                    }];
            }
        })(ObjectEnumerator || (ObjectEnumerator = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TablixUtils = visuals.controls.internal.TablixUtils;
        var TablixObjects = visuals.controls.internal.TablixObjects;
        var TableHierarchyNavigator = (function () {
            function TableHierarchyNavigator(tableDataView, formatter) {
                debug.assertValue(tableDataView, 'tableDataView');
                debug.assertValue(formatter, 'formatter');
                this.tableDataView = tableDataView;
                this.formatter = formatter;
            }
            /**
            * Returns the depth of the Columnm hierarchy.
            */
            TableHierarchyNavigator.prototype.getColumnHierarchyDepth = function () {
                return 1;
            };
            /**
            * Returns the depth of the Row hierarchy.
            */
            TableHierarchyNavigator.prototype.getRowHierarchyDepth = function () {
                return 1;
            };
            /**
             * Returns the leaf count of a hierarchy.
             */
            TableHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
                return hierarchy.length;
            };
            /**
             * Returns the leaf member of a hierarchy at a specified index.
             */
            TableHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
                return hierarchy[index];
            };
            /**
             * Returns the specified hierarchy member parent.
             */
            TableHierarchyNavigator.prototype.getParent = function (item) {
                return null;
            };
            /**
             * Returns the index of the hierarchy member relative to its parent.
             */
            TableHierarchyNavigator.prototype.getIndex = function (item) {
                if (!item)
                    return -1;
                if (this.isRow(item))
                    return item.index;
                return this.getColumnIndex(item);
            };
            TableHierarchyNavigator.prototype.isRow = function (item) {
                if (!item)
                    return false;
                var row = item;
                return row.index !== undefined && row.values !== undefined;
            };
            TableHierarchyNavigator.prototype.getColumnIndex = function (item) {
                return TableHierarchyNavigator.getIndex(this.tableDataView.columns, item);
            };
            /**
             * Checks whether a hierarchy member is a leaf.
             */
            TableHierarchyNavigator.prototype.isLeaf = function (item) {
                return true;
            };
            TableHierarchyNavigator.prototype.isRowHierarchyLeaf = function (cornerItem) {
                return false;
            };
            TableHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (cornerItem) {
                return true;
            };
            TableHierarchyNavigator.prototype.isFirstItem = function (item, items) {
                return item.index === 0;
            };
            TableHierarchyNavigator.prototype.areAllParentsFirst = function (item, items) {
                return this.isFirstItem(item, items);
            };
            /**
             * Checks whether a hierarchy member is the last item within its parent.
             */
            TableHierarchyNavigator.prototype.isLastItem = function (item, items) {
                debug.assertValue(item, 'item');
                return items[items.length - 1] === item;
            };
            TableHierarchyNavigator.prototype.areAllParentsLast = function (item, items) {
                return this.isLastItem(item, items);
            };
            /**
             * Gets the children members of a hierarchy member.
             */
            TableHierarchyNavigator.prototype.getChildren = function (item) {
                return null;
            };
            TableHierarchyNavigator.prototype.getChildrenLevelDifference = function (item) {
                return Infinity;
            };
            /**
             * Gets the members count in a specified collection.
             */
            TableHierarchyNavigator.prototype.getCount = function (items) {
                return items.length;
            };
            /**
             * Gets the member at the specified index.
             */
            TableHierarchyNavigator.prototype.getAt = function (items, index) {
                return items[index];
            };
            /**
             * Gets the hierarchy member level.
             */
            TableHierarchyNavigator.prototype.getLevel = function (item) {
                return 0;
            };
            /**
             * Returns the intersection between a row and a column item.
             */
            TableHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
                var value;
                var isTotal = false;
                var position = new TablixUtils.CellPosition();
                var columnIndex = TableHierarchyNavigator.getIndex(this.tableDataView.columns, columnItem);
                ;
                position.column.index = columnIndex;
                position.column.isFirst = columnIndex === 0 ? true : false;
                position.column.isLast = columnIndex === this.tableDataView.columns.length - 1;
                var totalRow = rowItem;
                if (totalRow.totalCells != null) {
                    isTotal = true;
                    value = totalRow.totalCells[columnIndex];
                }
                else {
                    var row = rowItem;
                    var rowIndex = row.index;
                    position.row.index = rowIndex;
                    position.row.isFirst = rowIndex === 0;
                    position.row.isLast = rowIndex === this.tableDataView.rows.length - 1;
                    value = row.values[columnIndex];
                }
                var cellItem = new TablixUtils.TablixVisualCell(value, isTotal, columnItem, this.formatter);
                cellItem.position = position;
                // VSTS 7167767: Remove temporary code for product demo.
                var tableRow = rowItem;
                if (tableRow && tableRow.values) {
                    var rowObjects = tableRow.values.objects;
                    if (rowObjects) {
                        var cellObject = rowObjects[columnIndex];
                        if (cellObject) {
                            cellItem.backColorCustomFormatting = TablixObjects.PropValuesBackColorPrimary.getValue(cellObject);
                        }
                    }
                }
                return cellItem;
            };
            /**
             * Returns the corner cell between a row and a column level.
             */
            TableHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
                return null;
            };
            TableHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
                if (item1 === item2)
                    return true;
                // Typechecking does not work with interfaces nor at runtime. We need to explicitly check for 
                // properties of DataViewMetadataColumn to determine if we can use the column equivalency check.
                // We expect this method to handle either VisualTableRows or DataViewMetadataColumns so checking
                // for displayName should be sufficient.
                if (item1.displayName && item2.displayName) {
                    var column1 = item1;
                    var column2 = item2;
                    return powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(column1, column2);
                }
                if (this.isRow(item1) && this.isRow(item2))
                    return item1.index === item2.index;
                return false;
            };
            TableHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
                //return (item1.dataPoint === item2.dataPoint);
                return (item1.isMatch(item2));
            };
            TableHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
                // Should not be called as we don't return any corner items for table
                return true;
            };
            TableHierarchyNavigator.prototype.update = function (table) {
                this.tableDataView = table;
            };
            TableHierarchyNavigator.getIndex = function (items, item) {
                for (var index = 0, len = items.length; index < len; index++) {
                    // For cases when the item was re-created during the DataTransformation phase,
                    // we check for the item's index to verify equality.
                    var arrayItem = items[index];
                    if (arrayItem.index != null && item.index != null && arrayItem.index === item.index) {
                        return index;
                    }
                    else {
                        if (item === items[index])
                            return index;
                    }
                }
                return -1;
            };
            return TableHierarchyNavigator;
        }());
        visuals.TableHierarchyNavigator = TableHierarchyNavigator;
        /**
         * Note: Public for testability.
         */
        var TableBinder = (function () {
            function TableBinder(options) {
                this.options = options;
            }
            TableBinder.prototype.onDataViewChanged = function (dataView) {
                this.tableDataView = dataView;
                this.formattingProperties = dataView.formattingProperties;
            };
            TableBinder.prototype.onStartRenderingSession = function () {
            };
            TableBinder.prototype.onEndRenderingSession = function () {
            };
            /**
             * Row Header.
             */
            TableBinder.prototype.bindRowHeader = function (item, cell) {
                this.ensureHeight(item, cell);
                // To clear the CSS classes that adds paddings
                TablixUtils.clearCellStyle(cell);
                if (this.options.onBindRowHeader)
                    this.options.onBindRowHeader(item);
            };
            TableBinder.prototype.unbindRowHeader = function (item, cell) {
            };
            /**
             * Column Header.
             */
            TableBinder.prototype.bindColumnHeader = function (item, cell) {
                var _this = this;
                cell.extension.disableDragResize();
                TablixUtils.resetCellCssClass(cell);
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                if (this.sortIconsEnabled())
                    TablixUtils.createColumnHeaderWithSortIcon(item, cell);
                else
                    TablixUtils.setCellTextAndTooltip(cell, item.displayName);
                if (this.options.onColumnHeaderClick) {
                    var handler = function (e) {
                        if (TablixUtils.isValidSortClick(e)) {
                            var sortDirection = TablixUtils.reverseSort(item.sort);
                            _this.options.onColumnHeaderClick(item.queryName ? item.queryName : item.displayName, sortDirection);
                        }
                    };
                    cell.extension.registerClickHandler(handler);
                }
                if (this.formattingProperties.isFormattingEnabled) {
                    this.getColumnHeaderStyle(cell).applyStyle(cell);
                }
            };
            TableBinder.prototype.getColumnHeaderStyle = function (cell) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.columnHeaders;
                var propsTotal = this.formattingProperties.total;
                var style = new TablixUtils.CellStyle();
                style.borders.top = new TablixUtils.EdgeSettings();
                style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.bottom = new TablixUtils.EdgeSettings();
                style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but Footer has, we need to apply padding
                    if (!visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsTotal.outline))
                        style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have right border, but Footer has, we need to apply padding
                    if (!visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsTotal.outline))
                        style.paddings.right = propsGrid.outlineWeight + TablixUtils.CellPaddingRight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                return style;
            };
            TableBinder.prototype.unbindColumnHeader = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
                if (this.sortIconsEnabled())
                    TablixUtils.removeSortIcons(cell);
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            /**
             * Body Cell.
             */
            TableBinder.prototype.bindBodyCell = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                if (item.isValidUrl) {
                    TablixUtils.appendATagToBodyCell(item.textContent, cell, this.formattingProperties.isFormattingEnabled && this.formattingProperties.values.urlIcon);
                }
                else if (item.isValidImage)
                    TablixUtils.appendImgTagToBodyCell(item.textContent, cell);
                else if (!_.isEmpty(item.domContent))
                    $(cell.extension.contentHost).append(item.domContent);
                else if (item.textContent) {
                    TablixUtils.setCellTextAndTooltip(cell, item.textContent);
                }
                else {
                    TablixUtils.setCellTextAndTooltip(cell, " ");
                }
                if (item.isTotal) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableFooter);
                }
                else if (item.position.row.isLast) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCellBottom);
                }
                else {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCell);
                }
                if (item.isNumeric)
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
                if (this.formattingProperties.isFormattingEnabled) {
                    if (item.isTotal) {
                        this.getFooterStyle(cell).applyStyle(cell);
                    }
                    else {
                        this.getBodyStyle(item, cell).applyStyle(cell);
                    }
                }
            };
            TableBinder.prototype.getBodyStyle = function (item, cell) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.values;
                var propsTotal = this.formattingProperties.total;
                var style = new TablixUtils.CellStyle();
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but Footer has, we need to apply padding
                    if (!visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsTotal.outline))
                        style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have right border, but Footer has, we need to apply padding
                    if (!visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsTotal.outline))
                        style.paddings.right = propsGrid.outlineWeight + TablixUtils.CellPaddingRight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = cell.position.row.index % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary;
                // TODO: VSTS 7167767: Remove temporary code for product demo.
                if (this.formattingProperties.isConditionalFormattingEnabled && this.formattingProperties.values.conditionalFormatting && item.backColorCustomFormatting)
                    style.backColor = item.backColorCustomFormatting;
                else
                    style.backColor = cell.position.row.index % 2 === 0 ? props.backColorPrimary : props.backColorSecondary;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                return style;
            };
            TableBinder.prototype.getFooterStyle = function (cell) {
                var props = this.formattingProperties.total;
                var propsGrid = this.formattingProperties.grid;
                var propsValues = this.formattingProperties.values;
                var propsColumns = this.formattingProperties.columnHeaders;
                var style = new TablixUtils.CellStyle();
                style.borders.top = new TablixUtils.EdgeSettings();
                style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.bottom = new TablixUtils.EdgeSettings();
                style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but values or column headers have, we need to apply padding
                    if (!visuals.outline.showLeft(props.outline) && (visuals.outline.showLeft(propsValues.outline) || visuals.outline.showLeft(propsColumns.outline)))
                        style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but values or column headers have, we need to apply padding
                    if (!visuals.outline.showRight(props.outline) && (visuals.outline.showRight(propsValues.outline) || visuals.outline.showRight(propsColumns.outline)))
                        style.paddings.right = propsGrid.outlineWeight + TablixUtils.CellPaddingRight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                return style;
            };
            TableBinder.prototype.unbindBodyCell = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
            };
            /**
             * Corner Cell.
             */
            TableBinder.prototype.bindCornerCell = function (item, cell) {
            };
            TableBinder.prototype.unbindCornerCell = function (item, cell) {
            };
            TableBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
                // Not needed for Table
            };
            /**
             * Measurement Helper.
             */
            TableBinder.prototype.getHeaderLabel = function (item) {
                return item.displayName;
            };
            TableBinder.prototype.getCellContent = function (item) {
                return item;
            };
            TableBinder.prototype.hasRowGroups = function () {
                return false;
            };
            TableBinder.prototype.ensureHeight = function (item, cell) {
                if (!item.values)
                    return;
                var count = item.values.length;
                if (count === 0)
                    return;
                var allValuesEmpty = true;
                for (var i = 0; i < count; i++) {
                    if (item.values[i]) {
                        allValuesEmpty = false;
                        break;
                    }
                }
                // In order to maintain the height of the row when the values are null or empty
                // we set the innerHTML to be a nonBreakingSpace. The nonBreakingSpace does not
                // show up in the visual because for actual cell content we use the textContent property instead.
                if (allValuesEmpty)
                    cell.extension.contentHost.innerHTML = TablixUtils.StringNonBreakingSpace;
            };
            TableBinder.prototype.sortIconsEnabled = function () {
                return this.options.layoutKind === 0 /* Canvas */;
            };
            return TableBinder;
        }());
        visuals.TableBinder = TableBinder;
        var Table = (function () {
            function Table(options) {
                if (options) {
                    this.isFormattingPropertiesEnabled = options.isFormattingPropertiesEnabled;
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    this.isConditionalFormattingEnabled = options.isConditionalFormattingEnabled;
                    this.isTouchEnabled = options.isTouchEnabled;
                }
            }
            Table.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.table || !dataViewMapping.metadata)
                    return;
                var dataViewTableRows = dataViewMapping.table.rows;
                var objects = dataViewMapping.metadata.objects;
                dataViewTableRows.for.in.subtotalType = TablixObjects.shouldShowTableTotals(objects) ? 1 /* Before */ : 0 /* None */;
            };
            Table.getSortableRoles = function () {
                return ['Values'];
            };
            Table.prototype.init = function (options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatValueColumn;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.getLocalizedString = options.host.getLocalizedString;
                this.hostServices = options.host;
                this.persistingObjects = false;
                this.waitingForData = false;
                this.lastAllowHeaderResize = true;
                this.waitingForSort = false;
            };
            /**
             * Note: Public for testability.
             */
            // TODO: VSTS 7167767: Remove temporary code for product demo.
            Table.converter = function (dataView, isFormattingEnabled, isConditionalFormattingEnabled) {
                var table = dataView.table;
                debug.assertValue(table, 'table');
                debug.assertValue(table.rows, 'table.rows');
                var visualTable = powerbi.Prototype.inherit(table);
                visualTable.visualRows = [];
                for (var i = 0; i < table.rows.length; i++) {
                    var visualRow = {
                        index: i,
                        values: table.rows[i]
                    };
                    visualTable.visualRows.push(visualRow);
                }
                // TODO: VSTS 7167767: Remove temporary code for product demo.
                visualTable.formattingProperties = TablixObjects.getTableObjects(dataView, isFormattingEnabled, isConditionalFormattingEnabled);
                return visualTable;
            };
            Table.prototype.onResizing = function (finalViewport) {
                this.updateViewport(finalViewport);
            };
            // Public for testability
            Table.prototype.getColumnWidthManager = function () {
                return this.columnWidthManager;
            };
            Table.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var previousDataView = this.dataView;
                    this.dataView = dataViews[0];
                    /* To avoid OnDataChanged being called every time we persist Objects. If:
                    * AutoSizeColumns options was flipped
                    * A Column was resized manually
                    * A Column was auto-sized
                    */
                    if (this.persistingObjects) {
                        this.persistingObjects = false;
                        return;
                    }
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    var visualTable = Table.converter(this.dataView, this.isFormattingPropertiesEnabled, this.isConditionalFormattingEnabled);
                    var textSize = visualTable.formattingProperties.general.textSize;
                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
                        this.hierarchyNavigator.update(visualTable);
                        this.tablixControl.updateModels(/*resetScrollOffsets*/ false, visualTable.visualRows, visualTable.columns);
                        this.refreshControl(/*clear*/ false);
                    }
                    else {
                        this.createOrUpdateHierarchyNavigator(visualTable);
                        this.createColumnWidthManager();
                        this.createTablixControl(textSize);
                        var binder = this.tablixControl.getBinder();
                        binder.onDataViewChanged(visualTable);
                        this.updateInternal(textSize, previousDataView, visualTable);
                    }
                }
                this.waitingForData = false;
                this.waitingForSort = false;
            };
            Table.prototype.createColumnWidthManager = function () {
                var _this = this;
                if (!this.columnWidthManager) {
                    this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, false /* isMatrix */, function (objectInstances) { return _this.persistColumnWidths(objectInstances); });
                }
                else {
                    this.columnWidthManager.updateDataView(this.dataView);
                }
            };
            Table.prototype.persistColumnWidths = function (objectInstances) {
                this.persistingObjects = true;
                this.hostServices.persistProperties(objectInstances);
            };
            Table.prototype.updateViewport = function (newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(false);
                }
            };
            Table.prototype.refreshControl = function (clear) {
                if (visuals.visibilityHelper.partiallyVisible(this.element) || this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.refresh(clear);
                }
            };
            Table.prototype.getLayoutKind = function () {
                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
            };
            Table.prototype.createOrUpdateHierarchyNavigator = function (visualTable) {
                if (!this.tablixControl) {
                    var dataNavigator = new TableHierarchyNavigator(visualTable, this.formatter);
                    this.hierarchyNavigator = dataNavigator;
                }
                else {
                    this.hierarchyNavigator.update(visualTable);
                }
            };
            Table.prototype.createTablixControl = function (textSize) {
                if (!this.tablixControl) {
                    // Create the control
                    this.tablixControl = this.createControl(this.hierarchyNavigator, textSize);
                }
            };
            Table.prototype.createControl = function (dataNavigator, textSize) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var tableBinderOptions = {
                    onBindRowHeader: function (item) { return _this.onBindRowHeader(item); },
                    onColumnHeaderClick: function (queryName, sortDirection) { return _this.onColumnHeaderClick(queryName, sortDirection); },
                    layoutKind: layoutKind,
                    formattingEnabled: this.isFormattingPropertiesEnabled,
                };
                var tableBinder = new TableBinder(tableBinderOptions);
                var layoutManager = layoutKind === 1 /* DashboardTile */
                    ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(tableBinder)
                    : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(tableBinder, this.columnWidthManager);
                // Create Host element
                var tablixContainer = document.createElement('div');
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: this.isTouchEnabled,
                    layoutKind: layoutKind,
                    fontSize: TablixObjects.getTextSizeInPx(textSize),
                };
                return new visuals.controls.TablixControl(dataNavigator, layoutManager, tableBinder, tablixContainer, tablixOptions);
            };
            Table.prototype.updateInternal = function (textSize, previousDataView, visualTable) {
                var _this = this;
                if (this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView));
                }
                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize);
                this.verifyHeaderResize();
                // Update models before the viewport to make sure column widths are computed correctly
                this.tablixControl.updateModels(/*resetScrollOffsets*/ true, visualTable.visualRows, visualTable.columns);
                var totals = this.createTotalsRow(this.dataView);
                this.tablixControl.rowDimension.setFooter(totals);
                this.tablixControl.viewport = this.currentViewport;
                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                // Render
                // We need the layout for the DIV to be done so that the control can measure items correctly.
                setTimeout(function () {
                    // Render
                    _this.refreshControl(shouldClearControl);
                    //Persist actual widths if autoSize flipped to true
                    if (_this.columnWidthManager.shouldPersistAllColumnWidths()) {
                        _this.columnWidthManager.persistAllColumnWidths(_this.tablixControl.layoutManager.columnWidthsToPersist);
                    }
                }, 0);
            };
            Table.prototype.shouldClearControl = function (previousDataView, newDataView) {
                if (!this.waitingForSort || !previousDataView || !newDataView)
                    return true;
                return !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata);
            };
            Table.prototype.createTotalsRow = function (dataView) {
                if (!TablixObjects.shouldShowTableTotals(dataView.metadata.objects))
                    return null;
                var totals = dataView.table.totals;
                if (!totals || totals.length === 0)
                    return null;
                var totalRow = [];
                var columns = dataView.table.columns;
                // Add totals for measure columns, blank for non-measure columns unless it's the first column
                for (var i = 0, len = columns.length; i < len; ++i) {
                    var column = columns[i];
                    var totalValue = totals[column.index];
                    if (totalValue != null) {
                        totalRow.push(totalValue);
                    }
                    else {
                        // If the first column is a non-measure column, we put 'Total' as the text similar to PV.
                        // Note that if the first column is a measure column we don't render any Total text at
                        // all, once again similar to PV.
                        totalRow.push((i === 0) ? this.getLocalizedString('TableTotalLabel') : '');
                    }
                }
                return { totalCells: totalRow };
            };
            Table.prototype.onBindRowHeader = function (item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Table.prototype.onColumnHeaderClick = function (queryName, sortDirection) {
                this.waitingForSort = true;
                this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
            };
            /**
             * Note: Public for testability.
             */
            Table.prototype.needsMoreData = function (item) {
                if (this.waitingForData || !this.dataView.metadata || !this.dataView.metadata.segment)
                    return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Table.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getIndex(item) >= loadMoreThreshold;
            };
            Table.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
                // we are resilient here when we do not have data view.
                if (this.dataView) {
                    TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, this.isFormattingPropertiesEnabled, this.isConditionalFormattingEnabled, visuals.controls.TablixType.Table);
                }
                return enumeration.complete();
            };
            Table.prototype.shouldAllowHeaderResize = function () {
                return this.hostServices.getViewMode() === 1 /* Edit */;
            };
            Table.prototype.onViewModeChanged = function (viewMode) {
                /* Refreshes the column headers to enable/disable Column resizing */
                this.updateViewport(this.currentViewport);
            };
            Table.prototype.verifyHeaderResize = function () {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Table.preferredLoadMoreThreshold = 0.8;
            return Table;
        }());
        visuals.Table = Table;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TablixUtils = visuals.controls.internal.TablixUtils;
        var TablixObjects = visuals.controls.internal.TablixObjects;
        var UrlUtils = jsCommon.UrlUtils;
        var MatrixVisualBodyItem = (function (_super) {
            __extends(MatrixVisualBodyItem, _super);
            function MatrixVisualBodyItem() {
                _super.apply(this, arguments);
            }
            Object.defineProperty(MatrixVisualBodyItem.prototype, "isMeasure", {
                get: function () {
                    return true;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidUrl", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidImage", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            ;
            return MatrixVisualBodyItem;
        }(TablixUtils.TablixVisualCell));
        visuals.MatrixVisualBodyItem = MatrixVisualBodyItem;
        /**
         * Factory method used by unit tests.
         */
        function createMatrixHierarchyNavigator(matrix, formatter) {
            return new MatrixHierarchyNavigator(matrix, formatter);
        }
        visuals.createMatrixHierarchyNavigator = createMatrixHierarchyNavigator;
        var MatrixHierarchyNavigator = (function () {
            function MatrixHierarchyNavigator(matrix, formatter) {
                this.matrix = matrix;
                this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.rows);
                this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.columns);
                this.formatter = formatter;
                this.update();
            }
            /**
             * Returns the data view matrix.
             */
            MatrixHierarchyNavigator.prototype.getDataViewMatrix = function () {
                return this.matrix;
            };
            /**
            * Returns the depth of the column hierarchy.
             */
            MatrixHierarchyNavigator.prototype.getColumnHierarchyDepth = function () {
                return Math.max(this.columnHierarchy.levels.length, 1);
            };
            /**
            * Returns the depth of the Row hierarchy.
            */
            MatrixHierarchyNavigator.prototype.getRowHierarchyDepth = function () {
                return Math.max(this.rowHierarchy.levels.length, 1);
            };
            /**
             * Returns the leaf count of a hierarchy.
             */
            MatrixHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy)
                    return matrixHierarchy.leafNodes.length;
                return 0;
            };
            /**
             * Returns the leaf member of a hierarchy at a specified index.
             */
            MatrixHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy)
                    return matrixHierarchy.leafNodes[index];
                return null;
            };
            /**
             * Returns the leaf index of the visual node.
             */
            MatrixHierarchyNavigator.prototype.getLeafIndex = function (item) {
                debug.assertValue(item, 'item');
                return item.leafIndex;
            };
            /**
             * Returns the specified hierarchy member parent.
             */
            MatrixHierarchyNavigator.prototype.getParent = function (item) {
                debug.assertValue(item, 'item');
                // Return null for outermost nodes
                if (item.level === 0)
                    return null;
                return item.parent;
            };
            /**
             * Returns the index of the hierarchy member relative to its parent.
             */
            MatrixHierarchyNavigator.prototype.getIndex = function (item) {
                debug.assertValue(item, 'item');
                return item.index;
            };
            /**
             * Checks whether a hierarchy member is a leaf.
             */
            MatrixHierarchyNavigator.prototype.isLeaf = function (item) {
                debug.assertValue(item, 'item');
                return !item.children || item.children.length === 0;
            };
            MatrixHierarchyNavigator.prototype.isRowHierarchyLeaf = function (item) {
                return true;
            };
            MatrixHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (item) {
                return false;
            };
            MatrixHierarchyNavigator.prototype.isFirstItem = function (item, items) {
                return item === _.first(items);
            };
            MatrixHierarchyNavigator.prototype.areAllParentsFirst = function (item, items) {
                if (!item)
                    return false;
                var parent = this.getParent(item);
                if (!parent) {
                    return this.isFirstItem(item, item.siblings);
                }
                else {
                    return this.isFirstItem(item, item.siblings) && this.areAllParentsFirst(parent, parent.siblings);
                }
            };
            /**
             * Checks whether a hierarchy member is the last item within its parent.
             */
            MatrixHierarchyNavigator.prototype.isLastItem = function (item, items) {
                debug.assertValue(item, 'item');
                return item === _.last(items);
            };
            MatrixHierarchyNavigator.prototype.areAllParentsLast = function (item, items) {
                if (!item)
                    return false;
                var parent = this.getParent(item);
                if (!parent) {
                    return this.isLastItem(item, item.siblings);
                }
                else {
                    return this.isLastItem(item, item.siblings) && this.areAllParentsLast(parent, parent.siblings);
                }
            };
            /**
             * Gets the children members of a hierarchy member.
             */
            MatrixHierarchyNavigator.prototype.getChildren = function (item) {
                debug.assertValue(item, 'item');
                return item.children;
            };
            /**
             * Gets the difference between current level and highest child's level. Can be > 1 if there are multiple values
             * @param {MatrixVisualNode} item
             * @returns
             */
            MatrixHierarchyNavigator.prototype.getChildrenLevelDifference = function (item) {
                var diff = Infinity;
                var children = this.getChildren(item);
                for (var i = 0, ilen = children.length; i < ilen; i++) {
                    diff = Math.min(diff, children[i].level - item.level);
                }
                return diff;
            };
            /**
             * Gets the members count in a specified collection.
             */
            MatrixHierarchyNavigator.prototype.getCount = function (items) {
                debug.assertValue(items, 'items');
                return items.length;
            };
            /**
             * Gets the member at the specified index.
             */
            MatrixHierarchyNavigator.prototype.getAt = function (items, index) {
                debug.assertValue(items, 'items');
                return items[index];
            };
            /**
             * Gets the hierarchy member level.
             */
            MatrixHierarchyNavigator.prototype.getLevel = function (item) {
                debug.assertValue(item, 'item');
                return item.level;
            };
            /**
             * Returns the intersection between a row and a column item.
             */
            MatrixHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
                debug.assertValue(rowItem, 'rowItem');
                debug.assertValue(columnItem, 'columnItem');
                var isSubtotalItem = rowItem.isSubtotal === true || columnItem.isSubtotal === true;
                var node;
                var valueSource;
                var rowIndex = rowItem.leafIndex;
                var colIndex = columnItem.leafIndex;
                var bodyCell;
                if (!rowItem.values) {
                    node = undefined;
                }
                else {
                    node = (rowItem.values[columnItem.leafIndex]);
                }
                if (node) {
                    valueSource = this.matrix.valueSources[node.valueSourceIndex || 0];
                    bodyCell = new MatrixVisualBodyItem(node.value, isSubtotalItem, valueSource, this.formatter);
                }
                else {
                    bodyCell = new MatrixVisualBodyItem(undefined, isSubtotalItem, undefined, this.formatter);
                }
                bodyCell.position.row.index = rowIndex;
                bodyCell.position.row.isFirst = rowIndex === 0;
                bodyCell.position.row.isLast = rowIndex === this.rowHierarchy.leafNodes.length - 1;
                bodyCell.position.column.index = colIndex;
                bodyCell.position.column.isFirst = colIndex === 0;
                bodyCell.position.column.isLast = colIndex === this.columnHierarchy.leafNodes.length - 1;
                return bodyCell;
            };
            /**
             * Returns the corner cell between a row and a column level.
             */
            MatrixHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
                debug.assert(rowLevel >= 0, 'rowLevel');
                debug.assert(columnLevel >= 0, 'columnLevel');
                var columnLevels = this.columnHierarchy.levels;
                var rowLevels = this.rowHierarchy.levels;
                if (columnLevel === columnLevels.length - 1 || columnLevels.length === 0) {
                    var levelSource = rowLevels[rowLevel];
                    if (levelSource)
                        return {
                            metadata: levelSource.sources[0],
                            isColumnHeaderLeaf: true,
                            isRowHeaderLeaf: rowLevel === rowLevels.length - 1,
                        };
                }
                if (rowLevel === rowLevels.length - 1) {
                    var levelSource = columnLevels[columnLevel];
                    if (levelSource)
                        return {
                            metadata: levelSource.sources[0],
                            isColumnHeaderLeaf: false,
                            isRowHeaderLeaf: true,
                        };
                }
                return {
                    metadata: null,
                    isColumnHeaderLeaf: false,
                    isRowHeaderLeaf: false,
                };
            };
            MatrixHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
                if (item1 && item2)
                    return (item1 === item2);
                else
                    return false;
            };
            MatrixHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
                return (item1.position.isMatch(item2.position));
            };
            MatrixHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
                return item1 === item2;
            };
            MatrixHierarchyNavigator.prototype.getMatrixColumnHierarchy = function () {
                return this.columnHierarchy;
            };
            MatrixHierarchyNavigator.prototype.getMatrixRowHierarchy = function () {
                return this.rowHierarchy;
            };
            /**
             * Implementation for MatrixDataAdapter interface.
             */
            MatrixHierarchyNavigator.prototype.update = function (dataViewMatrix, updateColumns) {
                if (updateColumns === void 0) { updateColumns = true; }
                if (dataViewMatrix) {
                    this.matrix = dataViewMatrix;
                    this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.rows);
                    if (updateColumns)
                        this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.columns);
                }
                this.updateHierarchy(this.rowHierarchy);
                if (updateColumns) {
                    this.updateHierarchy(this.columnHierarchy);
                    MatrixHierarchyNavigator.updateStaticColumnHeaders(this.columnHierarchy);
                }
            };
            MatrixHierarchyNavigator.wrapMatrixHierarchy = function (hierarchy) {
                var matrixHierarchy = powerbi.Prototype.inherit(hierarchy);
                matrixHierarchy.leafNodes = [];
                return matrixHierarchy;
            };
            MatrixHierarchyNavigator.prototype.updateHierarchy = function (hierarchy) {
                if (hierarchy.leafNodes.length > 0)
                    hierarchy.leafNodes.length = 0;
                if (hierarchy.root.children)
                    this.updateRecursive(hierarchy, hierarchy.root.children, null, hierarchy.leafNodes);
            };
            MatrixHierarchyNavigator.prototype.updateRecursive = function (hierarchy, nodes, parent, cache) {
                var level;
                for (var i = 0, ilen = nodes.length; i < ilen; i++) {
                    var node = nodes[i];
                    node.siblings = nodes;
                    if (parent)
                        node.parent = parent;
                    if (!level)
                        level = hierarchy.levels[node.level];
                    if (level) {
                        var source = level.sources[node.levelSourceIndex ? node.levelSourceIndex : 0];
                        var formatString = visuals.valueFormatter.getFormatString(source, TablixObjects.PropColumnFormatString.getPropertyID());
                        if (formatString)
                            node.name = this.formatter(node.value, source, TablixObjects.PropColumnFormatString.getPropertyID());
                        node.queryName = source.queryName;
                    }
                    node.index = i;
                    if (node.children && node.children.length > 0) {
                        this.updateRecursive(hierarchy, node.children, node, cache);
                    }
                    else {
                        node.leafIndex = cache.length;
                        cache.push(node);
                    }
                }
            };
            MatrixHierarchyNavigator.updateStaticColumnHeaders = function (columnHierarchy) {
                var columnLeafNodes = columnHierarchy.leafNodes;
                if (columnLeafNodes && columnLeafNodes.length > 0) {
                    var columnLeafSources = columnHierarchy.levels[columnLeafNodes[0].level].sources;
                    for (var i = 0, ilen = columnLeafNodes.length; i < ilen; i++) {
                        var columnLeafNode = columnLeafNodes[i];
                        // Static leaf may need to get label from it's definition
                        if (!columnLeafNode.identity && columnLeafNode.value === undefined) {
                            // We make distincion between null and undefined. Null can be considered as legit value, undefined means we need to fall back to metadata
                            var source = columnLeafSources[columnLeafNode.levelSourceIndex ? columnLeafNode.levelSourceIndex : 0];
                            if (source)
                                columnLeafNode.name = source.displayName;
                        }
                    }
                }
            };
            MatrixHierarchyNavigator.prototype.getMatrixHierarchy = function (rootNodes) {
                var rowHierarchyRootNodes = this.rowHierarchy.root.children;
                if (rowHierarchyRootNodes && rootNodes === rowHierarchyRootNodes)
                    return this.rowHierarchy;
                var columnHierarchyRootNodes = this.columnHierarchy.root.children;
                if (columnHierarchyRootNodes && rootNodes === columnHierarchyRootNodes)
                    return this.columnHierarchy;
                return null;
            };
            return MatrixHierarchyNavigator;
        }());
        var MatrixBinder = (function () {
            function MatrixBinder(hierarchyNavigator, options) {
                // We pass the hierarchy navigator in here because it is the object that will
                // survive data changes and gets updated with the latest data view.
                this.hierarchyNavigator = hierarchyNavigator;
                this.options = options;
                this.formattingProperties = { isFormattingEnabled: false };
                ;
            }
            MatrixBinder.prototype.onDataViewChanged = function (formattingProperties) {
                this.formattingProperties = formattingProperties;
            };
            MatrixBinder.prototype.onStartRenderingSession = function () {
            };
            MatrixBinder.prototype.onEndRenderingSession = function () {
            };
            /**
             * Row Header.
             */
            MatrixBinder.prototype.bindRowHeader = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf);
                }
                if (item.isSubtotal) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderSubTotal);
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
                }
                this.bindHeader(item, cell, this.getRowHeaderMetadata(item));
                if (this.options.onBindRowHeader)
                    this.options.onBindRowHeader(item);
                if (this.formattingProperties.isFormattingEnabled) {
                    this.getRowHeaderStyle(cell).applyStyle(cell);
                }
            };
            MatrixBinder.prototype.getRowHeaderStyle = function (cell) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.rowHeaders;
                var style = new TablixUtils.CellStyle();
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                return style;
            };
            MatrixBinder.prototype.unbindRowHeader = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
            };
            /**
             * Column Header.
             */
            MatrixBinder.prototype.bindColumnHeader = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var overwriteTotalLabel = false;
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
                    var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                    if (sortableHeaderColumnMetadata && this.options.showSortIcons) {
                        this.registerColumnHeaderClickHandler(sortableHeaderColumnMetadata, cell);
                        TablixUtils.createColumnHeaderWithSortIcon(sortableHeaderColumnMetadata, cell);
                    }
                    // Overwrite only if the there are subtotal siblings (like in the multimeasure case), which means ALL siblings are subtotals.
                    if (item.isSubtotal && item.parent && item.parent.children.length > 1 && item.parent.children[0].isSubtotal)
                        overwriteTotalLabel = true;
                }
                if (item.isSubtotal)
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
                cell.extension.disableDragResize();
                this.bindHeader(item, cell, this.getColumnHeaderMetadata(item), overwriteTotalLabel);
                if (this.formattingProperties.isFormattingEnabled) {
                    this.getColumnHeaderStyle(cell).applyStyle(cell);
                }
            };
            MatrixBinder.prototype.getColumnHeaderStyle = function (cell) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.columnHeaders;
                var style = new TablixUtils.CellStyle();
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                // Do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                return style;
            };
            MatrixBinder.prototype.unbindColumnHeader = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
                var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                if (sortableHeaderColumnMetadata) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
                if (this.options.showSortIcons)
                    TablixUtils.removeSortIcons(cell);
            };
            MatrixBinder.prototype.registerColumnHeaderClickHandler = function (columnMetadata, cell) {
                var _this = this;
                if (this.options.onColumnHeaderClick) {
                    var handler = function (e) {
                        if (TablixUtils.isValidSortClick(e)) {
                            var sortDirection = TablixUtils.reverseSort(columnMetadata.sort);
                            _this.options.onColumnHeaderClick(columnMetadata.queryName ? columnMetadata.queryName : columnMetadata.displayName, sortDirection);
                        }
                    };
                    cell.extension.registerClickHandler(handler);
                }
            };
            MatrixBinder.prototype.unregisterColumnHeaderClickHandler = function (cell) {
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            /**
             * Body Cell.
             */
            MatrixBinder.prototype.bindBodyCell = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
                if (item.isTotal)
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
                if (item.textContent) {
                    TablixUtils.setCellTextAndTooltip(cell, item.textContent);
                }
                else if (!_.isEmpty(item.domContent))
                    $(cell.extension.contentHost).append(item.domContent);
                if (this.formattingProperties.isFormattingEnabled) {
                    this.getBodyCellStyle(cell, item).applyStyle(cell);
                }
            };
            MatrixBinder.prototype.getBodyCellStyle = function (cell, item) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.values;
                var propsTotal = this.formattingProperties.subtotals;
                var style = new TablixUtils.CellStyle();
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    style.paddings.left = propsGrid.outlineWeight + TablixUtils.CellPaddingLeft;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                if (item.isTotal && propsTotal.fontColor) {
                    style.fontColor = propsTotal.fontColor;
                }
                else {
                    style.fontColor = cell.position.row.index % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary;
                }
                if (item.isTotal && propsTotal.backColor) {
                    style.backColor = propsTotal.backColor;
                }
                else {
                    style.backColor = cell.position.row.index % 2 === 0 ? props.backColorPrimary : props.backColorSecondary;
                }
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                return style;
            };
            MatrixBinder.prototype.unbindBodyCell = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
            };
            /**
             * Corner Cell.
             */
            MatrixBinder.prototype.bindCornerCell = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                if (item.isColumnHeaderLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                    var cornerHeaderMetadata = this.getSortableCornerColumnMetadata(item);
                    if (cornerHeaderMetadata)
                        this.registerColumnHeaderClickHandler(cornerHeaderMetadata, cell);
                    if (this.options.showSortIcons)
                        TablixUtils.createColumnHeaderWithSortIcon(cornerHeaderMetadata, cell);
                    else
                        TablixUtils.setCellTextAndTooltip(cell, cornerHeaderMetadata.displayName);
                }
                else {
                    var itemText = item.metadata ? item.metadata.displayName : '';
                    TablixUtils.setCellTextAndTooltip(cell, itemText);
                }
                if (item.isRowHeaderLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf);
                }
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
                if (this.formattingProperties.isFormattingEnabled) {
                    this.getCornerCellsStyle(cell).applyStyle(cell);
                }
                cell.extension.disableDragResize();
            };
            MatrixBinder.prototype.getCornerCellsStyle = function (cell) {
                var propsGrid = this.formattingProperties.grid;
                var propsCol = this.formattingProperties.columnHeaders;
                var propsRow = this.formattingProperties.rowHeaders;
                var style = new TablixUtils.CellStyle();
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                style.fontColor = propsCol.fontColor || propsRow.fontColor;
                style.backColor = propsCol.backColor || propsRow.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                return style;
            };
            MatrixBinder.prototype.unbindCornerCell = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
                if (this.options.showSortIcons)
                    TablixUtils.removeSortIcons(cell);
                if (item.isColumnHeaderLeaf) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
            };
            MatrixBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
            };
            MatrixBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
            };
            MatrixBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
            };
            MatrixBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
            };
            /**
             * Measurement Helper.
             */
            MatrixBinder.prototype.getHeaderLabel = function (item) {
                return MatrixBinder.getNodeLabel(item);
            };
            MatrixBinder.prototype.getCellContent = function (item) {
                return item.textContent || '';
            };
            MatrixBinder.prototype.hasRowGroups = function () {
                // Figure out whether we have a static row header, i.e., not row groups
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
                    return false;
                return true;
            };
            MatrixBinder.getNodeLabel = function (node) {
                // Return formatted value
                if (node.name)
                    return node.name;
                // Return unformatted value (fallback case)
                if (node.value != null)
                    return node.value.toString();
                return '';
            };
            MatrixBinder.prototype.bindHeader = function (item, cell, metadata, overwriteSubtotalLabel) {
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
                if (item.isSubtotal && !overwriteSubtotalLabel) {
                    TablixUtils.setCellTextAndTooltip(cell, this.options.totalLabel);
                    return;
                }
                var value = MatrixBinder.getNodeLabel(item);
                if (!value) {
                    // just to maintain the height of the row in case all realized cells are nulls
                    cell.extension.contentHost.innerHTML = TablixUtils.StringNonBreakingSpace;
                    return;
                }
                if (visuals.converterHelper.isWebUrlColumn(metadata) && UrlUtils.isValidUrl(value)) {
                    TablixUtils.appendATagToBodyCell(item.value, cell);
                }
                else if (visuals.converterHelper.isImageUrlColumn(metadata) && UrlUtils.isValidImageUrl(value)) {
                    TablixUtils.appendImgTagToBodyCell(item.value, cell);
                }
                else {
                    TablixUtils.setCellTextAndTooltip(cell, value);
                }
            };
            /**
             * Returns the column metadata of the column that needs to be sorted for the specified matrix corner node.
             *
             * @return Column metadata or null if the specified corner node does not represent a sortable header.
             */
            MatrixBinder.prototype.getSortableCornerColumnMetadata = function (item) {
                if (!item.isColumnHeaderLeaf)
                    return null;
                return item.metadata;
            };
            MatrixBinder.prototype.getRowHeaderMetadata = function (item) {
                if (!this.hierarchyNavigator || !item)
                    return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows)
                    return;
                return this.getHierarchyMetadata(dataView.rows, item.level);
            };
            MatrixBinder.prototype.getColumnHeaderMetadata = function (item) {
                if (!this.hierarchyNavigator || !item)
                    return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.columns)
                    return;
                return this.getHierarchyMetadata(dataView.columns, item.level);
            };
            MatrixBinder.prototype.getHierarchyMetadata = function (hierarchy, level) {
                if (!hierarchy || !hierarchy.levels || hierarchy.levels.length < level)
                    return;
                var levelInfo = hierarchy.levels[level];
                if (!levelInfo || !levelInfo.sources || levelInfo.sources.length === 0)
                    return;
                // This assumes the source will always be the first item in the array of sources.
                return levelInfo.sources[0];
            };
            /**
             * Returns the column metadata of the column that needs to be sorted for the specified header node.
             *
             * @return Column metadata or null if the specified header node does not represent a sortable header.
             */
            MatrixBinder.prototype.getSortableHeaderColumnMetadata = function (item) {
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                // If there are no row groups, sorting is not supported (as it does not make sense).
                if (!dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
                    return null;
                // Note that the measures establish a level as well, so need to subtract 1
                var columnGroupCount = dataView.columns ? dataView.columns.levels.length : 0;
                var valueIndex = -1;
                if (columnGroupCount === 0) {
                    // Matrices without column groups, support sorting on all columns (which are then measure columns).
                    valueIndex = item.levelSourceIndex;
                }
                else if (item.isSubtotal) {
                    // Matrices with column groups support sorting only on the column grand total.
                    var isMultiMeasure = dataView.valueSources && dataView.valueSources.length > 1;
                    if (isMultiMeasure) {
                        // In the multi-measure case we need to check if the parent's level is 0 in order
                        // to determine whether this is the column grand total.  The cells are layed out such
                        // that the clickable cells are at the innermost level, but the parent for the column
                        // grand total will have level 0.
                        if (item.parent && item.parent.level === 0)
                            valueIndex = item.levelSourceIndex;
                    }
                    else {
                        // In the single-measure case we can directly check the level of the subtotal to
                        // detect the column grand total (at level 0).
                        if (item.level === 0)
                            valueIndex = item.levelSourceIndex;
                    }
                }
                if (valueIndex !== -1) {
                    // NOTE: if the valueIndex is undefined it implicitly means that it is 0 based on the 
                    //       visual node contract
                    valueIndex = valueIndex ? valueIndex : 0;
                    return dataView.valueSources[valueIndex];
                }
                return null;
            };
            return MatrixBinder;
        }());
        visuals.MatrixBinder = MatrixBinder;
        var Matrix = (function () {
            function Matrix(options) {
                if (options) {
                    this.isFormattingPropertiesEnabled = options.isFormattingPropertiesEnabled;
                    this.isTouchEnabled = options.isTouchEnabled;
                }
            }
            Matrix.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata)
                    return;
                var dataViewMatrix = dataViewMapping.matrix;
                // If Columns Hierarchy is not empty, set Window DataReduction Count to 100
                if (!_.isEmpty(dataViewMatrix.columns.for.in.items)) {
                    dataViewMatrix.rows.dataReductionAlgorithm.window.count = 100;
                }
                var objects = dataViewMapping.metadata.objects;
                dataViewMatrix.rows.for.in.subtotalType = TablixObjects.shouldShowRowSubtotals(objects) ? 2 /* After */ : 0 /* None */;
                dataViewMatrix.columns.for.in.subtotalType = TablixObjects.shouldShowColumnSubtotals(objects) ? 2 /* After */ : 0 /* None */;
            };
            Matrix.getSortableRoles = function () {
                return ['Rows', 'Values'];
            };
            Matrix.prototype.init = function (options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatValueColumn;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.hostServices = options.host;
                this.persistingObjects = false;
                this.waitingForData = false;
                this.lastAllowHeaderResize = true;
                this.waitingForSort = false;
            };
            Matrix.converter = function (dataView, isFormattingEnabled) {
                debug.assertValue(dataView, 'dataView');
                return TablixObjects.getMatrixObjects(dataView, isFormattingEnabled);
            };
            Matrix.prototype.onResizing = function (finalViewport) {
                this.updateViewport(finalViewport);
            };
            /*
            Public for testing
            */
            Matrix.prototype.getColumnWidthManager = function () {
                return this.columnWidthManager;
            };
            Matrix.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var previousDataView = this.dataView;
                    this.dataView = dataViews[0];
                    // We don't check for persisting flag
                    // Any change to the Column Widths need to go through to update all column group instances
                    // ToDo: Consider not resetting scrollbar everytime
                    var formattingProperties = Matrix.converter(this.dataView, this.isFormattingPropertiesEnabled);
                    formattingProperties.isFormattingEnabled = this.isFormattingPropertiesEnabled;
                    var textSize = formattingProperties.general.textSize;
                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
                        var rootChanged = previousDataView.matrix.rows.root !== this.dataView.matrix.rows.root;
                        this.hierarchyNavigator.update(this.dataView.matrix, rootChanged);
                        // If Root for Rows or Columns has changed by the DataViewTransform (e.g. when having reorders in values)
                        if (rootChanged)
                            this.tablixControl.updateModels(/*resetScrollOffsets*/ false, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children);
                        this.refreshControl(/*clear*/ false);
                    }
                    else {
                        this.createOrUpdateHierarchyNavigator();
                        this.createColumnWidthManager();
                        this.createTablixControl(textSize);
                        var binder = this.tablixControl.getBinder();
                        binder.onDataViewChanged(formattingProperties);
                        this.updateInternal(textSize, previousDataView);
                    }
                }
                this.waitingForData = false;
                this.waitingForSort = false;
            };
            Matrix.prototype.createColumnWidthManager = function () {
                var _this = this;
                var columnHierarchy = this.hierarchyNavigator.getMatrixColumnHierarchy();
                if (!this.columnWidthManager) {
                    this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, true /* isMatrix */, function (objectInstances) { return _this.persistColumnWidths(objectInstances); }, columnHierarchy.leafNodes);
                }
                else if (!this.persistingObjects) {
                    this.columnWidthManager.updateDataView(this.dataView, columnHierarchy.leafNodes);
                }
            };
            Matrix.prototype.persistColumnWidths = function (objectInstances) {
                this.persistingObjects = true;
                this.hostServices.persistProperties(objectInstances);
            };
            Matrix.prototype.updateViewport = function (newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(/*clear*/ false);
                }
            };
            Matrix.prototype.refreshControl = function (clear) {
                if (visuals.visibilityHelper.partiallyVisible(this.element) || this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.refresh(clear);
                }
            };
            Matrix.prototype.getLayoutKind = function () {
                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
            };
            Matrix.prototype.createOrUpdateHierarchyNavigator = function () {
                if (!this.tablixControl) {
                    var matrixNavigator = createMatrixHierarchyNavigator(this.dataView.matrix, this.formatter);
                    this.hierarchyNavigator = matrixNavigator;
                }
                else {
                    this.hierarchyNavigator.update(this.dataView.matrix);
                }
            };
            Matrix.prototype.createTablixControl = function (textSize) {
                if (!this.tablixControl) {
                    // Create the control
                    this.tablixControl = this.createControl(this.hierarchyNavigator, textSize);
                }
            };
            Matrix.prototype.createControl = function (matrixNavigator, textSize) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var matrixBinderOptions = {
                    onBindRowHeader: function (item) { _this.onBindRowHeader(item); },
                    totalLabel: this.hostServices.getLocalizedString(Matrix.TotalLabel),
                    onColumnHeaderClick: function (queryName, sortDirection) { return _this.onColumnHeaderClick(queryName, sortDirection); },
                    showSortIcons: layoutKind === 0 /* Canvas */,
                };
                var matrixBinder = new MatrixBinder(this.hierarchyNavigator, matrixBinderOptions);
                var layoutManager = layoutKind === 1 /* DashboardTile */
                    ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(matrixBinder)
                    : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(matrixBinder, this.columnWidthManager);
                var tablixContainer = document.createElement('div');
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: this.isTouchEnabled,
                    layoutKind: layoutKind,
                    fontSize: TablixObjects.getTextSizeInPx(textSize),
                };
                return new visuals.controls.TablixControl(matrixNavigator, layoutManager, matrixBinder, tablixContainer, tablixOptions);
            };
            Matrix.prototype.updateInternal = function (textSize, previousDataView) {
                var _this = this;
                if (this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView));
                }
                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize);
                this.verifyHeaderResize();
                /* To avoid resetting scrollbar every time we persist Objects. If:
                * AutoSizeColumns options was flipped
                * A Column was resized manually
                * A Column was auto-sized
                */
                // Update models before the viewport to make sure column widths are computed correctly
                // if a persisting operation is going, don't reset the scrollbar (column resize)
                this.tablixControl.updateModels(/*resetScrollOffsets*/ !this.persistingObjects, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children);
                this.tablixControl.viewport = this.currentViewport;
                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                // We need the layout for the DIV to be done so that the control can measure items correctly.
                setTimeout(function () {
                    // Render
                    _this.refreshControl(shouldClearControl);
                    // At this point, all columns are rendered with proper width, reset the flag if it was raised
                    if (_this.persistingObjects) {
                        _this.persistingObjects = false;
                        return;
                    }
                    // if AutoSize option was set to OFF, persist all columns width
                    if (_this.columnWidthManager.shouldPersistAllColumnWidths()) {
                        _this.columnWidthManager.persistAllColumnWidths(_this.tablixControl.layoutManager.columnWidthsToPersist);
                    }
                }, 0);
            };
            Matrix.prototype.shouldClearControl = function (previousDataView, newDataView) {
                if (!this.waitingForSort || !previousDataView || !newDataView)
                    return true;
                // ToDo: Get better criteria
                return !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata);
            };
            Matrix.prototype.onBindRowHeader = function (item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Matrix.prototype.onColumnHeaderClick = function (queryName, sortDirection) {
                this.waitingForSort = true;
                this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
            };
            /**
             * Note: Public for testability.
             */
            Matrix.prototype.needsMoreData = function (item) {
                if (this.waitingForData || !this.hierarchyNavigator.isLeaf(item) || !this.dataView.metadata || !this.dataView.metadata.segment)
                    return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Matrix.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getLeafIndex(item) >= loadMoreThreshold;
            };
            Matrix.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
                // we are resilient here when we do not have data view.
                if (this.dataView) {
                    TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, this.isFormattingPropertiesEnabled, false, visuals.controls.TablixType.Matrix);
                }
                return enumeration.complete();
            };
            Matrix.prototype.shouldAllowHeaderResize = function () {
                return this.hostServices.getViewMode() === 1 /* Edit */;
            };
            Matrix.prototype.onViewModeChanged = function (viewMode) {
                /* Refreshes the column headers to enable/disable Column resizing */
                this.updateViewport(this.currentViewport);
            };
            Matrix.prototype.verifyHeaderResize = function () {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Matrix.preferredLoadMoreThreshold = 0.8;
            /**
             * Note: Public only for testing.
             */
            Matrix.TotalLabel = 'TableTotalLabel';
            return Matrix;
        }());
        visuals.Matrix = Matrix;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CssConstants = jsCommon.CssConstants;
        /**
         * Renders an interactive treemap visual from categorical data.
         */
        var Treemap = (function () {
            function Treemap(options) {
                this.tooltipsEnabled = options && options.tooltipsEnabled;
                if (options && options.animator) {
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                    this.behavior = options.behavior;
                }
            }
            Treemap.getLayout = function (labelsSettings, alternativeScale) {
                var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
                var majorLabelsEnabled = labelsSettings.showCategory;
                var minorLabelsEnabled = labelsSettings.show || labelsSettings.showCategory;
                return {
                    shapeClass: function (d) { return Treemap.getNodeClass(d, false); },
                    shapeLayout: Treemap.createTreemapShapeLayout(false),
                    highlightShapeClass: function (d) { return Treemap.getNodeClass(d, true); },
                    highlightShapeLayout: Treemap.createTreemapShapeLayout(true),
                    zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
                    majorLabelClass: function (d) { return Treemap.MajorLabelClassName; },
                    majorLabelLayout: {
                        x: function (d) { return d.x + Treemap.TextMargin; },
                        y: function (d) { return d.y + Treemap.TextMargin + Treemap.MajorLabelTextSize; },
                    },
                    majorLabelText: function (d) { return Treemap.createMajorLabelText(d, labelsSettings, alternativeScale, formattersCache); },
                    minorLabelClass: function (d) { return Treemap.MinorLabelClassName; },
                    minorLabelLayout: {
                        x: function (d) { return d.x + Treemap.TextMargin; },
                        y: function (d) { return d.y + d.dy - Treemap.TextMargin; },
                    },
                    minorLabelText: function (d) { return Treemap.createMinorLabelText(d, labelsSettings, alternativeScale, formattersCache); },
                    areMajorLabelsEnabled: function () { return majorLabelsEnabled; },
                    areMinorLabelsEnabled: function () { return minorLabelsEnabled; },
                };
            };
            Treemap.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                // Ensure viewport is empty on init
                element.empty();
                this.svg = d3.select(element.get(0))
                    .append('svg')
                    .style('position', 'absolute')
                    .classed(Treemap.ClassName, true);
                this.shapeGraphicsContext = this.svg
                    .append('g')
                    .classed(Treemap.ShapesClassName, true);
                this.labelGraphicsContext = this.svg
                    .append('g')
                    .classed(Treemap.LabelsGroupClassName, true);
                this.element = element;
                // avoid deep copy
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                };
                this.style = options.style;
                this.treemap = d3.layout.treemap()
                    .sticky(false)
                    .sort(function (a, b) { return a.size - b.size; })
                    .value(function (d) { return d.size; })
                    .round(false);
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(options.host);
                }
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.colors = this.style.colorPalette.dataColors;
                this.hostService = options.host;
            };
            /**
             * Note: Public for testing purposes.
             */
            Treemap.converter = function (dataView, colors, labelSettings, interactivityService, viewport, legendObjectProperties, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var rootNode = {
                    key: "root",
                    name: "root",
                    children: [],
                    selected: false,
                    highlightMultiplier: 0,
                    identity: visuals.SelectionId.createNull(),
                    color: undefined,
                };
                var allNodes = [];
                var hasHighlights;
                var legendDataPoints = [];
                var legendTitle = "";
                var colorHelper = new visuals.ColorHelper(colors, visuals.treemapProps.dataPoint.fill);
                var dataWasCulled = undefined;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    labelSettings.show = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.show, labelSettings.show);
                    labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.treemapProps.labels.color, labelSettings.labelColor);
                    labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelDisplayUnits, labelSettings.displayUnits);
                    labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelPrecision, labelSettings.precision);
                    labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.categoryLabels.show, labelSettings.showCategory);
                }
                if (dataView && dataView.categorical && dataView.categorical.values) {
                    var data_9 = dataView.categorical;
                    var valueColumns = data_9.values;
                    hasHighlights = !!(valueColumns.length > 0 && valueColumns[0].highlights);
                    var formatStringProp = visuals.treemapProps.general.formatString;
                    var result = Treemap.getValuesFromCategoricalDataView(data_9, hasHighlights);
                    var values = result.values;
                    var highlights = result.highlights;
                    var totalValue = result.totalValue;
                    if (result.highlightsOverflow) {
                        hasHighlights = false;
                        values = highlights;
                    }
                    var cullableValue = Treemap.getCullableValue(totalValue, viewport);
                    var grouped = valueColumns.grouped();
                    var isMultiSeries = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    var hasDynamicSeries = !!valueColumns.source;
                    dataWasCulled = false;
                    var shouldCullValue = undefined;
                    var highlight = undefined;
                    var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(data_9);
                    var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(data_9);
                    if ((data_9.categories == null) && !_.isEmpty(values)) {
                        // No categories, sliced by series and measures
                        for (var i = 0, ilen = values[0].length; i < ilen; i++) {
                            // Don't add the gradient data as a node
                            if (i === gradientMeasureIndex) {
                                continue;
                            }
                            var value = values[0][i];
                            if (!Treemap.checkValueForShape(value)) {
                                continue;
                            }
                            if (value < cullableValue) {
                                dataWasCulled = dataWasCulled || shouldCullValue;
                                continue;
                            }
                            var valueColumn = valueColumns[i];
                            var nodeName = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, valueColumns, formatStringProp);
                            var identity = hasDynamicSeries
                                ? visuals.SelectionId.createWithId(valueColumns[i].identity)
                                : visuals.SelectionId.createWithMeasure(valueColumns[i].source.queryName);
                            var key = identity.getKey();
                            var color = hasDynamicSeries
                                ? colorHelper.getColorForSeriesValue(grouped[i] && grouped[i].objects, data_9.values.identityFields, visuals.converterHelper.getSeriesName(valueColumn.source))
                                : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName);
                            var highlightedValue = hasHighlights && highlight !== 0 ? highlight : undefined;
                            var categorical = dataView.categorical;
                            var valueIndex = i;
                            var tooltipInfo = void 0;
                            var highlightedTooltipInfo = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, nodeName, value, null, null, valueIndex, i);
                                if (highlightedValue !== undefined) {
                                    highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, nodeName, value, null, null, valueIndex, i, highlightedValue);
                                }
                            }
                            var node = {
                                key: key,
                                name: nodeName,
                                size: value,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo,
                                labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp),
                            };
                            if (hasHighlights && highlights) {
                                node.highlightMultiplier = value !== 0 ? highlights[0][i] / value : 0;
                                node.highlightValue = highlights[0][i];
                            }
                            rootNode.children.push(node);
                            allNodes.push(node);
                            legendDataPoints.push({
                                label: nodeName,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                identity: identity,
                                selected: false
                            });
                        }
                    }
                    else if (data_9.categories && data_9.categories.length > 0) {
                        // Remove 1 from the value column count if there is a gradient
                        var valueColumnCount = valueColumns.length - (gradientMeasureIndex !== -1 ? 1 : 0);
                        // Do not add second level if it's one and only one data point per shape and it's not a group value
                        // e.g. Category/Series group plus only one Value field (excluding the gradient)
                        var omitSecondLevel = valueColumnCount === 1 && (valueColumns[0].source.groupName == null);
                        // Create the first level from categories
                        var categoryColumn = data_9.categories[0];
                        legendTitle = categoryColumn.source ? categoryColumn.source.displayName : "";
                        var categorical = undefined;
                        var categoryFormat = visuals.valueFormatter.getFormatString(categoryColumn.source, formatStringProp);
                        for (var categoryIndex = 0, categoryLen = values.length; categoryIndex < categoryLen; categoryIndex++) {
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(categoryColumn, categoryIndex)
                                .createSelectionId();
                            var key = JSON.stringify({ nodeKey: identity.getKey(), depth: 1 });
                            var objects = categoryColumn.objects && categoryColumn.objects[categoryIndex];
                            var color = colorHelper.getColorForSeriesValue(objects, categoryColumn.identityFields, categoryColumn.values[categoryIndex]);
                            var categoryValue = visuals.valueFormatter.format(categoryColumn.values[categoryIndex], categoryFormat);
                            var currentValues = values[categoryIndex];
                            categorical = dataView.categorical;
                            // This section area builds the tooltip for the parent node. It's only displayed if the node doesn't have any children (essentially if omitSecondLevel is true).
                            // seriesIndex is used to figure determine what the value is for this tooltip. 
                            // If omitSecondLevel is true, currentValues should have (at most) 2 series - one for the value and optionally one for the gradient.
                            // seriesIndex is set the 1st series that is not a gradient
                            var seriesIndex = gradientMeasureIndex === 0 ? 1 : 0;
                            var value = currentValues[seriesIndex];
                            var highlightValue = hasHighlights && highlights ? highlights[categoryIndex][seriesIndex] : undefined;
                            var tooltipInfo = void 0;
                            var highlightedTooltipInfo = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, seriesIndex, categoryIndex, null, omitSecondLevel ? gradientValueColumn : undefined);
                                if (highlightValue !== undefined) {
                                    highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, seriesIndex, categoryIndex, highlightValue, omitSecondLevel ? gradientValueColumn : undefined);
                                }
                            }
                            var node = {
                                key: key,
                                name: categoryValue,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo,
                                labelFormatString: valueColumnCount === 1 ? visuals.valueFormatter.getFormatString(data_9.values[0].source, formatStringProp) : categoryFormat,
                            };
                            if (hasHighlights) {
                                node.highlightMultiplier = value !== 0 ? highlightValue / value : 0;
                                node.highlightValue = highlightValue;
                            }
                            legendDataPoints.push({
                                label: categoryValue,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                identity: identity,
                                selected: false
                            });
                            var total = 0;
                            var highlightTotal = 0; // Used if omitting second level
                            for (var j = 0, jlen = currentValues.length; j < jlen; j++) {
                                // Don't add the gradient data as a node
                                if (j === gradientMeasureIndex) {
                                    continue;
                                }
                                var valueColumn = valueColumns[j];
                                var value_1 = currentValues[j];
                                var highlight_1 = void 0;
                                shouldCullValue = value_1 < cullableValue;
                                if (!Treemap.checkValueForShape(value_1) || shouldCullValue) {
                                    dataWasCulled = dataWasCulled || shouldCullValue;
                                    continue;
                                }
                                total += value_1;
                                if (hasHighlights) {
                                    highlight_1 = highlights[categoryIndex][j];
                                    highlightTotal += highlight_1;
                                }
                                if (!omitSecondLevel) {
                                    var childName = null;
                                    if (isMultiSeries) {
                                        // Measure: use name and index
                                        childName = valueColumn.source.displayName;
                                    }
                                    else {
                                        // Series group instance
                                        childName = valueColumn.source.groupName;
                                    }
                                    var categoricalValues = categorical ? categorical.values : null;
                                    var measureId = isMultiSeries ? valueColumn.source.queryName : undefined;
                                    var childIdentity = visuals.SelectionIdBuilder.builder()
                                        .withCategory(categoryColumn, categoryIndex)
                                        .withSeries(categoricalValues, valueColumn)
                                        .withMeasure(measureId)
                                        .createSelectionId();
                                    var childKey = JSON.stringify({ nodeKey: childIdentity.getKey(), depth: 2 });
                                    var highlightedValue = hasHighlights && highlight_1 !== 0 ? highlight_1 : undefined;
                                    categorical = dataView.categorical;
                                    var tooltipInfo_4 = void 0;
                                    var highlightedTooltipInfo_1 = void 0;
                                    if (tooltipsEnabled) {
                                        tooltipInfo_4 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value_1, null, null, j, categoryIndex, null, gradientValueColumn);
                                        if (highlightedValue !== undefined) {
                                            highlightedTooltipInfo_1 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value_1, null, null, j, categoryIndex, highlightedValue, gradientValueColumn);
                                        }
                                    }
                                    var childNode = {
                                        key: childKey,
                                        name: childName,
                                        size: value_1,
                                        color: color,
                                        selected: false,
                                        identity: childIdentity,
                                        tooltipInfo: tooltipInfo_4,
                                        highlightedTooltipInfo: highlightedTooltipInfo_1,
                                        labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp),
                                    };
                                    if (hasHighlights) {
                                        childNode.highlightMultiplier = value_1 !== 0 ? highlight_1 / value_1 : 0;
                                        childNode.highlightValue = highlight_1;
                                    }
                                    if (node.children == null)
                                        node.children = [];
                                    node.children.push(childNode);
                                    allNodes.push(childNode);
                                }
                            }
                            if (Treemap.checkValueForShape(total)) {
                                node.size = total;
                                rootNode.children.push(node);
                                allNodes.push(node);
                            }
                            if (hasHighlights)
                                node.highlightMultiplier = total ? highlightTotal / total : 0;
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(allNodes);
                    interactivityService.applySelectionStateToData(legendDataPoints);
                }
                return {
                    root: rootNode,
                    hasHighlights: hasHighlights,
                    legendData: { title: legendTitle, dataPoints: legendDataPoints, fontSize: visuals.SVGLegend.DefaultFontSizeInPt },
                    dataLabelsSettings: labelSettings,
                    legendObjectProperties: legendObjectProperties,
                    dataWasCulled: dataWasCulled,
                };
            };
            Treemap.getValuesFromCategoricalDataView = function (data, hasHighlights) {
                var valueColumns = data.values;
                var categoryValueCount;
                if (valueColumns && (data.categories == null)) {
                    categoryValueCount = 1; // We only get the first value out of each valueColumn since we don't have a category
                }
                else if (valueColumns && data.categories && data.categories.length > 0) {
                    categoryValueCount = data.categories[0].values.length;
                }
                var values = [];
                var highlights = [];
                var totalValue = 0;
                for (var i = 0; i < categoryValueCount; i++) {
                    values.push([]);
                    if (hasHighlights)
                        highlights.push([]);
                }
                var highlightsOverflow;
                for (var j = 0; j < valueColumns.length; j++) {
                    var valueColumn = valueColumns[j];
                    for (var i = 0; i < categoryValueCount; i++) {
                        var value = valueColumn.values[i];
                        values[i].push(value);
                        totalValue += isNaN(value) ? 0 : value;
                        if (hasHighlights) {
                            var highlight = valueColumn.highlights[i];
                            if (!highlight)
                                highlight = 0;
                            highlights[i].push(highlight);
                            if (highlight > value)
                                highlightsOverflow = true;
                        }
                    }
                }
                return {
                    values: values,
                    highlights: hasHighlights ? highlights : undefined,
                    highlightsOverflow: hasHighlights ? highlightsOverflow : undefined,
                    totalValue: totalValue,
                };
            };
            Treemap.getCullableValue = function (totalValue, viewport) {
                var totalArea = viewport.width * viewport.height;
                var culledPercent = Treemap.CullableArea / totalArea;
                return culledPercent * totalValue;
            };
            Treemap.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                var dataViewCategorical = dataViews && dataViews.length > 0 && dataViews[0].categorical ? dataViews[0].categorical : undefined;
                var labelSettings = visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                var legendObjectProperties = null;
                if (dataViewCategorical) {
                    var dataView = dataViews[0];
                    var dataViewMetadata = dataView.metadata;
                    var objects = void 0;
                    if (dataViewMetadata)
                        objects = dataViewMetadata.objects;
                    if (objects) {
                        legendObjectProperties = objects['legend'];
                    }
                    this.data = Treemap.converter(dataView, this.colors, labelSettings, this.interactivityService, this.currentViewport, legendObjectProperties, this.tooltipsEnabled);
                }
                else {
                    var rootNode = {
                        key: "root",
                        name: "root",
                        children: [],
                        selected: false,
                        highlightMultiplier: 0,
                        identity: visuals.SelectionId.createNull(),
                        color: undefined,
                    };
                    var legendData = { title: "", dataPoints: [] };
                    var treeMapData = {
                        root: rootNode,
                        hasHighlights: false,
                        legendData: legendData,
                        dataLabelsSettings: labelSettings,
                        dataWasCulled: false,
                    };
                    this.data = treeMapData;
                }
                this.updateInternal(options.suppressAnimations);
                if (dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    this.hostService.setWarnings(warnings);
                }
            };
            // TODO: Remove this once all visuals have implemented update.
            Treemap.prototype.onDataChanged = function (options) {
                this.update({
                    suppressAnimations: options.suppressAnimations,
                    dataViews: options.dataViews,
                    viewport: this.currentViewport
                });
            };
            // TODO: Remove this once all visuals have implemented update.
            Treemap.prototype.onResizing = function (viewport) {
                this.update({
                    suppressAnimations: true,
                    dataViews: this.dataViews,
                    viewport: viewport
                });
            };
            Treemap.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            Treemap.prototype.enumerateObjectInstances = function (options) {
                var data = this.data;
                if (!data)
                    return;
                var objectName = options.objectName, enumeration = new visuals.ObjectEnumerationBuilder();
                var dataLabelsSettings = this.data.dataLabelsSettings
                    ? this.data.dataLabelsSettings
                    : visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                switch (objectName) {
                    case 'dataPoint':
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        if (!hasGradientRole)
                            this.enumerateDataPoints(enumeration, data);
                        break;
                    case 'legend':
                        return this.enumerateLegend(data);
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: dataLabelsSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                    case 'categoryLabels':
                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, dataLabelsSettings, false /* withFill */, true /* isShowCategory */);
                        break;
                }
                return enumeration.complete();
            };
            Treemap.prototype.enumerateDataPoints = function (enumeration, data) {
                var rootChildren = data.root.children;
                if (_.isEmpty(rootChildren))
                    return;
                for (var y = 0; y < rootChildren.length; y++) {
                    var treemapNode = rootChildren[y];
                    enumeration.pushInstance({
                        displayName: treemapNode.name,
                        selector: treemapNode.identity.getSelector(),
                        properties: {
                            fill: { solid: { color: treemapNode.color } }
                        },
                        objectName: 'dataPoint'
                    });
                }
            };
            Treemap.prototype.enumerateLegend = function (data) {
                var legendObjectProperties = { legend: data.legendObjectProperties };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.titleText, this.data.legendData.title);
                var labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData ? this.data.legendData.labelColor : visuals.LegendData.DefaultLegendLabelFillColor);
                var labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData && this.data.legendData.fontSize ? this.data.legendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
                return [{
                        selector: null,
                        objectName: 'legend',
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: labelFontSize,
                        }
                    }];
            };
            Treemap.checkValueForShape = function (value) {
                if (!value)
                    return false;
                return value > 0;
            };
            Treemap.prototype.calculateTreemapSize = function () {
                var legendMargins = this.legend.getMargins();
                return {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
            };
            Treemap.prototype.initViewportDependantProperties = function (duration) {
                if (duration === void 0) { duration = 0; }
                var viewport = this.calculateTreemapSize();
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                visuals.Legend.positionChartArea(this.svg, this.legend);
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.hasChildrenWithIdentity = function (node) {
                var children = node.children;
                if (!children)
                    return false;
                var count = children.length;
                if (count === 0)
                    return false;
                for (var i = count - 1; i >= 0; i--) {
                    if (children[i].identity.hasIdentity())
                        return true;
                }
                return false;
            };
            Treemap.canDisplayMajorLabel = function (node) {
                // Only display major labels for level 1
                if (node.depth !== 1)
                    return false;
                if (_.isEmpty(node.name))
                    return false;
                // Check if the room is enough for text with or without ellipse
                var availableWidth = node.dx - Treemap.TextMargin * 2;
                if (availableWidth < Treemap.MinTextWidthForMajorLabel)
                    return false;
                // Check if the shape is high enough for label
                var textHeightWithMargin = Treemap.MajorLabelTextSize + Treemap.TextMargin * 2;
                if (node.dy < textHeightWithMargin)
                    return false;
                return true;
            };
            Treemap.canDisplayMinorLabel = function (node, labelSettings) {
                // Only display minor labels for level 1 and 2
                if (node.depth < 1 || node.depth > 2)
                    return false;
                // If a depth 1 node has children or is not showing data labels, do not show minor labels
                if (node.depth === 1 && (node.children || !labelSettings.show)) {
                    return false;
                }
                if (_.isEmpty(node.name))
                    return false;
                // Check if the room is enough for text with or without ellipse
                var availableWidth = node.dx - Treemap.TextMargin * 2;
                if (availableWidth < Treemap.MinTextWidthForMinorLabel)
                    return false;
                // Check if the shape is high enough for label
                var textHeightWithMargin = Treemap.MinorLabelTextSize + Treemap.TextMargin * 2;
                if (node.dy < textHeightWithMargin)
                    return false;
                if (node.depth === 1) {
                    var roomTop = node.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2;
                    if (node.y + node.dy - roomTop < textHeightWithMargin)
                        return false;
                }
                else if (node.depth === 2) {
                    var parent_1 = node.parent;
                    var roomTop = Math.max(parent_1.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2, node.y);
                    // Parent's label needs the room
                    if (node.y + node.dy - roomTop < textHeightWithMargin)
                        return false;
                }
                return true;
            };
            Treemap.createMajorLabelText = function (node, labelsSettings, alternativeScale, formattersCache) {
                var spaceAvaliableForLabels = node.dx - Treemap.TextMargin * 2;
                var baseTextProperties = Treemap.MajorLabelTextProperties;
                var textProperties = {
                    text: node.name,
                    fontFamily: baseTextProperties.fontFamily,
                    fontSize: baseTextProperties.fontSize
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
            };
            Treemap.createMinorLabelText = function (node, labelsSettings, alternativeScale, formattersCache) {
                var spaceAvaliableForLabels = node.dx - Treemap.TextMargin * 2;
                var label = node.name;
                if (labelsSettings.show) {
                    var measureFormatter = formattersCache.getOrCreate(node.labelFormatString, labelsSettings, alternativeScale);
                    // Create measure label
                    label = visuals.dataLabelUtils.getLabelFormattedText({
                        label: node.highlightValue != null ? node.highlightValue : node.value, maxWidth: spaceAvaliableForLabels, formatter: measureFormatter
                    });
                    // Add category if needed (we're showing category and the node depth is 2)
                    if (labelsSettings.showCategory && node.depth === 2)
                        label = visuals.dataLabelUtils.getLabelFormattedText({
                            label: node.name,
                            maxWidth: spaceAvaliableForLabels
                        }) + " " + label;
                }
                return visuals.dataLabelUtils.getLabelFormattedText({
                    label: label,
                    maxWidth: spaceAvaliableForLabels,
                    fontSize: labelsSettings.fontSize
                });
            };
            Treemap.getFill = function (d, isHighlightRect) {
                // NOTE: only painted shapes will catch click event. We either paint children or their parent but not both.
                // If it's a leaf with no category, parent will be painted instead (and support interactivity)
                if (d.depth > 1 && !d.identity.hasIdentity() && !isHighlightRect)
                    return CssConstants.noneValue;
                // If it's not a leaf and it has children with a category, children will be painted
                if (Treemap.hasChildrenWithIdentity(d))
                    return CssConstants.noneValue;
                return d.color;
            };
            Treemap.getFillOpacity = function (d, hasSelection, hasHighlights, isHighlightRect) {
                if (hasHighlights) {
                    if (isHighlightRect)
                        return null;
                    return Treemap.DimmedShapeOpacity.toString();
                }
                if (!hasSelection || d.selected)
                    return null;
                // Parent node is selected (as an optimization, we only check below level 1 because root node cannot be selected anyway)
                if (d.depth > 1 && d.parent.selected)
                    return null;
                // It's a parent node with interactive children, fall back to default opacity
                if (Treemap.hasChildrenWithIdentity(d))
                    return null;
                return Treemap.DimmedShapeOpacity.toString();
            };
            Treemap.prototype.updateInternal = function (suppressAnimations) {
                var data = this.data;
                var hasHighlights = data && data.hasHighlights;
                var labelSettings = data ? data.dataLabelsSettings : null;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend) && this.data) {
                    this.renderLegend();
                }
                this.initViewportDependantProperties(duration);
                var viewport = this.calculateTreemapSize();
                this.treemap.size([viewport.width, viewport.height]);
                // Shapes are drawn for all nodes
                var nodes = (data && data.root) ? this.treemap.nodes(data.root) : [];
                // Highlight shapes are drawn only for nodes with non-null/undefed highlightMultipliers that have no children
                var highlightNodes = nodes.filter(function (value) { return value.highlightMultiplier != null && (!value.children || value.children.length === 0); });
                var majorLabeledNodes = [];
                var minorLabeledNodes = [];
                var alternativeScale = null;
                // Only populate major labels if category labels are turned on
                if (labelSettings.showCategory) {
                    majorLabeledNodes = nodes.filter(function (d) { return Treemap.canDisplayMajorLabel(d); });
                }
                // Only populate minor labels if category or data labels are turned on
                if (labelSettings.show || labelSettings.showCategory) {
                    minorLabeledNodes = nodes.filter(function (d) { return Treemap.canDisplayMinorLabel(d, labelSettings); });
                    // If the display unit is 0 we calculate the format scale using the maximum value available
                    if (labelSettings.displayUnits === 0)
                        alternativeScale = d3.max(minorLabeledNodes, function (d) { return Math.abs(d.value); });
                }
                var treemapLayout = Treemap.getLayout(labelSettings, alternativeScale);
                var shapes;
                var highlightShapes;
                var majorLabels;
                var minorLabels;
                var result;
                if (this.animator && !suppressAnimations) {
                    var options = {
                        viewModel: data,
                        nodes: nodes,
                        highlightNodes: highlightNodes,
                        majorLabeledNodes: majorLabeledNodes,
                        minorLabeledNodes: minorLabeledNodes,
                        shapeGraphicsContext: this.shapeGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        interactivityService: this.interactivityService,
                        layout: treemapLayout,
                        labelSettings: labelSettings,
                    };
                    result = this.animator.animate(options);
                    shapes = result.shapes;
                    highlightShapes = result.highlightShapes;
                    majorLabels = result.majorLabels;
                    minorLabels = result.minorLabels;
                }
                if (!this.animator || suppressAnimations || result.failed) {
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    var shapeGraphicsContext = this.shapeGraphicsContext;
                    shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasSelection, hasHighlights, treemapLayout);
                    highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights, treemapLayout);
                    var labelGraphicsContext = this.labelGraphicsContext;
                    majorLabels = Treemap.drawDefaultMajorLabels(labelGraphicsContext, majorLabeledNodes, labelSettings, treemapLayout);
                    minorLabels = Treemap.drawDefaultMinorLabels(labelGraphicsContext, minorLabeledNodes, labelSettings, treemapLayout);
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        majorLabels: majorLabels,
                        minorLabels: minorLabels,
                        nodes: nodes,
                        hasHighlights: data.hasHighlights,
                    };
                    this.interactivityService.bind(nodes, this.behavior, behaviorOptions);
                }
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.highlightedTooltipInfo ? tooltipEvent.data.highlightedTooltipInfo : tooltipEvent.data.tooltipInfo; });
                    visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.highlightedTooltipInfo; });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.prototype.renderLegend = function () {
                var legendObjectProperties = this.data.legendObjectProperties;
                if (legendObjectProperties) {
                    var legendData = this.data.legendData;
                    visuals.LegendData.update(legendData, legendObjectProperties);
                    var position = legendObjectProperties[visuals.legendProps.position];
                    if (position)
                        this.legend.changeOrientation(visuals.LegendPosition[position]);
                    this.legend.drawLegend(legendData, this.currentViewport);
                }
                else {
                    // TODO: Draw should be the only API. Visuals should only call that with orientation, props, etc 
                    // instead of managing state. Will follow up with another change.
                    this.legend.changeOrientation(visuals.LegendPosition.Top);
                    this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
                }
            };
            Treemap.getNodeClass = function (d, highlight) {
                var nodeClass;
                switch (d.depth) {
                    case 1:
                        nodeClass = Treemap.ParentGroupClassName;
                        break;
                    case 2:
                        nodeClass = Treemap.NodeGroupClassName;
                        break;
                    case 0:
                        nodeClass = Treemap.RootNodeClassName;
                        break;
                    default:
                        debug.assertFail('Treemap only supports 2 levels maxiumum');
                }
                nodeClass += " " + (highlight ? Treemap.HighlightNodeClassName : Treemap.TreemapNodeClassName);
                return nodeClass;
            };
            Treemap.createTreemapShapeLayout = function (isHighlightRect) {
                if (isHighlightRect === void 0) { isHighlightRect = false; }
                return {
                    x: function (d) { return d.x; },
                    y: function (d) { return d.y + (isHighlightRect ? d.dy * (1 - d.highlightMultiplier) : 0); },
                    width: function (d) { return Math.max(0, d.dx); },
                    height: function (d) { return Math.max(0, d.dy * (isHighlightRect ? d.highlightMultiplier : 1)); },
                };
            };
            Treemap.createTreemapZeroShapeLayout = function () {
                return {
                    x: function (d) { return d.x; },
                    y: function (d) { return d.y + d.dy; },
                    width: function (d) { return Math.max(0, d.dx); },
                    height: function (d) { return 0; },
                };
            };
            Treemap.drawDefaultShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = false;
                var shapes = context.selectAll('.' + Treemap.TreemapNodeClassName)
                    .data(nodes, function (d) { return d.key; });
                shapes.enter().append('rect')
                    .attr('class', layout.shapeClass);
                shapes
                    .style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            Treemap.drawDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll('.' + Treemap.HighlightNodeClassName)
                    .data(nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', layout.highlightShapeClass);
                highlightShapes
                    .style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            Treemap.drawDefaultMajorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + Treemap.MajorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.majorLabelClass);
                labels
                    .attr(layout.majorLabelLayout)
                    .text(layout.majorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; });
                labels.exit().remove();
                return labels;
            };
            Treemap.drawDefaultMinorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + Treemap.MinorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.minorLabelClass);
                labels
                    .attr(layout.minorLabelLayout)
                    .text(layout.minorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; });
                labels.exit().remove();
                return labels;
            };
            Treemap.cleanMinorLabels = function (context) {
                var empty = [];
                var labels = context
                    .selectAll('.' + Treemap.LabelsGroupClassName)
                    .selectAll('.' + Treemap.MinorLabelClassName)
                    .data(empty);
                labels.exit().remove();
            };
            Treemap.DimmedShapeOpacity = 0.4;
            Treemap.ClassName = 'treemap';
            Treemap.LabelsGroupClassName = "labels";
            Treemap.MajorLabelClassName = 'majorLabel';
            Treemap.MinorLabelClassName = 'minorLabel';
            Treemap.ShapesClassName = "shapes";
            Treemap.TreemapNodeClassName = "treemapNode";
            Treemap.RootNodeClassName = 'rootNode';
            Treemap.ParentGroupClassName = 'parentGroup';
            Treemap.NodeGroupClassName = 'nodeGroup';
            Treemap.HighlightNodeClassName = 'treemapNodeHighlight';
            Treemap.TextMargin = 5;
            Treemap.MinorLabelTextSize = 10;
            Treemap.MinTextWidthForMinorLabel = 18;
            Treemap.MajorLabelTextSize = 12;
            Treemap.MinTextWidthForMajorLabel = 22;
            Treemap.MajorLabelTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: Treemap.MajorLabelTextSize + 'px'
            };
            /**
             * A rect with an area of 9 is a treemap rectangle of only
             * a single pixel in the middle with a 1 pixel stroke on each edge.
             */
            Treemap.CullableArea = 9;
            return Treemap;
        }());
        visuals.Treemap = Treemap;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var Card = (function (_super) {
            __extends(Card, _super);
            function Card(options) {
                _super.call(this, Card.cardClassName);
                this.isScrollable = false;
                this.displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits;
                if (options) {
                    this.isScrollable = !!options.isScrollable;
                    if (options.animator)
                        this.animator = options.animator;
                    if (options.displayUnitSystemType != null)
                        this.displayUnitSystemType = options.displayUnitSystemType;
                }
            }
            Card.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.animationOptions = options.animation;
                var element = options.element;
                this.kpiImage = d3.select(element.get(0)).append('div')
                    .classed(Card.KPIImage.class, true);
                var svg = this.svg = d3.select(element.get(0)).append('svg');
                this.graphicsContext = svg.append('g');
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportProperties();
                if (this.isScrollable) {
                    svg.attr('class', Card.cardClassName);
                    this.labelContext = svg.append('g');
                }
            };
            Card.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataView = options.dataViews[0];
                var value;
                if (dataView) {
                    this.getMetaDataColumn(dataView);
                    if (dataView.single) {
                        value = dataView.single.value;
                    }
                    // Update settings based on new metadata column
                    this.cardFormatSetting = this.getDefaultFormatSettings();
                    var dataViewMetadata = dataView.metadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var labelSettings = this.cardFormatSetting.labelSettings;
                            labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.labels.color, labelSettings.labelColor);
                            labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelPrecision, labelSettings.precision);
                            labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.fontSize, labelSettings.fontSize);
                            // The precision can't go below 0
                            if (labelSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && labelSettings.precision < 0) {
                                labelSettings.precision = 0;
                            }
                            labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelDisplayUnits, labelSettings.displayUnits);
                            //category labels
                            labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.show, labelSettings.showCategory);
                            labelSettings.categoryLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.categoryLabels.color, labelSettings.categoryLabelColor);
                            this.cardFormatSetting.wordWrap = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.wordWrap.show, this.cardFormatSetting.wordWrap);
                            this.cardFormatSetting.textSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.fontSize, this.cardFormatSetting.textSize);
                        }
                    }
                }
                this.updateInternal(value, true /* suppressAnimations */, true /* forceUpdate */);
            };
            Card.prototype.onResizing = function (viewport) {
                this.currentViewport = viewport;
                this.updateViewportProperties();
                this.updateInternal(this.value, true /* suppressAnimations */, true /* forceUpdate */);
            };
            Card.prototype.updateViewportProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width)
                    .attr('height', viewport.height);
            };
            Card.prototype.setTextProperties = function (text, fontSize) {
                Card.cardTextProperties.fontSize = jsCommon.PixelConverter.fromPoint(fontSize);
                Card.cardTextProperties.text = text;
            };
            Card.prototype.getCardFormatTextSize = function () {
                return this.cardFormatSetting.textSize;
            };
            Card.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
                var adjustedFontHeight = _super.prototype.getAdjustedFontHeight.call(this, availableWidth, textToMeasure, seedFontHeight);
                return Math.min(adjustedFontHeight, Card.DefaultStyle.card.maxFontSize);
            };
            Card.prototype.clear = function (valueOnly) {
                if (valueOnly === void 0) { valueOnly = false; }
                this.svg.select(Card.Value.selector).text('');
                if (!valueOnly)
                    this.svg.select(Card.Label.selector).text('');
                _super.prototype.clear.call(this);
            };
            Card.prototype.updateInternal = function (target, suppressAnimations, forceUpdate) {
                if (forceUpdate === void 0) { forceUpdate = false; }
                var start = this.value;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (target === undefined) {
                    if (start !== undefined)
                        this.clear();
                    return;
                }
                var metaDataColumn = this.metaDataColumn;
                var labelSettings = this.cardFormatSetting.labelSettings;
                var isDefaultDisplayUnit = labelSettings.displayUnits === 0;
                var format = this.getFormatString(metaDataColumn);
                var formatter = visuals.valueFormatter.create({
                    format: format,
                    value: isDefaultDisplayUnit ? target : labelSettings.displayUnits,
                    precision: visuals.dataLabelUtils.getLabelPrecision(labelSettings.precision, format),
                    displayUnitSystemType: isDefaultDisplayUnit && labelSettings.precision === visuals.dataLabelUtils.defaultLabelPrecision ? this.displayUnitSystemType : powerbi.DisplayUnitSystemType.WholeUnits,
                    formatSingleValues: isDefaultDisplayUnit ? true : false,
                    allowFormatBeautification: true,
                    columnType: metaDataColumn ? metaDataColumn.type : undefined
                });
                var formatSettings = this.cardFormatSetting;
                var valueTextHeightInPx = jsCommon.PixelConverter.fromPointToPixel(labelSettings.fontSize);
                var valueStyles = Card.DefaultStyle.value;
                this.setTextProperties(target, this.getCardFormatTextSize());
                var labelTextHeightInPx = powerbi.TextMeasurementService.estimateSvgTextHeight(Card.cardTextProperties);
                var labelHeightWithPadding = labelTextHeightInPx + Card.DefaultStyle.label.paddingTop;
                var width = this.currentViewport.width;
                var height = this.currentViewport.height;
                var translateX = this.getTranslateX(width);
                var translateY = (height - labelHeightWithPadding - valueTextHeightInPx) / 2;
                var statusGraphicInfo = getKpiImageMetadata(metaDataColumn, target, 1 /* Big */);
                if (this.isScrollable) {
                    if (!forceUpdate && start === target)
                        return;
                    if (start !== target)
                        target = formatter.format(target);
                    var label = metaDataColumn ? metaDataColumn.displayName : undefined;
                    var labelData = labelSettings.showCategory
                        ? [label]
                        : [];
                    var translatedLabelY = this.getTranslateY(valueTextHeightInPx + labelHeightWithPadding + translateY);
                    var labelElement = this.labelContext
                        .attr('transform', visuals.SVGUtil.translate(translateX, translatedLabelY))
                        .selectAll('text')
                        .data(labelData);
                    labelElement
                        .enter()
                        .append('text')
                        .attr('class', Card.Label.class);
                    labelElement
                        .text(function (d) { return d; })
                        .style({
                        'font-size': jsCommon.PixelConverter.fromPoint(this.getCardFormatTextSize()),
                        'fill': labelSettings.categoryLabelColor,
                        'text-anchor': this.getTextAnchor()
                    });
                    var labelElementNode = labelElement.node();
                    if (labelElementNode) {
                        if (formatSettings.wordWrap)
                            powerbi.TextMeasurementService.wordBreak(labelElementNode, width / 2, height - translatedLabelY);
                        else
                            labelElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    labelElement
                        .append('title')
                        .text(function (d) { return d; });
                    labelElement.exit().remove();
                    if (statusGraphicInfo) {
                        // Display card KPI icon
                        this.graphicsContext.selectAll('text').remove();
                        this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx);
                    }
                    else {
                        // Display card text value
                        this.kpiImage.selectAll('div').remove();
                        var valueElement = this.graphicsContext
                            .attr('transform', visuals.SVGUtil.translate(translateX, this.getTranslateY(valueTextHeightInPx + translateY)))
                            .selectAll('text')
                            .data([target]);
                        valueElement
                            .enter()
                            .append('text')
                            .attr('class', Card.Value.class);
                        valueElement
                            .text(function (d) { return d; })
                            .style({
                            'font-size': jsCommon.PixelConverter.fromPoint(labelSettings.fontSize),
                            'fill': labelSettings.labelColor,
                            'font-family': valueStyles.fontFamily,
                            'text-anchor': this.getTextAnchor(),
                        });
                        valueElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                        valueElement
                            .append('title')
                            .text(function (d) { return d; });
                        valueElement.exit().remove();
                    }
                }
                else {
                    if (statusGraphicInfo) {
                        // Display card KPI icon
                        this.graphicsContext.selectAll('text').remove();
                        this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx);
                    }
                    else {
                        this.kpiImage.selectAll('div').remove();
                        this.doValueTransition(start, target, this.displayUnitSystemType, this.animationOptions, duration, forceUpdate, formatter);
                        //in order to remove duplicated title values we first remove all and than add a new one
                        this.graphicsContext.call(visuals.tooltipUtils.tooltipUpdate, [target]);
                    }
                }
                this.value = target;
            };
            Card.prototype.displayStatusGraphic = function (statusGraphicInfo, translateX, translateY, labelTextSizeInPx) {
                // Remove existing text
                this.graphicsContext.selectAll('text').remove();
                // Create status graphic, if necessary
                var kpiImageDiv = this.kpiImage.select('div');
                if (!kpiImageDiv || kpiImageDiv.empty())
                    kpiImageDiv = this.kpiImage.append('div');
                // Style status graphic
                kpiImageDiv
                    .attr('class', statusGraphicInfo.class)
                    .style('position', 'absolute')
                    .style('font-size', labelTextSizeInPx + 'px');
                // Layout thrash to get image dimensions (could set as a const in future when icon font is fixed)
                var imageWidth = kpiImageDiv.node().offsetWidth;
                var imageHeight = kpiImageDiv.node().offsetHeight;
                // Position based on image height
                kpiImageDiv.style('transform', visuals.SVGUtil.translateWithPixels((translateX - (imageWidth / 2)), this.getTranslateY(labelTextSizeInPx + translateY) - imageHeight));
            };
            Card.prototype.getDefaultFormatSettings = function () {
                return {
                    labelSettings: visuals.dataLabelUtils.getDefaultCardLabelSettings(Card.DefaultStyle.value.color, Card.DefaultStyle.label.color, Card.DefaultStyle.value.textSize),
                    wordWrap: false,
                    textSize: Card.DefaultStyle.label.textSize,
                };
            };
            Card.prototype.enumerateObjectInstances = function (options) {
                if (!this.cardFormatSetting)
                    this.cardFormatSetting = this.getDefaultFormatSettings();
                var formatSettings = this.cardFormatSetting;
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'categoryLabels':
                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, formatSettings.labelSettings, true /* withFill */, true /* isShowCategory */, formatSettings.textSize);
                        break;
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: formatSettings.labelSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                            fontSize: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                    case 'wordWrap':
                        enumeration.pushInstance({
                            objectName: 'wordWrap',
                            selector: null,
                            properties: {
                                show: formatSettings.wordWrap,
                            },
                        });
                        break;
                }
                return enumeration.complete();
            };
            Card.cardClassName = 'card';
            Card.Label = createClassAndSelector('label');
            Card.Value = createClassAndSelector('value');
            Card.KPIImage = createClassAndSelector('caption');
            Card.cardTextProperties = {
                fontSize: null,
                text: null,
                fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
            };
            Card.DefaultStyle = {
                card: {
                    maxFontSize: 200
                },
                label: {
                    textSize: 12,
                    color: '#a6a6a6',
                    paddingTop: 8
                },
                value: {
                    textSize: 27,
                    color: '#333333',
                    fontFamily: 'wf_segoe-ui_Semibold'
                }
            };
            return Card;
        }(visuals.AnimatedText));
        visuals.Card = Card;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var OwlHappiness;
        (function (OwlHappiness) {
            OwlHappiness[OwlHappiness["Sad"] = 0] = "Sad";
            OwlHappiness[OwlHappiness["Meh"] = 1] = "Meh";
            OwlHappiness[OwlHappiness["Happy"] = 2] = "Happy";
        })(OwlHappiness || (OwlHappiness = {}));
        var OwlGauge = (function () {
            function OwlGauge() {
            }
            OwlGauge.converter = function (dataView) {
                return {};
            };
            OwlGauge.getGaugeData = function (dataView) {
                var settings = {
                    max: 100,
                    min: 0,
                    target: undefined,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
                    var values = dataView.categorical.values;
                    var metadataColumns = dataView.metadata.columns;
                    debug.assert(metadataColumns.length >= values.length, 'length');
                    for (var i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        if (col && col.roles) {
                            if (col.roles[visuals.gaugeRoleNames.y]) {
                                settings.total = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                            else if (col.roles[visuals.gaugeRoleNames.minValue]) {
                                settings.min = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.maxValue]) {
                                settings.max = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.targetValue]) {
                                settings.target = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                        }
                    }
                }
                return settings;
            };
            OwlGauge.prototype.init = function (options) {
                var _this = this;
                this.rootElem = options.element;
                this.rootElem.addClass('owlGaugeVisual');
                this.svgTailElem = $(OwlGauge.owlTailSvg);
                this.svgBgElem = $(OwlGauge.visualBgSvg);
                this.svgBodyElem = $(OwlGauge.owlBodySvg);
                this.rootElem.append(this.svgBgElem).append(this.svgTailElem).append(this.svgBodyElem);
                if (OwlGauge.OwlDemoMode) {
                    window.setInterval(function () {
                        var randomPercentage = Math.random() * 100 + 1;
                        _this.updateGauge(randomPercentage);
                    }, 2000);
                }
                this.updateViewportSize(options.viewport.width, options.viewport.height);
            };
            OwlGauge.prototype.update = function (options) {
                this.updateViewportSize(options.viewport.width, options.viewport.height);
                var dataView = options.dataViews.length > 0 ? options.dataViews[0] : null;
                if (dataView) {
                    var gaugeData = OwlGauge.getGaugeData(options.dataViews[0]);
                    var percentage = (gaugeData.total - gaugeData.min) / (gaugeData.max - gaugeData.min);
                    this.updateGauge(percentage * 100 | 0);
                }
                else
                    this.updateGauge(0);
            };
            OwlGauge.prototype.updateGauge = function (percentage) {
                if (percentage >= 0 && percentage <= 100) {
                    var rotationDeg = -180 + (180 * percentage / 100);
                    this.svgBgElem.css({ transform: 'rotate(' + rotationDeg + 'deg)' });
                    if (percentage >= 66) {
                        this.happinessLevel = OwlHappiness.Happy;
                    }
                    else if (percentage >= 33) {
                        this.happinessLevel = OwlHappiness.Meh;
                    }
                    else {
                        this.happinessLevel = OwlHappiness.Sad;
                    }
                }
            };
            Object.defineProperty(OwlGauge.prototype, "happinessLevel", {
                set: function (level) {
                    this.rootElem.removeClass('sad').removeClass('meh').removeClass('happy');
                    switch (level) {
                        case OwlHappiness.Sad:
                            this.rootElem.addClass('sad');
                            break;
                        case OwlHappiness.Meh:
                            this.rootElem.addClass('meh');
                            break;
                        case OwlHappiness.Happy:
                            this.rootElem.addClass('happy');
                            break;
                        default:
                            console.log('Well, this is interesting...');
                    }
                },
                enumerable: true,
                configurable: true
            });
            OwlGauge.prototype.updateViewportSize = function (width, height) {
                var _this = this;
                var smoothingFn = window.setImmediate || window.requestAnimationFrame;
                smoothingFn(function () {
                    _this.rootElem.css({
                        height: height,
                        width: width
                    });
                    _this.svgBodyElem.height(_this.svgBodyElem.width() * OwlGauge.owlBodyHeightMultiplier);
                    _this.svgBgElem.height(_this.svgBgElem.width() * OwlGauge.visualBgHeightMultiplier);
                    _this.svgTailElem.height(_this.svgTailElem.width() * OwlGauge.owlTailHeightMultiplier);
                });
            };
            OwlGauge.owlBodySvg = '<svg version="1.1" class="owlGaugeBody" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 267.7 291.2" style="enable-background:new 0 0 267.7 291.2;" xml:space="preserve"> <style type="text/css"> .owlGaugeBody .st0{fill:#A87D50;} .owlGaugeBody .st1{fill:#C2B59B;} .owlGaugeBody .st2{fill:#EB2227;} .owlGaugeBody .st3{fill:#FFFFFF;} .owlGaugeBody .st4{fill:#F9D018;} .owlGaugeBody .st5{fill:none;} .owlGaugeBody .st6{fill:#83381B;} .owlGaugeBody .st7{fill:#231F20;} </style> <g id="XMLID_31_"> <g id="XMLID_34_"> <ellipse id="XMLID_21_" transform="matrix(0.9998 1.947640e-02 -1.947640e-02 0.9998 2.8614 -2.5802)" class="st0" cx="133.9" cy="145.6" rx="133.9" ry="145.6"/> <polygon id="XMLID_20_" class="st0" points="199.2,32.8 184,11.3 209,9.7 "/> <polygon id="XMLID_19_" class="st0" points="73.9,31.2 62.1,7.7 87.1,9.8 "/> <circle id="XMLID_18_" class="st1" cx="134.8" cy="189.2" r="89.8"/> <path id="XMLID_17_" class="st2" d="M140.1,88c-2.7,3.8-7.9,4.7-11.7,2c-2.7-1.9-3.9-5.1-3.4-8.1c0,0,9.6-41.8,9.6-41.8l6.9,40.8 C142,83.2,141.6,85.8,140.1,88z"/> <path id="XMLID_16_" class="st3" d="M164.6,16.2c-14.2,0-26.3,9.2-30.6,21.9c-4.1-13.1-16.3-22.6-30.8-22.6 C85.4,15.6,71,30,71,47.8s14.4,32.3,32.3,32.3c14.2,0,26.3-9.2,30.6-21.9c4.1,13.1,16.3,22.6,30.8,22.6 c17.8,0,32.3-14.4,32.3-32.3S182.4,16.2,164.6,16.2z"/> <path id="XMLID_15_" class="st4" d="M122,58.7l23.3-0.1c0,0-9,14.8-10.2,16.6c-1.2,1.9-2.2,0.1-2.2,0.1L122,58.7z"/> <rect id="XMLID_14_" x="-11.4" y="-68.8" class="st5" width="288.3" height="259.7"/> <g id="XMLID_37_"> <path id="XMLID_13_" class="st6" d="M121.6,125.5c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_12_" class="st6" d="M160.1,126.5c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_11_" class="st6" d="M142.4,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_10_" class="st6" d="M183.1,148.8c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_9_" class="st6" d="M160.9,177.4c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_8_" class="st6" d="M201.6,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_7_" class="st6" d="M76.4,177.4c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_6_" class="st6" d="M117,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_5_" class="st6" d="M98.6,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> </g> <circle id="XMLID_4_" class="st7" cx="164.1" cy="49" r="6.4"/> <circle id="XMLID_3_" class="st7" cx="102.7" cy="47.7" r="6.4"/> </g> <path id="XMLID_2_" class="st0" d="M160.1,140.9c11.1-8.4,55.6-36,55.6-36l4.7,0.8l10.2,38.8c0,0-3,3-9.2,3.1 c-5.1,0.1-45.9-2.6-60.2-3.5C158.1,143.9,157.7,142.7,160.1,140.9z"/> <path id="XMLID_1_" class="st0" d="M110.6,140.8c-11.1-8.4-55.6-36-55.6-36l-4.7,0.8L40,144.4c0,0,3,3,9.2,3.1 c5.1,0.1,45.9-2.6,60.2-3.5C112.5,143.8,113,142.6,110.6,140.8z"/> </g> </svg>';
            OwlGauge.owlTailSvg = '<svg version="1.1" class="owlGaugeTail" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 587.8 295.5" style="enable-background:new 0 0 587.8 295.5;" xml:space="preserve"> <style type="text/css"> .owlGaugeTail .st0{fill:#3B2416;} .owlGaugeTail .st1{fill:#5B4B43;} .owlGaugeTail .st2{fill:#603A17;} .owlGaugeTail .st3{fill:#726659;} </style> <g id="XMLID_55_"> <path id="XMLID_29_" class="st0" d="M85.2,106.2c-27.1,0-49.2,22-49.2,49.2c0,19.1,10.9,35.7,26.9,43.8c0,0,231.2,95.9,231.2,95.9 l-171-171C114.1,113.2,100.5,106.2,85.2,106.2z"/> <g id="XMLID_56_"> <path id="XMLID_28_" class="st1" d="M482.5,86.4c0-27.1-22-49.2-49.2-49.2c-19.1,0-35.7,10.9-43.8,26.9c0,0-95.9,231.2-95.9,231.2 l171-171C475.5,115.3,482.5,101.7,482.5,86.4z"/> <path id="XMLID_27_" class="st2" d="M573.5,281.3c19.2-19.2,19.2-50.3,0-69.5c-13.5-13.5-33-17.5-50-12c0,0-231.3,95.7-231.3,95.7 l241.8,0C548,296.9,562.6,292.1,573.5,281.3z"/> <path id="XMLID_26_" class="st3" d="M279.9,14.4c-19.2-19.2-50.3-19.2-69.5,0c-13.5,13.5-17.5,33-12,50c0,0,95.7,231.3,95.7,231.3 L294,54C295.4,39.8,290.7,25.2,279.9,14.4z"/> <path id="XMLID_25_" class="st2" d="M105.3,86.4c0-27.1,22-49.2,49.2-49.2c19.1,0,35.7,10.9,43.8,26.9c0,0,95.9,231.2,95.9,231.2 l-171-171C112.3,115.3,105.3,101.7,105.3,86.4z"/> <path id="XMLID_24_" class="st2" d="M14.4,281.4c-19.2-19.2-19.2-50.3,0-69.5c13.5-13.5,33-17.5,50-12c0,0,231.3,95.7,231.3,95.7 l-241.8,0C39.8,297,25.2,292.3,14.4,281.4z"/> <path id="XMLID_23_" class="st2" d="M308.2,14c19.2-19.2,50.3-19.2,69.5,0c13.5,13.5,17.5,33,12,50c0,0-95.7,231.3-95.7,231.3 l0-241.8C292.6,39.4,297.4,24.8,308.2,14z"/> <path id="XMLID_22_" class="st0" d="M503.2,106c27.1,0,49.2,22,49.2,49.2c0,19.1-10.9,35.7-26.9,43.8c0,0-231.2,95.9-231.2,95.9 l171-171C474.2,113,487.8,106,503.2,106z"/> </g> </g> </svg>';
            OwlGauge.visualBgSvg = '<svg version="1.1" class="owlGaugeBg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="123.8 94.9 349.1 175.3" style="enable-background:new 123.8 94.9 349.1 175.3;" xml:space="preserve"> <style type="text/css"> .owlGaugeBg .st0{fill:#EF4137;} .owlGaugeBg .st1{fill:#FAAF42;} .owlGaugeBg .st2{fill:#F15B2A;} .owlGaugeBg .st3{fill:#F69321;} </style> <g id="XMLID_10_"> <path id="XMLID_8_" class="st0" d="M174.3,158c-16.1,0-29.2,13.1-29.2,29.2c0,11.4,6.5,21.2,16,26.1l137.3,57L196.9,168.7 C191.5,162.2,183.4,158,174.3,158z"/> <g id="XMLID_11_"> <path id="XMLID_7_" class="st1" d="M410.2,146.3c0-16.1-13.1-29.2-29.2-29.2c-11.4,0-21.2,6.5-26,16l-57,137.5L399.5,169 C406.1,163.5,410.2,155.4,410.2,146.3z"/> <path id="XMLID_6_" class="st0" d="M464.3,262.2c11.4-11.4,11.4-29.9,0-41.3c-8-8-19.6-10.4-29.7-7.1l-137.4,56.9h143.6 C449.2,271.4,457.9,268.6,464.3,262.2z"/> <path id="XMLID_5_" class="st2" d="M290,103.5c-11.4-11.4-29.9-11.4-41.3,0c-8,8-10.4,19.6-7.1,29.7l56.8,137.5V127 C299.2,118.6,296.4,109.9,290,103.5z"/> <path id="XMLID_4_" class="st3" d="M186.3,146.3c0-16.1,13.1-29.2,29.2-29.2c11.4,0,21.2,6.5,26,16l57,137.5L197,168.8 C190.5,163.5,186.3,155.4,186.3,146.3z"/> <path id="XMLID_3_" class="st2" d="M132.3,262.2c-11.4-11.4-11.4-29.9,0-41.3c8-8,19.6-10.4,29.7-7.1l137.4,56.9H155.8 C147.4,271.5,138.7,268.7,132.3,262.2z"/> <path id="XMLID_2_" class="st3" d="M306.8,103.2c11.4-11.4,29.9-11.4,41.3,0c8,8,10.4,19.6,7.1,29.7l-56.8,137.5V126.7 C297.5,118.3,300.3,109.7,306.8,103.2z"/> <path id="XMLID_1_" class="st2" d="M422.5,157.9c16.1,0,29.2,13.1,29.2,29.2c0,11.4-6.5,21.2-16,26.1l-137.3,57L400,168.6 C405.3,162.1,413.4,157.9,422.5,157.9z"/> </g> </g> </svg>';
            OwlGauge.owlBodyHeightMultiplier = 291.2 / 267.7;
            OwlGauge.owlTailHeightMultiplier = 295.5 / 587.8;
            OwlGauge.visualBgHeightMultiplier = 295.5 / 587.8;
            OwlGauge.OwlDemoMode = false;
            OwlGauge.capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                    },
                    {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                    },
                ],
                dataViewMappings: [{
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{ bind: { to: 'Y' } }]
                        },
                    }]
            };
            return OwlGauge;
        }());
        visuals.OwlGauge = OwlGauge;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var NoMapLocationWarning = (function () {
            function NoMapLocationWarning() {
            }
            Object.defineProperty(NoMapLocationWarning.prototype, "code", {
                get: function () {
                    return 'NoMapLocation';
                },
                enumerable: true,
                configurable: true
            });
            NoMapLocationWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoMapLocationMessage';
                var titleKey = 'NoMapLocationKey';
                var detailKey = 'NoMapLocationValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return NoMapLocationWarning;
        }());
        visuals.NoMapLocationWarning = NoMapLocationWarning;
        var FilledMapWithoutValidGeotagCategoryWarning = (function () {
            function FilledMapWithoutValidGeotagCategoryWarning() {
            }
            Object.defineProperty(FilledMapWithoutValidGeotagCategoryWarning.prototype, "code", {
                get: function () {
                    return 'NoValidGeotaggedCategory';
                },
                enumerable: true,
                configurable: true
            });
            FilledMapWithoutValidGeotagCategoryWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoValidGeotaggedCategoryMessage';
                var titleKey = 'NoValidGeotaggedCategoryKey';
                var detailKey = 'NoValidGeotaggedCategoryValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return FilledMapWithoutValidGeotagCategoryWarning;
        }());
        visuals.FilledMapWithoutValidGeotagCategoryWarning = FilledMapWithoutValidGeotagCategoryWarning;
        var GeometryCulledWarning = (function () {
            function GeometryCulledWarning() {
            }
            Object.defineProperty(GeometryCulledWarning.prototype, "code", {
                get: function () {
                    return 'GeometryCulledWarning';
                },
                enumerable: true,
                configurable: true
            });
            GeometryCulledWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'GeometryCulledWarningMessage';
                var titleKey = 'GeometryCulledWarningKey';
                var detailKey = 'GeometryCulledWarningVal';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return GeometryCulledWarning;
        }());
        visuals.GeometryCulledWarning = GeometryCulledWarning;
        var NegativeValuesNotSupportedWarning = (function () {
            function NegativeValuesNotSupportedWarning() {
            }
            Object.defineProperty(NegativeValuesNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'NegativeValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            NegativeValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_NegativeValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return NegativeValuesNotSupportedWarning;
        }());
        visuals.NegativeValuesNotSupportedWarning = NegativeValuesNotSupportedWarning;
        var AllNegativeValuesWarning = (function () {
            function AllNegativeValuesWarning() {
            }
            Object.defineProperty(AllNegativeValuesWarning.prototype, "code", {
                get: function () {
                    return 'AllNegativeValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            AllNegativeValuesWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_AllNegativeValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return AllNegativeValuesWarning;
        }());
        visuals.AllNegativeValuesWarning = AllNegativeValuesWarning;
        var NaNNotSupportedWarning = (function () {
            function NaNNotSupportedWarning() {
            }
            Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'NaNNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            NaNNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_NanValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return NaNNotSupportedWarning;
        }());
        visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
        var InfinityValuesNotSupportedWarning = (function () {
            function InfinityValuesNotSupportedWarning() {
            }
            Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'InfinityValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            InfinityValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_InfinityValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return InfinityValuesNotSupportedWarning;
        }());
        visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
        var ValuesOutOfRangeWarning = (function () {
            function ValuesOutOfRangeWarning() {
            }
            Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
                get: function () {
                    return 'ValuesOutOfRange';
                },
                enumerable: true,
                configurable: true
            });
            ValuesOutOfRangeWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_VisualizationOutOfRange';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return ValuesOutOfRangeWarning;
        }());
        visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
        var ZeroValueWarning = (function () {
            function ZeroValueWarning() {
            }
            Object.defineProperty(ZeroValueWarning.prototype, "code", {
                get: function () {
                    return "ZeroValuesNotSupported";
                },
                enumerable: true,
                configurable: true
            });
            ZeroValueWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_ZeroValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return ZeroValueWarning;
        }());
        visuals.ZeroValueWarning = ZeroValueWarning;
        var VisualKPIDataMissingWarning = (function () {
            function VisualKPIDataMissingWarning() {
            }
            Object.defineProperty(VisualKPIDataMissingWarning.prototype, "code", {
                get: function () {
                    return "VisualKPIDataMissing";
                },
                enumerable: true,
                configurable: true
            });
            VisualKPIDataMissingWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_KPI_DataMissing';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return VisualKPIDataMissingWarning;
        }());
        visuals.VisualKPIDataMissingWarning = VisualKPIDataMissingWarning;
        var ScriptVisualRefreshWarning = (function () {
            function ScriptVisualRefreshWarning() {
            }
            Object.defineProperty(ScriptVisualRefreshWarning.prototype, "code", {
                get: function () {
                    return "ScriptVisualNotRefreshed";
                },
                enumerable: true,
                configurable: true
            });
            ScriptVisualRefreshWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'ScriptVisualRefreshWarningMessage';
                var detailKey = 'ScriptVisualRefreshWarningValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return ScriptVisualRefreshWarning;
        }());
        visuals.ScriptVisualRefreshWarning = ScriptVisualRefreshWarning;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var WaterfallChart = (function () {
            function WaterfallChart(options) {
                this.isScrollable = options.isScrollable;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.interactivityService = options.interactivityService;
            }
            WaterfallChart.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.svg = options.svg;
                this.svg.classed(WaterfallChart.WaterfallClassName, true);
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.element = options.element;
                this.colors = this.style.colorPalette.dataColors;
                this.mainGraphicsSVG = this.svg.append('svg');
                this.mainGraphicsContext = this.mainGraphicsSVG.append('g')
                    .classed(WaterfallChart.MainGraphicsContextClassName, true);
                this.labelGraphicsContext = this.mainGraphicsSVG.append('g')
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
            };
            WaterfallChart.converter = function (dataView, palette, hostServices, dataLabelSettings, sentimentColors, interactivityService, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                debug.assertValue(palette, 'palette');
                var formatStringProp = WaterfallChart.formatStringProp;
                var categories = dataView.categorical.categories || [];
                var increaseColor = sentimentColors.increaseFill.solid.color;
                var decreaseColor = sentimentColors.decreaseFill.solid.color;
                var totalColor = sentimentColors.totalFill.solid.color;
                var totalLabel = hostServices.getLocalizedString(WaterfallChart.TotalLabel);
                var increaseLabel = hostServices.getLocalizedString(WaterfallChart.IncreaseLabel);
                var decreaseLabel = hostServices.getLocalizedString(WaterfallChart.DecreaseLabel);
                var legend = [
                    {
                        label: increaseLabel,
                        color: increaseColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure('increase').createSelectionId(),
                        selected: false,
                    }, {
                        label: decreaseLabel,
                        color: decreaseColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure('decrease').createSelectionId(),
                        selected: false,
                    }, {
                        label: totalLabel,
                        color: totalColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure('total').createSelectionId(),
                        selected: false,
                    }];
                /**
                 * The position represents the starting point for each bar,
                 * for any value it is the sum of all previous values.
                 * Values > 0 are considered gains, values < 0 are losses.
                 */
                var pos = 0, posMin = 0, posMax = 0;
                var dataPoints = [];
                var categoryValues = [];
                var categoryMetadata;
                var values = dataView.categorical.values;
                var valuesMetadata = undefined;
                if (!_.isEmpty(values)) {
                    var column = values[0];
                    valuesMetadata = column.source;
                    var labelFormatString = valuesMetadata.format;
                    if (_.isEmpty(categories)) {
                        // We have values but no category, just show the total bar.
                        pos = posMax = column.values[0];
                        posMin = 0;
                    }
                    else {
                        var categoryColumn = categories[0];
                        categoryMetadata = categoryColumn.source;
                        categoryValues = categoryColumn.values.slice();
                        categoryValues.push(totalLabel);
                        for (var categoryIndex = 0, catLen = column.values.length; categoryIndex < catLen; categoryIndex++) {
                            var category = categoryValues[categoryIndex];
                            var value = column.values[categoryIndex] || 0;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(categoryColumn, categoryIndex)
                                .createSelectionId();
                            var tooltipInfo_5 = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo_5 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categorical, category, value);
                            }
                            var color = value > 0 ? increaseColor : decreaseColor;
                            dataPoints.push({
                                value: value,
                                position: pos,
                                color: color,
                                categoryValue: category,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: false,
                                identity: identity,
                                highlight: false,
                                key: identity.getKey(),
                                tooltipInfo: tooltipInfo_5,
                                labelFill: dataLabelSettings.labelColor,
                                labelFormatString: labelFormatString,
                            });
                            pos += value;
                            if (pos > posMax)
                                posMax = pos;
                            if (pos < posMin)
                                posMin = pos;
                        }
                    }
                    var tooltipInfo = void 0;
                    if (tooltipsEnabled) {
                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categorical, totalLabel, pos);
                    }
                    var totalIdentity = visuals.SelectionId.createNull();
                    dataPoints.push({
                        value: pos,
                        position: 0,
                        color: totalColor,
                        categoryValue: totalLabel,
                        categoryIndex: categoryIndex,
                        identity: totalIdentity,
                        seriesIndex: 0,
                        selected: false,
                        highlight: false,
                        key: totalIdentity.getKey(),
                        tooltipInfo: tooltipInfo,
                        labelFill: dataLabelSettings.labelColor,
                        labelFormatString: labelFormatString,
                        isTotal: true,
                    });
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(dataPoints);
                }
                var xAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                var yAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisProperties, yAxisProperties, categoryMetadata, [valuesMetadata]);
                return {
                    series: [{ data: dataPoints }],
                    categories: categoryValues,
                    categoryMetadata: categoryMetadata,
                    valuesMetadata: valuesMetadata,
                    legend: { dataPoints: legend },
                    hasHighlights: false,
                    positionMin: posMin,
                    positionMax: posMax,
                    dataLabelsSettings: dataLabelSettings,
                    sentimentColors: sentimentColors,
                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
                };
            };
            WaterfallChart.prototype.setData = function (dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var sentimentColors = this.getSentimentColorsFromObjects(null);
                var dataView = dataViews.length > 0 ? dataViews[0] : undefined;
                this.data = {
                    series: [{ data: [] }],
                    categories: [],
                    valuesMetadata: null,
                    legend: { dataPoints: [], },
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    positionMax: 0,
                    positionMin: 0,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(/* show */ false, /* labelColor */ undefined),
                    sentimentColors: sentimentColors,
                    axesLabels: { x: null, y: null },
                };
                if (dataView) {
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        var labelsObj = objects['labels'];
                        if (labelsObj) {
                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, this.data.dataLabelsSettings);
                        }
                        sentimentColors = this.getSentimentColorsFromObjects(objects);
                    }
                    if (dataView.categorical) {
                        this.data = WaterfallChart.converter(dataView, this.colors, this.hostServices, this.data.dataLabelsSettings, sentimentColors, this.interactivityService, this.tooltipsEnabled);
                    }
                }
            };
            WaterfallChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'sentimentColors':
                        this.enumerateSentimentColors(enumeration);
                        break;
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: this.data.dataLabelsSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                            fontSize: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                }
            };
            WaterfallChart.prototype.enumerateSentimentColors = function (enumeration) {
                var sentimentColors = this.data.sentimentColors;
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        increaseFill: sentimentColors.increaseFill,
                        decreaseFill: sentimentColors.decreaseFill,
                        totalFill: sentimentColors.totalFill
                    },
                    objectName: 'sentimentColors'
                });
            };
            WaterfallChart.prototype.calculateLegend = function () {
                // TODO: support interactive legend
                return this.data.legend;
            };
            WaterfallChart.prototype.hasLegend = function () {
                // Waterfall legend is more like a color-key, so just return true
                return true;
            };
            WaterfallChart.createClippedDataIfOverflowed = function (data, renderableDataCount) {
                var clipped = data;
                var dataPoints = data.series[0].data;
                if (data && renderableDataCount < dataPoints.length) {
                    clipped = powerbi.Prototype.inherit(data);
                    clipped.series = [{ data: dataPoints.slice(0, renderableDataCount) }];
                    clipped.categories = data.categories.slice(0, renderableDataCount);
                }
                return clipped;
            };
            WaterfallChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                this.margin = options.margin;
                var data = this.clippedData = this.data;
                var categoryCount = data.categories.length;
                var preferredPlotArea = this.getPreferredPlotArea(false, categoryCount, visuals.CartesianChart.MinOrdinalRectThickness);
                var cartesianLayout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: preferredPlotArea.width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
                // In the case that we have overflowed horizontally we want to clip the data and use that to calculate the axes on the dashboard.           
                if (!this.isScrollable) {
                    data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, cartesianLayout.categoryCount);
                }
                var xAxisCreationOptions = WaterfallChart.getXAxisCreationOptions(data, preferredPlotArea.width, cartesianLayout, options);
                var yAxisCreationOptions = WaterfallChart.getYAxisCreationOptions(data, preferredPlotArea.height, options);
                var xAxisProperties = this.xAxisProperties = visuals.AxisHelper.createAxis(xAxisCreationOptions);
                var yAxisProperties = this.yAxisProperties = visuals.AxisHelper.createAxis(yAxisCreationOptions);
                var categoryWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
                var labelSettings = data.dataLabelsSettings;
                var value2 = WaterfallChart.getDisplayUnitValueFromAxisFormatter(yAxisProperties, labelSettings);
                this.layout = {
                    categoryCount: cartesianLayout.categoryCount,
                    categoryThickness: cartesianLayout.categoryThickness,
                    isScalar: cartesianLayout.isScalar,
                    outerPaddingRatio: cartesianLayout.outerPaddingRatio,
                    categoryWidth: categoryWidth,
                    labelText: function (d) {
                        //total value has no identity
                        var formatter = formattersCache.getOrCreate(d.labelFormatString, labelSettings, value2);
                        return visuals.dataLabelUtils.getLabelFormattedText({ label: formatter.format(d.value) });
                    },
                    labelLayout: visuals.dataLabelUtils.getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, yAxisCreationOptions.dataDomain),
                    filter: function (d) {
                        return visuals.dataLabelUtils.doesDataLabelFitInShape(d, yAxisProperties, _this.layout);
                    },
                    style: {
                        'fill': function (d) {
                            if (d.isLabelInside)
                                return visuals.dataLabelUtils.defaultInsideLabelColor;
                            return d.labelFill;
                        },
                    },
                };
                this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null;
                return [xAxisProperties, yAxisProperties];
            };
            WaterfallChart.getDisplayUnitValueFromAxisFormatter = function (yAxisProperties, labelSettings) {
                return (yAxisProperties.formatter && yAxisProperties.formatter.displayUnit && labelSettings.displayUnits === 0) ? yAxisProperties.formatter.displayUnit.value : null;
            };
            WaterfallChart.lookupXValue = function (data, index, type) {
                var dataPoints = data.series[0].data;
                if (index === dataPoints.length - 1)
                    // Total
                    return dataPoints[index].categoryValue;
                else
                    return visuals.CartesianHelper.lookupXValue(data, index, type, false);
            };
            WaterfallChart.getXAxisCreationOptions = function (data, width, layout, options) {
                debug.assertValue(data, 'data');
                debug.assertValue(options, 'options');
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata);
                var domain = visuals.AxisHelper.createDomain(data.series, categoryDataType, /* isScalar */ false, options.forcedXDomain, options.ensureXDomain);
                var categoryThickness = layout.categoryThickness;
                var outerPadding = categoryThickness * layout.outerPaddingRatio;
                return {
                    pixelSpan: width,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, WaterfallChart.formatStringProp),
                    isScalar: false,
                    outerPadding: outerPadding,
                    categoryThickness: categoryThickness,
                    getValueFn: function (index, type) { return WaterfallChart.lookupXValue(data, index, type); },
                    forcedTickCount: options.forcedTickCount,
                    isCategoryAxis: true,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                };
            };
            WaterfallChart.getYAxisCreationOptions = function (data, height, options) {
                debug.assertValue(data, 'data');
                debug.assertValue(options, 'options');
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [data.positionMin, data.positionMax], options.ensureYDomain);
                return {
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    isScalar: true,
                    isVertical: true,
                    metaDataColumn: data.valuesMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.valuesMetadata, WaterfallChart.formatStringProp),
                    outerPadding: 0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision
                };
            };
            WaterfallChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin);
            };
            WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return false;
            };
            WaterfallChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            WaterfallChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = [{ data: data.series[0].data.slice(startIndex, endIndex) }];
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            WaterfallChart.prototype.createRects = function (data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var colsSelection = mainGraphicsContext.selectAll(WaterfallChart.CategoryValueClasses.selector);
                var cols = colsSelection.data(data, function (d) { return d.key; });
                cols
                    .enter()
                    .append('rect')
                    .attr('class', function (d) { return WaterfallChart.CategoryValueClasses.class.concat(d.highlight ? 'highlight' : ''); });
                cols.exit().remove();
                return cols;
            };
            WaterfallChart.prototype.createConnectors = function (data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var connectorSelection = mainGraphicsContext.selectAll(WaterfallChart.WaterfallConnectorClasses.selector);
                var connectors = connectorSelection.data(data.slice(0, data.length - 1), function (d) { return d.key; });
                connectors
                    .enter()
                    .append('line')
                    .classed(WaterfallChart.WaterfallConnectorClasses.class, true);
                connectors.exit().remove();
                return connectors;
            };
            WaterfallChart.prototype.render = function (suppressAnimations) {
                var _this = this;
                var dataPoints = this.clippedData.series[0].data;
                var bars = this.createRects(dataPoints);
                var connectors = this.createConnectors(dataPoints);
                if (this.tooltipsEnabled)
                    visuals.TooltipManager.addTooltip(bars, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var y0 = yScale(0);
                this.mainGraphicsSVG.attr('height', this.getAvailableHeight())
                    .attr('width', this.getAvailableWidth());
                /**
                 * The y-value is always at the top of the rect. If the data value is negative then we can
                 * use the scaled position directly since we are drawing down. If the data value is positive
                 * we have to calculate the top of the rect and use that as the y-value. Since the y-value
                 * is always the top of the rect, height should always be positive.
                 */
                bars
                    .style('fill', function (d) { return d.color; })
                    .style('fill-opacity', function (d) { return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, _this.data.hasHighlights); })
                    .attr('width', this.layout.categoryWidth)
                    .attr('x', function (d) { return xScale(d.categoryIndex); })
                    .attr('y', function (d) { return WaterfallChart.getRectTop(yScale, d.position, d.value); })
                    .attr('height', function (d) { return y0 - yScale(Math.abs(d.value)); });
                connectors
                    .attr({
                    'x1': function (d) { return xScale(d.categoryIndex); },
                    'y1': function (d) { return yScale(d.position + d.value); },
                    'x2': function (d) { return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth; },
                    'y2': function (d) { return yScale(d.position + d.value); },
                });
                var labelSettings = this.data.dataLabelsSettings;
                var labelDataPoints = [];
                if (labelSettings && labelSettings.show || labelSettings.showCategory) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    behaviorOptions = {
                        bars: bars,
                        datapoints: dataPoints,
                    };
                }
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return { dataPoints: dataPoints, behaviorOptions: behaviorOptions, labelDataPoints: labelDataPoints, labelsAreNumeric: true };
            };
            WaterfallChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            WaterfallChart.prototype.getSupportedCategoryAxisType = function () {
                return visuals.axisType.categorical;
            };
            WaterfallChart.getRectTop = function (scale, pos, value) {
                if (value < 0)
                    return scale(pos);
                else
                    return scale(pos) - (scale(0) - scale(value));
            };
            WaterfallChart.prototype.getAvailableWidth = function () {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            WaterfallChart.prototype.getAvailableHeight = function () {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            WaterfallChart.prototype.getSentimentColorsFromObjects = function (objects) {
                var defaultSentimentColors = this.colors.getSentimentColors();
                var increaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.increaseFill, defaultSentimentColors[2].value);
                var decreaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.decreaseFill, defaultSentimentColors[0].value);
                var totalColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.totalFill, WaterfallChart.defaultTotalColor);
                return {
                    increaseFill: { solid: { color: increaseColor } },
                    decreaseFill: { solid: { color: decreaseColor } },
                    totalFill: { solid: { color: totalColor } }
                };
            };
            // Public for testing
            WaterfallChart.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var y0 = yScale(0);
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, data.dataLabelsSettings);
                var labelSettings = this.data.dataLabelsSettings;
                for (var _i = 0, series_6 = series; _i < series_6.length; _i++) {
                    var currentSeries = series_6[_i];
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        // Calculate parent rectangle
                        var parentRect = {
                            left: xScale(dataPoint.categoryIndex),
                            top: WaterfallChart.getRectTop(yScale, dataPoint.position, dataPoint.value),
                            width: this.layout.categoryWidth,
                            height: y0 - yScale(Math.abs(dataPoint.value)),
                        };
                        // Calculate label text
                        var formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, this.data.dataLabelsSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                            insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: dataPoint.value === 0 ? WaterfallChart.validZeroLabelPosition : WaterfallChart.validLabelPositions,
                            },
                            fontSize: labelSettings.fontSize,
                            identity: undefined,
                        });
                    }
                }
                return labelDataPoints;
            };
            WaterfallChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            WaterfallChart.WaterfallClassName = 'waterfallChart';
            WaterfallChart.MainGraphicsContextClassName = 'mainGraphicsContext';
            WaterfallChart.IncreaseLabel = "Waterfall_IncreaseLabel";
            WaterfallChart.DecreaseLabel = "Waterfall_DecreaseLabel";
            WaterfallChart.TotalLabel = "Waterfall_TotalLabel";
            WaterfallChart.CategoryValueClasses = createClassAndSelector('column');
            WaterfallChart.WaterfallConnectorClasses = createClassAndSelector('waterfall-connector');
            WaterfallChart.defaultTotalColor = "#00b8aa";
            WaterfallChart.validLabelPositions = [16 /* OutsideEnd */, 4 /* InsideEnd */];
            WaterfallChart.validZeroLabelPosition = [16 /* OutsideEnd */, 8 /* OutsideBase */];
            return WaterfallChart;
        }());
        visuals.WaterfallChart = WaterfallChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TouchUtils = powerbi.visuals.controls.TouchUtils;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        ;
        var ContainerClassName = createClassAndSelector("tooltip-container");
        var ContentContainerClassName = createClassAndSelector("tooltip-content-container");
        var ArrowClassName = createClassAndSelector("arrow");
        var TooltipHeaderClassName = createClassAndSelector("tooltip-header");
        var TooltipRowClassName = createClassAndSelector("tooltip-row");
        var TooltipColorCellClassName = createClassAndSelector("tooltip-color-cell");
        var TooltipTitleCellClassName = createClassAndSelector("tooltip-title-cell");
        var TooltipValueCellClassName = createClassAndSelector("tooltip-value-cell");
        var ToolTipComponent = (function () {
            function ToolTipComponent(tooltipOptions) {
                this.tooltipOptions = tooltipOptions;
                this.isTooltipVisible = false;
                if (!tooltipOptions) {
                    this.tooltipOptions = ToolTipComponent.DefaultTooltipOptions;
                }
            }
            ToolTipComponent.prototype.isTooltipComponentVisible = function () {
                return this.isTooltipVisible;
            };
            /** Note: For tests only */
            ToolTipComponent.prototype.setTestScreenSize = function (width, height) {
                this.customScreenWidth = width;
                this.customScreenHeight = height;
            };
            ToolTipComponent.prototype.show = function (tooltipData, clickedArea) {
                this.isTooltipVisible = true;
                if (!this.tooltipContainer) {
                    this.tooltipContainer = this.createTooltipContainer();
                }
                this.setTooltipContent(tooltipData);
                this.tooltipContainer
                    .style("visibility", "visible")
                    .transition()
                    .duration(0) // Cancel previous transitions
                    .style("opacity", this.tooltipOptions.opacity);
                this.setPosition(clickedArea);
            };
            ToolTipComponent.prototype.move = function (tooltipData, clickedArea) {
                if (this.isTooltipVisible) {
                    if (tooltipData) {
                        this.setTooltipContent(tooltipData);
                    }
                    this.setPosition(clickedArea);
                }
            };
            ToolTipComponent.prototype.hide = function () {
                if (this.isTooltipVisible) {
                    this.isTooltipVisible = false;
                    this.tooltipContainer
                        .transition()
                        .duration(this.tooltipOptions.animationDuration)
                        .style("opacity", 0)
                        .each('end', function () { this.style.visibility = "hidden"; });
                }
            };
            ToolTipComponent.prototype.createTooltipContainer = function () {
                var container = d3.select(ToolTipComponent.parentContainerSelector)
                    .append("div")
                    .attr("class", ContainerClassName.class);
                container.append("div").attr("class", ArrowClassName.class);
                container.append("div").attr("class", ContentContainerClassName.class);
                return container;
            };
            ToolTipComponent.prototype.setTooltipContent = function (tooltipData) {
                if (_.isEqual(tooltipData, this.currentTooltipData))
                    return;
                this.currentTooltipData = tooltipData;
                var rowsSelector = TooltipRowClassName.selector;
                var contentContainer = this.tooltipContainer.select(ContentContainerClassName.selector);
                // Clear existing content
                contentContainer.selectAll(TooltipHeaderClassName.selector).remove();
                contentContainer.selectAll(TooltipRowClassName.selector).remove();
                if (tooltipData.length === 0)
                    return;
                if (tooltipData[0].header) {
                    contentContainer.append("div").attr("class", TooltipHeaderClassName.class).text(tooltipData[0].header);
                }
                var tooltipRow = contentContainer.selectAll(rowsSelector).data(tooltipData);
                var newRow = tooltipRow.enter().append("div").attr("class", TooltipRowClassName.class);
                if (tooltipData[0].color) {
                    var newColorCell = newRow.append("div").attr("class", TooltipColorCellClassName.class);
                    newColorCell
                        .append('svg')
                        .attr({
                        'width': '100%',
                        'height': '15px'
                    })
                        .append('circle')
                        .attr({
                        'cx': '5',
                        'cy': '8',
                        'r': '5'
                    })
                        .style({
                        'fill': function (d) { return d.color; }
                    });
                }
                var newTitleCell = newRow.append("div").attr("class", TooltipTitleCellClassName.class);
                var newValueCell = newRow.append("div").attr("class", TooltipValueCellClassName.class);
                newTitleCell.text(function (d) { return d.displayName; });
                newValueCell.text(function (d) { return d.value; });
            };
            ToolTipComponent.prototype.getTooltipPosition = function (clickedArea, clickedScreenArea) {
                var tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect();
                var centerPointOffset = Math.floor(clickedArea.width / 2);
                var offsetX = 0;
                var offsetY = 0;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var arrowOffset = 7;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
                }
                else if (clickedScreenArea === 2 /* BottomRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
                }
                centerPoint.offset(offsetX, offsetY);
                return centerPoint;
            };
            ToolTipComponent.prototype.setPosition = function (clickedArea) {
                var clickedScreenArea = this.getClickedScreenArea(clickedArea);
                var tooltipPosition = this.getTooltipPosition(clickedArea, clickedScreenArea);
                this.tooltipContainer.style({ "left": tooltipPosition.x + "px", "top": tooltipPosition.y + "px" });
                this.setArrowPosition(clickedArea, clickedScreenArea);
            };
            ToolTipComponent.prototype.setArrowPosition = function (clickedArea, clickedScreenArea) {
                var arrow = this.getArrowElement();
                var arrowClassName;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    arrowClassName = "top left";
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    arrowClassName = "top right";
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    arrowClassName = "bottom left";
                }
                else if (clickedScreenArea === 2 /* BottomRight */) {
                    arrowClassName = "bottom right";
                }
                arrow
                    .attr('class', 'arrow') // Reset all classes
                    .classed(arrowClassName, true);
            };
            ToolTipComponent.prototype.getArrowElement = function () {
                return this.tooltipContainer.select(ArrowClassName.selector);
            };
            ToolTipComponent.prototype.getClickedScreenArea = function (clickedArea) {
                var screenWidth = this.customScreenWidth || window.innerWidth;
                var screenHeight = this.customScreenHeight || window.innerHeight;
                var centerPointOffset = clickedArea.width / 2;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var halfWidth = screenWidth / 2;
                var halfHeight = screenHeight / 2;
                if (centerPoint.x < halfWidth && centerPoint.y < halfHeight) {
                    return 0 /* TopLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y < halfHeight) {
                    return 1 /* TopRight */;
                }
                else if (centerPoint.x < halfWidth && centerPoint.y >= halfHeight) {
                    return 3 /* BottomLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y >= halfHeight) {
                    return 2 /* BottomRight */;
                }
            };
            ToolTipComponent.DefaultTooltipOptions = {
                opacity: 1,
                animationDuration: 250,
                offsetX: 10,
                offsetY: 10
            };
            ToolTipComponent.parentContainerSelector = "body";
            ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName";
            return ToolTipComponent;
        }());
        visuals.ToolTipComponent = ToolTipComponent;
        var TooltipManager;
        (function (TooltipManager) {
            TooltipManager.ShowTooltips = true;
            TooltipManager.ToolTipInstance = new ToolTipComponent();
            var GlobalTooltipEventsAttached = false;
            var tooltipMouseOverDelay = 350;
            var tooltipMouseOutDelay = 500;
            var tooltipTouchDelay = 350;
            var tooltipTimeoutId;
            var handleTouchDelay = 1000;
            var handleTouchTimeoutId = 0;
            var mouseCoordinates;
            var tooltipData;
            function addTooltip(selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove, onMouseOutDelegate) {
                if (!TooltipManager.ShowTooltips) {
                    return;
                }
                debug.assertValue(selection, "selection");
                var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
                // Mouse events
                selection.on("mouseover", function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    // Ignore mouseover while handling touch events
                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
                        return;
                    mouseCoordinates = getCoordinates(rootNode, true);
                    var elementCoordinates = getCoordinates(target, true);
                    var tooltipEvent = {
                        data: data,
                        coordinates: mouseCoordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: false
                    };
                    clearTooltipTimeout();
                    // if it is already visible, change contents immediately (use 16ms minimum perceivable frame rate to prevent thrashing)
                    var delay = TooltipManager.ToolTipInstance.isTooltipComponentVisible() ? 16 : tooltipMouseOverDelay;
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delay);
                });
                selection.on("mouseout", function () {
                    if (!handleTouchTimeoutId) {
                        clearTooltipTimeout();
                        tooltipTimeoutId = hideDelayedTooltip(tooltipMouseOutDelay);
                    }
                    if (onMouseOutDelegate) {
                        onMouseOutDelegate();
                    }
                });
                selection.on("mousemove", function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    // Ignore mousemove while handling touch events
                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
                        return;
                    mouseCoordinates = getCoordinates(rootNode, true);
                    var elementCoordinates = getCoordinates(target, true);
                    var tooltipEvent = {
                        data: data,
                        coordinates: mouseCoordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: false
                    };
                    moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
                });
                // --- Touch events ---
                // TODO: static?
                var touchStartEventName = getTouchStartEventName();
                var touchEndEventName = getTouchEndEventName();
                var isPointerEvent = touchStartEventName === "pointerdown" || touchStartEventName === "MSPointerDown";
                if (!GlobalTooltipEventsAttached) {
                    // Add root container hide tooltip event
                    attachGlobalEvents(touchStartEventName);
                    GlobalTooltipEventsAttached = true;
                }
                selection.on(touchStartEventName, function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    hideTooltipEventHandler();
                    var coordinates = getCoordinates(rootNode, isPointerEvent);
                    var elementCoordinates = getCoordinates(target, isPointerEvent);
                    var tooltipEvent = {
                        data: data,
                        coordinates: coordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: true
                    };
                    clearTooltipTimeout();
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipTouchDelay);
                });
                selection.on(touchEndEventName, function () {
                    clearTooltipTimeout();
                    if (handleTouchTimeoutId)
                        clearTimeout(handleTouchTimeoutId);
                    // At the end of touch action, set a timeout that will let us ignore the incoming mouse events for a small amount of time
                    handleTouchTimeoutId = setTimeout(function () {
                        handleTouchTimeoutId = 0;
                    }, handleTouchDelay);
                });
            }
            TooltipManager.addTooltip = addTooltip;
            function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
                return setTimeout(function () { return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate); }, delayInMs);
            }
            TooltipManager.showDelayedTooltip = showDelayedTooltip;
            function hideDelayedTooltip(delayInMs) {
                return setTimeout(function () { return hideTooltipEventHandler(); }, delayInMs);
            }
            TooltipManager.hideDelayedTooltip = hideDelayedTooltip;
            function setLocalizedStrings(localizationOptions) {
                ToolTipComponent.localizationOptions = localizationOptions;
            }
            TooltipManager.setLocalizedStrings = setLocalizedStrings;
            function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
                var tooltipInfo = tooltipData || getTooltipInfoDelegate(tooltipEvent);
                if (!_.isEmpty(tooltipInfo)) {
                    var coordinates = mouseCoordinates || tooltipEvent.coordinates;
                    var clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
                    TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
                }
            }
            function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                tooltipData = undefined;
                if (reloadTooltipDataOnMouseMove) {
                    tooltipData = getTooltipInfoDelegate(tooltipEvent);
                }
                var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
                TooltipManager.ToolTipInstance.move(tooltipData, clickedArea);
            }
            ;
            function hideTooltipEventHandler() {
                TooltipManager.ToolTipInstance.hide();
            }
            ;
            function clearTooltipTimeout() {
                if (tooltipTimeoutId) {
                    clearTimeout(tooltipTimeoutId);
                }
            }
            function canDisplayTooltip(d3Event) {
                var cadDisplay = true;
                var mouseEvent = d3Event;
                if (mouseEvent.buttons !== undefined) {
                    // Check mouse buttons state
                    var hasMouseButtonPressed = mouseEvent.buttons !== 0;
                    cadDisplay = !hasMouseButtonPressed;
                }
                return cadDisplay;
            }
            function getTouchStartEventName() {
                var eventName = "touchstart";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerdown";
                }
                else if (window["MSPointerEvent"]) {
                    // IE10
                    eventName = "MSPointerDown";
                }
                return eventName;
            }
            function getTouchEndEventName() {
                var eventName = "touchend";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerup";
                }
                else if (window["MSPointerEvent"]) {
                    // IE10
                    eventName = "MSPointerUp";
                }
                return eventName;
            }
            function getCoordinates(rootNode, isPointerEvent) {
                var coordinates;
                if (isPointerEvent) {
                    // DO NOT USE - WebKit bug in getScreenCTM with nested SVG results in slight negative coordinate shift
                    // Also, IE will incorporate transform scale but WebKit does not, forcing us to detect browser and adjust appropriately.
                    // Just use non-scaled coordinates for all browsers, and adjust for the transform scale later (see lineChart.findIndex)
                    //coordinates = d3.mouse(rootNode);
                    // copied from d3_eventSource (which is not exposed)
                    var e = d3.event, s = void 0;
                    while (s = e.sourceEvent)
                        e = s;
                    var rect = rootNode.getBoundingClientRect();
                    coordinates = [e.clientX - rect.left - rootNode.clientLeft, e.clientY - rect.top - rootNode.clientTop];
                }
                else {
                    var touchCoordinates = d3.touches(rootNode);
                    if (touchCoordinates && touchCoordinates.length > 0) {
                        coordinates = touchCoordinates[0];
                    }
                }
                return coordinates;
            }
            function attachGlobalEvents(touchStartEventName) {
                d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, function (d, i) {
                    TooltipManager.ToolTipInstance.hide();
                });
            }
            function getClickedArea(x, y, isTouchEvent) {
                var width = 0;
                var pointX = x;
                var pointY = y;
                if (isTouchEvent) {
                    width = 12;
                    var offset = width / 2;
                    pointX = Math.max(x - offset, 0);
                    pointY = Math.max(y - offset, 0);
                }
                return new TouchUtils.Rectangle(pointX, pointY, width, width);
            }
        })(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
        var TooltipBuilder;
        (function (TooltipBuilder) {
            // TODO: implement options bag as input parameter
            function createTooltipInfo(formatStringProp, dataViewCat, categoryValue, value, categories, seriesData, seriesIndex, categoryIndex, highlightedValue, gradientValueColumn) {
                var categorySource;
                var seriesSource = [];
                var valuesSource = undefined;
                seriesIndex = seriesIndex | 0;
                var categoriesData = dataViewCat ? dataViewCat.categories : categories;
                if (categoriesData && categoriesData.length > 0) {
                    if (categoriesData.length > 1) {
                        var compositeCategoriesData = [];
                        for (var i = 0, ilen = categoriesData.length; i < ilen; i++) {
                            compositeCategoriesData.push(categoriesData[i].source);
                        }
                        categorySource = { value: categoryValue, metadata: compositeCategoriesData };
                    }
                    else {
                        categorySource = { value: categoryValue, metadata: [categoriesData[0].source] };
                    }
                }
                if (dataViewCat && dataViewCat.values) {
                    if (categorySource && categorySource.metadata[0] === dataViewCat.values.source) {
                    }
                    else {
                        valuesSource = dataViewCat.values.source;
                    }
                    if (dataViewCat.values.length > 0) {
                        var valueColumn = dataViewCat.values[seriesIndex];
                        var isAutoGeneratedColumn = !!(valueColumn && valueColumn.source && valueColumn.source.isAutoGeneratedColumn);
                        if (!isAutoGeneratedColumn) {
                            seriesSource.push({ value: value, highlightedValue: highlightedValue, metadata: valueColumn });
                        }
                    }
                    //Create Gradient tooltip value
                    var gradientToolTipData = createGradientToolTipData(gradientValueColumn, categoryIndex);
                    if (gradientToolTipData != null)
                        seriesSource.push(gradientToolTipData);
                }
                if (seriesData) {
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        var singleSeriesData = seriesData[i];
                        if (categorySource && categorySource.metadata[0] === singleSeriesData.metadata.source)
                            continue;
                        seriesSource.push({ value: singleSeriesData.value, metadata: singleSeriesData.metadata });
                    }
                }
                var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
                return tooltipInfo;
            }
            TooltipBuilder.createTooltipInfo = createTooltipInfo;
            function createGradientToolTipData(gradientValueColumn, categoryIndex) {
                if (gradientValueColumn) {
                    // Saturation color
                    return { value: gradientValueColumn.values[categoryIndex], metadata: { source: gradientValueColumn.source, values: [] } };
                }
                return null;
            }
            TooltipBuilder.createGradientToolTipData = createGradientToolTipData;
            function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
                debug.assertValue(seriesValues, "seriesSource");
                debug.assertValue(ToolTipComponent.localizationOptions, "ToolTipComponent.localizationOptions");
                debug.assertAnyValue(formatStringProp, 'formatStringProp');
                var items = [];
                if (categoryValue) {
                    if (categoryValue.metadata.length > 1) {
                        var displayName = '';
                        // This is being done simply for lat/long for now, as that's the only composite category we use.  If we ever have tooltips
                        //   involving other composite categories, we need to do a more thorough design and be more careful here.
                        for (var i = 0, ilen = categoryValue.metadata.length; i < ilen; i++) {
                            if (i !== 0)
                                displayName += '/';
                            displayName += categoryValue.metadata[i].displayName;
                        }
                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                        items.push({ displayName: displayName, value: categoryFormattedValue });
                    }
                    else {
                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                        items.push({ displayName: categoryValue.metadata[0].displayName, value: categoryFormattedValue });
                    }
                }
                if (valuesSource) {
                    // Dynamic series value
                    var dynamicValue = void 0;
                    if (seriesValues.length > 0) {
                        var dynamicValueMetadata = seriesValues[0].metadata.source;
                        dynamicValue = getFormattedValue(valuesSource, formatStringProp, dynamicValueMetadata.groupName);
                    }
                    items.push({ displayName: valuesSource.displayName, value: dynamicValue });
                }
                for (var i = 0; i < seriesValues.length; i++) {
                    var seriesData = seriesValues[i];
                    if (seriesData && seriesData.metadata) {
                        var seriesMetadataColumn = seriesData.metadata.source;
                        var value = seriesData.value;
                        var highlightedValue = seriesData.highlightedValue;
                        if (value || value === 0) {
                            var formattedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
                            items.push({ displayName: seriesMetadataColumn.displayName, value: formattedValue });
                        }
                        if (highlightedValue || highlightedValue === 0) {
                            var formattedHighlightedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue);
                            var displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                            items.push({ displayName: displayName, value: formattedHighlightedValue });
                        }
                    }
                }
                return items;
            }
            function getFormattedValue(column, formatStringProp, value) {
                var formatString = getFormatStringFromColumn(column, formatStringProp);
                return visuals.valueFormatter.format(value, formatString);
            }
            function getFormatStringFromColumn(column, formatStringProp) {
                if (column) {
                    var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
                    return formatString || column.format;
                }
                return null;
            }
        })(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualStyles;
        (function (visualStyles) {
            function create(dataColors) {
                if (dataColors === undefined)
                    dataColors = new visuals.DataColorPalette();
                return {
                    titleText: {
                        color: { value: 'rgba(51,51,51,1)' }
                    },
                    subTitleText: {
                        color: { value: 'rgba(145,145,145,1)' }
                    },
                    colorPalette: {
                        dataColors: dataColors,
                    },
                    labelText: {
                        color: {
                            value: 'rgba(51,51,51,1)',
                        },
                        fontSize: '11px'
                    },
                    isHighContrast: false,
                };
            }
            visualStyles.create = create;
        })(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        /**
         * Renders a donut chart.
         */
        var DonutChart = (function () {
            function DonutChart(options) {
                if (options) {
                    this.sliceWidthRatio = options.sliceWidthRatio;
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                    this.disableGeometricCulling = options.disableGeometricCulling ? options.disableGeometricCulling : false;
                    this.behavior = options.behavior;
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    if (options.smallViewPortProperties) {
                        this.maxHeightToScaleDonutLegend = options.smallViewPortProperties.maxHeightToScaleDonutLegend;
                    }
                }
                if (this.sliceWidthRatio == null) {
                    this.sliceWidthRatio = DonutChart.defaultSliceWidthRatio;
                }
            }
            DonutChart.converter = function (dataView, colors, defaultDataPointColor, viewport, disableGeometricCulling, interactivityService, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var converter = new DonutChartConversion.DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled);
                converter.convert();
                var d3PieLayout = d3.layout.pie()
                    .sort(null)
                    .value(function (d) {
                    return d.percentage;
                });
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(converter.dataPoints);
                    interactivityService.applySelectionStateToData(converter.legendData.dataPoints);
                }
                var culledDataPoints = (!disableGeometricCulling && viewport) ? DonutChart.cullDataByViewport(converter.dataPoints, converter.maxValue, viewport) : converter.dataPoints;
                return {
                    dataPointsToDeprecate: culledDataPoints,
                    dataPoints: d3PieLayout(culledDataPoints),
                    unCulledDataPoints: converter.dataPoints,
                    dataPointsToEnumerate: converter.legendData.dataPoints,
                    legendData: converter.legendData,
                    hasHighlights: converter.hasHighlights,
                    dataLabelsSettings: converter.dataLabelsSettings,
                    legendObjectProperties: converter.legendObjectProperties,
                    maxValue: converter.maxValue,
                    visibleGeometryCulled: converter.dataPoints.length !== culledDataPoints.length,
                };
            };
            DonutChart.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                // Ensure viewport is empty on init
                element.empty();
                this.parentViewport = options.viewport;
                // avoid deep copy
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                };
                this.formatter = visuals.valueFormatter.format;
                this.data = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: { title: "", dataPoints: [], fontSize: visuals.SVGLegend.DefaultFontSizeInPt },
                    hasHighlights: false,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                };
                this.drilled = false;
                // Leaving this false for now, will depend on the datacategory in the future
                this.allowDrilldown = false;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                this.radius = 0;
                this.isInteractive = options.interactivity && options.interactivity.isInteractiveLegend;
                var donutChartSettings = this.settings;
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(options.host);
                }
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.hostService = options.host;
                if (this.isInteractive) {
                    this.chartRotationAnimationDuration = (donutChartSettings && donutChartSettings.chartRotationAnimationDuration) ? donutChartSettings.chartRotationAnimationDuration : 0;
                    // Create interactive legend
                    var legendContainer = this.legendContainer = d3.select(element.get(0))
                        .append('div')
                        .classed(DonutChart.InteractiveLegendClassName, true);
                    this.interactivityState = {
                        interactiveLegend: new DonutChartInteractiveLegend(this, legendContainer, this.colors, options, this.settings),
                        valueToAngleFactor: 0,
                        sliceAngles: [],
                        currentRotate: 0,
                        interactiveChosenSliceFinishedSetting: false,
                        lastChosenInteractiveSliceIndex: 0,
                        totalDragAngleDifference: 0,
                        currentIndexDrag: 0,
                        previousIndexDrag: 0,
                        previousDragAngle: 0,
                        donutCenter: { x: 0, y: 0 },
                    };
                }
                this.svg = d3.select(element.get(0))
                    .append('svg')
                    .style('position', 'absolute')
                    .classed(DonutChart.ClassName, true);
                if (this.behavior)
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.mainGraphicsContext = this.svg.append('g');
                this.mainGraphicsContext.append("g")
                    .classed('slices', true);
                this.labelGraphicsContext = this.svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                this.pie = d3.layout.pie()
                    .sort(null)
                    .value(function (d) {
                    return d.percentage;
                });
            };
            DonutChart.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                // Viewport resizing
                var viewport = options.viewport;
                this.parentViewport = viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                    var dataViewMetadata = dataViews[0].metadata;
                    var defaultDataPointColor = undefined;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.donutChartProps.dataPoint.defaultColor);
                        }
                    }
                    this.data = DonutChart.converter(dataViews[0], this.colors, defaultDataPointColor, this.currentViewport, this.disableGeometricCulling, this.interactivityService, this.tooltipsEnabled);
                    this.data.defaultDataPointColor = defaultDataPointColor;
                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend))
                        this.renderLegend();
                }
                else {
                    this.data = {
                        dataPointsToDeprecate: [],
                        dataPointsToEnumerate: [],
                        dataPoints: [],
                        unCulledDataPoints: [],
                        legendData: { title: "", dataPoints: [] },
                        hasHighlights: false,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                    };
                }
                this.initViewportDependantProperties();
                this.initDonutProperties();
                this.updateInternal(this.data, options.suppressAnimations);
                this.hasSetData = true;
                if (dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    this.hostService.setWarnings(warnings);
                }
            };
            DonutChart.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport,
                });
            };
            DonutChart.prototype.onResizing = function (viewport) {
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: viewport,
                });
            };
            DonutChart.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                var dataLabelsSettings = this.data && this.data.dataLabelsSettings
                    ? this.data.dataLabelsSettings
                    : visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                switch (options.objectName) {
                    case 'legend':
                        this.enumerateLegend(enumeration);
                        break;
                    case 'dataPoint':
                        this.enumerateDataPoints(enumeration);
                        break;
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: dataLabelsSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                            fontSize: true,
                            labelStyle: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                }
                return enumeration.complete();
            };
            DonutChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var dataPoints = data.dataPointsToEnumerate;
                var dataPointsLength = dataPoints.length;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dataPoint = dataPoints[i];
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        displayName: dataPoint.label,
                        selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                        properties: {
                            fill: { solid: { color: dataPoint.color } }
                        },
                    });
                }
            };
            DonutChart.prototype.enumerateLegend = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var legendObjectProperties = { legend: data.legendObjectProperties };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.titleText, this.data.legendData.title);
                var labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData.labelColor);
                var labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData.fontSize);
                enumeration.pushInstance({
                    selector: null,
                    objectName: 'legend',
                    properties: {
                        show: show,
                        position: visuals.LegendPosition[this.legend.getOrientation()],
                        showTitle: showTitle,
                        titleText: titleText,
                        labelColor: labelColor,
                        fontSize: labelFontSize
                    }
                });
            };
            DonutChart.prototype.setInteractiveChosenSlice = function (sliceIndex) {
                var _this = this;
                if (this.interactivityState.sliceAngles.length === 0)
                    return;
                this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex;
                this.interactivityState.interactiveChosenSliceFinishedSetting = false;
                var viewport = this.currentViewport;
                var moduledIndex = sliceIndex % this.data.dataPoints.length;
                var angle = this.interactivityState.sliceAngles[moduledIndex];
                this.svg.select('g')
                    .transition()
                    .duration(this.chartRotationAnimationDuration)
                    .ease('elastic')
                    .attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, angle))
                    .each('end', function () { _this.interactivityState.interactiveChosenSliceFinishedSetting = true; });
                this.interactivityState.currentRotate = angle;
                this.interactivityState.interactiveLegend.updateLegend(moduledIndex);
                // Set the opacity of chosen slice to full and the others to semi-transparent
                this.svg.selectAll('.slice').attr('opacity', function (d, index) {
                    return index === moduledIndex ? 1 : 0.6;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.calculateRadius = function () {
                var viewport = this.currentViewport;
                if (!this.isInteractive && this.data && this.data.dataLabelsSettings.show) {
                    // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.
                    // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.
                    var hw = viewport.height / viewport.width;
                    var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
                    return Math.min(viewport.height, viewport.width) / denom;
                }
                // no labels (isInteractive does not have labels since the interactive legend shows extra info)
                return Math.min(viewport.height, viewport.width) / 2;
            };
            DonutChart.prototype.getScaleForLegendArrow = function () {
                var ratio = 1.0;
                if (this.maxHeightToScaleDonutLegend && this.currentViewport.height < this.maxHeightToScaleDonutLegend) {
                    ratio = this.currentViewport.height / this.maxHeightToScaleDonutLegend;
                }
                return ratio;
            };
            DonutChart.prototype.initViewportDependantProperties = function (duration) {
                if (duration === void 0) { duration = 0; }
                this.currentViewport.height = this.parentViewport.height;
                this.currentViewport.width = this.parentViewport.width;
                var viewport = this.currentViewport;
                if (this.isInteractive) {
                    viewport.height -= DonutChart.InteractiveLegendContainerHeight; // leave space for the legend
                }
                else {
                    var legendMargins = this.legend.getMargins();
                    viewport.height -= legendMargins.height;
                    viewport.width -= legendMargins.width;
                }
                this.svg.attr({
                    'width': viewport.width,
                    'height': viewport.height
                });
                if (this.isInteractive) {
                    this.legendContainer
                        .style({
                        'width': '100%',
                        'height': DonutChart.InteractiveLegendContainerHeight + 'px',
                        'overflow': 'hidden',
                        'top': 0
                    });
                    this.svg
                        .style('top', DonutChart.InteractiveLegendContainerHeight);
                }
                else {
                    visuals.Legend.positionChartArea(this.svg, this.legend);
                }
                this.previousRadius = this.radius;
                var radius = this.radius = this.calculateRadius();
                var halfViewportWidth = viewport.width / 2;
                var halfViewportHeight = viewport.height / 2;
                this.arc = d3.svg.arc();
                this.outerArc = d3.svg.arc()
                    .innerRadius(radius * DonutChart.OuterArcRadiusRatio)
                    .outerRadius(radius * DonutChart.OuterArcRadiusRatio);
                if (this.isInteractive) {
                    this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                    this.labelGraphicsContext.attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                }
                else {
                    this.mainGraphicsContext.transition().duration(duration).attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                    this.labelGraphicsContext.transition().duration(duration).attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.initDonutProperties = function () {
                this.donutProperties = {
                    viewport: this.currentViewport,
                    radius: this.radius,
                    arc: this.arc.innerRadius(0).outerRadius(this.radius * DonutChart.InnerArcRadiusRatio),
                    outerArc: this.outerArc,
                    innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
                    outerArcRadiusRatio: DonutChart.OuterArcRadiusRatio,
                    dataLabelsSettings: this.data.dataLabelsSettings,
                };
            };
            DonutChart.prototype.mergeDatasets = function (first, second) {
                var secondSet = d3.set();
                second.forEach(function (d) {
                    secondSet.add(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                });
                var onlyFirst = first.filter(function (d) {
                    return !secondSet.has(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                }).map(function (d) {
                    var derived = powerbi.Prototype.inherit(d);
                    derived.percentage === undefined ? derived.data.percentage = 0 : derived.percentage = 0;
                    return derived;
                });
                return d3.merge([second, onlyFirst]);
            };
            DonutChart.prototype.updateInternal = function (data, suppressAnimations, duration) {
                if (duration === void 0) { duration = 0; }
                var viewport = this.currentViewport;
                duration = duration || visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (this.animator) {
                    var layout = DonutChart.getLayout(this.radius, this.sliceWidthRatio, viewport);
                    var result = void 0;
                    var shapes_1;
                    var highlightShapes = void 0;
                    var labelSettings = data.dataLabelsSettings;
                    var labels = [];
                    if (labelSettings && labelSettings.show) {
                        labels = this.createLabels();
                    }
                    if (!suppressAnimations) {
                        var animationOptions = {
                            viewModel: data,
                            colors: this.colors,
                            graphicsContext: this.mainGraphicsContext,
                            labelGraphicsContext: this.labelGraphicsContext,
                            interactivityService: this.interactivityService,
                            layout: layout,
                            radius: this.radius,
                            sliceWidthRatio: this.sliceWidthRatio,
                            viewport: viewport,
                            labels: labels,
                            innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
                        };
                        result = this.animator.animate(animationOptions);
                        shapes_1 = result.shapes;
                        highlightShapes = result.highlightShapes;
                    }
                    if (suppressAnimations || result.failed) {
                        shapes_1 = DonutChart.drawDefaultShapes(this.svg, data, layout, this.colors, this.radius, this.interactivityService && this.interactivityService.hasSelection(), this.sliceWidthRatio, this.data.defaultDataPointColor);
                        highlightShapes = DonutChart.drawDefaultHighlightShapes(this.svg, data, layout, this.colors, this.radius, this.sliceWidthRatio);
                        visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, true, true /*has tooltip */);
                        visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
                    }
                    this.assignInteractions(shapes_1, highlightShapes, data);
                    if (this.tooltipsEnabled) {
                        visuals.TooltipManager.addTooltip(shapes_1, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                        visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    }
                }
                else {
                    this.updateInternalToMove(data, duration);
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.createLabels = function () {
                var labelLayout = new powerbi.DonutLabelLayout({
                    maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                    startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                }, this.donutProperties);
                var labelDataPoints = this.createLabelDataPoints();
                return labelLayout.layout(labelDataPoints);
            };
            DonutChart.prototype.createLabelDataPoints = function () {
                var data = this.data;
                var labelDataPoints = [];
                var measureFormatterCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
                var alternativeScale = null;
                if (data.dataLabelsSettings.displayUnits === 0)
                    alternativeScale = d3.max(data.dataPoints, function (d) { return Math.abs(d.data.measure); });
                for (var i = 0; i < this.data.dataPoints.length; i++) {
                    var label = this.createLabelDataPoint(data.dataPoints[i], alternativeScale, measureFormatterCache);
                    labelDataPoints.push(label);
                }
                return labelDataPoints;
            };
            DonutChart.prototype.createLabelDataPoint = function (d, alternativeScale, measureFormatterCache) {
                var labelPoint = this.outerArc.centroid(d);
                var labelX = visuals.DonutLabelUtils.getXPositionForDonutLabel(labelPoint[0]);
                var labelY = labelPoint[1];
                var labelSettings = this.data.dataLabelsSettings;
                var measureFormatter = measureFormatterCache.getOrCreate(d.data.labelFormatString, labelSettings, alternativeScale);
                var position = labelX < 0 ? 4 /* Left */ : 8 /* Right */;
                var pointPosition = {
                    point: {
                        x: labelX,
                        y: labelY,
                    },
                    validPositions: [position],
                    radius: 0,
                };
                var outsideFill = labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor;
                var dataLabel;
                var dataLabelSize;
                var categoryLabel;
                var categoryLabelSize;
                var textSize;
                var labelSettingsStyle = labelSettings.labelStyle;
                var fontSize = labelSettings.fontSize;
                var tooltip = "";
                if (labelSettingsStyle === visuals.labelStyle.both || labelSettingsStyle === visuals.labelStyle.data) {
                    dataLabel = measureFormatter.format(d.data.highlightValue != null ? d.data.highlightValue : d.data.measure);
                    dataLabelSize = visuals.NewDataLabelUtils.getTextSize(dataLabel, fontSize);
                }
                if (labelSettingsStyle === visuals.labelStyle.both || labelSettingsStyle === visuals.labelStyle.category) {
                    categoryLabel = d.data.label;
                    categoryLabelSize = visuals.NewDataLabelUtils.getTextSize(categoryLabel, fontSize);
                }
                switch (labelSettingsStyle) {
                    case visuals.labelStyle.both:
                        var text = categoryLabel + " (" + dataLabel + ")";
                        tooltip = text;
                        textSize = visuals.NewDataLabelUtils.getTextSize(text, fontSize);
                        break;
                    case visuals.labelStyle.category:
                        textSize = _.clone(categoryLabelSize);
                        tooltip = categoryLabel;
                        break;
                    case visuals.labelStyle.data:
                        textSize = _.clone(dataLabelSize);
                        tooltip = dataLabel;
                        break;
                }
                var leaderLinePoints = visuals.DonutLabelUtils.getLabelLeaderLineForDonutChart(d, this.donutProperties, pointPosition.point);
                var leaderLinesSize = visuals.DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
                return {
                    isPreferred: true,
                    text: "",
                    tooltip: tooltip,
                    textSize: textSize,
                    outsideFill: outsideFill,
                    fontSize: fontSize,
                    identity: d.data.identity,
                    parentShape: pointPosition,
                    insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                    parentType: 0 /* Point */,
                    alternativeScale: alternativeScale,
                    donutArcDescriptor: d,
                    angle: (d.startAngle + d.endAngle) / 2 - (Math.PI / 2),
                    dataLabel: dataLabel,
                    dataLabelSize: dataLabelSize,
                    categoryLabel: categoryLabel,
                    categoryLabelSize: categoryLabelSize,
                    leaderLinePoints: leaderLinePoints,
                    linesSize: leaderLinesSize,
                };
            };
            DonutChart.prototype.renderLegend = function () {
                if (!this.isInteractive) {
                    var legendObjectProperties = this.data.legendObjectProperties;
                    if (legendObjectProperties) {
                        var legendData = this.data.legendData;
                        visuals.LegendData.update(legendData, legendObjectProperties);
                        var position = legendObjectProperties[visuals.legendProps.position];
                        if (position)
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                        this.legend.drawLegend(legendData, this.parentViewport);
                    }
                    else {
                        this.legend.changeOrientation(visuals.LegendPosition.Top);
                        this.legend.drawLegend({ dataPoints: [] }, this.parentViewport);
                    }
                }
            };
            DonutChart.prototype.addInteractiveLegendArrow = function () {
                var arrowHeightOffset = 11;
                var arrowWidthOffset = 33 / 2;
                if (!this.interactiveLegendArrow) {
                    var interactiveLegendArrow = this.svg.append('g');
                    interactiveLegendArrow.append('path')
                        .classed(DonutChart.InteractiveLegendArrowClassName, true)
                        .attr('d', 'M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z');
                    this.interactiveLegendArrow = interactiveLegendArrow;
                }
                var viewport = this.currentViewport;
                // Calculate the offsets from the legend container to the arrow.
                var scaleRatio = this.getScaleForLegendArrow();
                var distanceBetweenLegendAndArrow = (viewport.height - 2 * this.radius) / 2 + (arrowHeightOffset * scaleRatio);
                var middleOfChart = viewport.width / 2 - (arrowWidthOffset * scaleRatio);
                this.interactiveLegendArrow.attr('transform', visuals.SVGUtil.translateAndScale(middleOfChart, distanceBetweenLegendAndArrow, scaleRatio));
            };
            DonutChart.prototype.calculateSliceAngles = function () {
                var angles = [];
                var data = this.data.dataPoints;
                if (data.length === 0) {
                    this.interactivityState.valueToAngleFactor = 0;
                    this.interactivityState.sliceAngles = [];
                    return;
                }
                var sum = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    sum += data[i].data.percentage; // value is an absolute number
                }
                debug.assert(sum !== 0, 'sum of slices values cannot be zero');
                this.interactivityState.valueToAngleFactor = 360 / sum; // Calculate the ratio between 360 and the sum to know the angles to rotate by
                var currentAngle = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
                    currentAngle += relativeAngle;
                    angles.push((relativeAngle / 2) - currentAngle);
                }
                this.interactivityState.sliceAngles = angles;
            };
            DonutChart.prototype.assignInteractions = function (slices, highlightSlices, data) {
                // assign interactions according to chart interactivity type
                if (this.isInteractive) {
                    this.assignInteractiveChartInteractions(slices);
                }
                else if (this.interactivityService) {
                    var dataPoints = data.dataPoints.map(function (value) { return value.data; });
                    var behaviorOptions = {
                        clearCatcher: this.clearCatcher,
                        slices: slices,
                        highlightSlices: highlightSlices,
                        allowDrilldown: this.allowDrilldown,
                        visual: this,
                        hasHighlights: data.hasHighlights,
                        svg: this.svg,
                    };
                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                }
            };
            DonutChart.prototype.setDrilldown = function (selection) {
                if (selection) {
                    var d3PieLayout = d3.layout.pie()
                        .sort(null)
                        .value(function (d) {
                        return d.percentage;
                    });
                    // Drill into the current selection.
                    var legendDataPoints = [{ label: selection.label, color: selection.color, icon: visuals.LegendIcon.Box, identity: selection.identity, selected: selection.selected }];
                    var legendData = { title: "", dataPoints: legendDataPoints };
                    var drilledDataPoints = d3PieLayout(selection.internalDataPoints);
                    this.updateInternal({
                        dataPointsToDeprecate: selection.internalDataPoints,
                        dataPoints: drilledDataPoints,
                        unCulledDataPoints: drilledDataPoints.map(function (value) { return value.data; }),
                        legendData: legendData,
                        hasHighlights: false,
                        dataLabelsSettings: this.data.dataLabelsSettings,
                    }, false /* suppressAnimations */, DonutChart.DrillDownAnimationDuration);
                }
                else {
                    // Pop out of drill down to view the "outer" data.
                    this.updateInternal(this.data, false /* suppressAnimations */, DonutChart.DrillDownAnimationDuration);
                }
            };
            DonutChart.prototype.assignInteractiveChartInteractions = function (slice) {
                var _this = this;
                var svg = this.svg;
                this.interactivityState.interactiveChosenSliceFinishedSetting = true;
                var svgRect = svg.node().getBoundingClientRect();
                this.interactivityState.donutCenter = { x: svgRect.left + svgRect.width / 2, y: svgRect.top + svgRect.height / 2 }; // Center of the donut chart
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.currentRotate = 0;
                this.calculateSliceAngles();
                // Set the on click method for the slices so thsete pie chart will turn according to each slice's corresponding angle [the angle its on top]
                slice.on('click', function (d, clickedIndex) {
                    if (d3.event.defaultPrevented)
                        return; // click was suppressed, for example from drag event
                    _this.setInteractiveChosenSlice(clickedIndex);
                });
                // Set the drag events
                var drag = d3.behavior.drag()
                    .origin(Object)
                    .on('dragstart', function () { return _this.interactiveDragStart(); })
                    .on('drag', function () { return _this.interactiveDragMove(); })
                    .on('dragend', function () { return _this.interactiveDragEnd(); });
                svg
                    .style('touch-action', 'none')
                    .call(drag);
            };
            /**
             * Get the angle (in degrees) of the drag event coordinates.
             * The angle is calculated against the plane of the center of the donut
             * (meaning, when the center of the donut is at (0,0) coordinates).
             */
            DonutChart.prototype.getAngleFromDragEvent = function () {
                var interactivityState = this.interactivityState;
                // get pageX and pageY (coordinates of the drag event) according to event type
                var pageX, pageY;
                var sourceEvent = d3.event.sourceEvent;
                // check if that's a touch event or not
                if (sourceEvent.type.toLowerCase().indexOf('touch') !== -1) {
                    if (sourceEvent.touches.length !== 1)
                        return null; // in case there isn't a single touch - return null and do nothing.
                    // take the first, single, touch surface.
                    var touch = sourceEvent.touches[0];
                    pageX = touch.pageX;
                    pageY = touch.pageY;
                }
                else {
                    pageX = sourceEvent.pageX;
                    pageY = sourceEvent.pageY;
                }
                // Adjust the coordinates, putting the donut center as the (0,0) coordinates
                var adjustedCoordinates = { x: pageX - interactivityState.donutCenter.x, y: -pageY + interactivityState.donutCenter.y };
                // Move to polar axis - take only the angle (theta), and convert to degrees
                var angleToThePlane = Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) * 180 / Math.PI;
                return angleToThePlane;
            };
            DonutChart.prototype.interactiveDragStart = function () {
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
            };
            DonutChart.prototype.interactiveDragMove = function () {
                var data = this.data.dataPoints;
                var viewport = this.currentViewport;
                var interactivityState = this.interactivityState;
                if (interactivityState.interactiveChosenSliceFinishedSetting === true) {
                    // get current angle from the drag event
                    var currentDragAngle = this.getAngleFromDragEvent();
                    if (!currentDragAngle)
                        return; // if no angle was returned, do nothing
                    // compare it to the previous drag event angle
                    var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
                    interactivityState.totalDragAngleDifference += angleDragDiff;
                    interactivityState.previousDragAngle = currentDragAngle;
                    // Rotate the chart by the difference in angles
                    interactivityState.currentRotate += angleDragDiff;
                    // Rotate the chart to the current rotate angle
                    this.svg.select('g')
                        .attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, this.interactivityState.currentRotate));
                    var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor;
                    var currentAngle = interactivityState.currentRotate <= 0 ? (interactivityState.currentRotate * -1) % 360 : (360 - (interactivityState.currentRotate % 360));
                    interactivityState.currentIndexDrag = 0;
                    //consider making this  ++interactivityState.currentIndexDrag ? then you don't need the if statement, the interactivityState.currentIndexDrag +1 and interactivityState.currentIndexDrag++
                    // Check the current index according to the angle 
                    var dataLength = data.length;
                    while ((interactivityState.currentIndexDrag < dataLength) && (currentAngle > currentHigherLimit)) {
                        if (interactivityState.currentIndexDrag < (dataLength - 1)) {
                            currentHigherLimit += (data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor);
                        }
                        interactivityState.currentIndexDrag++;
                    }
                    // If the index changed update the legend and opacity
                    if (interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag) {
                        interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag);
                        // set the opacticity of the top slice to full and the others to semi-transparent
                        this.svg.selectAll('.slice').attr('opacity', function (d, index) {
                            return index === interactivityState.currentIndexDrag ? DonutChart.OpaqueOpacity : DonutChart.SemiTransparentOpacity;
                        });
                        interactivityState.previousIndexDrag = interactivityState.currentIndexDrag;
                    }
                }
            };
            DonutChart.prototype.interactiveDragEnd = function () {
                // If totalDragDifference was changed, means we have a drag event (compared to a click event)
                if (this.interactivityState.totalDragAngleDifference !== 0) {
                    this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag);
                    // drag happened - disable click event
                    d3.event.sourceEvent.stopPropagation();
                }
            };
            DonutChart.prototype.updateInternalToMove = function (data, duration) {
                if (duration === void 0) { duration = 0; }
                // Cache for performance
                var svg = this.svg;
                var pie = this.pie;
                var key = this.key;
                var arc = this.arc;
                var radius = this.radius;
                var previousRadius = this.previousRadius;
                var sliceWidthRatio = this.sliceWidthRatio;
                var existingData = this.svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data().map(function (d) { return d.data; });
                if (existingData.length === 0) {
                    existingData = data.dataPointsToDeprecate;
                }
                var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate);
                var slice = svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(pie(data.dataPointsToDeprecate), key);
                slice.enter()
                    .insert('path')
                    .classed(DonutChart.sliceClass.class, true)
                    .each(function (d) { this._current = d; });
                slice = svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(pie(is), key);
                var innerRadius = radius * sliceWidthRatio;
                DonutChart.isSingleColor(data.dataPoints);
                slice
                    .style('fill', function (d) { return d.data.color; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, data.hasHighlights); })
                    .style('stroke', 'white')
                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio); })
                    .style('stroke-width', function (d) { return d.data.strokeWidth; })
                    .transition().duration(duration)
                    .attrTween('d', function (d) {
                    var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, radius * DonutChart.InnerArcRadiusRatio);
                    this._current = i(0);
                    return function (t) {
                        return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                    };
                });
                slice = svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(pie(data.dataPointsToDeprecate), key);
                slice.exit()
                    .transition()
                    .delay(duration)
                    .duration(0)
                    .remove();
                // For interactive chart, there shouldn't be slice labels (as you have the legend).
                if (!this.isInteractive) {
                    var labelSettings = data.dataLabelsSettings;
                    var labels = [];
                    if (labelSettings && labelSettings.show) {
                        labels = this.createLabels();
                    }
                    visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, true);
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
                }
                var highlightSlices = undefined;
                if (data.hasHighlights) {
                    // Draw partial highlight slices.
                    highlightSlices = svg
                        .select('.slices')
                        .selectAll('path' + DonutChart.sliceHighlightClass.selector)
                        .data(pie(data.dataPointsToDeprecate), key);
                    highlightSlices
                        .enter()
                        .insert('path')
                        .classed(DonutChart.sliceHighlightClass.class, true)
                        .each(function (d) { this._current = d; });
                    DonutChart.isSingleColor(data.dataPoints);
                    highlightSlices
                        .style('fill', function (d) { return d.data.color; })
                        .style('fill-opacity', 1.0)
                        .style('stroke', 'white')
                        .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio); })
                        .style('stroke-width', function (d) { return d.data.highlightRatio === 0 ? 0 : d.data.strokeWidth; })
                        .transition().duration(duration)
                        .attrTween('d', function (d) {
                        var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                        this._current = i(0);
                        return function (t) {
                            return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                        };
                    });
                    highlightSlices
                        .exit()
                        .transition()
                        .delay(duration)
                        .duration(0)
                        .remove();
                }
                else {
                    svg
                        .selectAll('path' + DonutChart.sliceHighlightClass.selector)
                        .transition()
                        .delay(duration)
                        .duration(0)
                        .remove();
                }
                this.assignInteractions(slice, highlightSlices, data);
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(slice, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    if (data.hasHighlights) {
                        visuals.TooltipManager.addTooltip(highlightSlices, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    }
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                if (this.isInteractive) {
                    this.addInteractiveLegendArrow();
                    this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate);
                    this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0);
                }
            };
            DonutChart.drawDefaultShapes = function (graphicsContext, donutData, layout, colors, radius, hasSelection, sliceWidthRatio, defaultColor) {
                var shapes = graphicsContext.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(donutData.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed(DonutChart.sliceClass.class, true);
                DonutChart.isSingleColor(donutData.dataPoints);
                shapes
                    .style('fill', function (d) { return d.data.color; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, donutData.hasHighlights); })
                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio); })
                    .style('stroke-width', function (d) { return d.data.strokeWidth; })
                    .attr(layout.shapeLayout);
                shapes.exit()
                    .remove();
                return shapes;
            };
            DonutChart.drawDefaultHighlightShapes = function (graphicsContext, donutData, layout, colors, radius, sliceWidthRatio) {
                var shapes = graphicsContext.select('.slices')
                    .selectAll('path' + DonutChart.sliceHighlightClass.selector)
                    .data(donutData.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed(DonutChart.sliceHighlightClass.class, true)
                    .each(function (d) { this._current = d; });
                DonutChart.isSingleColor(donutData.dataPoints);
                shapes
                    .style('fill', function (d) { return d.data.color; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, donutData.hasHighlights); })
                    .style('stroke', 'white')
                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio); })
                    .style('stroke-width', function (d) { return d.data.highlightRatio === 0 ? 0 : d.data.strokeWidth; })
                    .attr(layout.highlightShapeLayout);
                shapes.exit()
                    .remove();
                return shapes;
            };
            /**
                Set true to the last data point when all slices have the same color
            */
            DonutChart.isSingleColor = function (dataPoints) {
                if (dataPoints.length > 1) {
                    var lastPoint = dataPoints.length - 1;
                    dataPoints[lastPoint].data.isLastInDonut = dataPoints[lastPoint].data.color === dataPoints[0].data.color;
                }
            };
            DonutChart.drawStrokeForDonutChart = function (radius, innerArcRadiusRatio, d, sliceWidthRatio, highlightRatio) {
                if (highlightRatio === void 0) { highlightRatio = 1; }
                var sliceRadius = radius * innerArcRadiusRatio * highlightRatio;
                var sliceArc = (d.endAngle - d.startAngle) * sliceRadius;
                var sectionWithoutStroke;
                var sectionWithStroke;
                /*Donut chart*/
                if (sliceWidthRatio) {
                    var innerRadius = radius * sliceWidthRatio;
                    var outerRadius = highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
                    var innerSliceArc = (d.endAngle - d.startAngle) * innerRadius;
                    if (d.data.highlightRatio)
                        sliceArc = (d.endAngle - d.startAngle) * (outerRadius + innerRadius);
                    if (d.data.isLastInDonut) {
                        //if all slices have the same color, the stroke of the last slice needs to be drawn on both radiuses
                        return 0 + " " + sliceArc + " " + outerRadius + " " + innerSliceArc + " " + outerRadius;
                    }
                    sectionWithoutStroke = sliceArc + outerRadius + innerSliceArc;
                    sectionWithStroke = outerRadius;
                }
                else {
                    if (d.data.isLastInDonut) {
                        //if all slices have the same color, the stroke of the last slice needs to be drawn on both radiuses
                        sectionWithoutStroke = sliceArc;
                        sectionWithStroke = sliceRadius * 2;
                    }
                    else {
                        sectionWithoutStroke = sliceArc + sliceRadius;
                        sectionWithStroke = sliceRadius;
                    }
                }
                return 0 + " " + sectionWithoutStroke + " " + sectionWithStroke;
            };
            DonutChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            DonutChart.getLayout = function (radius, sliceWidthRatio, viewport) {
                var innerRadius = radius * sliceWidthRatio;
                var arc = d3.svg.arc().innerRadius(innerRadius);
                var arcWithRadius = arc.outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                return {
                    shapeLayout: {
                        d: function (d) {
                            return arcWithRadius(d);
                        }
                    },
                    highlightShapeLayout: {
                        d: function (d) {
                            var highlightArc = arc.outerRadius(DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                            return highlightArc(d);
                        }
                    },
                    zeroShapeLayout: {
                        d: function (d) {
                            var zeroWithZeroRadius = arc.outerRadius(innerRadius || DonutChart.EffectiveZeroValue);
                            return zeroWithZeroRadius(d);
                        }
                    },
                };
            };
            DonutChart.getHighlightRadius = function (radius, sliceWidthRatio, highlightRatio) {
                var innerRadius = radius * sliceWidthRatio;
                return innerRadius + highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
            };
            DonutChart.cullDataByViewport = function (dataPoints, maxValue, viewport) {
                var estimatedRadius = Math.min(viewport.width, viewport.height) / 2;
                // Ratio of slice too small to show (invisible) = invisbleArcLength / circumference
                var cullRatio = this.invisibleArcLengthInPixels / (estimatedRadius * DonutChart.twoPi);
                var cullableValue = cullRatio * maxValue;
                var culledDataPoints = [];
                var prevPointColor;
                for (var _i = 0, dataPoints_5 = dataPoints; _i < dataPoints_5.length; _i++) {
                    var datapoint = dataPoints_5[_i];
                    if (datapoint.measure >= cullableValue) {
                        //updates the stroke width
                        datapoint.strokeWidth = prevPointColor === datapoint.color ? 1 : 0;
                        prevPointColor = datapoint.color;
                        culledDataPoints.push(datapoint);
                    }
                }
                return culledDataPoints;
            };
            DonutChart.ClassName = 'donutChart';
            DonutChart.InteractiveLegendClassName = 'donutLegend';
            DonutChart.InteractiveLegendArrowClassName = 'donutLegendArrow';
            DonutChart.DrillDownAnimationDuration = 1000;
            DonutChart.OuterArcRadiusRatio = 0.9;
            DonutChart.InnerArcRadiusRatio = 0.8;
            DonutChart.OpaqueOpacity = 1.0;
            DonutChart.SemiTransparentOpacity = 0.6;
            DonutChart.defaultSliceWidthRatio = 0.48;
            DonutChart.invisibleArcLengthInPixels = 3;
            DonutChart.sliceClass = createClassAndSelector('slice');
            DonutChart.sliceHighlightClass = createClassAndSelector('slice-highlight');
            DonutChart.twoPi = 2 * Math.PI;
            DonutChart.InteractiveLegendContainerHeight = 70;
            DonutChart.EffectiveZeroValue = 0.000000001; // Very small multiplier so that we have a properly shaped zero arc to animate to/from.
            DonutChart.PolylineOpacity = 0.5;
            return DonutChart;
        }());
        visuals.DonutChart = DonutChart;
        /**
        * This class is an interactive legend for the Donut Chart.
         *
         * Features: It is scrollable indefinitely, using drag gesture
         * when you interact with it, it updates the donut chart itself.
        */
        var DonutChartInteractiveLegend = (function () {
            function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions, settings) {
                this.legendContainerParent = legendContainer;
                this.colors = colors;
                this.donutChart = donutChart;
                this.visualInitOptions = visualInitOptions;
                this.legendItemsPositions = [];
                this.legendTransitionAnimationDuration = settings && settings.legendTransitionAnimationDuration ? settings.legendTransitionAnimationDuration : 0;
            }
            DonutChartInteractiveLegend.prototype.drawLegend = function (data) {
                var _this = this;
                this.data = data;
                this.currentNumberOfLegendItems = data.length;
                this.currentIndex = 0;
                this.leftMostIndex = 0;
                this.rightMostIndex = data.length - 1;
                if (this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty()) {
                    this.legendContainer = this.legendContainerParent.append('div').classed(DonutChartInteractiveLegend.LegendContainerClassName, true);
                }
                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data);
                var legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width;
                var initialXOffset = legendContainerWidth / 2 - (legendContainerWidth * 0.4 / 2) + DonutChartInteractiveLegend.ItemMargin;
                var currX = initialXOffset;
                this.currentXOffset = initialXOffset;
                // Given the legend item div, create the item values (category, percentage and measure) on top of it.
                var createLegendItem = function (itemDiv, datum) {
                    // position the legend item
                    itemDiv
                        .attr('data-legend-index', datum.index) // assign index for later use
                        .css({
                        'position': 'absolute',
                        'left': currX,
                    });
                    // Add the category, percentage and value
                    var itemCategory = visuals.valueFormatter.format(datum.label);
                    var itemValue = visuals.valueFormatter.format(datum.measure, datum.measureFormat);
                    var itemPercentage = visuals.valueFormatter.format(datum.percentage, '0.00 %;-0.00 %;0.00 %');
                    var itemColor = datum.color;
                    // Create basic spans for width calculations
                    var itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11);
                    var itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11);
                    var itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20);
                    // Calculate Legend Box size according to widths and set the width accordingly
                    var valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan);
                    var categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan);
                    var precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan);
                    var currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
                    itemDiv.css('width', currentLegendBoxWidth);
                    // Calculate margins so that all the spans will be placed in the middle
                    var getLeftValue = function (spanWidth) {
                        return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
                    };
                    var marginLeftValue = getLeftValue(valueSpanWidth);
                    var marginLeftCategory = getLeftValue(categorySpanWidth);
                    var marginLeftPrecentage = getLeftValue(precentageSpanWidth);
                    // Create the actual spans with the right styling and margins so it will be center aligned and add them
                    DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css('color', itemColor);
                    itemDiv.append(itemCategorySpan);
                    itemDiv.append(itemPercentageSpan);
                    itemDiv.append(itemValueSpan);
                    _this.legendItemsPositions.push({
                        startX: currX,
                        boxWidth: currentLegendBoxWidth,
                    });
                    currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
                };
                // Create the Legend Items
                legendItems.enter()
                    .insert('div')
                    .classed(DonutChartInteractiveLegend.LegendItemClassName, true)
                    .each(function (d) {
                    createLegendItem($(this), d);
                });
                legendItems.exit().remove();
                // Assign interactions on the legend
                this.assignInteractions();
            };
            DonutChartInteractiveLegend.prototype.updateLegend = function (sliceIndex) {
                var _this = this;
                if (this.currentNumberOfLegendItems <= 1)
                    return; // If the number of labels is one no updates are needed
                var legendContainerWidth = this.legendContainerWidth;
                this.currentIndex = sliceIndex;
                // "rearrange" legend items if needed, so we would have contnious endless scrolling
                this.updateLabelBlocks(sliceIndex);
                var legendTransitionAnimationDuration = this.legendTransitionAnimationDuration;
                // Transform the legend so that the selected slice would be in the middle
                var nextXOffset = (this.legendItemsPositions[sliceIndex].startX + (this.legendItemsPositions[sliceIndex].boxWidth / 2) - (legendContainerWidth / 2)) * (-1);
                this.legendContainer
                    .transition()
                    .styleTween('-webkit-transform', function (d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                })
                    .styleTween('transform', function (d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                })
                    .duration(legendTransitionAnimationDuration)
                    .ease('bounce')
                    .each('end', function () {
                    _this.currentXOffset = nextXOffset;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.visualInitOptions);
            };
            DonutChartInteractiveLegend.prototype.assignInteractions = function () {
                var _this = this;
                var currentDX = 0; // keep how much drag had happened
                var hasChanged = false; // flag to indicate if we changed the "center" value in the legend. We only change it once per swipe.
                var dragStart = function () {
                    currentDX = 0; // start of drag gesture
                    hasChanged = false;
                };
                var dragMove = function () {
                    currentDX += d3.event.dx;
                    // Detect if swipe occured and if the index already changed in this drag
                    if (hasChanged || Math.abs(currentDX) < DonutChartInteractiveLegend.MinimumSwipeDX)
                        return;
                    var dragDirectionLeft = (currentDX < 0);
                    _this.dragLegend(dragDirectionLeft);
                    hasChanged = true;
                };
                var drag = d3.behavior.drag()
                    .origin(Object)
                    .on('drag', dragMove)
                    .on('dragstart', dragStart);
                this.legendContainer
                    .style({
                    'touch-action': 'none',
                    'cursor': 'pointer'
                })
                    .call(drag);
            };
            DonutChartInteractiveLegend.prototype.dragLegend = function (dragDirectionLeft) {
                if (this.currentNumberOfLegendItems > (DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1)) {
                    this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft);
                }
                else {
                    if (this.shouldChangeIndexInNonCycling(dragDirectionLeft)) {
                        if (dragDirectionLeft) {
                            this.currentIndex++;
                        }
                        else {
                            this.currentIndex--;
                        }
                    }
                }
                this.donutChart.setInteractiveChosenSlice(this.currentIndex);
            };
            DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function (dragDirectionLeft) {
                if ((this.currentIndex === 0 && !dragDirectionLeft) || (this.currentIndex === (this.currentNumberOfLegendItems - 1) && dragDirectionLeft)) {
                    return false;
                }
                return true;
            };
            DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function (dragDirectionLeft) {
                var dataLen = this.data.length;
                var delta = dragDirectionLeft ? 1 : -1;
                var newIndex = (this.currentIndex + delta) % (dataLen || 1); // modolu of negative number stays negative on javascript
                return (newIndex < 0) ? newIndex + dataLen : newIndex;
            };
            DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function (rightSidedShift, numberOfLegendItemsBlocksToShift) {
                var legendContainer$ = $(this.legendContainer[0]);
                if (rightSidedShift) {
                    var smallestItem = legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']');
                    smallestItem.remove().insertAfter(legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']'));
                    var newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.leftMostIndex].startX = newX;
                    smallestItem.css('left', newX);
                    this.rightMostIndex = this.leftMostIndex;
                    this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
                }
                else {
                    var highestItem = legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']');
                    highestItem.remove().insertBefore(legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']'));
                    var newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.rightMostIndex].startX = newX;
                    highestItem.css('left', newX);
                    this.leftMostIndex = this.rightMostIndex;
                    this.rightMostIndex = (this.rightMostIndex - 1) === -1 ? (this.legendItemsPositions.length - 1) : (this.rightMostIndex - 1);
                }
                if ((numberOfLegendItemsBlocksToShift - 1) !== 0) {
                    this.updateLegendItemsBlocks(rightSidedShift, (numberOfLegendItemsBlocksToShift - 1));
                }
            };
            /** Update the legend items, allowing for endless rotation */
            DonutChartInteractiveLegend.prototype.updateLabelBlocks = function (index) {
                if (this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                    // The idea of the four if's is to keep two labels before and after the current one so it will fill the screen.
                    // If the index of the slice is the highest currently availble add 2 labels "ahead" of it
                    if (this.rightMostIndex === index)
                        this.updateLegendItemsBlocks(true, 2);
                    // If the index of the slice is the lowest currently availble add 2 labels "before" it
                    if (this.leftMostIndex === index)
                        this.updateLegendItemsBlocks(false, 2);
                    // If the index of the slice is the second highest currently availble add a labels "ahead" of it
                    if (this.rightMostIndex === (index + 1) || ((this.rightMostIndex === 0) && (index === (this.currentNumberOfLegendItems - 1))))
                        this.updateLegendItemsBlocks(true, 1);
                    // If the index of the slice is the second lowest currently availble add a labels "before" it
                    if (this.leftMostIndex === (index - 1) || ((this.leftMostIndex === (this.currentNumberOfLegendItems - 1) && (index === 0))))
                        this.updateLegendItemsBlocks(false, 1);
                }
                else {
                    if (this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                        // If the index of the slice is the highest currently availble add a label "ahead" of it
                        if (this.rightMostIndex === index)
                            this.updateLegendItemsBlocks(true, 1);
                        // If the index of the slice is the lowest currently availble add a label "before" it
                        if (this.leftMostIndex === index)
                            this.updateLegendItemsBlocks(false, 1);
                    }
                }
            };
            DonutChartInteractiveLegend.createBasicLegendItemSpan = function (spanClass, text, fontSize) {
                return $('<span/>')
                    .addClass(spanClass)
                    .css({
                    'white-space': 'nowrap',
                    'font-size': fontSize + 'px',
                })
                    .text(text);
            };
            /** This method alters the given span and sets it to the final legen item span style. */
            DonutChartInteractiveLegend.createLegendItemSpan = function (existingSpan, marginLeft) {
                existingSpan
                    .css({
                    'overflow': 'hidden',
                    'text-overflow': 'ellipsis',
                    'display': 'inline-block',
                    'width': '100%',
                    'margin-left': marginLeft
                });
                return existingSpan;
            };
            /** Caclulte entire legend box size according to its building spans */
            DonutChartInteractiveLegend.legendBoxSize = function (valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
                var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
                boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth;
                boxSize = boxSize > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : (boxSize + 2);
                return boxSize;
            };
            DonutChartInteractiveLegend.spanWidth = function (span) {
                if (!this.FakeElementSpan) {
                    this.FakeElementSpan = $('<span>').hide().appendTo(document.body);
                }
                this.FakeElementSpan.empty();
                this.FakeElementSpan.append(span);
                return this.FakeElementSpan.width();
            };
            DonutChartInteractiveLegend.LegendContainerClassName = 'legend-container';
            DonutChartInteractiveLegend.LegendContainerSelector = '.legend-container';
            DonutChartInteractiveLegend.LegendItemClassName = 'legend-item';
            DonutChartInteractiveLegend.LegendItemSelector = '.legend-item';
            DonutChartInteractiveLegend.LegendItemCategoryClassName = 'category';
            DonutChartInteractiveLegend.LegendItemPercentageClassName = 'percentage';
            DonutChartInteractiveLegend.LegendItemValueClassName = 'value';
            DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160;
            DonutChartInteractiveLegend.ItemMargin = 30; // Margin between items
            DonutChartInteractiveLegend.MinimumSwipeDX = 15; // Minimup swipe gesture to create a change in the legend
            DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3; // Minimum items in the legend before we cycle it
            return DonutChartInteractiveLegend;
        }());
        var DonutChartConversion;
        (function (DonutChartConversion) {
            ;
            var DonutChartConverter = (function () {
                function DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled) {
                    if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                    var dataViewCategorical = dataView.categorical;
                    this.dataViewCategorical = dataViewCategorical;
                    this.dataViewMetadata = dataView.metadata;
                    this.tooltipsEnabled = tooltipsEnabled;
                    this.seriesCount = dataViewCategorical.values ? dataViewCategorical.values.length : 0;
                    this.colorHelper = new visuals.ColorHelper(colors, visuals.donutChartProps.dataPoint.fill, defaultDataPointColor);
                    this.maxValue = 0;
                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        var category = dataViewCategorical.categories[0];
                        this.categoryIdentities = category.identity;
                        this.categoryValues = category.values;
                        this.allCategoryObjects = category.objects;
                        this.categoryColumnRef = category.identityFields;
                        this.categoryFormatString = visuals.valueFormatter.getFormatString(category.source, visuals.donutChartProps.general.formatString);
                    }
                    var grouped = this.grouped = dataViewCategorical && dataViewCategorical.values ? dataViewCategorical.values.grouped() : undefined;
                    this.isMultiMeasure = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    this.isSingleMeasure = grouped && grouped.length === 1 && grouped[0].values && grouped[0].values.length === 1;
                    this.isDynamicSeries = !!(dataViewCategorical.values && dataViewCategorical.values.source);
                    this.hasHighlights = this.seriesCount > 0 && !_.isEmpty(dataViewCategorical.values) && !!dataViewCategorical.values[0].highlights;
                    this.highlightsOverflow = false;
                    this.total = 0;
                    this.highlightTotal = 0;
                    this.dataPoints = [];
                    this.legendDataPoints = [];
                    this.dataLabelsSettings = null;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        for (var measureIndex = 0; measureIndex < seriesData.values.length; measureIndex++) {
                            this.total += Math.abs(seriesData.values[measureIndex]);
                            this.highlightTotal += this.hasHighlights ? Math.abs(seriesData.highlights[measureIndex]) : 0;
                        }
                    }
                    this.total = visuals.AxisHelper.normalizeNonFiniteNumber(this.total);
                    this.highlightTotal = visuals.AxisHelper.normalizeNonFiniteNumber(this.highlightTotal);
                }
                DonutChartConverter.normalizedMeasureAndValue = function (measureAndValue) {
                    var normalized = $.extend(true, {}, measureAndValue);
                    normalized.measure = visuals.AxisHelper.normalizeNonFiniteNumber(normalized.measure);
                    normalized.value = visuals.AxisHelper.normalizeNonFiniteNumber(normalized.value);
                    return normalized;
                };
                DonutChartConverter.prototype.convert = function () {
                    var convertedData;
                    if (this.total !== 0) {
                        // We render based on categories, series, or measures in that order of preference
                        if (this.categoryValues) {
                            convertedData = this.convertCategoricalWithSlicing();
                        }
                        else if (this.isDynamicSeries) {
                            // Series but no category.
                            convertedData = this.convertSeries();
                        }
                        else {
                            // No category or series; only measures.
                            convertedData = this.convertMeasures();
                        }
                    }
                    else {
                        convertedData = [];
                    }
                    // Check if any of the highlight values are > non-highlight values
                    var highlightsOverflow = false;
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount && !highlightsOverflow; i++) {
                        var point = convertedData[i];
                        if (Math.abs(point.highlightMeasureValue.measure) > Math.abs(point.measureValue.measure)) {
                            highlightsOverflow = true;
                        }
                    }
                    // Create data labels settings
                    this.dataLabelsSettings = this.convertDataLabelSettings();
                    var dataViewMetadata = this.dataViewMetadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            this.legendObjectProperties = objects['legend'];
                        }
                    }
                    this.dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var prevPointColor;
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount; i++) {
                        var point = convertedData[i];
                        // Normalize the values here and then handle tooltip value as infinity
                        var normalizedHighlight = DonutChartConverter.normalizedMeasureAndValue(point.highlightMeasureValue);
                        var normalizedNonHighlight = DonutChartConverter.normalizedMeasureAndValue(point.measureValue);
                        var measure = normalizedNonHighlight.measure;
                        var percentage = (this.total > 0) ? normalizedNonHighlight.value / this.total : 0.0;
                        var highlightRatio = undefined;
                        if (normalizedNonHighlight.value > this.maxValue)
                            this.maxValue = normalizedNonHighlight.value;
                        if (normalizedHighlight.value > this.maxValue)
                            this.maxValue = normalizedHighlight.value;
                        if (this.hasHighlights) {
                            // When any highlight value is greater than the corresponding non-highlight value
                            // we just render all of the highlight values and discard the non-highlight values.
                            if (highlightsOverflow) {
                                measure = normalizedHighlight.measure;
                                percentage = (this.highlightTotal > 0) ? normalizedHighlight.value / this.highlightTotal : 0.0;
                                highlightRatio = 1;
                            }
                            else {
                                highlightRatio = normalizedNonHighlight.value !== 0 ? normalizedHighlight.value / normalizedNonHighlight.value : 0;
                            }
                            if (!highlightRatio) {
                                highlightRatio = DonutChart.EffectiveZeroValue;
                            }
                        }
                        var categoryValue = point.categoryLabel;
                        var categorical = this.dataViewCategorical;
                        var valueIndex = categorical.categories ? null : i;
                        valueIndex = point.seriesIndex !== undefined ? point.seriesIndex : valueIndex;
                        var valuesMetadata = categorical.values[valueIndex].source;
                        var value = this.hasHighlights && highlightsOverflow ? point.highlightMeasureValue.measure : point.measureValue.measure;
                        var highlightValue = this.hasHighlights && !highlightsOverflow ? point.highlightMeasureValue.measure : undefined;
                        var tooltipInfo = void 0;
                        if (this.tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, valueIndex, i, highlightValue);
                        }
                        var strokeWidth = prevPointColor === point.color && value && value > 0 ? 1 : 0;
                        prevPointColor = value && value > 0 ? point.color : prevPointColor;
                        this.dataPoints.push({
                            identity: point.identity,
                            measure: measure,
                            measureFormat: point.measureFormat,
                            percentage: percentage,
                            index: point.index,
                            label: point.label,
                            highlightRatio: highlightRatio,
                            highlightValue: highlightValue,
                            selected: false,
                            tooltipInfo: tooltipInfo,
                            color: point.color,
                            strokeWidth: strokeWidth,
                            labelFormatString: valuesMetadata.format,
                        });
                    }
                    this.legendData = this.convertLegendData();
                };
                DonutChartConverter.prototype.getLegendTitle = function () {
                    if (this.total !== 0) {
                        // If category exists, we render title using category source. If not, we render title
                        // using measure.
                        var dvValuesSourceName = this.dataViewCategorical.values && this.dataViewCategorical.values.source
                            ? this.dataViewCategorical.values.source.displayName : "";
                        var dvCategorySourceName = this.dataViewCategorical.categories && this.dataViewCategorical.categories.length > 0 && this.dataViewCategorical.categories[0].source
                            ? this.dataViewCategorical.categories[0].source.displayName : "";
                        if (this.categoryValues) {
                            return dvCategorySourceName;
                        }
                        else {
                            return dvValuesSourceName;
                        }
                    }
                    else {
                        return "";
                    }
                };
                DonutChartConverter.prototype.convertCategoricalWithSlicing = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var dataPoints = [];
                    for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
                        var categoryValue = this.categoryValues[categoryIndex];
                        var thisCategoryObjects = this.allCategoryObjects ? this.allCategoryObjects[categoryIndex] : undefined;
                        var legendIdentity = visuals.SelectionId.createWithId(this.categoryIdentities[categoryIndex]);
                        var color = this.colorHelper.getColorForSeriesValue(thisCategoryObjects, this.categoryColumnRef, categoryValue);
                        var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                        // Series are either measures in the multi-measure case, or the single series otherwise
                        for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                            var seriesData = dataViewCategorical.values[seriesIndex];
                            var label = this.isSingleMeasure
                                ? categoryLabel
                                : visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                            var nonHighlight = seriesData.values[categoryIndex] || 0;
                            var highlight = this.hasHighlights ? seriesData.highlights[categoryIndex] || 0 : 0;
                            var measure = void 0;
                            var seriesGroup = void 0;
                            if (this.isMultiMeasure) {
                                measure = seriesData.source.queryName;
                            }
                            else if (seriesData.identity)
                                seriesGroup = seriesData;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(dataViewCategorical.categories[0], categoryIndex)
                                .withSeries(seriesGroup, seriesGroup)
                                .withMeasure(measure)
                                .createSelectionId();
                            var dataPoint = {
                                identity: identity,
                                measureFormat: visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true),
                                measureValue: {
                                    measure: nonHighlight,
                                    value: Math.abs(nonHighlight),
                                },
                                highlightMeasureValue: {
                                    measure: highlight,
                                    value: Math.abs(highlight),
                                },
                                index: categoryIndex * this.seriesCount + seriesIndex,
                                label: label,
                                categoryLabel: categoryLabel,
                                color: color,
                                seriesIndex: seriesIndex
                            };
                            dataPoints.push(dataPoint);
                        }
                        this.legendDataPoints.push({
                            label: categoryLabel,
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            identity: legendIdentity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertMeasures = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
                        var measureData = dataViewCategorical.values[measureIndex];
                        var measureFormat = visuals.valueFormatter.getFormatString(measureData.source, formatStringProp, true);
                        var measureLabel = measureData.source.displayName;
                        var identity = visuals.SelectionId.createWithMeasure(measureData.source.queryName);
                        debug.assert(measureData.values.length > 0, 'measure should have data points');
                        debug.assert(!this.hasHighlights || measureData.highlights.length > 0, 'measure with highlights should have highlight data points');
                        var nonHighlight = measureData.values[0] || 0;
                        var highlight = this.hasHighlights ? measureData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForMeasure(measureData.source.objects, measureData.source.queryName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: measureFormat,
                            measureValue: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight),
                            },
                            highlightMeasureValue: {
                                measure: highlight,
                                value: Math.abs(highlight),
                            },
                            index: measureIndex,
                            label: measureLabel,
                            categoryLabel: measureLabel,
                            color: color
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: visuals.LegendIcon.Box,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertSeries = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        var seriesFormat = visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true);
                        var label = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                        var identity = visuals.SelectionId.createWithId(seriesData.identity);
                        var seriesName = visuals.converterHelper.getSeriesName(seriesData.source);
                        var objects = this.grouped && this.grouped[seriesIndex] && this.grouped[seriesIndex].objects;
                        debug.assert(seriesData.values.length > 0, 'measure should have data points');
                        debug.assert(!this.hasHighlights || seriesData.highlights.length > 0, 'measure with highlights should have highlight data points');
                        var nonHighlight = seriesData.values[0] || 0;
                        var highlight = this.hasHighlights ? seriesData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForSeriesValue(objects, dataViewCategorical.values.identityFields, seriesName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: seriesFormat,
                            measureValue: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight),
                            },
                            highlightMeasureValue: {
                                measure: highlight,
                                value: Math.abs(highlight),
                            },
                            index: seriesIndex,
                            label: label,
                            categoryLabel: label,
                            color: color,
                            seriesIndex: seriesIndex
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: visuals.LegendIcon.Box,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertDataLabelSettings = function () {
                    var dataViewMetadata = this.dataViewMetadata;
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            // Handle lables settings
                            var labelsObj = objects['labels'];
                            if (labelsObj) {
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                            }
                        }
                    }
                    return dataLabelsSettings;
                };
                DonutChartConverter.prototype.convertLegendData = function () {
                    return {
                        dataPoints: this.legendDataPoints,
                        labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                        title: this.getLegendTitle(),
                        fontSize: visuals.SVGLegend.DefaultFontSizeInPt,
                    };
                };
                return DonutChartConverter;
            }());
            DonutChartConversion.DonutChartConverter = DonutChartConverter;
        })(DonutChartConversion || (DonutChartConversion = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Utility = jsCommon.Utility;
        var ScriptVisual = (function () {
            function ScriptVisual(options) {
                this.canRefresh = options.canRefresh;
            }
            ScriptVisual.prototype.init = function (options) {
                this.element = options.element;
                this.hostServices = options.host;
                if (!this.canRefresh) {
                    this.hostServices.setWarnings([new visuals.ScriptVisualRefreshWarning()]);
                }
            };
            ScriptVisual.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0)
                    return;
                var dataView = dataViews[0];
                if (!dataView || !dataView.metadata)
                    return;
                var imageUrl = this.getImageUrl(dataView);
                var div = this.ensureHtmlElement();
                if (imageUrl && Utility.isValidImageDataUrl(imageUrl)) {
                    var viewport = options.viewport;
                    div.css({ height: viewport.height, width: viewport.width, backgroundImage: 'url(' + imageUrl + ')' });
                }
                else {
                    div.css({ backgroundImage: 'none' });
                }
            };
            ScriptVisual.prototype.onResizing = function (finalViewport) {
                var div = this.ensureHtmlElement();
                div.css({ height: finalViewport.height, width: finalViewport.width });
            };
            ScriptVisual.prototype.getImageUrl = function (dataView) {
                debug.assertValue(dataView, 'dataView');
                if (dataView.scriptResult && dataView.scriptResult.imageBase64) {
                    return "data:image/png;base64," + dataView.scriptResult.imageBase64;
                }
                return null;
            };
            ScriptVisual.prototype.ensureHtmlElement = function () {
                var div = this.imageBackgroundElement;
                if (!div) {
                    div = $("<div class='imageBackground' />");
                    this.imageBackgroundElement = div;
                    this.imageBackgroundElement.appendTo(this.element);
                }
                return div;
            };
            return ScriptVisual;
        }());
        visuals.ScriptVisual = ScriptVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var plugins;
        (function (plugins) {
            // This file registers the built-in visualizations
            plugins.animatedNumber = {
                name: 'animatedNumber',
                capabilities: visuals.capabilities.animatedNumber,
                create: function () { return new visuals.AnimatedNumber(); }
            };
            plugins.areaChart = {
                name: 'areaChart',
                watermarkKey: 'area',
                capabilities: visuals.capabilities.lineChart,
                create: function () { return new visuals.CartesianChart({ chartType: 1 /* Area */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.barChart = {
                name: 'barChart',
                watermarkKey: 'bar',
                capabilities: visuals.capabilities.barChart,
                create: function () { return new visuals.CartesianChart({ chartType: 6 /* StackedBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.basicShape = {
                name: 'basicShape',
                capabilities: visuals.basicShapeCapabilities,
                create: function () { return new visuals.BasicShapeVisual(); }
            };
            plugins.card = {
                name: 'card',
                watermarkKey: 'card',
                capabilities: visuals.capabilities.card,
                create: function () { return new visuals.Card(); }
            };
            plugins.multiRowCard = {
                name: 'multiRowCard',
                watermarkKey: 'multiRowCard',
                capabilities: visuals.capabilities.multiRowCard,
                create: function () { return new visuals.MultiRowCard(); }
            };
            plugins.clusteredBarChart = {
                name: 'clusteredBarChart',
                watermarkKey: 'clusteredBar',
                capabilities: visuals.capabilities.clusteredBarChart,
                create: function () { return new visuals.CartesianChart({ chartType: 5 /* ClusteredBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.clusteredColumnChart = {
                name: 'clusteredColumnChart',
                watermarkKey: 'clusteredColumn',
                capabilities: visuals.capabilities.clusteredColumnChart,
                create: function () { return new visuals.CartesianChart({ chartType: 3 /* ClusteredColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.columnChart = {
                name: 'columnChart',
                watermarkKey: 'column',
                capabilities: visuals.capabilities.columnChart,
                create: function () { return new visuals.CartesianChart({ chartType: 4 /* StackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.comboChart = {
                name: 'comboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.comboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 10 /* ComboChart */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.dataDotChart = {
                name: 'dataDotChart',
                capabilities: visuals.capabilities.dataDotChart,
                create: function () { return new visuals.CartesianChart({ chartType: 11 /* DataDot */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.dataDotClusteredColumnComboChart = {
                name: 'dataDotClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.dataDotClusteredColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 15 /* DataDotClusteredColumnCombo */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.dataDotStackedColumnComboChart = {
                name: 'dataDotStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.dataDotStackedColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 16 /* DataDotStackedColumnCombo */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.donutChart = {
                name: 'donutChart',
                watermarkKey: 'donut',
                capabilities: visuals.capabilities.donutChart,
                create: function () { return new visuals.DonutChart(); }
            };
            plugins.funnel = {
                name: 'funnel',
                watermarkKey: 'funnel',
                capabilities: visuals.capabilities.funnel,
                create: function () { return new visuals.FunnelChart(); }
            };
            plugins.gauge = {
                name: 'gauge',
                watermarkKey: 'gauge',
                capabilities: visuals.capabilities.gauge,
                create: function () { return new visuals.Gauge(); }
            };
            plugins.hundredPercentStackedBarChart = {
                name: 'hundredPercentStackedBarChart',
                watermarkKey: '100stackedbar',
                capabilities: visuals.capabilities.hundredPercentStackedBarChart,
                create: function () { return new visuals.CartesianChart({ chartType: 7 /* HundredPercentStackedBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.hundredPercentStackedColumnChart = {
                name: 'hundredPercentStackedColumnChart',
                watermarkKey: '100stackedcolumn',
                capabilities: visuals.capabilities.hundredPercentStackedColumnChart,
                create: function () { return new visuals.CartesianChart({ chartType: 8 /* HundredPercentStackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.image = {
                name: 'image',
                capabilities: visuals.capabilities.image,
                create: function () { return new visuals.ImageVisual(); }
            };
            plugins.lineChart = {
                name: 'lineChart',
                watermarkKey: 'line',
                capabilities: visuals.capabilities.lineChart,
                create: function () { return new visuals.CartesianChart({ chartType: 0 /* Line */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.LineChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.lineStackedColumnComboChart = {
                name: 'lineStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.lineStackedColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 14 /* LineStackedColumnCombo */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.lineClusteredColumnComboChart = {
                name: 'lineClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.lineClusteredColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 13 /* LineClusteredColumnCombo */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.map = {
                name: 'map',
                watermarkKey: 'map',
                capabilities: visuals.capabilities.map,
                create: function () { return new visuals.Map({ filledMap: false }); }
            };
            plugins.filledMap = {
                name: 'filledMap',
                watermarkKey: 'filledMap',
                capabilities: visuals.capabilities.filledMap,
                create: function () { return new visuals.Map({ filledMap: true }); }
            };
            plugins.treemap = {
                name: 'treemap',
                watermarkKey: 'tree',
                capabilities: visuals.capabilities.treemap,
                create: function () { return new visuals.Treemap(); }
            };
            plugins.pieChart = {
                name: 'pieChart',
                watermarkKey: 'pie',
                capabilities: visuals.capabilities.donutChart,
                create: function () { return new visuals.DonutChart({ sliceWidthRatio: 0 }); }
            };
            plugins.scatterChart = {
                name: 'scatterChart',
                watermarkKey: 'scatterplot',
                capabilities: visuals.capabilities.scatterChart,
                create: function () { return new visuals.CartesianChart({ chartType: 9 /* Scatter */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.ScatterChart.getAdditionalTelemetry(dataView); },
            };
            plugins.stackedAreaChart = {
                name: 'stackedAreaChart',
                watermarkKey: 'stackedarea',
                capabilities: visuals.capabilities.lineChart,
                create: function () { return new visuals.CartesianChart({ chartType: 2 /* StackedArea */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.table = {
                name: 'table',
                watermarkKey: 'table',
                capabilities: visuals.capabilities.table,
                create: function () { return new visuals.Table(); },
                customizeQuery: visuals.Table.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.Table.getSortableRoles(); },
            };
            plugins.matrix = {
                name: 'matrix',
                watermarkKey: 'matrix',
                capabilities: visuals.capabilities.matrix,
                create: function () { return new visuals.Matrix(); },
                customizeQuery: visuals.Matrix.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.Matrix.getSortableRoles(); },
            };
            plugins.slicer = {
                name: 'slicer',
                watermarkKey: 'slicer',
                capabilities: visuals.capabilities.slicer,
                create: function () { return new visuals.Slicer(); }
            };
            plugins.textbox = {
                name: 'textbox',
                capabilities: visuals.capabilities.textbox,
                create: function () { return new visuals.Textbox(); }
            };
            plugins.waterfallChart = {
                name: 'waterfallChart',
                watermarkKey: 'waterfall',
                capabilities: visuals.capabilities.waterfallChart,
                create: function () { return new visuals.CartesianChart({ chartType: 12 /* Waterfall */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.cheerMeter = {
                name: 'cheerMeter',
                capabilities: visuals.CheerMeter.capabilities,
                create: function () { return new visuals.CheerMeter(); }
            };
            plugins.owlGauge = {
                name: 'owlGauge',
                watermarkKey: 'gauge',
                capabilities: visuals.OwlGauge.capabilities,
                create: function () { return new visuals.OwlGauge(); }
            };
            plugins.scriptVisual = {
                name: 'scriptVisual',
                watermarkKey: 'scriptvisual',
                capabilities: visuals.capabilities.scriptVisual,
                create: function () { return new visuals.ScriptVisual({ canRefresh: false }); }
            };
            plugins.kpi = {
                name: 'kpi',
                watermarkKey: 'kpi',
                capabilities: visuals.capabilities.kpi,
                create: function () { return new visuals.KPIStatusWithHistory(); }
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CanvasBackgroundHelper;
        (function (CanvasBackgroundHelper) {
            function getDefaultColor() {
                return '#FFFFFF';
            }
            CanvasBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                };
            }
            CanvasBackgroundHelper.getDefaultValues = getDefaultValues;
        })(CanvasBackgroundHelper = visuals.CanvasBackgroundHelper || (visuals.CanvasBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

//# sourceMappingURL=Visuals.js.map
